<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/"><channel><title>Read Rust - Crates</title><link>https://readrust.net/</link><description>Crates posts on Read Rust</description><item><title>Starling, the Binary Indexed Merkle Tree (Or Merkle-BIT)</title><link>https://www.reddit.com/r/rust/comments/aww097/starling_the_binary_indexed_merkle_tree_or/</link><description><![CDATA[Hey rustaceans! With a little help from your feedback just a few hours ago, I'm proud to present to you all Starling, a Binary Indexed Merkle tree! I've been working on this data structure for the last few months, and I think it is ready now for the community to have a look. Let me explain what it is and why it might be useful for your project.]]></description><guid isPermaLink="false">ce110dd7-46c1-4f12-880f-1c0bbf3a6726</guid><pubDate>Mon,  4 Mar 2019 04:12:50 +1100</pubDate><dc:creator>ChosunOne</dc:creator></item><item><title>Pedal to the metal: dynamic templates with Ramhorns</title><link>https://maciej.codes/2019-03-03-ramhorns.html</link><description><![CDATA[I have a problem. I don't know what to call it, but there is this itch I have when I find something that can obviously be made more efficient. The way I get about scratching that itch these days is by writing some Rust. I just got such an itch when looking at static site generators for this blog, Hugo (written in Go) is pretty much state-of-the art. In Rust land we have Zola, which is feature-rich, mature (for v0.5), and definitely fast enough for most users, and yet it is not as fast as it could be. Being written in Rust is, by itself, not a guarantee of top performance. The implementation matters. After some looking around I've narrowed down a problem I want to tackle (for now) to one area: template engines.]]></description><guid isPermaLink="false">a540ae81-ddbb-4279-a507-b7faf43e5b19</guid><pubDate>Sun,  3 Mar 2019 00:00:00 +0000</pubDate><dc:creator>Maciej Hirsz</dc:creator></item><item><title>Low level text layout kickoff</title><link>https://raphlinus.github.io/rust/skribo/text/2019/02/27/text-layout-kickoff.html</link><description><![CDATA[This post is to announce a new Rust library for low-level text layout, called “skribo” (the Esperanto word for “writing”). This has been a major gap in the Rust ecosystem, and I hope the new crate can improve text handling across the board.]]></description><guid isPermaLink="false">70a94e2b-dbd2-4f66-ada8-5886b5c51fab</guid><pubDate>Wed, 27 Feb 2019 18:16:42 +0000</pubDate><dc:creator>Raph Levien</dc:creator></item><item><title>Releasing rust_gpiozero v0.2.0</title><link>https://rahul-thakoor.github.io/releasing-rust_gpiozero-v0.2.0/</link><description><![CDATA[A new version packed with new features and improvements: Blink leds without blocking main thread and adjust brightness. ⚙️ Work with servo motors and adjust motor speed. 〜 Work with software PWM.]]></description><guid isPermaLink="false">e0caaf97-6980-4421-afbe-3fca31872c73</guid><pubDate>Wed, 27 Feb 2019 17:43:48 +0400</pubDate><dc:creator>Rahul Thakoor</dc:creator></item><item><title>100x improvement on startup time in Wasmer 0.2.0</title><link>https://medium.com/wasmer/running-webassembly-100x-faster-%EF%B8%8F-a8237e9a372d</link><description><![CDATA[We’ve been working steadily to get Wasmer to execute WebAssembly modules on the server-side as fast as possible. TL;DR — We got 100x improvement on startup time on Wasmer 0.2.0.]]></description><guid isPermaLink="false">fe2180a3-53fb-4b12-b6b2-722c19587b39</guid><pubDate>Mon, 25 Feb 2019 22:04:55 +0000</pubDate><dc:creator>Syrus Akbary</dc:creator></item><item><title>Introducing battery crate</title><link>https://svartalf.info/posts/2019-02-25-introducing-battery-crate/</link><description><![CDATA[My new pet project for reading batteries information in Rust.]]></description><guid isPermaLink="false">e513ef63-5727-4db5-8830-08606838d1e3</guid><pubDate>Mon, 25 Feb 2019 00:00:00 +0000</pubDate><dc:creator>Nikita Kuznetsov</dc:creator></item><item><title>Combine Results for Improved Rust Validation Logic</title><link>https://www.joshmcguigan.com/blog/multi-try-improved-validation-logic-rust/</link><description><![CDATA[The error handling features within Rust are some of my favorite things about the language. This system works great when you are in a function which returns a Result and you want to exit at the first error you come to. However, it can be challenging if your goal is to try a few failure-prone things and return each of the errors, rather than just the first error. This is the problem multi_try attempts to solve. ]]></description><guid isPermaLink="false">03e057c7-1da0-4468-b0f8-3aaedde6b241</guid><pubDate>Sat, 23 Feb 2019 00:00:00 +0000</pubDate><dc:creator>Josh Mcguigan</dc:creator></item><item><title>Our first Rust crate: decrypting ansible vaults</title><link>https://medium.com/@woutergeraedts/our-first-rust-crate-decrypting-ansible-vaults-25f2f3a9a674</link><description><![CDATA[We encrypt these secrets in so-called ansible vaults. Kuberwave also has the need to access these secrets. Because our staff is already comfortable with using these vaults, we’ve decided to also employ them for our Kubernetes setup. For this I created ansible-vault-rs, a library that can decrypt ansible vaults. Note that it can not create or edit vaults, because I have no need (yet) for this functionality.]]></description><guid isPermaLink="false">2c0b32cc-51a7-4e6f-a729-92c6cedcd7b1</guid><pubDate>Fri, 22 Feb 2019 08:12:26 +0000</pubDate><dc:creator>Wouter Geraedts</dc:creator></item><item><title>New Gtk-rs release finally happened!</title><link>https://gtk-rs.org/blog/2019/02/21/new-release.html</link><description><![CDATA[It’s time for a new release! Main adds/changes this time are: We added the generation of the Atk crate. We now generate functions taking callback as parameters. We improved the channels handling in GLib. The whole new GString type! The minimum Rust version supported is now the 1.31. The minimum version of all libraries has been changed to GNOME 3.14. The maximum version of all libraries has been upgraded to GNOME 3.30. Added subclassing support in GLib. Even more bindings generated. Let’s see those in details.]]></description><guid isPermaLink="false">7a149bc9-7e87-40cb-b3ef-da277059f897</guid><pubDate>Thu, 21 Feb 2019 00:00:00 +0000</pubDate><dc:creator>Gtk-rs</dc:creator></item><item><title>Introducing embedded-sdmmc - a pure-Rust #[no_std] SD card and FAT16/FAT32 library</title><link>https://www.reddit.com/r/rust/comments/ascvls/introducing_embeddedsdmmc_a_purerust_no_std_sd/</link><description><![CDATA[161 votes and 6 comments so far on Reddit]]></description><guid isPermaLink="false">fe990782-d611-46a2-a6c1-4048707e61df</guid><pubDate>Wed, 20 Feb 2019 04:32:00 +0000</pubDate><dc:creator>Jonathan Pallant</dc:creator></item><item><title>Lyon in 2018</title><link>https://nical.github.io/posts/lyon-2018.html</link><description><![CDATA[In 2018 my activity on the project has varied depending on the time and energy I have had left after work and other activities. As it turns out, working on getting WebRender shipped in Firefox is at the same time amazing and very demanding, and what's left of my brain after a good day of work isn't always up to some of the ambitions I have planned for lyon. Fortunately I am not the only one who contributed to the project, and while progress was slow on the most ambitious plans, I did spend some time on smaller features and polish.

I'll get to these big plans towards the end of this post. In the mean time let's look at some of the highlights of what changed in lyon in 2018.]]></description><guid isPermaLink="false">0a429d63-c63c-4161-8960-c83915c01b26</guid><pubDate>Sun, 17 Feb 2019 00:00:00 +0100</pubDate><dc:creator>Nical</dc:creator></item><item><title>First release of ieee802154 crate - Partial implementation of the IEEE 802.15.4 standard</title><link>https://users.rust-lang.org/t/first-release-of-ieee802154-0-1-partial-implementation-of-the-ieee-802-15-4-standard/25094</link><description><![CDATA[I’ve released the ieee802154 crate, a partial implementation of the IEEE 802.15.4 standard, earlier this week.  IEEE 802.15.4 is a standard for low-rate wireless personal area networks. It is used as the basis for higher-level protocols like 6LoWPAN, Zigbee, or Thread. The ieee802154 crate is only a partial implementation of this standard, but I hope it can be used as a basis for future work by extending it as required.]]></description><guid isPermaLink="false">5e8e4feb-2bb8-4337-bfba-a71003c797ed</guid><pubDate>Fri,  8 Feb 2019 14:24:56 +0000</pubDate><dc:creator>Hanno Braun</dc:creator></item><item><title>Metered-rs: fast, ergonomic metrics for Rust</title><link>https://users.rust-lang.org/t/metered-rs-fast-ergonomic-metrics-for-rust/25061</link><description><![CDATA[I’m pleased to announce the release of metered-rs, a crate that helps live measurements of code, inspired by Coda Hale’s Java metrics, with the philosophy that measuring program performance at runtime is valuable, and independent from benchmarking.]]></description><guid isPermaLink="false">6b4003d7-f0ce-4105-8ed5-f4bea94f77b9</guid><pubDate>Thu,  7 Feb 2019 18:14:21 +0000</pubDate><dc:creator>Simon Chemouil</dc:creator></item><item><title>Lock-free Rust: Crossbeam in 2019</title><link>https://stjepang.github.io/2019/01/29/lock-free-rust-crossbeam-in-2019.html</link><description><![CDATA[This is a follow-up post to Lock-freedom without garbage collection from 2015, which introduced Crossbeam, a Rust library that implements efficient lock-free data structures without relying on a tracing garbage collector.]]></description><guid isPermaLink="false">7d5bbb25-d599-43d5-82cb-1a4dcdf47286</guid><pubDate>Tue, 29 Jan 2019 00:00:00 +0000</pubDate><dc:creator>Stjepan Glavina</dc:creator></item><item><title>Writing Mails from Rust (1/3): Mail in general</title><link>https://blog.1aim.com/post/002-mail-1-intro/</link><description><![CDATA[This is the first part in a three part blog post about (e-)mails and how to create, encode and send them using the mail crate (a library).]]></description><guid isPermaLink="false">5b4334f5-08f9-450c-88cf-20fe91993cdc</guid><pubDate>Mon, 28 Jan 2019 00:00:00 +0000</pubDate><dc:creator>Philipp Korber</dc:creator></item><item><title>Typetag: Serde serializable and deserializable trait objects</title><link>https://github.com/dtolnay/typetag/blob/master/README.md</link><description><![CDATA[Serde serializable and deserializable trait objects. This crate provides a macro for painless serialization of &dyn Trait trait objects and serialization + deserialization of Box<dyn Trait> trait objects.]]></description><guid isPermaLink="false">c4806dc1-431a-46e2-a950-8f29194a87b1</guid><pubDate>Thu, 24 Jan 2019 01:13:57 +0000</pubDate><dc:creator>David Tolnay</dc:creator></item><item><title>paw at Rust GUIs</title><link>https://medium.com/@m.siglreith/paw-at-rust-guis-d4d848e14b94</link><description><![CDATA[The recent release of Flutter 1.0 was quite exciting for me. I’m not much of anGUI person nor do I make a lot of mobile apps but after looking through some examples, I started to like their take on UI frameworks. In particular, the three aspects mentioned above seemed to be handled very well!

Back to Rust. I wondered how to adopt a similar API under the strict eyes 👀 of the borrow- and typechecker — which resulted in the experimental UI framework paw (in progress..)]]></description><guid isPermaLink="false">04445dcf-4cd1-47ee-b40e-58d17bdf0a9c</guid><pubDate>Thu, 17 Jan 2019 18:12:55 +0000</pubDate><dc:creator>msiglreith</dc:creator></item><item><title>Rust bindings for GStreamerGL: Memoirs</title><link>https://blogs.igalia.com/vjaquez/2019/01/16/rust-bindings-for-gstreamergl-memoirs/</link><description><![CDATA[Thanks to Mozilla and Igalia I have the opportunity to work on Servo, adding it HTML5 multimedia features. First, with the help of Fernando Jiménez, we finished what my colleague Philippe Normand and Sebastian Dröge (one of my programming heroes) started: a media player in Rust designed to be integrated in Servo. This media player lives in its own crate: servo/media along with the WebAudio engine. A crate, in Rust jargon, is like a library. This crate is (very ad-hocly) designed to be multimedia framework agnostic, but the only backend right now is for GStreamer. Later we integrated it into Servo adding an initial support for audio and video tags.]]></description><guid isPermaLink="false">3697f091-2478-437f-bdbb-3e464fe1ab8a</guid><pubDate>Wed, 16 Jan 2019 19:42:55 +0000</pubDate><dc:creator>vjaquez</dc:creator></item><item><title>proc-macro-rules - macro_rules-like pattern matching inside a procedural macro</title><link>https://www.ncameron.org/blog/proc-macro-rules/</link><description><![CDATA[I'm announcing a new library for procedural macro authors: proc-macro-rules (and on crates.io). It allows you to do macro_rules-like pattern matching inside a procedural macro. The goal is to smooth the transition from declarative to procedural macros (this works pretty well when used with the quote crate).]]></description><guid isPermaLink="false">6e54473a-fefd-4447-8888-98137bd74692</guid><pubDate>Wed, 16 Jan 2019 19:27:54 +0000</pubDate><dc:creator>Nick Cameron</dc:creator></item><item><title>Stretch — A flexbox implementation in Rust</title><link>https://medium.com/visly/stretch-a-flexbox-implementation-in-rust-60762b5a3331</link><description><![CDATA[Let’s talk about Layout. Layout is fundamental to any UI application. The layout engine is what takes a set of rules and figures out where to place elements on the screen. This sounds simple enough but as UIs become increasingly complex we rely more on the layout engine to be able to create these UIs as easily as possible. Not only should it be easy to build these UIs but the engine performing this work is also required to do so at minimum cost as it runs possibly on every frame (for example when performing layout animations).]]></description><guid isPermaLink="false">cdb3ed72-c1a4-4ff2-8350-cb5768fd96d4</guid><pubDate>Tue, 15 Jan 2019 20:04:57 +0000</pubDate><dc:creator>Emil Sjölander</dc:creator></item><item><title>Rutie: “The Tie Between Ruby and Rust.”</title><link>https://github.com/danielpclark/rutie/blob/master/README.md</link><description><![CDATA[Integrate Ruby with your Rust application. Or integrate Rust with your Ruby application. This project allows you to do either with relative ease.]]></description><guid isPermaLink="false">7405fc44-d31f-49f8-a260-b837ff0e3f12</guid><pubDate>Thu, 10 Jan 2019 15:23:58 +0000</pubDate><dc:creator>Daniel P. Clark</dc:creator></item><item><title>Parsing, Validating, and Assembling URLs in Rust</title><link>https://www.secretfader.com/blog/2019/01/parsing-validating-assembling-urls-rust/</link><description><![CDATA[These days, we hardly think about URLs. Popular content management tools default to so-called “pretty” slugs, and even here, on secretfader.com, I remove stop-words to ensure the tidiest, most SEO-friendly URLs possible.
It would be easy to forget the struggles that led to best practices of today’s web. However, to my generation of internet hackers, URLs riddled with ampersands and question marks were entirely normal. In those days, assuming URLs would be comprised of hyphenated alphanumeric characters was obviously unsafe; instead, we learned the official standard for parsing and constructing URLs.]]></description><guid isPermaLink="false">2a37239a-12d8-4647-bef0-90312992b2b7</guid><pubDate>Tue,  8 Jan 2019 00:00:00 +0000</pubDate><dc:creator>Nicholas (Fader) Young</dc:creator></item><item><title>generic-array Design and Usage Notes</title><link>https://github.com/fizyk20/generic-array/blob/master/DESIGN.md</link><description><![CDATA[generic-array is a method of achieving fixed-length fixed-size stack-allocated generic arrays without needing const generics in stable Rust.]]></description><guid isPermaLink="false">1dd7a631-a2a9-42e8-ba0c-87b56bc6af38</guid><pubDate>Tue,  8 Jan 2019 00:00:00 +0000</pubDate><dc:creator>Aaron Trent</dc:creator></item><item><title>Scannerless parsing of boolean grammars with derivatives in Rust</title><link>https://github.com/jameysharp/weighted-regexp-rs/blob/master/README.md</link><description><![CDATA[This is yet another library for writing parsers in Rust. What makes this one different is that I've combined some existing academic work in a way that I think is novel. The result is an unusually flexible parsing library while still offering competitive performance and memory usage.]]></description><guid isPermaLink="false">ad9d038f-52e6-4860-a264-61a795428b87</guid><pubDate>Sun,  6 Jan 2019 00:00:00 +0000</pubDate><dc:creator>Jamey Sharp</dc:creator></item><item><title>Version 0.2 of Smithay, a library for making wayland compositors</title><link>https://smithay.github.io/smithay-v-0-2.html</link><description><![CDATA[Announcement of version 0.2 of smithay, now providing the fundamentals of a wayland compositor.]]></description><guid isPermaLink="false">bc334e2e-7ac8-4019-a197-da3d1d19edbf</guid><pubDate>Fri, 28 Dec 2018 17:00:00 +0100</pubDate><dc:creator>Victor Berger</dc:creator></item><item><title>Announcing &apos;err-derive&apos; - yet another error handling library</title><link>https://users.rust-lang.org/t/announcing-err-derive-yet-another-error-handling-library/23594</link><description><![CDATA[err-derive A failure-like derive macro for the std Error. The source code is mostly copied from failure-derive.]]></description><guid isPermaLink="false">0461ffc8-05b3-413d-a015-c0859ed9665f</guid><pubDate>Thu, 27 Dec 2018 13:09:02 +0000</pubDate><dc:creator>Thomas Schaller</dc:creator></item><item><title>Easy Postgres extensions in Rust with pg-extend-rs</title><link>https://bluejekyll.github.io/blog/rust/2018/12/27/announcing-pg-extend.html</link><description><![CDATA[A project to make Postgres extensions in Rust easy, you might learn how to use macro_rules, attribute macros, allocators and some FFI in this post.]]></description><guid isPermaLink="false">043f0bae-caa0-4d77-8336-9ec0813a0ca0</guid><pubDate>Thu, 27 Dec 2018 07:00:00 +0000</pubDate><dc:creator>Benjamin Fry</dc:creator></item><item><title>Jix&apos; Site: Introducing partial_ref</title><link>https://jix.one/introducing-partial_ref/</link><description><![CDATA[Recently there has been some discussion about interprocedural borrowing conflicts in rust. This is something I’ve been fighting with a lot, especially while working on my SAT solver varisat. Around the time Niko Matsakis published his blog post about this, I realized that the existing workarounds I’ve been using in varisat have become a maintenance nightmare. Making simple changes to the code required lots of changes in the boilerplate needed to thread various references to the places where they’re needed.

While I didn’t think that a new language feature to solve this would be something I’d be willing to wait for, I decided to sit down and figure out how such a language feature would have to look like. I knew that I wanted something that allows for partial borrows across function calls. I also prefer this to work with annotations instead of global inference. While trying to come up with a coherent design that fits neatly into the existing type and trait system, I realized that most of what I wanted can be realized in stable rust today.]]></description><guid isPermaLink="false">2508ab68-2b48-4066-a6b4-a15a4f061025</guid><pubDate>Mon, 24 Dec 2018 14:07:10 +0100</pubDate><dc:creator>Jannis Harder</dc:creator></item><item><title>A great 2018, an even better 2019</title><link>https://tokio.rs/blog/2018-12-recap-2018/</link><description><![CDATA[A year ago, Tokio was a very different library. It includes the (now deprecated) tokio-core which provided a future executor, I/O selector, and basic TCP/UDP types in a single library. It also included tokio-proto, but we won't talk about that. Over the past year, Tokio has grown to become Rust's asynchronous I/O platform. It has been adopted by a number of large companies to build apps.]]></description><guid isPermaLink="false">8abe1072-74b2-4cc8-b349-ba38a3bfae1b</guid><pubDate>Wed, 19 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Carl Lerche</dc:creator></item><item><title>QADAPT - debug_assert! for your memory usage</title><link>https://speice.io/2018/12/allocation-safety.html</link><description><![CDATA[I think it’s part of the human condition to ignore perfectly good advice when it comes our way. A bit over a month ago, I was dispensing sage wisdom for the ages: I had a really great idea: build a custom allocator that allows you to track your own allocations. I gave it a shot, but learned very quickly: never write your own allocator. I proceeded to ignore it, because we never really learn from our mistakes. There’s another part of the human condition that derives joy from seeing things explode. And that’s the part I’m going to focus on.]]></description><guid isPermaLink="false">e72d0a8e-198f-4bd2-bf1e-7e0e94fac9d5</guid><pubDate>Sat, 15 Dec 2018 00:00:00 -0500</pubDate><dc:creator>Bradlee Speice</dc:creator></item><item><title>Building Alexa Skills in Rust</title><link>https://medium.com/@amalec/building-alexa-skills-in-rust-4cf54a497ea4</link><description><![CDATA[My favorite way to explore Lambdas is to build Alexa skills because of the immediate feedback: you write a little code, and a home device talks to you. It’s a peek into the long promised of world of easy service composition.

Unfortunately, Rust didn’t have complete Alexa skill request/response handling (there is a crate from 2 years ago that handled only the basics), so I wrote one called alexa_sdk. (It’s basically a struct plus serde wrapper around the Alexa JSON spec, with some helpers.]]></description><guid isPermaLink="false">36dce8e1-2508-4e34-8aaf-1eb43a8b17e1</guid><pubDate>Sun,  9 Dec 2018 21:30:38 +0000</pubDate><dc:creator>Arien Malec</dc:creator></item><item><title>Spirit Tutorial</title><link>https://vorner.github.io/2018/12/09/Spirit-Tutorial.html</link><description><![CDATA[In short, when writing a daemon or a service, we have the „muscle“ of the application ‒ whatever we write the daemon for. And we have a whole lot of infrastructure around that: logging, command line parsing, configuration. And while there are Rust libraries for all that, one needs nontrivial amount of boilerplate code to bridge all this together. Spirit aims to be this bridge.]]></description><guid isPermaLink="false">8f8ef893-ae80-4991-9d17-93049ee0adc6</guid><pubDate>Sun,  9 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Michal &apos;vorner&apos; Vaner</dc:creator></item><item><title>encoding_rs: a Web-Compatible Character Encoding Library in Rust</title><link>https://hsivonen.fi/encoding_rs/</link><description><![CDATA[encoding_rs is a high-decode-performance, low-legacy-encode-footprint and high-correctness implementation of the WHATWG Encoding Standard written in Rust. In Firefox 56, encoding_rs replaced uconv as the character encoding library used in Firefox. This wasn’t an addition of a component but an actual replacement: uconv was removed when encoding_rs landed. This writeup covers the motivation and design of encoding_rs, as well as some benchmark results.]]></description><guid isPermaLink="false">62aed63f-688e-45cd-9d1e-5247b3cbeae3</guid><pubDate>Mon,  3 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Henri Sivonen</dc:creator></item><item><title>Writing MapReduce Jobs Using Rust and Efflux</title><link>https://whitfin.io/writing-mapreduce-jobs-using-rust/</link><description><![CDATA[During my work life, I spend a lot of time working with MapReduce-style workflows, particularly with Hadoop infrastructure. A lot of this work is spent with larger amounts of data in order to implement the batch layer of the Lambda architecture. Due to this, the largest concern is that the behaviour is consistent across both the batch layer and the realtime layer - naturally you wouldn't want sporadic behaviour across the two. The easiest way to do this is to share code across the layers, to avoid having to keep implementations in sync. We have recently been working with Rust, which has been a little difficult to integrate with Hadoop MapReduce flows due to the fact it's mainly written in Java. It's because of this that I began to work on a small library named Efflux. It's designed as a very small interface to the MapReduce pattern, and implemented in Rust to allow us to share code across the batch layer easily.]]></description><guid isPermaLink="false">00a3f85a-45c7-42b3-8fac-605dcb945229</guid><pubDate>Wed, 28 Nov 2018 07:00:49 +0000</pubDate><dc:creator>Isaac Whitfield</dc:creator></item><item><title>Thessaloniki GNOME+Rust Hackfest 2018</title><link>https://people.gnome.org/~federico/blog/thessaloniki-gnome-rust-2018.html</link><description><![CDATA[A couple of weeks ago we had the fourth GNOME+Rust hackfest, this time in Thessaloniki, Greece.  We held the hackfest at the CoHo coworking space, a small, cozy office between the University and the sea. Every such hackfest I am overwhelmed by the kind hackers who work on [gnome-class], the code generator for GObject implementations in Rust.]]></description><guid isPermaLink="false">7828aada-388f-4b7b-bac1-24de2e65cf6a</guid><pubDate>Tue, 27 Nov 2018 17:37:31 -0600</pubDate><dc:creator>Federico Mena Quintero</dc:creator></item><item><title>Rust+GNOME Hackfest #4</title><link>http://antoyo.ml/rust-gnome-hackfest-thessaloniki</link><description><![CDATA[Less than 2 weeks ago, I was working on improving the integration of Rust with GNOME libraries at the fourth Hackfest, which happened this time in Thessaloniki.]]></description><guid isPermaLink="false">c9feb6f2-ba42-42ca-a0a3-dc37f4ce69ff</guid><pubDate>Sun, 25 Nov 2018 00:00:00 +0000</pubDate><dc:creator>Antoni Boucher</dc:creator></item><item><title>Implementing an EBNF grammar in pest</title><link>https://compenguy.github.io/hobbies/rust/ebnf-to-pest.html</link><description><![CDATA[A recent project has led me to have a go at writing an XML parser. I thought I’d document my experiences using pest to implement a lexer using the EBNF-esque formal grammar.]]></description><guid isPermaLink="false">fd9c743c-fb89-4e75-8a46-a837c02174a1</guid><pubDate>Thu, 22 Nov 2018 05:46:00 +1100</pubDate><dc:creator>Will Page</dc:creator></item><item><title>Wait-Free Per-Object Thread-Local Storage</title><link>https://bzim.gitlab.io/blog/posts/wait-free-per-object-thread-local-storage.html</link><description><![CDATA[In this post, I present a wait-free thread-local storage using the Rust language.]]></description><guid isPermaLink="false">3c9dc7f2-978e-4663-900e-8a49c10bf57f</guid><pubDate>Sun, 18 Nov 2018 00:00:00 +0000</pubDate><dc:creator>Bruno Corrêa Zimmermann</dc:creator></item><item><title>Introducing pest into glsl and hindsight about nom vs. pest (part 2)</title><link>https://phaazon.net/blog/glsl-pest-part-2</link><description><![CDATA[This is the second article about my experience at supporting pest in my glsl crate – without, for now, removing the nom parser.]]></description><guid isPermaLink="false">84353bd7-6977-4894-883f-b917ccef0b45</guid><pubDate>Sat, 17 Nov 2018 20:40:00 +0000</pubDate><dc:creator>Dimitri Sabadie</dc:creator></item><item><title>Introducing pest into glsl and hindsight about nom vs. pest (part 1)</title><link>https://phaazon.net/blog/glsl-pest-part-1</link><description><![CDATA[This is the first article out of a (I guess?!) series of upcoming articles about… parsing. More specifically, I’ve been writing the glsl crate for a while now and the current, in-use parser is backed with nom. nom is a parser combinator crate written originally by @geal and there has been a lot of fuzz around nom vs. pest lately.

Soooooooooooo. Because glsl is written with nom in its third iteration and because nom is now at version 4, I decided it was time to update the parser code of glsl. I heard about the comparison between pest and nom and decided to write an implementation with pest.

This is the first article of a series about how writing a pest looks like is fun compared to writing the nom parser. I’ll post several articles as I advance and see interesting matter to discuss and share.]]></description><guid isPermaLink="false">2a3a85cf-b4ac-49ff-9a27-4d377cd3d0cb</guid><pubDate>Sat, 17 Nov 2018 05:00:00 +0000</pubDate><dc:creator>Dimitri Sabadie</dc:creator></item><item><title>Gutenberg is out, Zola 0.5.0 is in</title><link>https://www.vincentprouillet.com/blog/releasing-zola-0-5-0/</link><description><![CDATA[Gutenberg changes name to Zola and gets a big release to celebrate.]]></description><guid isPermaLink="false">6b8f2916-9634-4d6b-ae64-02d565c58659</guid><pubDate>Sat, 17 Nov 2018 00:00:00 +0000</pubDate><dc:creator>Vincent Prouillet</dc:creator></item><item><title>Rust, MongoDB &amp; Wither 0.6</title><link>https://medium.com/docql/https-medium-com-docql-rust-mongodb-wither-13e803c9ae72</link><description><![CDATA[Hello everyone! I would like to share an update on an open source project which I have been developing for a little while now. It is a Rust project called Wither which attempts to “provide a simple, sane & predictable interface into MongoDB, based on data models”. This post is about the 0.6 release of this crate, and I would like to dive into some of the aspects of developing this release which I really enjoyed or which I found interesting.]]></description><guid isPermaLink="false">b21ca2e0-5670-4a7b-af11-3a6c1312d5e2</guid><pubDate>Wed, 14 Nov 2018 18:33:12 +0000</pubDate><dc:creator>Anthony Dodd</dc:creator></item><item><title>Introducing Mundane, a new cryptography library for Rust</title><link>https://joshlf.com/post/2018/11/06/introducing-mundane/</link><description><![CDATA[Mundane is a cryptography library written in Rust and backed by BoringSSL. It aims to be difficult to misuse, ergonomic, and performant (in that order). It was originally created to serve the cryptography needs of Fuchsia, but we’ve decided to split it off as a general-purpose crate.]]></description><guid isPermaLink="false">b612b468-7306-4f7b-a09a-2b4f0bac5b55</guid><pubDate>Tue,  6 Nov 2018 00:00:00 +0000</pubDate><dc:creator>Joshua Liebow-Feeser</dc:creator></item><item><title>eyeoh: My first Rust library</title><link>https://sts10.github.io//2018/11/02/eyeoh-rust-library.html</link><description><![CDATA[I realized I kept copy and pasting (or re-writing) functions to take user input or read simple files into Rust variables. So I’ve been working on a Rust library that attempts to make these tasks easier.]]></description><guid isPermaLink="false">db47620d-045e-42dc-bc1a-6aedaed9d948</guid><pubDate>Fri,  2 Nov 2018 22:18:50 +0000</pubDate><dc:creator>Sam Schlinkert</dc:creator></item><item><title>Pyro - A fast, small and documented Entity Component System</title><link>https://maikklein.github.io/pyro-ecs/</link><description><![CDATA[In contrast to many other ECS, iteration in Pyro is fully linear. Different combinations of components always live in the same storage. The advantage is that iteration is always fully linear and no cache is wasted. The storage behind the scene is a SoA storage.]]></description><guid isPermaLink="false">092a372d-fa4a-48e7-8382-c85069e9a425</guid><pubDate>Tue, 30 Oct 2018 00:00:00 +0000</pubDate><dc:creator>Maik Klein</dc:creator></item><item><title>Configuration envy</title><link>https://medium.com/@softprops/configuration-envy-a09584386705</link><description><![CDATA[For many of my use cases for running Rust applications, storing configuration in file format is less attractive as I’m typically running Rust inside docker containers and container orchestrators typically encourage the use of standard interfaces like the env for configuration. So I pondered 🤔, “What if I could treat my program’s env parameterization with the same level of typing I treat my functions and enclosing types with while getting everything one get’s from using serde for free?” That would be the bee’s knees 🐝 . Enter: envy.]]></description><guid isPermaLink="false">2e4df02b-88e0-4510-851a-d1dce6014568</guid><pubDate>Tue, 16 Oct 2018 04:17:18 +0000</pubDate><dc:creator>Doug Tangren</dc:creator></item><item><title>Reflections on Implementing the ndarray-csv Crate</title><link>https://paulkernfeld.com/2018/10/13/ndarray-csv-reflections.html</link><description><![CDATA[Recently, I wrote ndarray-csv, a Rust crate for converting between CSV files and 2D arrays. There are already crates for CSV and arrays, so how exciting could this possibly be? Actually, there was a lot more to it than I had thought: although it started out as a two-hour project, I ended up rewriting the entire thing three times!]]></description><guid isPermaLink="false">11700b19-9b9f-44c3-9708-2c4cd7f0d721</guid><pubDate>Sat, 13 Oct 2018 00:00:00 +0000</pubDate><dc:creator>Paul Kernfeld</dc:creator></item><item><title>Rust SGX SDK v1.0.4 Released</title><link>https://medium.com/baiduxlab/rust-sgx-sdk-v1-0-4-released-9c7d9056a888</link><description><![CDATA[Rust SGX SDK, maintained by Baidu X-Lab, is a convenient framework to develop secure trusted computing applications for Intel SGX enclaves. Based on it, developers can easily build trusted SGX enclaves with memory safety guarantees. This adds an extra strong (and strongest ever) security layer over the SGX isolation, further keeping attackers away from the secrets in enclave even if they compromised the privileged software environment (operating system, hypervisor, etc.). Rust SGX SDK thus means a lot to privacy protection and trusted computing on public cloud platforms and blockchains.]]></description><guid isPermaLink="false">620115c2-e4f9-4c5c-953a-d891cc636b01</guid><pubDate>Tue,  9 Oct 2018 17:50:10 +0000</pubDate><dc:creator>Baidu X-Lab</dc:creator></item><item><title>New crate: pin-cell</title><link>https://boats.gitlab.io/blog/post/pin-cell/</link><description><![CDATA[Today I realized a new crate called pin-cell. This crate contains a type called PinCell, which is a kind of cell that is similar to RefCell, but only can allow pinned mutable references into its interior. Right now, the crate is nightly only and no-std compatible.
How is the API of PinCell different from RefCell? When you call borrow_mut on a RefCell, you get a type back that implements DerefMut, allowing you to mutate the interior value.]]></description><guid isPermaLink="false">9ed3a1ea-2c0d-4508-a2d7-69e9bb07557a</guid><pubDate>Tue,  9 Oct 2018 00:00:00 +0000</pubDate><dc:creator>withoutboats</dc:creator></item><item><title>pest Parser 2.0 Released</title><link>https://pest.rs/</link><description><![CDATA[pest is a general purpose parser written in Rust with a focus on accessibility, correctness, and performance. It uses parsing expression grammars (or PEG) as input, which are similar in spirit to regular expressions, but which offer the enhanced expressivity needed to parse complex languages. ]]></description><guid isPermaLink="false">a708e2c2-f0bd-4691-88c0-d004bedd667a</guid><pubDate>Thu,  4 Oct 2018 00:00:00 +0000</pubDate><dc:creator>Dragoș Tiselice</dc:creator></item><item><title>What is Rusty ECMA Script Scanner (RESS)</title><link>https://wiredforge.com/blog/rusty_ecma/what-is-a-scanner/index.html</link><description><![CDATA[After releasing the Rusty ECMA Script Scanner (RESS) 0.5, my next big effort in the Rust+Javascript space is to increase the amount of documentation. This post is an effort to clarify what RESS does and how someone might use it.]]></description><guid isPermaLink="false">38c548bb-e3d4-428d-9a95-89ca0c8ce3c9</guid><pubDate>Tue,  2 Oct 2018 00:00:00 +0000</pubDate><dc:creator>Robert Masen</dc:creator></item><item><title>Merlin: flexible, composable transcripts for zero-knowledge proofs</title><link>https://medium.com/@hdevalence/merlin-flexible-composable-transcripts-for-zero-knowledge-proofs-28d9fda22d9a</link><description><![CDATA[Merlin is a small Rust library that performs the Fiat-Shamir transformation in software, maintaining a STROBE-based transcript of the proof protocol and allowing the prover to commit messages to the transcript and compute challenges bound to all previous messages. It also provides a transcript-based RNG for use by the prover, generalizing “deterministic” and “synthetic” nonces to arbitrarily complex zero-knowledge protocols.]]></description><guid isPermaLink="false">2e26b090-21b9-42e2-9ac5-9664e79af88e</guid><pubDate>Fri, 28 Sep 2018 21:07:20 +0000</pubDate><dc:creator>Henry de Valence</dc:creator></item><item><title>‘orion’ - yet another attempt at pure-Rust cryptography</title><link>https://brycx.github.io/2018/09/25/orion-pure-rust-crypto-lib.html</link><description><![CDATA[orion is another attempt at cryptography implemented in pure Rust. Its main focus is usability. This is in part achieved by providing a thorough documentation of the library. High-level abstractions are also provided, which are an attempt at guiding the users towards safe usage of the lower-level functionality of the library.]]></description><guid isPermaLink="false">96405556-ac98-433a-a0f8-c3de068e47d3</guid><pubDate>Tue, 25 Sep 2018 00:00:00 +0000</pubDate><dc:creator>brycx</dc:creator></item><item><title>GStreamer Rust bindings 0.12 and GStreamer Plugin 0.3 release</title><link>https://coaxion.net/blog/2018/09/gstreamer-rust-bindings-0-12-and-gstreamer-plugin-0-3-release/</link><description><![CDATA[After almost 6 months, a new release of the GStreamer Rust bindings and the GStreamer plugin writing infrastructure for Rust is out. As usual this was coinciding with the release of all the gtk-rs crates to make use of all the new features they contain.]]></description><guid isPermaLink="false">956dab4d-a04e-4278-bb20-906f4eac7a82</guid><pubDate>Mon, 10 Sep 2018 11:41:59 +0000</pubDate><dc:creator>Sebastian Dröge</dc:creator></item><item><title>Sonnerie: A simple timeseries database</title><link>https://github.com/njaard/sonnerie</link><description><![CDATA[Sonnerie is a time-series database. Map a timestamp to a floating-point value. Store multiple of these series in a single database. Insert tens of millions of samples in minutes, on rotational media.]]></description><guid isPermaLink="false">9572581f-4d30-4abb-9aa8-8f7842b37117</guid><pubDate>Sat,  8 Sep 2018 00:00:00 +0000</pubDate><dc:creator>Kalle Samuels</dc:creator></item><item><title>Announcing Spirit</title><link>https://vorner.github.io/2018/09/03/Announcing-Spirit.html</link><description><![CDATA[Spirit is a crate that cuts down on boilerplate when creating unix daemons, with support for live configuration reloading.]]></description><guid isPermaLink="false">919b55ea-6ff7-4893-8c6f-1bd17b6cbab2</guid><pubDate>Mon,  3 Sep 2018 00:00:00 +0000</pubDate><dc:creator>Michal &apos;vorner&apos; Vaner</dc:creator></item><item><title>GIR support in gnome-class</title><link>http://danigm.net/gnome-class-gir.html</link><description><![CDATA[Recently I've been working again in the rust port of libgepub, libgepub is C code, but in the rust-migration branch almost all the real functionality is done with rust and the GepubDoc class is a GObject wrapper around that code. For this reason I was thinking about to use gnome-class to implement GepubDoc. Gnome-class is a rust lib to write GObject code in rust that's compatible with the C binary API so then you can call this new GObject code written with gnome-class from C. So, libgepub is the excuse to start to implement GIR in gnome-class.]]></description><guid isPermaLink="false">d1f041f8-f77b-404b-a776-5615afef85f4</guid><pubDate>Sat,  1 Sep 2018 00:00:00 +0200</pubDate><dc:creator>danigm</dc:creator></item><item><title>Introducing windows-acl: working with ACLs in Rust</title><link>https://blog.trailofbits.com/2018/08/23/introducing-windows-acl-working-with-acls-in-rust/</link><description><![CDATA[Access Control Lists (ACLs) are an integral part of the Microsoft Windows security model. In addition to controlling access to secured resources, they are also used in sandboxing, event auditing, and specifying mandatory integrity levels. They are also exceedingly painful to programmatically manipulate, especially in Rust. Today, help has arrived — we released windows-acl, a Rust crate that simplifies the manipulation of access control lists on Windows.]]></description><guid isPermaLink="false">99ecbdf0-983f-42d8-850a-5e0532770f17</guid><pubDate>Thu, 23 Aug 2018 11:50:39 +0000</pubDate><dc:creator>Trail of Bits</dc:creator></item><item><title>Toykio, a toy event loop</title><link>https://rust-lang-nursery.github.io/futures-rs/blog/2018/08/17/toykio.html</link><description><![CDATA[In this blog post I’d like to present toykio, a simple futures executor intended for learning about how executors with an event loop work. Toykio only provides a very minimal feature set: An event loop and TCP streams and listeners. However, it turns out that due to the fact that futures are composable, this is enough to build complex clients and servers.]]></description><guid isPermaLink="false">e53853b1-a7ca-4ffc-bf71-510ed37ea402</guid><pubDate>Fri, 17 Aug 2018 00:00:00 +0000</pubDate><dc:creator>Alexander Polakov</dc:creator></item><item><title>Futures 0.3.0-alpha.3</title><link>https://rust-lang-nursery.github.io/futures-rs/blog/2018/08/15/futures-0.3.0-alpha.3.html</link><description><![CDATA[A compatibility layer between 0.3 an 0.1 was developed. It is now possible to convert an 0.3 future into an 0.1 future and vice versa. Similar conversions for streams and sinks are also supported. Additionally, it is now possible to run 0.3 futures and async functions on Tokio’s executor. We have a dedicated blog post coming up that explains this in more detail.]]></description><guid isPermaLink="false">2105e8ca-6037-4dfa-86f7-644bdbec71bd</guid><pubDate>Wed, 15 Aug 2018 00:00:00 +0000</pubDate><dc:creator>Josef Brandl</dc:creator></item><item><title>Tower Web 0.2 — Now 100% comment attribute free</title><link>https://medium.com/@carllerche/tower-web-0-2-now-100-comment-attribute-free-3ed0633e47e5</link><description><![CDATA[The short version is, Tower Web 0.2 was just released and regular Rust attributes are now used instead of magic comments. The doc comment is replaced with #[get("/")]. This is thanks to Rust macro wizard David Tolnay. I also thought that it would be best to immediately push out 0.2 and then we can all pretend 0.1 didn’t happen.]]></description><guid isPermaLink="false">e9ddc1eb-5ab9-4f23-8b9a-a41cea991044</guid><pubDate>Tue, 14 Aug 2018 16:22:13 +0000</pubDate><dc:creator>Carl Lerche</dc:creator></item><item><title>PrettySize for rust</title><link>https://neosmart.net/blog/2018/prettysize-for-rust/</link><description><![CDATA[We’ve just published a rust port of our PrettySize.NET library, now available via cargo and github. Like its .NET predecessor, PrettySize-rs aims to provide a comprehensive API for dealing with file sizes, covering both manipulation and human-readable formatting.]]></description><guid isPermaLink="false">02a5f7b7-0114-440d-9be0-d5aaf77bfa65</guid><pubDate>Sat, 11 Aug 2018 20:56:39 +0000</pubDate><dc:creator>Mahmoud Al-Qudsi</dc:creator></item><item><title>A small custom Bool Type in Diesel</title><link>https://noyez.gitlab.io/post/2018-08-05-a-small-custom-bool-type-in-diesel/</link><description><![CDATA[I’ve been working with diesel and serde. I use diesel for my postgres datastore, and serde for serializing/deserializing data to the web. Recently I came across a situation where I needed to define my type in diesel as well as implement deserialize in serde. The example below is a fairly simple so it makes for a good example to share so others can learn (and so I can remember how all this works next time I need it).]]></description><guid isPermaLink="false">2182c554-41eb-4ee7-a1de-11eb90a8223d</guid><pubDate>Sun,  5 Aug 2018 00:00:00 +0000</pubDate><dc:creator>Noyez</dc:creator></item><item><title>Amethyst 0.8 has been released!</title><link>https://www.amethyst.rs/blog/release-0-8/</link><description><![CDATA[With a brand new tutorial and a ton of new features, including prefabs, controller support, MP3 audio, localisation and an even better ergonomics!]]></description><guid isPermaLink="false">b5717efe-ad7b-4b02-8554-aba801aff909</guid><pubDate>Sun,  5 Aug 2018 00:00:00 +0000</pubDate><dc:creator>Moxinilian (Théo Degioanni)</dc:creator></item><item><title>Gutenberg 0.4.0: custom taxonomies, image processing and more</title><link>https://www.vincentprouillet.com/blog/releasing-gutenberg-0-4-0/</link><description><![CDATA[Gutenberg 0.4.0 is out with custom taxonomies, image processing, improved shortcodes and more.]]></description><guid isPermaLink="false">c1718910-2677-4da4-a45f-a8bd055fe075</guid><pubDate>Sat,  4 Aug 2018 00:00:00 +0000</pubDate><dc:creator>Vincent Prouillet</dc:creator></item><item><title>intl_pluralrules: A Rust Crate for Handling Plural Forms with CLDR Plural Rules</title><link>https://blog.mozilla.org/l10n/2018/08/03/intl_pluralrules-a-rust-crate-for-handling-plural-forms-with-cldr-plural-rules/</link><description><![CDATA[intl_pluralrules is a Rust crate, built to handle pluralization. Pluralization is the foundation for all localization and many internationalization APIs. With the addition of intl_pluralrules, any locale-aware date-, time- or unit-formatting (“1 second” vs “2 seconds”) and many other pluralization-dependent APIs can be added to Rust.]]></description><guid isPermaLink="false">577e9c57-0455-41c6-9711-be71bf55e550</guid><pubDate>Fri,  3 Aug 2018 23:30:19 +0000</pubDate><dc:creator>Kekoa Riggin</dc:creator></item><item><title>Sequoia, a new OpenPGP implementation</title><link>https://www.reddit.com/r/rust/comments/93mng5/ann_sequoia_a_new_openpgp_implementation/</link><description><![CDATA[This past fall, three former GnuPG developers began working on a new OpenPGP implementation in Rust called Sequoia. As it’s starting to shape up and become useful, I feel now is a good time to announce the project to the larger Rust community, and hopefully get some feedback before our first release.]]></description><guid isPermaLink="false">81096070-a563-47a0-8f09-2e5fb3c1b984</guid><pubDate>Wed,  1 Aug 2018 16:50:12 +1000</pubDate><dc:creator>/u/nwalfield</dc:creator></item><item><title>warp</title><link>http://seanmonstar.com/post/176530511587/warp</link><description><![CDATA[Over the past several months, I’ve been working a web framework in Rust. I wanted to make use of the new hyper 0.12 changes, so the framework is just as fast, is asynchronous, and benefits from all the improvements found powering Linkerd. More importantly, I wanted there to be a reason for making a new framework; it couldn’t just be yet another framework with the only difference being I’ve written it. Instead, the way this framework is used is quite different than many that exist. In doing so, it expresses a strong opinion, which might not match your previous experiences, but I believe it manages to do something really special.

I’m super excited to reveal warp, a joint project with @carllerche.]]></description><guid isPermaLink="false">55adde79-edfa-433f-8c4f-40f2baee7cd9</guid><pubDate>Wed,  1 Aug 2018 00:00:00 +0000</pubDate><dc:creator>Sean McArthur</dc:creator></item><item><title>#[derive(Debug)] on serde steroids</title><link>https://rreverser.com/derive-serdebug/</link><description><![CDATA[In this post I'd like to introduce a serdebug helper which is a drop-in replacement for #[derive(Debug)] with some of the advanced features that serde can provide.]]></description><guid isPermaLink="false">0a171d26-74e1-491c-befd-e02ac528c1ff</guid><pubDate>Tue, 31 Jul 2018 16:00:45 +0000</pubDate><dc:creator>Ingvar Stepanyan</dc:creator></item><item><title>Futures 0.3.0-alpha.2</title><link>https://rust-lang-nursery.github.io/futures-rs/blog/2018/07/30/futures-0.3.0-alpha.2.html</link><description><![CDATA[Several new changes while working towards 0.3.]]></description><guid isPermaLink="false">e29e550b-7c05-4625-9a81-513b316b5675</guid><pubDate>Mon, 30 Jul 2018 00:00:00 +0000</pubDate><dc:creator>Josef Brandl</dc:creator></item><item><title>Using C libraries in Rust: make a sys crate</title><link>https://kornel.ski/rust-sys-crate</link><description><![CDATA[Using C libraries in a portable way involves a bit of work: finding the library on the system or building it if it's not available, checking if it is compatible, finding C headers and converting them to Rust modules, and giving Cargo correct linking instructions. Often every step of this is tricky, because operating systems, package managers and libraries have their unique quirks that need special handling.

Fortunately, all this work can be done once in a build script, and published as a <insert library name>-sys Rust crate. This way other Rust programmers will be able to use the C library without having to re-invent the build script themselves.]]></description><guid isPermaLink="false">e0622344-66a9-4b93-a59f-1b5250ba8c98</guid><pubDate>Mon, 30 Jul 2018 00:00:00 +0000</pubDate><dc:creator>Kornel</dc:creator></item><item><title>nphysics: 2D and 3D real-time physics engine</title><link>http://nphysics.org/</link><description><![CDATA[I’m excited to announce the brand new website/user-guide for the nphysics2d and nphysics3d crates: pure-rust 2D and 3D real-time physics engines with rigid bodies and joints! Online wasm-based demos are also provided (see for example the Multibody joints 34 demo).]]></description><guid isPermaLink="false">a3f0bd42-0a42-4156-9fd6-74aebe5f0465</guid><pubDate>Sun, 29 Jul 2018 03:46:07 +1000</pubDate><dc:creator>Sébastien Crozet</dc:creator></item><item><title>Futures 0.3.0-alpha.1</title><link>https://rust-lang-nursery.github.io/futures-rs/blog/2018/07/19/futures-0.3.0-alpha.1.html</link><description><![CDATA[Welcome to the inaugural post of the new futures-rs blog!

After several months of work, we’re happy to announce an alpha release of the new edition of future-rs, version 0.3. The immediate goal of this work is to support async/await notation (with borrowing) in Rust itself, which has entailed significant changes to the futures crate.]]></description><guid isPermaLink="false">2a8864ba-0872-45d2-89f4-87e9f368374b</guid><pubDate>Thu, 19 Jul 2018 17:00:00 +0000</pubDate><dc:creator>Aaron Turon</dc:creator></item><item><title>Wayland-rs 0.21: Pure Rust implementation</title><link>https://smithay.github.io/wayland-rs-v-0-21.html</link><description><![CDATA[wayland-rs is a set of crates providing generic APIs to manipulate the Wayland protocol, successor of X11 for linux windowing.

Here I am finally, after having hinted at the possibility and finally taken the time to write and merge quite an epic pull request, I can finally say it: wayland-rs is now a pure rust implementation of the protocol, rather than a crate of bindings to the wayland system C libraries.]]></description><guid isPermaLink="false">e5caa9df-4d3f-46be-a8ce-79369f0cad32</guid><pubDate>Wed, 18 Jul 2018 22:00:00 +0200</pubDate><dc:creator>Victor Berger</dc:creator></item><item><title>Zapper: A Very Fast Templating Engine</title><link>https://ceres1.space/posts/zapper/</link><description><![CDATA[Thirty times faster than Handlebars, half the features! I am introducing a new templating engine for Rust that is designed to be robust and very fast! Why Zapper? Runtime templating is amazing, since you can reload templates on the fly or even allow users to provide their own templates, yet runtime templating engines are rarely fast. Templates that are statically compiled into your application can be super fast, but are completely inflexible. Recompiling and restarting your application just to change a template is especially boring. Zapper combines the flexibility of runtime templating with great performance!]]></description><guid isPermaLink="false">989d2bb2-c78b-4844-92ab-45509164c182</guid><pubDate>Mon, 25 Jun 2018 19:28:22 -0700</pubDate><dc:creator>Josh Leverette</dc:creator></item><item><title>Better HTTP Upgrades with hyper</title><link>http://seanmonstar.com/post/175280388657/better-http-upgrades-with-hyper</link><description><![CDATA[Better HTTP Upgrades with hyper It’s been possible to handle HTTP Upgrades (like Websockets) in hyper if you made use of the low-level APIs in the server and client, but it wasn’t especially nice to...]]></description><guid isPermaLink="false">faf1a345-9eaf-4d00-a7f7-9fa3afaa51ac</guid><pubDate>Tue, 26 Jun 2018 00:00:00 +0000</pubDate><dc:creator>Sean McArthur</dc:creator></item><item><title>Building an Event Sourcing Crate for Rust</title><link>https://medium.com/@KevinHoffman/building-an-event-sourcing-crate-for-rust-2c4294eea165</link><description><![CDATA[In one of my recent blog posts, I talked about Event Sourcing with Aggregates in Rust. In that post, I was just beginning to explore how the Rust language and its strongly typed native data structures would allow me to express event sourcing concepts and primitives. I have now created an initial version of an Event Sourcing crate that you can explore on crates.io]]></description><guid isPermaLink="false">ced93c25-32fb-4e74-a5e4-5fb7cd60e8ee</guid><pubDate>Mon, 25 Jun 2018 13:30:42 +0000</pubDate><dc:creator>Kevin Hoffman</dc:creator></item><item><title>What I Learned: Porting Dateutil Parser to Rust</title><link>https://speice.io/2018/06/dateutil-parser-to-rust.html</link><description><![CDATA[Hi. I’m Bradlee. I’ve mostly been a lurker in Rust for a while, making a couple small contributions here and there. So launching dtparse feels like nice step towards becoming a functioning member of society. But not too much, because then you know people start asking you to pay bills, and ain’t nobody got time for that.

But I built dtparse, and you can read about my thoughts on the process. Or don’t. I won’t tell you what to do with your life (but you should totally keep reading).]]></description><guid isPermaLink="false">9c9c6dda-6538-4088-8123-e1ad213082e5</guid><pubDate>Mon, 25 Jun 2018 00:00:00 +0000</pubDate><dc:creator>Bradlee Speice</dc:creator></item><item><title>Writing Python Extensions In Rust Using PyO3</title><link>https://www.benfrederickson.com/writing-python-extensions-in-rust-using-pyo3/</link><description><![CDATA[I've been writing some code in Rust recently, and I thought it would be cool if I could take some of this Rust code and provide it as a native extension that I can call from Python. It turns out there are some amazing tools like PyO3 that make it easy to write fully featured Python extensions in Rust, with considerably less effort than writing a CPython extension manually.

To test out PyO3 I wrote a small Python extension in Rust, and I thought I would share some of the tips and tricks I encountered in getting this going. This post aims to serve as a quick tutorial showing how to write extensions in Rust, talking about why you might want to use something more powerful than just exposing a C library called using CFFI, and how PyO3 lets you write Python aware extensions in Rust. ]]></description><guid isPermaLink="false">afc3d2f1-e848-4c25-af60-89cf7209b3ba</guid><pubDate>Thu, 21 Jun 2018 00:00:00 -0700</pubDate><dc:creator>Ben Frederickson</dc:creator></item><item><title>Building better compression together with DivANS</title><link>https://blogs.dropbox.com/tech/2018/06/building-better-compression-together-with-divans/</link><description><![CDATA[Compressing your files is a good way to save space on your hard drive. At Dropbox’s scale, it’s not just a good idea; it is essential. Even a 1% improvement in compression efficiency can make a huge difference. That’s why we conduct research into lossless compression algorithms that are highly tuned for certain classes of files and storage, like Lepton for jpeg images, and Pied-Piper-esque lossless video encoding. For other file types, Dropbox currently uses the zlib compression format, which saves almost 8% of disk storage.

We introduce DivANS, our latest open-source contribution to compression, in this blog post.]]></description><guid isPermaLink="false">ff081914-cb16-4004-bc20-53e494477b8c</guid><pubDate>Tue, 19 Jun 2018 16:00:24 +0000</pubDate><dc:creator>Daniel Reiter Horn and Jongmin Baek</dc:creator></item><item><title>Fast and Simple Rendering in Rust using Proc Macros</title><link>https://medium.com/@MertzAlertz/fast-and-simple-rendering-in-rust-using-proc-macros-f0d919eb6475</link><description><![CDATA[I’ve been working on a project called Thruster recently, and needed a way that a developer could reasonably use templates. Thruster is a middleware based web server written in Rust (get it, th-rust-er? I’m working on my tight 5 for amateur night at The Apollo,) and as such, I needed a way to load HTML templates and insert variables into them in a performant way. Rather than poking around the numerous existing libraries and choosing one made by someone I don’t know — stranger danger! — I decided to make it myself. This article is about that journey, the unbelievably thrilling adventures of writing my first proc_macro_derive in Rust.]]></description><guid isPermaLink="false">31acdf03-3f59-4102-81ba-edafd6f2cfad</guid><pubDate>Tue, 19 Jun 2018 13:22:54 +0000</pubDate><dc:creator>Pete Mertz</dc:creator></item><item><title>A Trick For Test Maintenance</title><link>https://matklad.github.io/2018/06/18/a-trick-for-test-maintenance.html</link><description><![CDATA[This is a post about an interesting testing technique which feels like it should be well known. However, I haven’t seen it mentioned anywhere. I don’t even have a good name for it, I’ve semi-discovered it in the wild. If you know how this thing is called, please leave a comment!]]></description><guid isPermaLink="false">4548e0ef-697b-414c-8bf5-9a63a707bafb</guid><pubDate>Mon, 18 Jun 2018 15:00:16 +0000</pubDate><dc:creator>Aleksey Kladov</dc:creator></item><item><title>Let&apos;s Talk About Vector Graphics (In Rust)</title><link>https://nical.github.io/posts/rustfest-paris-01.html</link><description><![CDATA[I gave a talk about lyon at RustFest Paris. This post is the introduction of the talk, wherein I introduce vector graphics and try to get the audience somewhat excited about it. Things will get technical in the follow-up posts.]]></description><guid isPermaLink="false">edd88db5-3f05-4171-9159-de17a3a4db8a</guid><pubDate>Mon, 18 Jun 2018 00:00:00 +0200</pubDate><dc:creator>Nical</dc:creator></item><item><title>Tarpaulin Past Present Future</title><link>https://xd009642.github.io/2018/06/11/Tarpaulin-past-present-future.html</link><description><![CDATA[Tarpaulin (or cargo-tarpaulin) is a code coverage tool for Rust. Last year was pretty busy with the launch of the project and the rush of issues as people started to use it so this is just a chance to look at what’s new with version 0.6.0 and what’s planned for the rest of this year.]]></description><guid isPermaLink="false">27c8b7ed-32ab-4390-8be8-58678541dfb8</guid><pubDate>Mon, 11 Jun 2018 00:00:00 +0000</pubDate><dc:creator>xd009642</dc:creator></item><item><title>Integrating QML and Rust: Creating a QMetaObject at Compile Time</title><link>https://woboq.com/blog/qmetaobject-from-rust.html</link><description><![CDATA[In this blog post, I would like to present a research project I have been working on: Trying to use QML from Rust, and in general, using a C++ library from Rust. The project is a Rust crate which allows to create QMetaObject at compile time from pure Rust code. It is available here: https://github.com/woboq/qmetaobject-rs]]></description><guid isPermaLink="false">f98c539d-bf5c-4329-a4b2-bba3c4816350</guid><pubDate>Thu,  7 Jun 2018 00:00:00 +0000</pubDate><dc:creator>Olivier Goffart</dc:creator></item><item><title>Crates.rs — a new, faster crate index website</title><link>https://crates.rs/index</link><description><![CDATA[Crates.rs, an alternative opinionated front-end to crates.io:

It’s fast.

All readmes are displayed whenever possible, and if there’s no or poor readme, doc comments are shown too.

It combines information from multiple sources, e.g. byline is a compact amalgamation of Cargo.toml, crates.io, and GitHub contributors, so you get an idea who wrote the code even if authors forgot to keep Cargo.toml up to date.

Crate popularity is displayed as top-N position in its most relevant category, e.g. “#5 in Cryptography”, which is more meaningful than absolute download numbers.

Optional dependencies display which feature or platform they’re for.

Version history is summarized to help see at a glance whether a crate gets regular updates and how often it has breaking changes.

Recognizes sys crates even if they’re not called -sys and shows when build.rs is used.

Category pages fit more crates on screen despite looking less cluttered and having easier to read descriptions.

All categories and their representative crates are right there on the homepage.

Syntax highlighting everywhere, including code blocks.

Everything works without JS and gets indexed by search engines, so I’m hoping the site will help find crates.]]></description><guid isPermaLink="false">01dd6aee-aa4b-46b9-a4dc-5d2550a96356</guid><pubDate>Mon,  4 Jun 2018 23:27:00 +0000</pubDate><dc:creator>Kornel</dc:creator></item><item><title>hyper v0.12</title><link>http://seanmonstar.com/post/174480374517/hyper-v012</link><description><![CDATA[Today sees the release of hyper v0.12.0, a fast and correct HTTP library for the Rust language.

This release adds support for several new features, while taking the opportunity to fix some annoyances, and improve the extreme speeds!]]></description><guid isPermaLink="false">9bf3f488-ace2-43b6-9f6b-3071241f7ed2</guid><pubDate>Fri,  1 Jun 2018 00:00:00 +0000</pubDate><dc:creator>Sean McArthur</dc:creator></item><item><title>HTTP Crate with URL Support &amp; a Simple HTTP Client</title><link>https://pyfisch.org/blog/http-with-url/</link><description><![CDATA[While the http crate generally has a great API I have been unsatisfied how it handles URLs. To create a HTTP request a full URL is needed with a scheme (http/https), authority (example.org) and a path (/search?q=rust) but http does enforce this and allows you to only state the path. This means both clients and servers are either unable to determine protocol and and authority information or have to do this manually.]]></description><guid isPermaLink="false">d7340b81-5e94-4123-b830-c5cbbfa154d2</guid><pubDate>Fri,  1 Jun 2018 00:00:00 +0000</pubDate><dc:creator>Pyfisch</dc:creator></item><item><title>nom 4.0: faster, safer, simpler parsers</title><link>http://unhandledexpression.com/general/2018/05/14/nom-4-0-faster-safer-simpler-parsers.html</link><description><![CDATA[It took nearly 6 months of development and the library went through nearly 5 entire rewrites. Compare that to previous major releases, which took a month at most to do. But it was worth it! This new release cleans up a lot of old bugs and unintuitive behaviours, simplifies some common patterns, is faster, uses less memory, gives better errors, but the way parsers are written stay the same. It’s like an entirely new engine under the same body work!]]></description><guid isPermaLink="false">600945e6-9cca-43fc-abe3-8b39f5eb1766</guid><pubDate>Mon, 14 May 2018 13:00:00 +0200</pubDate><dc:creator>Geoffroy Couprie</dc:creator></item><item><title>gtk-test - A crate for testing GTK UIs</title><link>http://gtk-rs.org/blog/2018/05/02/who-talked-about-testing.html</link><description><![CDATA[Currently, testing UIs is difficult, but with gtk-test you can test basically everything UI-related way more simply.]]></description><guid isPermaLink="false">df6d6cbf-58fc-49e6-a582-446c255a3d39</guid><pubDate>Wed,  2 May 2018 00:00:00 +0000</pubDate><dc:creator>Gtk-rs</dc:creator></item><item><title>New Tokio release, now with filesystem support</title><link>https://tokio.rs/blog/2018-05-tokio-fs/</link><description><![CDATA[It took a bit longer than I had initially hoped (as it always does), but a new Tokio version has been released. This release includes, among other features, a new set of APIs that allow performing filesystem operations from an asynchronous context.]]></description><guid isPermaLink="false">bcdee764-328b-440f-b1de-d4f4d4c14604</guid><pubDate>Wed,  2 May 2018 00:00:00 +0000</pubDate><dc:creator>Carl Lerche</dc:creator></item><item><title>Introducing Sentry for Rust</title><link>https://blog.sentry.io/2018/05/01/sentry-for-rust</link><description><![CDATA[As happy Rust users ourselves, it makes us even happier to be able to say that we now have a Sentry Rust SDK. This means you and your Fungiculture can now report panics, failures, and other types of incidents to Sentry.

Not only is the SDK new and fancy, it is also one of the first ones that follows our new API guidelines for Sentry SDKs, which makes it even newer and fancier than you might normally expect.]]></description><guid isPermaLink="false">83c972be-a658-4858-9277-474eebee81a1</guid><pubDate>Tue,  1 May 2018 00:00:00 +0000</pubDate><dc:creator>Armin Ronacher</dc:creator></item><item><title>Learn Rust by project</title><link>http://blog.jeffsmits.net/compsci/2018/04/30/learn-rust-by-project/</link><description><![CDATA[More than a year ago a friend of mine wanted to learn a bit more about Rust by trying out a project. He had a nice project in mind which suits Rust quite well I think. For fun I joined his effort and created an implementation at the same time as he did, discussing and comparing along the way. In this post I’ll tell you about the project specifics, but the point of the post is more an encouragement. If you’ve read about Rust before but haven’t tried it yet, find a small project like the one below, and learn Rust in a fun and hands-on way yourself. It’s a great programming language, I highly recommend it.]]></description><guid isPermaLink="false">d517cda7-1102-49bb-ab34-d14f5f0d09c0</guid><pubDate>Mon, 30 Apr 2018 00:00:00 +0000</pubDate><dc:creator>Jeff Smits</dc:creator></item><item><title>Rust+GNOME Hackfest #3</title><link>http://antoyo.ml/rust-gnome-hackfest-madrid</link><description><![CDATA[Last week, I was working on improving the integration of Rust with GNOME libraries at the third Hackfest, which happened this time in Madrid.]]></description><guid isPermaLink="false">8576f0a6-2866-4ac7-af07-dffd8e4ea019</guid><pubDate>Tue, 24 Apr 2018 00:00:00 +0000</pubDate><dc:creator>Antoni Boucher</dc:creator></item><item><title>im - Immutable Data Structures for Rust</title><link>https://docs.rs/im/10.0.0/im/</link><description><![CDATA[This library implements several of the more commonly useful immutable data structures for Rust. They rely on structural sharing to keep most operations fast without needing to mutate the underlying data store, leading to more predictable code without necessarily sacrificing performance.]]></description><guid isPermaLink="false">318f9d08-d86a-4799-ac08-75014d089475</guid><pubDate>Fri,  6 Apr 2018 21:06:00 +0000</pubDate><dc:creator>Bodil Stokke</dc:creator></item><item><title>MesaLink memory-safe and OpenSSL-compatible TLS library</title><link>https://github.com/mesalock-linux/mesalink</link><description><![CDATA[MesaLink is a memory-safe and OpenSSL-compatible TLS library. Since 2014, the industry has seen a huge loss due to memory vulnerabilities in TLS stacks, such as the infamous "Heartbleed" bug. MesaLink is created with the goal of eliminating memory vulnerabilities in TLS stacks. MesaLink is written in Rust, a programming language that guarantees memory safety. This significantly reduces the attack surfaces, which facilitates auditing and restricting the remaining attack surfaces. MesaLink is cross-platform and provides OpenSSL-compatible APIs. It works seamlessly in desktop, mobile, and IoT devices. With the growth of the ecosystem, MesaLink would also be adopted in the server environment in the future.]]></description><guid isPermaLink="false">afc97289-36f8-4acb-ab80-28e7770ea126</guid><pubDate>Fri,  6 Apr 2018 07:00:00 +1000</pubDate><dc:creator>MesaLock Linux</dc:creator></item><item><title>HTTP upgrades with hyper</title><link>http://seanmonstar.com/post/172531530657/http-upgrades-with-hyper</link><description><![CDATA[The newest release of hyper includes some lower-level connection APIs for both the server and client. Notably, this allows using hyper send and receive HTTP upgrade requests. The most popular of these is Websockets.]]></description><guid isPermaLink="false">0cb16bc7-daff-4747-81e5-d4455d33fc43</guid><pubDate>Mon,  2 Apr 2018 14:34:53 -0700</pubDate><dc:creator>Sean McArthur</dc:creator></item><item><title>Analysing crates.io data</title><link>https://tirkarthi.github.io/rust/2018/03/30/analyzing-crates-data.html</link><description><![CDATA[I am learning Clojure for the past one year and I thought making open source contributions is a great way to interact with the community. I made a post previously on using Clojars metadata to analyse JDK 9 and Clojure 1.9 issues that helped me file issues to ensure compatibility. I used the same method here to find the modules that were broken on a nightly version of a rustc due to a recent stabilisation.]]></description><guid isPermaLink="false">effc3ea9-0e61-4b47-ad1b-20782addb1bd</guid><pubDate>Fri, 30 Mar 2018 18:30:29 +0000</pubDate><dc:creator>Karthikeyan</dc:creator></item><item><title>New Timer implementation in Tokio</title><link>https://tokio.rs/blog/2018-03-timers/</link><description><![CDATA[To close out a great week, there is a new release of Tokio. This release includes a brand new timer implementation.]]></description><guid isPermaLink="false">cca40bed-4eaf-46c6-ae72-1e49ed3ef2ad</guid><pubDate>Fri, 30 Mar 2018 00:00:00 +0000</pubDate><dc:creator>Carl Lerche</dc:creator></item><item><title>History of the Rand crate</title><link>https://www.reddit.com/r/rust/comments/87qy40/history_of_the_rand_crate/</link><description><![CDATA[I wrote this bit to give a some background about why Rand looks the way it does, and why it is time to make some changes. The new release, Rand 0.5, is getting almost ready fro release. Also I hope it is a bit entertaining to read about the history in combination with early Rust.]]></description><guid isPermaLink="false">d6f7c587-36f5-4276-8b5b-60cd8d857606</guid><pubDate>Wed, 28 Mar 2018 21:52:43 +1100</pubDate><dc:creator>u/pitdicker</dc:creator></item></channel></rss>