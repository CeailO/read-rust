{
  "version": "https://jsonfeed.org/version/1",
  "title": "Read Rust - Crates",
  "home_page_url": "https://readrust.net/",
  "feed_url": "https://readrust.net/crates/feed.json",
  "description": "Crates posts on Read Rust",
  "author": {
    "name": "Wesley Moore",
    "url": "http://www.wezm.net/"
  },
  "items": [
    {
      "id": "7e260d4f-38ce-456b-be84-83ad8c13f4df",
      "title": "Announcing async-std 1.0",
      "content_text": "async-std is a port of Rust’s standard library to the async world. It comes with a fast runtime and is a pleasure to use. We’re happy to finally announce async-std 1.0. As promised in our first announcement blog post, the stable release coincides with the release of Rust 1.39, the release adding async/.await. We would like to thank the active community around async-std for helping get the release through the door.",
      "url": "https://async.rs/blog/announcing-async-std-1-0/",
      "date_published": "2019-11-11T00:00:00+00:00",
      "author": {
        "name": "Florian Gilcher",
        "url": "https://async.rs/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "2f92e5a1-d218-459f-a417-c5e4f58be832",
      "title": "CSS in librsvg is now in Rust, courtesy of Mozilla Servo",
      "content_text": "After an epic amount of refactoring, librsvg now does all CSS parsing and matching in Rust, without using libcroco. In addition, the CSS engine comes from Mozilla Servo, so it should be able to handle much more complex CSS than librsvg ever could before. This is the story of CSS support in librsvg.",
      "url": "https://people.gnome.org/~federico/blog/css-in-librsvg-is-now-in-rust.html",
      "date_published": "2019-11-11T19:36:04-06:00",
      "author": {
        "name": "Federico Mena Quintero",
        "url": "https://people.gnome.org/~federico/blog/index.html"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "eab14a89-9177-44ce-8259-07c6ae33bdfa",
      "title": "iou: Rust bindings for liburing",
      "content_text": "Today I’m releasing a library called iou. This library provides idiomatic Rust bindings to the C library called liburing, which itself is a higher interface for interacting with the io_uring Linux kernel interface. Here are the answers to some questions I expect that may provoke.\n\nWhat is io_uring? io_uring is an interface added to the Linux kernel in version 5.1. Concurrent with that, the primary maintainer of that interface has also been publishing a library for interacting with it called liburing.",
      "url": "https://boats.gitlab.io/blog/post/iou/",
      "date_published": "2019-11-08T00:00:00+00:00",
      "author": {
        "name": "boats",
        "url": "https://boats.gitlab.io/blog/"
      },
      "tags": [
        "Crates",
        "Operating Systems"
      ]
    },
    {
      "id": "30aad534-3914-4d3a-90f3-bc092652d92b",
      "title": "sorted-vec: A sorted array with O(lg n) access and O(√n) inserts and deletes",
      "content_text": "This repository contains implementations, unit tests, and benchmark code for the \"2-level rotated array\" structure, first published in Munro and Suwanda's 1979 paper \"Implicit Data Structures for Fast Search and Update\" (which also introduced the much better-known beap data structure). This structure is further developed and discussed in \"Implicit Data Structures for the Dictionary Problem\" (1983) and \"Succinct Dynamic Data Structures\" (2001). (The latter generalizes the idea to the dynamic array abstract data type, rather than a sorted array.)\n\nThe theoretical advantage of a 2-level rotated array over an ordinary sorted array is that it provides the same search performance (O(log n)), with much better insert and delete performance (O(√n), compared to O(n) for a sorted array), in exactly the same amount of space (i.e., no more than the data itself).",
      "url": "https://github.com/senderista/sorted-vec",
      "date_published": "2019-10-27T00:00:00+00:00",
      "author": {
        "name": "Tobin Baker",
        "url": "https://github.com/senderista"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "61d6deeb-4ef7-4ad7-b6d8-3d9c650501c8",
      "title": "Making Good On Momo’s Compile-Time Promise",
      "content_text": "When I announced momo, I wanted its users to save both binary size and compile time while keeping their code simple. I succeeded in the first goal, but failed regarding the second. The reason was that momo requires syn and quote which (unless you have other proc macros in your dependencies) add their own compile time to yours.",
      "url": "https://llogiq.github.io/2019/10/28/momo-fast.html",
      "date_published": "2019-10-28T00:00:00+00:00",
      "author": {
        "name": "Llogiq",
        "url": "http://llogiq.github.io/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "6b61d3a8-a487-4399-a347-43e16c50abc1",
      "title": "This month in rustsim #8 (August − September - October 2019)",
      "content_text": "Welcome to the eighth edition of This month in rustsim! This monthly newsletter will provide you with a summary of important update that occurred within the rustsim community. This includes in particular updates about the nphysics (physics engine), salva (fluid simulation), ncollide (for collision-detection), nalgebra (for linear algebra), and alga (for abstract algebra) crates. This eighth edition will actually contain updates for the past three months (I got sick between the second and third month so I did not get the time to write a new post then. Sorry!)",
      "url": "https://www.rustsim.org/blog/2019/11/01/this-month-in-rustsim/",
      "date_published": "2019-11-01T00:00:00+00:00",
      "author": {
        "name": "Sébastien Crozet",
        "url": "https://www.rustsim.org/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "44aef346-22de-444d-9258-0fe74a38d50d",
      "title": "Towards Overflower 1.0",
      "content_text": "The overflower crate contains a helper library and procedural attribute macro to allow specifying how overflow should be handled. Since its inception, it has relied on specialization to change just the integer arithmetics while leaving the other operations basically unchanged.",
      "url": "https://llogiq.github.io/2019/10/23/overflower.html",
      "date_published": "2019-10-23T00:00:00+00:00",
      "author": {
        "name": "Llogiq",
        "url": "http://llogiq.github.io/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "a128d6c7-98e7-4c7d-85df-1d23003ac824",
      "title": "fancy-regex: crate for regular expressions using \"fancy\" features like look-around and backreferences",
      "content_text": "A Rust library for compiling and matching regular expressions. It uses a hybrid regex implementation designed to support a relatively rich set of features. In particular, it uses backtracking to implement \"fancy\" features such as look-around and backtracking, which are not supported in purely NFA-based implementations (exemplified by RE2, and implemented in Rust in the regex crate).",
      "url": "https://github.com/fancy-regex/fancy-regex",
      "date_published": "2019-10-19T00:00:00+00:00",
      "author": {
        "name": "Raph Levien and Robin Stocker",
        "url": "https://github.com/fancy-regex"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "76b70816-eaa3-4343-b4b8-8f4d675575a1",
      "title": "Announcing Asuran, a new de-duplicating archiver with encryption",
      "content_text": "This archiver does deduplication, encryption, compression, data verification, and (ideally) supports backing up to untrusted storage, including cloud storage (though currently it only supports a local storage backend).",
      "url": "https://www.reddit.com/r/rust/comments/ddu1dq/announcing_asuran_a_new_deduplicating_archiver/",
      "date_published": "2019-10-06T00:00:00+00:00",
      "author": {
        "name": "Nathan McCarty",
        "url": "https://gitlab.com/thatonlutenist"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "d871ed8d-ed33-4814-8953-725eb83ba1e9",
      "title": "Semantic validation in Rust",
      "content_text": "If you need to validate complex data structures at runtime in the programming language Rust then our semval library may empower you to enrich your domain model with semantic validation.",
      "url": "https://slowtec.de/posts/2019-09-03-semantic-validation-with-rust.html",
      "date_published": "2019-09-03T00:00:00+00:00",
      "author": {
        "name": "slowtec",
        "url": "https://slowtec.de/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "8ae54c44-f631-4d1e-bcfc-66edd7805468",
      "title": "This month in heim, the system information crate",
      "content_text": "It’s been a month and a half since the heim public announcement, so it’s about time to sum up the work done and make a roadmap for next development iteration. As a quick reminder: heim is the Rust cross-platform async library for system information fetching — CPU, memory, disks, networks, you name it.",
      "url": "https://svartalf.info/posts/2019-09-02-this-month-in-heim-august-2019/",
      "date_published": "2019-09-02T00:00:00+00:00",
      "author": {
        "name": "Nikita Kuznetsov",
        "url": "https://svartalf.info/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "3a399e6a-a660-464b-90c0-9cee92eade7c",
      "title": "Criterion.rs v0.3 - Custom Measurements, Profiling Hooks, Custom Test Framework, API Changes",
      "content_text": "I’m pleased to announce the release of Criterion.rs v0.3, available today. Version 0.3 provides a number of new features including preliminary support for plugging in custom measurements (eg. hardware timers or POSIX CPU time), hooks to start/stop profilers, a new BenchmarkGroup struct that provides more flexibility than the older Benchmark and ParameterizedBenchmark structs, and an implementation of a #[criterion] custom-test-framework macro for those on Nightly.",
      "url": "https://bheisler.github.io/post/criterion-rs-0-3/",
      "date_published": "2019-08-25T10:30:00-06:00",
      "author": {
        "name": "Brook Heisler",
        "url": "https://bheisler.github.io/"
      },
      "tags": [
        "Performance",
        "Crates"
      ]
    },
    {
      "id": "8de2bce6-9245-4f95-b12c-ca3e38efb3bb",
      "title": "Migrate spirit to version 0.4",
      "content_text": "This post can serve as a step by step migration guide from spirit 0.3 to spirit 0.4. If you already have an application using the crate, read on.\n\nIf you haven’t heard about the spirit library yet, it is a library to help you manage your configuration in an application and have it reloaded at runtime. It allows you to have the changes applied automatically and also to manage lifetime of the application. You can read more about it here. In that case, a migration guide won’t help you much, but I’m planning on having a tutorial how to start with the library soon.",
      "url": "https://vorner.github.io/2019/10/19/migrate-spirit-to-0-4.html",
      "date_published": "2019-10-19T00:00:00+00:00",
      "author": {
        "name": "Michal 'vorner' Vaner",
        "url": "https://vorner.github.io/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "f33cd82d-46fa-4e3e-97e9-0bef43ba9b00",
      "title": "Watt: A runtime for executing Rust procedural macros compiled as WebAssembly",
      "content_text": " By compiling macros ahead-of-time to Wasm, we save all downstream users of the macro from having to compile the macro logic or its dependencies themselves. Instead, what they compile is a small self-contained Wasm runtime (~3 seconds, shared by all macros) and a tiny proc macro shim for each macro crate to hand off Wasm bytecode into the Watt runtime (~0.3 seconds per proc-macro crate you depend on). This is much less than the 20+ seconds it can take to compile complex procedural macros and their dependencies.",
      "url": "https://github.com/dtolnay/watt",
      "date_published": "2019-10-15T00:00:00+00:00",
      "author": {
        "name": "David Tolnay",
        "url": "https://github.com/dtolnay"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "97ca4165-4f8c-4c57-872d-e5986df0c7ee",
      "title": "Making the Tokio scheduler 10x faster",
      "content_text": "We’ve been hard at work on the next major revision of Tokio, Rust’s asynchronous runtime. Today, a complete rewrite of the scheduler has been submitted as a pull request. The result is huge performance and latency improvements. Some benchmarks saw a 10x speed up! It is always unclear how much these kinds of improvements impact “full stack” use cases, so we’ve also tested how these scheduler improvements impacted use cases like Hyper and Tonic (spoiler: it’s really good).",
      "url": "https://tokio.rs/blog/2019-10-scheduler/",
      "date_published": "2019-10-13T00:00:00+00:00",
      "author": {
        "name": "Carl Lerche",
        "url": "https://tokio.rs/"
      },
      "tags": [
        "Performance",
        "Crates"
      ]
    },
    {
      "id": "10dac43f-1aba-416e-bfbb-190a33ad2c5d",
      "title": "mda-rs: Custom Mail Delivery Agents in Rust",
      "content_text": "With mda-rs I wanted to create an experience as close as possible to using an interpreted domain specific language, the approach follow by typical MDAs, while still having the performance and power of a full, compiled language at the fingertips. One aspect of this experience was providing an API that feels like natural fit for the intended purpose. The other aspect was providing a straightforward way to build a custom MDA. For this second aspect, the simplicity of Rust's cargo was one of the reasons I decided to use Rust for this project.",
      "url": "https://afrantzis.com/posts/mda-rs/",
      "date_published": "2019-10-07T00:00:00+00:00",
      "author": {
        "name": "Alexandros Frantzis",
        "url": "https://afrantzis.com/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "22724643-a42b-447d-98e2-6d7d3ad56aed",
      "title": "Persy transactional storage engine version 0.7",
      "content_text": "In the last couple of months just right after the release of Persy 0.6 the development speeded up a bit, a few people started to play with persy and some downstream projects as well, first reporting few critical issue that produced the 3 hotfix 0.6.1,0.6.2,0.6.3 and then starting contributing back.",
      "url": "https://persy.rs/posts/persy-0.7.html",
      "date_published": "2019-10-11T07:23:00+00:00",
      "author": {
        "name": "tglman",
        "url": "https://gitlab.com/tglman"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "33fc22f5-6021-4395-b8ab-7f5f25ec2384",
      "title": "reqwest alpha.await",
      "content_text": "reqwest alpha.await reqwest is a higher-level HTTP client for Rust. I’m delighted to announce the first alpha release that brings async/await support!",
      "url": "https://seanmonstar.com/post/188220739932/reqwest-alphaawait",
      "date_published": "2019-10-08T00:00:00+00:00",
      "author": {
        "name": "Sean McArthur",
        "url": "http://seanmonstar.com/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "3fc0a35d-5eab-4143-98d5-7325738364e4",
      "title": "Riker - a framework for building modern, concurrent and resilient systems using the Rust language using the actor model",
      "content_text": "Riker is a framework for building modern, concurrent and resilient systems using the Rust language. Riker aims to make working with state and behavior in concurrent systems as easy and scalable as possible. The Actor Model has been chosen to realize this because of the familiar and inherent simplicity it provides while also providing strong guarantees that are easy to reason about. The Actor Model also provides a firm foundation for resilient systems through the use of the actor hierarchy and actor supervision.",
      "url": "https://riker.rs/",
      "date_published": "2019-10-08T00:00:00+00:00",
      "author": {
        "name": "Riker",
        "url": "https://riker.rs/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "b2b15138-1280-44d7-95a0-9e5954a14b9a",
      "title": "Announcing Bastion 0.2.0!",
      "content_text": "Bastion is a fault-tolerant runtime for Rust applications. After receiving plenty of good feedback from the community and a long-running development stage, now Bastion is 0.2.0!",
      "url": "https://www.reddit.com/r/rust/comments/day85g/announcing_bastion_020/",
      "date_published": "2019-10-06T04:16:30+00:00",
      "author": {
        "name": "Mahmut Bulut",
        "url": "https://twitter.com/vertexclique"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "e2d3a9d7-cc8b-4cd5-8d5b-3bb986487601",
      "title": "Static Assertions 1.0",
      "content_text": "static_assertions is a library designed to enable users to perform various checks at compile-time. It allows for finding errors quickly and early when it comes to ensuring certain features or aspects of a codebase. The macros it provides are especially important when exposing a public API that requires types to be the same size or implement certain traits.",
      "url": "https://nikolaivazquez.com/posts/programming/rust-static-assertions-1_0/",
      "date_published": "2019-10-02T00:00:00+00:00",
      "author": {
        "name": "Nikolai Vazquez",
        "url": "https://nikolaivazquez.com/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "c7b37ead-766f-4ca9-b816-eb99a0c01b33",
      "title": "Diagnostics with Tracing",
      "content_text": "Effectively developing systems and operating them in production requires visibility into their behavior at runtime. While conventional logging can provide some of this visibility, asynchronous software &mdash; like applications using the Tokio runtime &mdash; introduces new challenges.\n\ntracing is a collection of libraries that provide a framework for instrumenting Rust programs to collect structured, context-aware, event driven diagnostics. Note that tracing was originally released under the name tokio-trace; the name was changed to reflect that, although it is part of the Tokio project, the tokio runtime is not required to use tracing.",
      "url": "https://tokio.rs/blog/2019-08-tracing/",
      "date_published": "2019-08-14T00:00:00+00:00",
      "author": {
        "name": "Eliza Weisman",
        "url": "https://www.elizas.website/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "e2f780ad-41db-499a-999c-321f0e8f556e",
      "title": "We want smaller, faster, more secure native apps",
      "content_text": "Introducing Tauri-Apps, an open-source project to help you make native apps with any framework with the power of Rust.",
      "url": "https://medium.com/tauri-apps/we-want-smaller-faster-more-secure-native-apps-77222f590c64",
      "date_published": "2019-09-05T20:57:20.829+00:00",
      "author": {
        "name": "nothingismagick",
        "url": "https://medium.com/@drthompsonsmagickindustries"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "8e664490-3dfb-419b-8281-61ea737dd762",
      "title": "Announcing actix-raft: Raft distributed consensus implemented using Actix",
      "content_text": "An implementation of the Raft distributed consensus protocol using the Actix actor framework. Blazing fast Rust, a modern consensus protocol, an outstanding actor framework. This project intends to provide a backbone for the next generation of distributed data storage systems (SQL, NoSQL, KV, Streaming &c) built with Rust.",
      "url": "https://railgun-rs.github.io/actix-raft/overview.html",
      "date_published": "2019-08-28T00:00:00+00:00",
      "author": {
        "name": "Anthony Dodd",
        "url": "https://railgun-rs.github.io/actix-raft/overview.html"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "f40bd89a-d036-4bfd-819a-9f7c128707d9",
      "title": "Animate code with awoo!",
      "content_text": "Lately, I’ve been wanting to re-write demoscene-like applications. Not in the same mood and way as I usually did, though. Instead, I want to build small things for people to play with. A bit like small and easy to use audiovisual experiences (it can be seen as small video games for instance, but focused on the artistic expression as some games do).\n\nThe thing is, the kind of program we want generates its own inputs based on, mostly, the speed at which the hardware it’s running on is able to render a complete frame. The faster the more accurate we sample from that continuous function. That is actually quite logical: more FPS means, literally, more images to sample. The difference between two images will get less and less noticeable as the number of FPS rises. That gives you smooth images.\n\nThe “challenge” here is to write code to schedule those images. Instead of taking a parameter like the time on the command-line and rendering the corresponding image, we will generate a stream of images and will do different things at different times. Especially in demoscene productions, we want to synchronize what’s on the screen with what’s playing on the audio device.",
      "url": "https://phaazon.net/blog/introducing-awoo",
      "date_published": "2019-07-28T11:00:00+00:00",
      "author": {
        "name": "Dimitri Sabadie",
        "url": "http://phaazon.net/"
      },
      "tags": [
        "Games and Graphics",
        "Crates"
      ]
    },
    {
      "id": "9ce993e1-4fda-4f75-9d26-9b15c084d07c",
      "title": "This month in rustsim #7 (June − July 2019)",
      "content_text": "Welcome to the seventh edition of _This month in rustsim_! This monthly newsletter will provide you with a",
      "url": "https://www.rustsim.org/blog/2019/08/01/this-month-in-rustsim/",
      "date_published": "2019-08-01T00:00:00+00:00",
      "author": {
        "name": "Sébastien Crozet",
        "url": "https://www.rustsim.org/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "2439dd44-0bd5-437e-bb60-f7b24b4f02f2",
      "title": "Codenano, a tool for designing DNA nanostructures",
      "content_text": "We are proud to announce the release of our software codenano, available at https://dna.hamilton.ie/codenano/. Here, we give an introduction to what codenano can and can not do. The source code for codenano is hosted on a github repository: https://github.com/thenlevy/codenano, along with a short tutorial.\n\nCodenano allows one to design and visualise DNA nanostructures specified using code, all in your browser. Codenano also has the ability to compute some simple interactions between DNA bases in order to help the user design DNA nanostructures that are feasible according to some simple criteria. ",
      "url": "https://dna.hamilton.ie/2019-07-18-codenano.html",
      "date_published": "2019-07-18T00:00:00+00:00",
      "author": {
        "name": "Nicolas Levy, Pierre-Étienne Meunier and Damien Woods",
        "url": "https://dna.hamilton.ie/codenano/"
      },
      "tags": [
        "Computer Science",
        "Crates"
      ]
    },
    {
      "id": "f0cc3e18-ac97-474b-b8f1-416a9e11aadc",
      "title": "Implementing Lempel-Ziv Jaccard Distance (LZJD) in Rust",
      "content_text": "One of our clients helps companies in becoming GDPR-compliant. A goal is to recognize sensitive pieces of user data in a big pile of registrations, receipts, emails, and transcripts, and mark them to be checked out later. As more and more data is collected by companies, finding and eliminating sensitive data becomes harder and harder, to the point where it is no longer possible for mere human employees to keep up without assistance.",
      "url": "https://tweedegolf.nl/blog/33/implementing-lempel-ziv-jaccard-distance-lzjd-in-rust",
      "date_published": "2019-08-06T00:00:00+00:00",
      "author": {
        "name": "Henk Dieter",
        "url": "https://tweedegolf.nl/blog"
      },
      "tags": [
        "Computer Science",
        "Crates"
      ]
    },
    {
      "id": "a998ed84-202b-48ad-b8ca-829ae5f387ef",
      "title": "Using Tree-sitter Parsers in Rust",
      "content_text": "Tree-sitter is a parser generator tool and parsing library. It generates portable parsers that can be used in several languages including Rust. Tree-sitter grammars are available for several languages. This is a game changer because it lowers the barrier to entry for writing language tooling. You no longer need to write your own parser. With Tree-sitter, you can now simply use an existing parser.",
      "url": "https://rfdonnelly.github.io/posts/using-tree-sitter-parsers-in-rust/",
      "date_published": "2019-08-07T11:20:33-07:00",
      "author": {
        "name": "Rob Donnelly",
        "url": "https://rfdonnelly.github.io/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "1e20c763-7a28-429e-9d68-e3628dcc2edd",
      "title": "Artichoke is a Ruby made with Rust",
      "content_text": "Artichoke is a platform for building MRI-compatible Ruby implementations. Artichoke provides a Ruby runtime implemented in Rust that can be loaded into many VM backends.",
      "url": "https://github.com/artichoke/artichoke",
      "date_published": "2019-08-23T00:00:00+00:00",
      "author": {
        "name": "Ryan Lopopolo",
        "url": "https://github.com/lopopolo"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "2d8f15c2-34f2-4bc2-a1b2-aef6744a9691",
      "title": "surf",
      "content_text": "Today we're happy to announce Surf, an asynchronous cross-platform streaming HTTP client for Rust. This project was a collaboration between Kat Marchán (Entropic / Microsoft), Stjepan Glavina (Ferrous Systems), and myself (Yoshua Wuyts). Surf is a friendly HTTP client built for casual Rustaceans and veterans alike. ",
      "url": "https://blog.yoshuawuyts.com/surf/",
      "date_published": "2019-08-14T00:00:00+00:00",
      "author": {
        "name": "Yoshua Wuyts",
        "url": "https://blog.yoshuawuyts.com/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "5b6c323e-57a0-4281-86ee-67c3a4bf6173",
      "title": "Announcing async-std",
      "content_text": "We are excited to announce a beta release of async-std with the intent to publish version 1.0 by September 26th, 2019. async-std is a library that looks and feels like the Rust standard library, except everything in it is made to work with async/await exactly as you would expect it to. The library comes with a book and polished API documentation, and will soon provide a stable interface to base your async libraries and applications on. While we don't promise API stability before our 1.0 release, we also don't expect to make any breaking changes.",
      "url": "https://async.rs/blog/announcing-async-std/",
      "date_published": "2019-08-16T00:00:00+00:00",
      "author": {
        "name": "Stjepan Glavin",
        "url": "https://async.rs/blog"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "5f582def-af9d-44cb-9a18-648bff14bd67",
      "title": "Introducing glam and mathbench",
      "content_text": "glam is a simple and fast Rust linear algebra library for games and graphics. mathbench is a set of unit tests and benchmarks comparing the performance of glam with the popular Rust linear algebra libraries cgmath and nalgebra. The following is a table of benchmarks produced by mathbench comparing glam performance to cgmath and nalgebra on f32 data.",
      "url": "http://bitshifter.github.io/2019/07/10/introducing-glam-and-mathbench/",
      "date_published": "2019-07-10T00:00:00+00:00",
      "author": {
        "name": "Cameron Hart",
        "url": "https://bitshifter.github.io/"
      },
      "tags": [
        "Performance",
        "Crates"
      ]
    },
    {
      "id": "b958f8b9-38f2-42e9-8cb9-9b7c59f7b875",
      "title": "Tokio alpha release with async & await",
      "content_text": "We’re pleased to announce the release of the first Tokio alpha with async & await support. This includes updating all of the Tokio crates to use std::future instead of futures 0.1. It also includes adding async fn versions of the APIs.",
      "url": "https://tokio.rs/blog/2019-08-alphas/",
      "date_published": "2019-08-08T00:00:00+00:00",
      "author": {
        "name": "Tokio",
        "url": "https://tokio.rs/blog/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "14ef4b09-79cc-424c-88bd-97a5d40ec957",
      "title": "cHTTP 0.5 and the Journey Ahead",
      "content_text": "One of my more recent projects that I have been putting a lot of effort into is a Rust HTTP client called cHTTP, which I introduced on this blog over 18 months ago. Here I want to share an update on the direction of the project, and also give some detail on what months of late evenings and weekends produced in version 0.5 just published today.",
      "url": "https://stephencoakley.com/2019/07/22/chttp-0.5-and-the-journey-ahead",
      "date_published": "2019-07-22T05:00:00+00:00",
      "author": {
        "name": "Stephen Coakley",
        "url": "https://stephencoakley.com/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "c91d6ec8-c734-495e-89ad-e63da5825eb0",
      "title": "Announcing heim: async library for system information fetching",
      "content_text": "If you are familiar with Python ecosystem, probably you had heard about psutil package — a cross-platform library for retrieving information about system processes and system utilization (CPU, memory, disks, network and so on). It is very popular and actively used package, which has analogs in other languages: gopsutil for Golang, oshi for Java, you name it. Rust, of course, is not an exception here: we do have psutil, sysinfo, sys-info and systemstat crates.\n\nNow, despite the tremendous work that had been done already by the authors of these crates, I’m excited to announce what I’ve been working on for the past three months: “heim” project — library for system information fetching.",
      "url": "https://svartalf.info/posts/2019-07-17-announcing-heim-project/",
      "date_published": "2019-07-17T00:00:00+00:00",
      "author": {
        "name": "Nikita Kuznetsov",
        "url": "https://svartalf.info/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "4f959a60-5f69-4997-b6d8-6cf6e8311e1f",
      "title": "How to use Torch in Rust with tch-rs",
      "content_text": "Thanks to the diligent work of Laurent Mazare on his tch-rs crate, the Rust community can now enjoy an easy access to the powerful Torch neural net framework. Being personally an avid user of both Rust and Torch, stumbling on this repo has been nothing but a belated birthday present. In this post, I would like to dive into two examples to present its most fundamental functionalities.",
      "url": "http://vegapit.com/article/how-to-use-torch-in-rust-with-tch-rs",
      "date_published": "2019-07-19T13:18:00+01:00",
      "author": {
        "name": "Vegapit",
        "url": "http://vegapit.com/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "9ec74f93-14a2-47ec-8572-24b9efe51a62",
      "title": "Introducing Abscissa: iqlusion's security-oriented Rust application framework",
      "content_text": "Earlier this month we released Abscissa: our security-oriented Rust application framework. After releasing v0.1, we’ve spent the past few weeks further polishing it up in tandem with this blog post, and just released a follow-up v0.2.",
      "url": "https://iqlusion.blog/introducing-abscissa-rust-application-framework",
      "date_published": "2019-07-18T07:00:51-07:00",
      "author": {
        "name": "Tony Arcieri",
        "url": "http://iqlusion.blog/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "f1fef443-d169-4ff1-a74e-262d273c9b9d",
      "title": "Cactus Harvesting: Cycle-Aware Reference Counting in Rust",
      "content_text": "🌵 CactusRef is a single-threaded, cycle-aware, reference counting smart pointer [docs] [code]. CactusRef is nearly a drop-in replacement for std::rc1 from the Rust standard library.",
      "url": "https://hyperbo.la/w/cactus-harvesting/",
      "date_published": "2019-07-15T00:00:00+00:00",
      "author": {
        "name": "Ryan Lopopolo",
        "url": "https://hyperbo.la/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "84e8a302-326a-4c95-a6ae-78d4e8fa1029",
      "title": "Migrating a crate from futures 0.1 to 0.3",
      "content_text": "I recently migrated a small/medium-sized crate from Futures 0.1 to 0.3. It was fairly easy, but there were some tricky bits and some things that were not well documented, so I think it is worth me writing up my experience.",
      "url": "https://www.ncameron.org/blog/migrating-a-crate-from-futures-0-1-to-0-3/",
      "date_published": "2019-07-08T21:24:28+00:00",
      "author": {
        "name": "Nick Cameron",
        "url": "http://www.ncameron.org/blog/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "907a2ee8-f215-4259-8179-bc4d542a7647",
      "title": "Stream combinators implemented using for await syntax",
      "content_text": " I am a big fan of simplifying the existent code in futures-rs using async/await syntax. My goal was to rewrite the combinators in such a way that even a newbie can understand what was going on. However I met several issues with Stream combinators because it was a little bit hard to construct an impl Stream without defining a struct with a ::poll_next method. So I used Stream::unfold that can create streams from a closure.",
      "url": "https://www.reddit.com/r/rust/comments/cbvhq9/stream_combinators_implemented_using_for_await/",
      "date_published": "2019-07-11T00:00:00+00:00",
      "author": {
        "name": "Roman Proskuryakov",
        "url": "https://www.reddit.com/user/rproskuryakov/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "fdaab910-4937-451e-9fe4-3cfd693069b8",
      "title": "Building crates so they look like C(ABI) Libraries",
      "content_text": "How to write a well behaved C-API library in Rust.",
      "url": "https://dev.to/luzero/building-crates-so-they-look-like-c-abi-libraries-1ibn",
      "date_published": "2019-07-01T19:40:21+00:00",
      "author": {
        "name": "Luca Barbato",
        "url": "https://dev.to/luzero"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "876033ef-0f64-4108-89c6-8ce8d6536ac7",
      "title": "RESS (Rusty EcmaScript Scanner) 0.7.0 bring large performance improvements",
      "content_text": "A blog about learning computer science concepts with practical projects",
      "url": "https://wiredforge.com/blog/ress-7/",
      "date_published": "2019-06-26T00:00:00+00:00",
      "author": {
        "name": "Robert Masen",
        "url": "https://wiredforge.com/"
      },
      "tags": [
        "Crates",
        "Performance"
      ]
    },
    {
      "id": "1ea200e9-2dda-4cad-9190-7aec92439026",
      "title": "Winit 0.20, the state of windowing in Rust, and a request for help",
      "content_text": "I’m one of the maintainers of Winit, the main pure-Rust window creation library. Even if you haven’t used it directly, you’ve probably heard of projects that depend on it - Servo and Alacritty being the best-known applications that depend on our codebase. If you’ve done any graphics programming in Rust using Glutin (or dependent projects including gfx-rs, Glium, and Amethyst) we’ve been the ones making the windows actually show up on your desktop.\n\nThis announcement details the major changes since Winit 0.19. Also, we are looking for new contributors! If you are interested in working on the foundations of Rust’s GUI story, now is a great time to join the project.",
      "url": "https://users.rust-lang.org/t/winit-0-20-the-state-of-windowing-in-rust-and-a-request-for-help/29485",
      "date_published": "2019-06-21T16:16:03+00:00",
      "author": {
        "name": "Osspial",
        "url": "https://users.rust-lang.org/u/osspial/summary"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "f85b4664-304e-4eeb-a93b-2377b74263cd",
      "title": "async log",
      "content_text": "Today we'd like to introduce async-log, a general-purpose crate that extends the standard log crate with asynchronous metadata. This is a first step in introducing full-fledged asynchronous tracing capabilities to Rust.",
      "url": "https://blog.yoshuawuyts.com/async-log/",
      "date_published": "2019-06-29T00:00:00+00:00",
      "author": {
        "name": "Yoshua Wuyts",
        "url": "https://blog.yoshuawuyts.com/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "9f8dfcb3-e67c-456d-94d5-76ea84f8caa8",
      "title": "termimad: A library to display rich (Markdown) snippets and texts in a Rust terminal application",
      "content_text": "A simple tool to display static or dynamic Markdown snippets in the terminal, with skin isolation. Based on crossterm so works on most terminals (even on windows).",
      "url": "https://github.com/Canop/termimad",
      "date_published": "2019-06-27T00:00:00+00:00",
      "author": {
        "name": "Canop",
        "url": "https://github.com/Canop"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "c274055b-d2a2-43f1-9ef3-a9fc15521878",
      "title": "swym: Are we lock-free yet?",
      "content_text": "swym is a transactional memory library that prioritizes performance. It’s not lock-free, but it does have progress guarantees. This post will explore some of the recent work on swym’s progress promises, as well as some comparisons with non-blocking algorithms. I’m not an expert on schedulers or OS’s, so please correct me if anything is wrong. It might benefit swym!",
      "url": "https://mtak-blog.github.io/are-we-lock-free-yet",
      "date_published": "2019-06-24T00:00:00+00:00",
      "author": {
        "name": "mtak-",
        "url": "https://github.com/mtak-"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "24f33796-8ad9-4162-b8a1-1048ab285062",
      "title": "The Rust Module System and Useful Crates for CLI Apps",
      "content_text": "Today I’ll be continuing my series of posts on the rust implementation of the Mercurial version control system I’ve been working on. In this post I’ll be focusing on what I learned this week about the rust module system as well as a few helpful crates I discovered to aid in command-line argument parsing and error handling.",
      "url": "https://ngoldbaum.github.io/posts/helpful-rust-cli-crates/",
      "date_published": "2019-06-12T10:06:24-04:00",
      "author": {
        "name": "Nathan Goldbaum",
        "url": "https://ngoldbaum.github.io/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "f6a2f624-a597-4ae7-b89a-e621ebb50c55",
      "title": "nom, the Rust parser combinators library, is now available at version 5",
      "content_text": "nom, the Rust parser combinators library, is now available at version 5. This is the most mature version of nom. This is the one that feels “done”. This is the parser library that I wanted when I started nom 5 years ago. It’s here at last. nom 5 is a complete rewrite of the internal architecture, to use functions instead of macros, while keeping backward compatibility with existing macros based parsers, and making the error type completely generic.",
      "url": "http://unhandledexpression.com/general/2019/06/17/nom-5-is-here.html",
      "date_published": "2019-06-24T00:00:00+00:00",
      "author": {
        "name": "Geoffroy Couprie",
        "url": "https://unhandledexpression.com/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "0904d040-f6c1-4b6a-a9ee-328a5ed55d2d",
      "title": "Orkhon: ML Inference Framework and Server Runtime",
      "content_text": "Orkhon is Rust framework for Machine Learning to run/use inference/prediction code written in Python, frozen models and process unseen data. It is mainly focused on serving models and processing unseen data in a performant manner. Instead of using Python directly and having scalability problems for servers this framework tries to solve them with built-in async API.",
      "url": "https://docs.rs/orkhon/0.1.0/orkhon/",
      "date_published": "2019-05-29T21:32:00+00:00",
      "author": {
        "name": "Mahmut Bulut",
        "url": "https://github.com/vertexclique"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "0f224e61-b4f3-40f2-b99a-431cf41ec5d8",
      "title": "Gtk-rs: New release - more complete, safer",
      "content_text": "Welcome everyone to this whole new gtk-rs release! Time to check what was added/updated in this new version.",
      "url": "https://gtk-rs.org/blog/2019/06/22/new-release.html",
      "date_published": "2019-06-22T00:00:00+00:00",
      "author": {
        "name": "Gtk-rs Developers",
        "url": "https://gtk-rs.org/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "f1697ece-4d5e-46b8-88b5-d5a2e729ae96",
      "title": "Rust crates – frehberg’s annotated catalogue",
      "content_text": "The base of Rust users and contributors is growing steadily. The amount of libraries (aka crates) at http://crates.io is growing quickly; the overall “noise” is increasing. Some libraries might not be maintained any longer 🙁\n\nThis annotated catalogue shall help the Rust-users to find specific, popular, mature Rust crates. This list is WIP (Work In Progress), reflecting my personal shortlist. The ordering in the table top-down doesn’t express any preference.",
      "url": "https://frehberg.com/2019/06/rust-crates-frehbergs-annotated-catalogue/",
      "date_published": "2019-06-19T19:13:23+00:00",
      "author": {
        "name": "Frank Rehberger",
        "url": "https://frehberg.com/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "ae6027ab-b71f-4bce-9ab8-e1853aa24030",
      "title": "Actix - Actor System and Web Framework for Rust",
      "content_text": "Actix web 1.0.0 is released - a small, pragmatic, and extremely fast web framework.",
      "url": "https://actix.rs/",
      "date_published": "2019-06-05T15:38:00+00:00",
      "author": {
        "name": "Nikolay Kim",
        "url": "https://twitter.com/fafhrd91"
      },
      "tags": [
        "Web and Network Services",
        "Crates"
      ]
    },
    {
      "id": "aea12212-4a3a-4c00-baa5-313f5c998977",
      "title": "Announcing our Verifiable Random Function (VRF) Rust library",
      "content_text": "Recently Gorka Irazoqui Apecechea and me proudly published a VRF crate as an open source project under the MIT license. The library is a fast, flexible and general-purpose Verifiable Random Function (VRF) library written in Rust, which follows the IETF standard draft written by Sharon Goldberg, Moni Naor, Dimitris Papadopoulos, Leonid Reyzin, and Jan Včelák.",
      "url": "https://medium.com/witnet/announcing-our-verifiable-random-function-vrf-rust-library-2e042c29a4f7",
      "date_published": "2019-06-03T15:03:50.164+00:00",
      "author": {
        "name": "Mario Cao",
        "url": "https://medium.com/@mariocao"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "aaa397b7-d0b2-43d0-af75-0934ac4bfe73",
      "title": "Announcing Contrie: concurrent maps and sets",
      "content_text": "This is partly an announcement of a new crate folks might find useful, partly a call for participation and help and partly a journal like story how the crate came to being. Read on (or not) or skip to the parts that seem interesting to you.",
      "url": "https://vorner.github.io/2019/06/09/announcing-contrie.html",
      "date_published": "2019-06-09T00:00:00+00:00",
      "author": {
        "name": "Michal 'vorner' Vaner",
        "url": "https://vorner.github.io/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "f94980b0-dfbb-421b-b861-16e158c7c0c2",
      "title": "Announcing j4rs",
      "content_text": "j4rs stands for “Java for Rust” and allows effortless calls to Java code, from Rust. Some time ago, on a need to call Java code from Rust, I started the j4rs project. The main idea was to implement a crate that would give the ability to its users to make calls to Java easily, so that they can benefit from the huge Java ecosystem.",
      "url": "https://astonbitecode.github.io/blog/post/j4rs_0.6.0/",
      "date_published": "2019-05-24T00:10:10+00:00",
      "author": {
        "name": "Aston",
        "url": "https://astonbitecode.github.io/blog"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "635d3c1f-b71e-4883-b72e-52efe1ab01d0",
      "title": "Announcing Mockiato - A strict, yet friendly mocking library for Rust 2018",
      "content_text": "We’re proud to announce mockiato! For the last few months, we tackled the issue of creating a usable mocking library. Our primary goals were: Ease of use: The mocks are written in idiomatic Rust and don’t rely on custom macro syntax. Maintainability: The entire code base strives to follow the rules of Clean Code and Clean Architecture as specified by Robert C. Martin.  Strict expectation enforcement: Mockiato catches unexpected behavior as soon as it happens instead of returning default values.",
      "url": "https://blog.myelin.ch/2019/05/24/mockiato-announcement.html",
      "date_published": "2019-05-24T00:00:00+00:00",
      "author": {
        "name": "Jeremy, Ruben, Jan, Mathias",
        "url": "https://blog.myelin.ch/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "db12537e-42d3-4bba-9c68-7adc1afec917",
      "title": "mini-aio: the new async IO library for Rust",
      "content_text": "During my work at Adgear, I’ve been working for a while on an async IO library for Rust. This post will present this new library. This library takes a very different approach than most other async IO libraries in Rust: it is actually inspired by the Pony programming language. So, it does not use futures, it does not use async/await: it just provides simple trait",
      "url": "http://antoyo.ml/mini-aio-new-async-io-library",
      "date_published": "2019-05-20T00:00:00+00:00",
      "author": {
        "name": "Antoni Boucher",
        "url": "http://antoyo.ml/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "feed408e-361c-4a9c-9432-5729aed1e789",
      "title": "powerset-enum - anonymous enum and a PoC for how that feature can be used to improve Rust's error handling",
      "content_text": "My crate offers a powerset enum - an enum that can be parametrized to any subset of it's variants. I also included a macro for doing this parametrization by providing the types of the variants - so for example Error![std::io::Error, serde_json::Error] would generate a subset of the enum that can only have IO and JSON parsing errors.",
      "url": "https://www.reddit.com/r/rust/comments/bqn9e6/announcing_the_powersetenum_crate_a_poor_mans/",
      "date_published": "2019-05-20T08:50:00+10:00",
      "author": {
        "name": "someboddy",
        "url": "https://www.reddit.com/user/somebodddy/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "fdf7f732-0af5-4031-9135-4b1db1ebfc28",
      "title": "Shell Completions in Pure Rust",
      "content_text": "Custom completion behavior is configured using a special bash built-in called complete. complete can be used to designate either a bash function or any other command as the completion script for a particular command. When the user requests completions for a command, complete will run specified code, passing in as args information about what the user has already typed, and expecting as output the completion suggestions. Typically these completion scripts are written in bash, but we’ll look at how it is possible to write them in Rust.",
      "url": "https://www.joshmcguigan.com/blog/shell-completions-pure-rust/",
      "date_published": "2019-05-12T00:00:00+00:00",
      "author": {
        "name": "Josh Mcguigan",
        "url": "https://www.joshmcguigan.com/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "93fbaebd-c627-46f3-89ea-1469e58ecd22",
      "title": "Papers on Rust",
      "content_text": "With these crates in a basic but usable state, I went to write papers, Rust code to gather data from the above sources, and inject them into Wikidata. I wrote a Rust trait to represent a generic source, and then wrote adapter structs for each of the sources. Finally, I added some wrapper code to take a list of adapters, query them about a paper, and update Wikidata accordingly.",
      "url": "http://magnusmanske.de/wordpress/?p=617",
      "date_published": "2019-05-16T10:06:00+00:00",
      "author": {
        "name": "Magnus Manske",
        "url": "http://blog.magnusmanske.de/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "ad13d235-c5b0-454f-b35c-891006484207",
      "title": "Rust+GNOME Hackfest #5",
      "content_text": "Last week, I went to the fifth Rust+GNOME hackfest which was in Berlin again. My goal for this hackfest was to fix this issue I opened nearly three years ago. The problem is that sometimes you want to create a widget or an object and set some properties at construction time. This might be needed when you want to set construct-only properties. For instance, you might want to create a webkit2gtk::WebView with a WebContext and a UserContentManager at the same time. That’s why a constructor was manually written for this use case.",
      "url": "http://antoyo.ml/rust-gnome-hackfest-berlin",
      "date_published": "2019-05-14T00:00:00+00:00",
      "author": {
        "name": "Antoni Boucher",
        "url": "http://antoyo.ml/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "a0a1c63f-18d2-440f-8568-0cdd5899afe3",
      "title": "Generating a GNOME library using gir crate",
      "content_text": "In this tutorial, we’ll see how to generate a GNOME library using the gir crate. A few things to note first: It only works on GObject-based libraries.  You need .gir files.\n\nA little explanation about those requirements: the gir crate needs .gir files to generate the library API. You can generally find them alongside the library header files (as you can see here for example, look for “.gir”).\n\nThe .gir files “describes” the library API (objects, arguments, even ownership!). This is where the gir crate comes in: it reads those .gir files and generates the Rust crates from them. You can learn more about the GIR format here.",
      "url": "https://gtk-rs.org/docs-src/tutorial/gir_tutorial",
      "date_published": "2019-05-11T00:00:00+00:00",
      "author": {
        "name": "Gtk-rs",
        "url": "https://gtk-rs.org/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "09931418-a93c-4b3f-ab7a-de486a0373fd",
      "title": "Paw",
      "content_text": "Today we're announcing paw, a first step by the CLI Working Group to make command line applications more first class in Rust.\n\nWe introduce a procedural macro paw::main that allows passing arguments to fn main, and a new trait ParseArgs that must be implemented by the arguments to main. This allows passing not only the classic std::env::Args to main but also, for example, structopt instances.",
      "url": "https://blog.yoshuawuyts.com/paw/",
      "date_published": "2019-05-06T00:00:00+00:00",
      "author": {
        "name": "Yoshua Wuyts",
        "url": "https://blog.yoshuawuyts.com/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "b5691501-490d-4eef-a8cc-2728e42774d2",
      "title": "Learn Rust: Parsing command line arguments with StructOpt",
      "content_text": "A beginners guide to using StructOpt for parsing command line arguments.",
      "url": "https://www.tenderisthebyte.com/blog/2019/05/08/parsing-cli-args-with-structopt/",
      "date_published": "2019-05-08T00:00:00+00:00",
      "author": {
        "name": "Ryan Moore",
        "url": "https://www.tenderisthebyte.com/"
      },
      "tags": [
        "Crates",
        "Getting Started"
      ]
    },
    {
      "id": "db1287e6-d66c-486a-812b-87ba2b37d423",
      "title": "phrase: A tool for learning significant phrase/term models, and efficiently labeling with them",
      "content_text": "In general, using phrase falls into 3 steps: Counting n-grams, Exporting scored models, Significant term/phrase extraction/transform N-gram counting is done continuously, providing batches of documents as they come in. Model export reads all n-gram counts so far and calculates mutual information-based collocations - you can then deploy the models by shipping the binary and data/scores_* files to a server. Labeling (identifying all significant terms and phrases in text) or transforming (eager replace of longest found phrases in text) can be done either via the CLI or the web server. Providing labels for documents is not necessary for learning phrases, but does help, and allows for significant term labeling also.",
      "url": "https://github.com/soaxelbrooke/phrase",
      "date_published": "2019-05-06T00:00:00+00:00",
      "author": {
        "name": "Stuart Axelbrooke",
        "url": "https://github.com/soaxelbrooke"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "5af81963-5163-49f3-bd47-27b91d6dbd34",
      "title": "Monitoring AWS Batch Jobs with Rust",
      "content_text": "At Pixability my team and I recently created a pretty neat AWS Batch driven system. AWS Batch can can handle almost any task seamlessly and it’s pretty easy to manage with the console. This is great already, but I was curious to see what it would look like to monitor Batch with Rust. Watchrs was inspired by this question and currently provides basic functionality to do so. In this post we will be briefly going over how the main components of watchrs were built and how to use them all together.",
      "url": "https://medium.com/rusted/monitoring-aws-batch-jobs-with-rust-8f1ef6115871",
      "date_published": "2019-04-24T01:05:46.511+00:00",
      "author": {
        "name": "Michael Habib",
        "url": "https://medium.com/@itsHabib"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "8ff4000f-f8c6-41b9-a91b-c0bd9d23ca69",
      "title": "Pre luminance-1.0.0 and random thoughts",
      "content_text": "Hello people. It’s been weeks I have started to work on luminance-1.0.0. For a brief recap, luminance is a graphics crate that I originally created in Haskell, when I ripped it off from a demoscene engine called quaazar in order to make and maintain tiner packages. The Rust port was my first Rust project and it became quickly the default language I would develop graphics applications in.",
      "url": "https://phaazon.net/blog/pre-luminance-n-random-thoughts",
      "date_published": "2019-04-26T22:30:00+00:00",
      "author": {
        "name": "Dimitri Sabadie",
        "url": "http://phaazon.net/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "675a435e-aadf-4ded-b3d1-50d6a8afaced",
      "title": "emacs-module-rs provides high-level Rust binding and tools to write Emacs's dynamic modules.",
      "content_text": "This provides a high-level binding to emacs-module, Emacs's support for dynamic modules.",
      "url": "https://ubolonton.github.io/emacs-module-rs/0.8.0/",
      "date_published": "2019-04-20T11:11:45+00:00",
      "author": {
        "name": "Tuấn-Anh Nguyễn",
        "url": "https://github.com/ubolonton"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "9f8e4402-c90a-4e59-90c2-ca34bf6c2689",
      "title": "Writing Mails from Rust (3/3): Example usage with explanations",
      "content_text": "After the previous two posts this post will go step by step through how the mail crate can be used to create mails based on a handlebars template and send them to a Mail Submission Agent (MSA).",
      "url": "https://blog.1aim.com/post/004-mail-3-example/",
      "date_published": "2019-02-28T00:00:00+00:00",
      "author": {
        "name": "Philipp Korber",
        "url": "https://blog.1aim.com/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "3ac75258-fb50-4341-9a2a-e5a90def4a55",
      "title": "Writing Mails from Rust (2/3): The mail crate",
      "content_text": "The mail crate is a modular Rust library for creating, modifying and then encoding mails. It also has bindings to our new crate new-tokio-smtp to allow sending mails asynchronously, as well as bindings to handlebars for creating mails from templates. It currently does not support parsing mails, but is designed in a way that decoding capabilities could be easily added in the future (contact me if that is something you'd be interested in working on!). At 1aim, we are already using mail in production.",
      "url": "https://blog.1aim.com/post/003-mail-2-crate/",
      "date_published": "2019-01-29T00:00:00+00:00",
      "author": {
        "name": "Philipp Korber",
        "url": "https://blog.1aim.com/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "adc39c05-2876-4ef4-b071-b4133c96c8ca",
      "title": "Futures 0.1 Compatibility Layer",
      "content_text": "Rust’s futures ecosystem is currently split in two: On the one hand we have the vibrant ecosystem built around futures@0.1 with its many libraries working on stable Rust and on the other hand there’s the unstable std::future ecosystem with support for the ergonomic and powerful async/await language feature. To bridge the gap between these two worlds we have introduced a compatibility layer as part of the futures@0.3 extension to std::future. This blog post aims to give an overview over how to use it.",
      "url": "https://rust-lang-nursery.github.io/futures-rs/blog/2019/04/18/compatibility-layer.html",
      "date_published": "2019-04-18T00:00:00+00:00",
      "author": {
        "name": "Josef Brandl",
        "url": "https://rust-lang-nursery.github.io/futures-rs/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "50725324-0ca7-4137-8e95-9d5e023881f8",
      "title": "splines-1.0.0 and first release candidate",
      "content_text": "today, I’m going to talk about the splines crate. And more specifically, the splines-1.0.0-rc.1 release candidate I uploaded today on crates.io. Maybe you’re wondering what a spline is, in the first place. A spline is a mathematic curve that is defined by several polynomials. You can picture them mentally by several small and simple curves combined to each others, giving the curve an interesting shape and properties. Now why we want splines is easy to understand: imagine a curve, something smooth and a bit complex (maybe even with loops). Now, imagine you want to make an object move along that curve. How do you represent that curve and how to you “make something advance along it?”",
      "url": "https://phaazon.net/blog/splines-1.0.0-rc.1",
      "date_published": "2019-04-22T01:10:00+00:00",
      "author": {
        "name": "Dimitri Sabadie",
        "url": "http://phaazon.net/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "b8b79bb1-c176-43e8-bad9-943285e361c6",
      "title": "12 Killer Rust Libraries You Should Try",
      "content_text": "I’ve just crossed a 20K LOC in one of my bigger Rust projects, and thought about pausing for a moment and sharing some great Rust libraries that I’ve used.",
      "url": "https://medium.com/@jondot/12-killer-rust-libraries-you-should-know-c60bab07624f",
      "date_published": "2019-04-19T15:21:32.205+00:00",
      "author": {
        "name": "Dotan Nahum",
        "url": "https://medium.com/@jondot"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "b2657146-974b-41b9-ba31-8aae62c25f7d",
      "title": "6 useful Rust macros that you might not have seen before",
      "content_text": "Below are 6 Rust macros that are worth taking a look at to improve your project. Rust macros are a great feature that can reduce code boilerplate and be a time saver for programmers. They also offer flexibility for developers to use metaprogramming to add new features to the language and package them in a way that is easy to integrate into code. They are one of the more powerful features of the language and this led me to search github and cargo to see what was out there. Below are some interest macros that are not as well known.",
      "url": "https://medium.com/@benmcdonald_11671/6-useful-rust-macros-that-you-might-not-have-seen-before-59d1386f7bc5",
      "date_published": "2019-04-22T02:00:39.198+00:00",
      "author": {
        "name": "Ben McDonald",
        "url": "https://medium.com/@benmcdonald_11671"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "53c58e52-158a-40e1-b59d-3a9ad1a92edb",
      "title": "Runtime",
      "content_text": "The vision of the Async Ecosystem WG is to refine the async Rust experience until it matches the quality and ease of working with today's std. There are a lot of components in that vision, including async/await syntax and borrow checker integration. Today, though, we'd like to introduce another component: Runtime, a crate that makes working with async code feel closer to working with std, and a stepping stone toward ecosystem standardization.",
      "url": "https://blog.yoshuawuyts.com/runtime/",
      "date_published": "2019-04-16T00:00:00+00:00",
      "author": {
        "name": "Yoshua Wuyts",
        "url": "https://blog.yoshuawuyts.com/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "ebf00798-d92a-4f61-8b2b-8ffceb2c09a9",
      "title": "Protocols in Tokio (i3 IPC)",
      "content_text": "There’s a dearth of blog posts online that cover the details of implementing a custom protocol in tokio, at least that I’ve found. I’m going to cover some of the steps I went through in implementing an async version i3wm’s IPC.",
      "url": "https://leshow.github.io/post/impl_proto_tokio/",
      "date_published": "2019-04-08T18:53:18-04:00",
      "author": {
        "name": "Evan Cameron",
        "url": "https://leshow.github.io/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "914d12c5-ea4a-49f4-8466-1f15a9c3340a",
      "title": "Using rav1e - from your own code",
      "content_text": "AV1 is a modern video codec brought to you by an alliance of many different bigger and smaller players in the multimedia field. rav1e: The safest and fastest AV1 encoder, built by many volunteers and Mozilla/Xiph developers. crav1e: A companion crate, written by yours truly, that provides a C-API, so the encoder can be used by C libraries and programs. This article will just give a quick overview of the API available right now and it is mainly to help people start using it and hopefully report issues and problem.",
      "url": "https://dev.to/luzero/using-rav1e-from-your-own-code-2ie0",
      "date_published": "2019-04-09T00:00:00+00:00",
      "author": {
        "name": "Luca Barbato",
        "url": "https://dev.to/luzero"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "5826453d-6731-41d9-a4f5-f5dbce6ef1df",
      "title": "Arraigning a Statement, vol. 2",
      "content_text": "Last time we defined a minimum viable implementation for mutagen statement removal: Remove only function call statements whose results are not returned from the surrounding block and whose AST do not contain any Assign expressions.",
      "url": "https://llogiq.github.io/2019/03/14/stmt2.html",
      "date_published": "2019-03-14T00:00:00+00:00",
      "author": {
        "name": "Llogiq",
        "url": "http://llogiq.github.io/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "410c0a3f-026f-4e8c-9910-40745122a369",
      "title": "Zola 0.6.0: start of multi-lingual sites",
      "content_text": "Zola gets the beginning of multi-lingual support and perf improvements.",
      "url": "https://www.vincentprouillet.com/blog/releasing-zola-0-6-0/",
      "date_published": "2019-03-25T00:00:00+00:00",
      "author": {
        "name": "Vincent Prouillet",
        "url": "https://www.vincentprouillet.com/blog/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "e216ede8-5599-48f4-a458-770944ef44f2",
      "title": "Arraigning a Statement, vol. 1",
      "content_text": "This time in our “Mutating Rust” series, we want to tackle the most complex mutation so far: Statement removal. Now why do I think this is complex? It’s just removing the statement (or, as we bake our mutations into the code, activating at runtime, putting it behind an if), right?",
      "url": "https://llogiq.github.io/2019/03/11/stmt.html",
      "date_published": "2019-03-11T00:00:00+00:00",
      "author": {
        "name": "Llogiq",
        "url": "http://llogiq.github.io/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "ed083e12-489d-4720-8e59-eea15c03c3f8",
      "title": "MeiliES - Event sourcing in Rust",
      "content_text": "MeiliES is an Event Sourcing database that uses the RESP (REdis Serialization Protocol) to communicate. We use the Redis protocol to simplify clients implementation. The portability problematics are resolved by using a full Rust implementation (we are using Sled as internal storage).",
      "url": "https://blog.meilisearch.com/meilies-release/",
      "date_published": "2019-03-25T14:16:32+00:00",
      "author": {
        "name": "Thomas Payet",
        "url": "https://blog.meilisearch.com/author/thomas/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "710b4e1e-9882-413b-bf2d-9fc746502ede",
      "title": "clap v3 Update: No More Strings",
      "content_text": "This is the second post in a series detailing the issues, progress, and design decisions used in clap v3. This post details removing the \"stringly typed\" nature of clap.",
      "url": "https://kbknapp.dev/clap-v3-update-no-more-strings/",
      "date_published": "2019-03-08T00:00:00+00:00",
      "author": {
        "name": "Kevin K.",
        "url": "https://kbknapp.dev/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "0dbd06f7-147e-404c-81ce-360e61e087e5",
      "title": "Sonic: Fast, lightweight & schema-less search backend",
      "content_text": "Sonic is a fast, lightweight and schema-less search backend. It ingests search texts and identifier tuples that can then be queried against in a microsecond's time.",
      "url": "https://github.com/valeriansaliou/sonic",
      "date_published": "2019-03-24T00:00:00+00:00",
      "author": {
        "name": "Valerian Saliou",
        "url": "https://github.com/valeriansaliou"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "554b2733-697f-41c7-b91b-0261acc1aa24",
      "title": "barrel.rs: a powerful schema migration builder's 0.5.0 release",
      "content_text": "barrel makes writing migrations for different databases as easy as possible. It provides you with a common API over SQL, with certain features only provided for database specific implementations. This way you can focus on your Rust code, and stop worrying about SQL.",
      "url": "https://rust-db.github.io/barrel/blog/releasing-050/",
      "date_published": "2019-03-21T00:00:00+00:00",
      "author": {
        "name": "Squirrel People",
        "url": "https://rust-db.github.io/barrel/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "677c24c1-719c-4744-acb3-46eb5e21f991",
      "title": "The last two months in rustsim #4 (January - February 2019)",
      "content_text": "Welcome to the fourth edition of This month in rustsim. This monthly newsletter will provide you with a summary of important update that occurred within the rustsim community. This includes in particular updates about the nphysics, ncollide, nalgebra, and alga crate.",
      "url": "https://www.rustsim.org/blog/2019/03/01/this-month-in-rustsim/",
      "date_published": "2019-03-01T00:00:00+00:00",
      "author": {
        "name": "Sébastien Crozet",
        "url": "https://www.rustsim.org/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "187cf7df-3448-4699-86f6-28e90a1a025f",
      "title": "Implementing a Hidden Markov Model in Rust",
      "content_text": "Over the past few months, I’ve implemented hmmm, a Rust library for Hidden Markov Models (HMMs). HMMs are a well-established statistical machine learning technique for modeling sequences of data. They have been applied to problems like speech recognition and bioinformatics. They are called “hidden” because each discrete time step is associated with a hidden state. Below, I’ll briefly discuss some challenges that I ran into while implementing this library.",
      "url": "https://paulkernfeld.com/2019/03/17/hmmm.html",
      "date_published": "2019-03-17T00:00:00+00:00",
      "author": {
        "name": "Paul Kernfeld",
        "url": "https://paulkernfeld.com/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "04f2e112-c86d-4468-9b75-d74f84429d69",
      "title": "A Rust API for librsvg",
      "content_text": "After the librsvg team finished the rustification of librsvg's main library, I wanted to start porting the high-level test suite to Rust. This is mainly to be able to run tests in parallel, which cargo test does automatically in order to reduce test times. However, this meant that librsvg needed a Rust API that would exercise the same code paths as the C entry points. At the same time, I wanted the Rust API to make it impossible to misuse the library.",
      "url": "https://people.gnome.org/~federico/blog/a-rust-api-for-librsvg.html",
      "date_published": "2019-03-15T13:36:47-06:00",
      "author": {
        "name": "Federico Mena Quintero",
        "url": "https://people.gnome.org/~federico/blog/index.html"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "c3575790-8873-4860-bc2a-15ba5f636a42",
      "title": "Persy: an attempt to write a transactional storage engine in Rust",
      "content_text": "Persy is a single file storage engine, all the data, referencing structures and logs are kept in a single file. Persy support read-committed transactions, using copy on write to guarantee high concurrency and isolation, the data consistency is guaranteed by a transaction log that recover the operations in case of crash. Persy provide segments to organize records of different kinds and allow the scan on a single segment. Persy provide index implementation that can be used to associate any simple value to another value or a record reference. In Persy a record is a simple Vec<u8>, the content of the record is ignored by Persy, is just stored and retrieved on request.",
      "url": "http://persy.rs/posts/persy-0.4.html",
      "date_published": "2019-03-15T00:00:00+00:00",
      "author": {
        "name": "tglman",
        "url": "https://gitlab.com/tglman"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "ad1ab029-a374-4fde-8f62-6100bf699da2",
      "title": "Pulldown_cmark 0.3 release announcement",
      "content_text": "pulldown_cmark, a fast pull parser for the CommonMark markdown standard written in Rust, has just seen its 0.3 release. It marks a milestone for renewed CommonMark test compliance and performance. In this blog post, we'll have a quick look at the goals of the rewrite, how they were achieved and what's next for the crate.",
      "url": "https://fullyfaithful.eu/pulldown-cmark/",
      "date_published": "2019-03-15T08:19:00+00:00",
      "author": {
        "name": "Marcus Klaas de Vries",
        "url": "https://fullyfaithful.eu/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "7da6de6b-bbf8-4587-ab48-615ee988d899",
      "title": "Up and Running with React + Rust + Wasm",
      "content_text": "I’m super excited about WebAssembly! It’s fast, (can be) small, and extremely portable. In fact, I wouldn’t be surprised if in the near future most web developers write code that eventually gets compiled to Wasm.\n\nBut currently there’s not a huge selection of resources showing how to get started with WebAssembly, and I couldn’t find any tutorials that worked with create-react-app. Most focus on writing and compiling a module, but rush over the details of actually using Wasm code. What follows is a basic setup for a React app using WebAssembly that should serve as a good foundation for more complex applications.",
      "url": "https://prestonrichey.com/blog/react-rust-wasm/",
      "date_published": "2019-02-25T00:00:00+00:00",
      "author": {
        "name": "Preston Richey",
        "url": "https://prestonrichey.com/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "c4806dc1-431a-46e2-a950-8f29194a87b1",
      "title": "Typetag: Serde serializable and deserializable trait objects",
      "content_text": "Serde serializable and deserializable trait objects. This crate provides a macro for painless serialization of &dyn Trait trait objects and serialization + deserialization of Box<dyn Trait> trait objects.",
      "url": "https://github.com/dtolnay/typetag/blob/master/README.md",
      "date_published": "2019-01-24T01:13:57+00:00",
      "author": {
        "name": "David Tolnay",
        "url": "https://github.com/dtolnay"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "e0caaf97-6980-4421-afbe-3fca31872c73",
      "title": "Releasing rust_gpiozero v0.2.0",
      "content_text": "A new version packed with new features and improvements: Blink leds without blocking main thread and adjust brightness. ⚙️ Work with servo motors and adjust motor speed. 〜 Work with software PWM.",
      "url": "https://rahul-thakoor.github.io/releasing-rust_gpiozero-v0.2.0/",
      "date_published": "2019-02-27T17:43:48+04:00",
      "author": {
        "name": "Rahul Thakoor",
        "url": "https://rahul-thakoor.github.io/"
      },
      "tags": [
        "Crates",
        "Embedded"
      ]
    },
    {
      "id": "fe2180a3-53fb-4b12-b6b2-722c19587b39",
      "title": "100x improvement on startup time in Wasmer 0.2.0",
      "content_text": "We’ve been working steadily to get Wasmer to execute WebAssembly modules on the server-side as fast as possible. TL;DR — We got 100x improvement on startup time on Wasmer 0.2.0.",
      "url": "https://medium.com/wasmer/running-webassembly-100x-faster-%EF%B8%8F-a8237e9a372d",
      "date_published": "2019-02-25T22:04:55.331+00:00",
      "author": {
        "name": "Syrus Akbary",
        "url": "https://medium.com/@syrusakbary"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "a540ae81-ddbb-4279-a507-b7faf43e5b19",
      "title": "Pedal to the metal: dynamic templates with Ramhorns",
      "content_text": "I have a problem. I don't know what to call it, but there is this itch I have when I find something that can obviously be made more efficient. The way I get about scratching that itch these days is by writing some Rust. I just got such an itch when looking at static site generators for this blog, Hugo (written in Go) is pretty much state-of-the art. In Rust land we have Zola, which is feature-rich, mature (for v0.5), and definitely fast enough for most users, and yet it is not as fast as it could be. Being written in Rust is, by itself, not a guarantee of top performance. The implementation matters. After some looking around I've narrowed down a problem I want to tackle (for now) to one area: template engines.",
      "url": "https://maciej.codes/2019-03-03-ramhorns.html",
      "date_published": "2019-03-03T00:00:00+00:00",
      "author": {
        "name": "Maciej Hirsz",
        "url": "https://maciej.codes/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "ce110dd7-46c1-4f12-880f-1c0bbf3a6726",
      "title": "Starling, the Binary Indexed Merkle Tree (Or Merkle-BIT)",
      "content_text": "Hey rustaceans! With a little help from your feedback just a few hours ago, I'm proud to present to you all Starling, a Binary Indexed Merkle tree! I've been working on this data structure for the last few months, and I think it is ready now for the community to have a look. Let me explain what it is and why it might be useful for your project.",
      "url": "https://www.reddit.com/r/rust/comments/aww097/starling_the_binary_indexed_merkle_tree_or/",
      "date_published": "2019-03-04T04:12:50+11:00",
      "author": {
        "name": "ChosunOne",
        "url": "https://www.reddit.com/user/ChosunOne"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "2c0b32cc-51a7-4e6f-a729-92c6cedcd7b1",
      "title": "Our first Rust crate: decrypting ansible vaults",
      "content_text": "We encrypt these secrets in so-called ansible vaults. Kuberwave also has the need to access these secrets. Because our staff is already comfortable with using these vaults, we’ve decided to also employ them for our Kubernetes setup. For this I created ansible-vault-rs, a library that can decrypt ansible vaults. Note that it can not create or edit vaults, because I have no need (yet) for this functionality.",
      "url": "https://medium.com/@woutergeraedts/our-first-rust-crate-decrypting-ansible-vaults-25f2f3a9a674",
      "date_published": "2019-02-22T08:12:26.080+00:00",
      "author": {
        "name": "Wouter Geraedts",
        "url": "https://medium.com/@woutergeraedts"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "70a94e2b-dbd2-4f66-ada8-5886b5c51fab",
      "title": "Low level text layout kickoff",
      "content_text": "This post is to announce a new Rust library for low-level text layout, called “skribo” (the Esperanto word for “writing”). This has been a major gap in the Rust ecosystem, and I hope the new crate can improve text handling across the board.",
      "url": "https://raphlinus.github.io/rust/skribo/text/2019/02/27/text-layout-kickoff.html",
      "date_published": "2019-02-27T18:16:42+00:00",
      "author": {
        "name": "Raph Levien",
        "url": "https://raphlinus.github.io/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "03e057c7-1da0-4468-b0f8-3aaedde6b241",
      "title": "Combine Results for Improved Rust Validation Logic",
      "content_text": "The error handling features within Rust are some of my favorite things about the language. This system works great when you are in a function which returns a Result and you want to exit at the first error you come to. However, it can be challenging if your goal is to try a few failure-prone things and return each of the errors, rather than just the first error. This is the problem multi_try attempts to solve. ",
      "url": "https://www.joshmcguigan.com/blog/multi-try-improved-validation-logic-rust/",
      "date_published": "2019-02-23T00:00:00+00:00",
      "author": {
        "name": "Josh Mcguigan",
        "url": "https://www.joshmcguigan.com/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "e513ef63-5727-4db5-8830-08606838d1e3",
      "title": "Introducing battery crate",
      "content_text": "My new pet project for reading batteries information in Rust.",
      "url": "https://svartalf.info/posts/2019-02-25-introducing-battery-crate/",
      "date_published": "2019-02-25T00:00:00+00:00",
      "author": {
        "name": "Nikita Kuznetsov",
        "url": "https://svartalf.info/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "7a149bc9-7e87-40cb-b3ef-da277059f897",
      "title": "New Gtk-rs release finally happened!",
      "content_text": "It’s time for a new release! Main adds/changes this time are: We added the generation of the Atk crate. We now generate functions taking callback as parameters. We improved the channels handling in GLib. The whole new GString type! The minimum Rust version supported is now the 1.31. The minimum version of all libraries has been changed to GNOME 3.14. The maximum version of all libraries has been upgraded to GNOME 3.30. Added subclassing support in GLib. Even more bindings generated. Let’s see those in details.",
      "url": "https://gtk-rs.org/blog/2019/02/21/new-release.html",
      "date_published": "2019-02-21T00:00:00+00:00",
      "author": {
        "name": "Gtk-rs",
        "url": "http://gtk-rs.org/blog"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "7405fc44-d31f-49f8-a260-b837ff0e3f12",
      "title": "Rutie: “The Tie Between Ruby and Rust.”",
      "content_text": "Integrate Ruby with your Rust application. Or integrate Rust with your Ruby application. This project allows you to do either with relative ease.",
      "url": "https://github.com/danielpclark/rutie/blob/master/README.md",
      "date_published": "2019-01-10T15:23:58+00:00",
      "author": {
        "name": "Daniel P. Clark",
        "url": "http://www.6ftdan.com/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "fe990782-d611-46a2-a6c1-4048707e61df",
      "title": "Introducing embedded-sdmmc - a pure-Rust #[no_std] SD card and FAT16/FAT32 library",
      "content_text": "161 votes and 6 comments so far on Reddit",
      "url": "https://www.reddit.com/r/rust/comments/ascvls/introducing_embeddedsdmmc_a_purerust_no_std_sd/",
      "date_published": "2019-02-20T04:32:00+00:00",
      "author": {
        "name": "Jonathan Pallant",
        "url": "http://railwayelectronics.blogspot.com.au/"
      },
      "tags": [
        "Embedded",
        "Crates"
      ]
    },
    {
      "id": "7d5bbb25-d599-43d5-82cb-1a4dcdf47286",
      "title": "Lock-free Rust: Crossbeam in 2019",
      "content_text": "This is a follow-up post to Lock-freedom without garbage collection from 2015, which introduced Crossbeam, a Rust library that implements efficient lock-free data structures without relying on a tracing garbage collector.",
      "url": "https://stjepang.github.io/2019/01/29/lock-free-rust-crossbeam-in-2019.html",
      "date_published": "2019-01-29T00:00:00+00:00",
      "author": {
        "name": "Stjepan Glavina",
        "url": "https://stjepang.github.io/"
      },
      "tags": [
        "Crates",
        "Performance"
      ]
    },
    {
      "id": "0a429d63-c63c-4161-8960-c83915c01b26",
      "title": "Lyon in 2018",
      "content_text": "In 2018 my activity on the project has varied depending on the time and energy I have had left after work and other activities. As it turns out, working on getting WebRender shipped in Firefox is at the same time amazing and very demanding, and what's left of my brain after a good day of work isn't always up to some of the ambitions I have planned for lyon. Fortunately I am not the only one who contributed to the project, and while progress was slow on the most ambitious plans, I did spend some time on smaller features and polish.\n\nI'll get to these big plans towards the end of this post. In the mean time let's look at some of the highlights of what changed in lyon in 2018.",
      "url": "https://nical.github.io/posts/lyon-2018.html",
      "date_published": "2019-02-17T00:00:00+01:00",
      "author": {
        "name": "Nical",
        "url": "https://nical.github.io/index.html"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "6b4003d7-f0ce-4105-8ed5-f4bea94f77b9",
      "title": "Metered-rs: fast, ergonomic metrics for Rust",
      "content_text": "I’m pleased to announce the release of metered-rs, a crate that helps live measurements of code, inspired by Coda Hale’s Java metrics, with the philosophy that measuring program performance at runtime is valuable, and independent from benchmarking.",
      "url": "https://users.rust-lang.org/t/metered-rs-fast-ergonomic-metrics-for-rust/25061",
      "date_published": "2019-02-07T18:14:21+00:00",
      "author": {
        "name": "Simon Chemouil",
        "url": "https://twitter.com/simach"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "5e8e4feb-2bb8-4337-bfba-a71003c797ed",
      "title": "First release of ieee802154 crate - Partial implementation of the IEEE 802.15.4 standard",
      "content_text": "I’ve released the ieee802154 crate, a partial implementation of the IEEE 802.15.4 standard, earlier this week.  IEEE 802.15.4 is a standard for low-rate wireless personal area networks. It is used as the basis for higher-level protocols like 6LoWPAN, Zigbee, or Thread. The ieee802154 crate is only a partial implementation of this standard, but I hope it can be used as a basis for future work by extending it as required.",
      "url": "https://users.rust-lang.org/t/first-release-of-ieee802154-0-1-partial-implementation-of-the-ieee-802-15-4-standard/25094",
      "date_published": "2019-02-08T14:24:56+00:00",
      "author": {
        "name": "Hanno Braun",
        "url": "https://users.rust-lang.org/u/hannobraun"
      },
      "tags": [
        "Crates",
        "Embedded"
      ]
    },
    {
      "id": "5b4334f5-08f9-450c-88cf-20fe91993cdc",
      "title": "Writing Mails from Rust (1/3): Mail in general",
      "content_text": "This is the first part in a three part blog post about (e-)mails and how to create, encode and send them using the mail crate (a library).",
      "url": "https://blog.1aim.com/post/002-mail-1-intro/",
      "date_published": "2019-01-28T00:00:00+00:00",
      "author": {
        "name": "Philipp Korber",
        "url": "https://blog.1aim.com/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "04445dcf-4cd1-47ee-b40e-58d17bdf0a9c",
      "title": "paw at Rust GUIs",
      "content_text": "The recent release of Flutter 1.0 was quite exciting for me. I’m not much of anGUI person nor do I make a lot of mobile apps but after looking through some examples, I started to like their take on UI frameworks. In particular, the three aspects mentioned above seemed to be handled very well!\n\nBack to Rust. I wondered how to adopt a similar API under the strict eyes 👀 of the borrow- and typechecker — which resulted in the experimental UI framework paw (in progress..)",
      "url": "https://medium.com/@m.siglreith/paw-at-rust-guis-d4d848e14b94",
      "date_published": "2019-01-17T18:12:55.923+00:00",
      "author": {
        "name": "msiglreith",
        "url": "https://medium.com/@m.siglreith"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "cdb3ed72-c1a4-4ff2-8350-cb5768fd96d4",
      "title": "Stretch — A flexbox implementation in Rust",
      "content_text": "Let’s talk about Layout. Layout is fundamental to any UI application. The layout engine is what takes a set of rules and figures out where to place elements on the screen. This sounds simple enough but as UIs become increasingly complex we rely more on the layout engine to be able to create these UIs as easily as possible. Not only should it be easy to build these UIs but the engine performing this work is also required to do so at minimum cost as it runs possibly on every frame (for example when performing layout animations).",
      "url": "https://medium.com/visly/stretch-a-flexbox-implementation-in-rust-60762b5a3331",
      "date_published": "2019-01-15T20:04:57.767+00:00",
      "author": {
        "name": "Emil Sjölander",
        "url": "https://medium.com/@emilsj"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "6e54473a-fefd-4447-8888-98137bd74692",
      "title": "proc-macro-rules - macro_rules-like pattern matching inside a procedural macro",
      "content_text": "I'm announcing a new library for procedural macro authors: proc-macro-rules (and on crates.io). It allows you to do macro_rules-like pattern matching inside a procedural macro. The goal is to smooth the transition from declarative to procedural macros (this works pretty well when used with the quote crate).",
      "url": "https://www.ncameron.org/blog/proc-macro-rules/",
      "date_published": "2019-01-16T19:27:54+00:00",
      "author": {
        "name": "Nick Cameron",
        "url": "http://www.ncameron.org/blog/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "3697f091-2478-437f-bdbb-3e464fe1ab8a",
      "title": "Rust bindings for GStreamerGL: Memoirs",
      "content_text": "Thanks to Mozilla and Igalia I have the opportunity to work on Servo, adding it HTML5 multimedia features. First, with the help of Fernando Jiménez, we finished what my colleague Philippe Normand and Sebastian Dröge (one of my programming heroes) started: a media player in Rust designed to be integrated in Servo. This media player lives in its own crate: servo/media along with the WebAudio engine. A crate, in Rust jargon, is like a library. This crate is (very ad-hocly) designed to be multimedia framework agnostic, but the only backend right now is for GStreamer. Later we integrated it into Servo adding an initial support for audio and video tags.",
      "url": "https://blogs.igalia.com/vjaquez/2019/01/16/rust-bindings-for-gstreamergl-memoirs/",
      "date_published": "2019-01-16T19:42:55+00:00",
      "author": {
        "name": "vjaquez",
        "url": "https://blogs.igalia.com/vjaquez/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "2a37239a-12d8-4647-bef0-90312992b2b7",
      "title": "Parsing, Validating, and Assembling URLs in Rust",
      "content_text": "These days, we hardly think about URLs. Popular content management tools default to so-called “pretty” slugs, and even here, on secretfader.com, I remove stop-words to ensure the tidiest, most SEO-friendly URLs possible.\nIt would be easy to forget the struggles that led to best practices of today’s web. However, to my generation of internet hackers, URLs riddled with ampersands and question marks were entirely normal. In those days, assuming URLs would be comprised of hyphenated alphanumeric characters was obviously unsafe; instead, we learned the official standard for parsing and constructing URLs.",
      "url": "https://www.secretfader.com/blog/2019/01/parsing-validating-assembling-urls-rust/",
      "date_published": "2019-01-08T00:00:00+00:00",
      "author": {
        "name": "Nicholas (Fader) Young",
        "url": "https://secretfader.com/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "1dd7a631-a2a9-42e8-ba0c-87b56bc6af38",
      "title": "generic-array Design and Usage Notes",
      "content_text": "generic-array is a method of achieving fixed-length fixed-size stack-allocated generic arrays without needing const generics in stable Rust.",
      "url": "https://github.com/fizyk20/generic-array/blob/master/DESIGN.md",
      "date_published": "2019-01-08T00:00:00+00:00",
      "author": {
        "name": "Aaron Trent",
        "url": "https://github.com/novacrazy"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "7828aada-388f-4b7b-bac1-24de2e65cf6a",
      "title": "Thessaloniki GNOME+Rust Hackfest 2018",
      "content_text": "A couple of weeks ago we had the fourth GNOME+Rust hackfest, this time in Thessaloniki, Greece.  We held the hackfest at the CoHo coworking space, a small, cozy office between the University and the sea. Every such hackfest I am overwhelmed by the kind hackers who work on [gnome-class], the code generator for GObject implementations in Rust.",
      "url": "https://people.gnome.org/~federico/blog/thessaloniki-gnome-rust-2018.html",
      "date_published": "2018-11-27T17:37:31-06:00",
      "author": {
        "name": "Federico Mena Quintero",
        "url": "https://people.gnome.org/~federico/blog/index.html"
      },
      "tags": [
        "Community",
        "Crates"
      ]
    },
    {
      "id": "ad9d038f-52e6-4860-a264-61a795428b87",
      "title": "Scannerless parsing of boolean grammars with derivatives in Rust",
      "content_text": "This is yet another library for writing parsers in Rust. What makes this one different is that I've combined some existing academic work in a way that I think is novel. The result is an unusually flexible parsing library while still offering competitive performance and memory usage.",
      "url": "https://github.com/jameysharp/weighted-regexp-rs/blob/master/README.md",
      "date_published": "2019-01-06T00:00:00+00:00",
      "author": {
        "name": "Jamey Sharp",
        "url": "https://github.com/jameysharp"
      },
      "tags": [
        "Crates",
        "Computer Science"
      ]
    },
    {
      "id": "bc334e2e-7ac8-4019-a197-da3d1d19edbf",
      "title": "Version 0.2 of Smithay, a library for making wayland compositors",
      "content_text": "Announcement of version 0.2 of smithay, now providing the fundamentals of a wayland compositor.",
      "url": "https://smithay.github.io/smithay-v-0-2.html",
      "date_published": "2018-12-28T17:00:00+01:00",
      "author": {
        "name": "Victor Berger",
        "url": "https://smithay.github.io/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "0461ffc8-05b3-413d-a015-c0859ed9665f",
      "title": "Announcing 'err-derive' - yet another error handling library",
      "content_text": "err-derive A failure-like derive macro for the std Error. The source code is mostly copied from failure-derive.",
      "url": "https://users.rust-lang.org/t/announcing-err-derive-yet-another-error-handling-library/23594",
      "date_published": "2018-12-27T13:09:02+00:00",
      "author": {
        "name": "Thomas Schaller",
        "url": "https://users.rust-lang.org/u/torkleyy"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "2508ab68-2b48-4066-a6b4-a15a4f061025",
      "title": "Jix' Site: Introducing partial_ref",
      "content_text": "Recently there has been some discussion about interprocedural borrowing conflicts in rust. This is something I’ve been fighting with a lot, especially while working on my SAT solver varisat. Around the time Niko Matsakis published his blog post about this, I realized that the existing workarounds I’ve been using in varisat have become a maintenance nightmare. Making simple changes to the code required lots of changes in the boilerplate needed to thread various references to the places where they’re needed.\n\nWhile I didn’t think that a new language feature to solve this would be something I’d be willing to wait for, I decided to sit down and figure out how such a language feature would have to look like. I knew that I wanted something that allows for partial borrows across function calls. I also prefer this to work with annotations instead of global inference. While trying to come up with a coherent design that fits neatly into the existing type and trait system, I realized that most of what I wanted can be realized in stable rust today.",
      "url": "https://jix.one/introducing-partial_ref/",
      "date_published": "2018-12-24T14:07:10+01:00",
      "author": {
        "name": "Jannis Harder",
        "url": "https://jix.one/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "e72d0a8e-198f-4bd2-bf1e-7e0e94fac9d5",
      "title": "QADAPT - debug_assert! for your memory usage",
      "content_text": "I think it’s part of the human condition to ignore perfectly good advice when it comes our way. A bit over a month ago, I was dispensing sage wisdom for the ages: I had a really great idea: build a custom allocator that allows you to track your own allocations. I gave it a shot, but learned very quickly: never write your own allocator. I proceeded to ignore it, because we never really learn from our mistakes. There’s another part of the human condition that derives joy from seeing things explode. And that’s the part I’m going to focus on.",
      "url": "https://speice.io/2018/12/allocation-safety.html",
      "date_published": "2018-12-15T00:00:00-05:00",
      "author": {
        "name": "Bradlee Speice",
        "url": "https://speice.io/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "043f0bae-caa0-4d77-8336-9ec0813a0ca0",
      "title": "Easy Postgres extensions in Rust with pg-extend-rs",
      "content_text": "A project to make Postgres extensions in Rust easy, you might learn how to use macro_rules, attribute macros, allocators and some FFI in this post.",
      "url": "https://bluejekyll.github.io/blog/rust/2018/12/27/announcing-pg-extend.html",
      "date_published": "2018-12-27T07:00:00+00:00",
      "author": {
        "name": "Benjamin Fry",
        "url": "https://bluejekyll.github.io/blog/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "8abe1072-74b2-4cc8-b349-ba38a3bfae1b",
      "title": "A great 2018, an even better 2019",
      "content_text": "A year ago, Tokio was a very different library. It includes the (now deprecated) tokio-core which provided a future executor, I/O selector, and basic TCP/UDP types in a single library. It also included tokio-proto, but we won't talk about that. Over the past year, Tokio has grown to become Rust's asynchronous I/O platform. It has been adopted by a number of large companies to build apps.",
      "url": "https://tokio.rs/blog/2018-12-recap-2018/",
      "date_published": "2018-12-19T00:00:00+00:00",
      "author": {
        "name": "Carl Lerche",
        "url": "https://tokio.rs/blog/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "62aed63f-688e-45cd-9d1e-5247b3cbeae3",
      "title": "encoding_rs: a Web-Compatible Character Encoding Library in Rust",
      "content_text": "encoding_rs is a high-decode-performance, low-legacy-encode-footprint and high-correctness implementation of the WHATWG Encoding Standard written in Rust. In Firefox 56, encoding_rs replaced uconv as the character encoding library used in Firefox. This wasn’t an addition of a component but an actual replacement: uconv was removed when encoding_rs landed. This writeup covers the motivation and design of encoding_rs, as well as some benchmark results.",
      "url": "https://hsivonen.fi/encoding_rs/",
      "date_published": "2018-12-03T00:00:00+00:00",
      "author": {
        "name": "Henri Sivonen",
        "url": "https://hsivonen.fi/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "00a3f85a-45c7-42b3-8fac-605dcb945229",
      "title": "Writing MapReduce Jobs Using Rust and Efflux",
      "content_text": "During my work life, I spend a lot of time working with MapReduce-style workflows, particularly with Hadoop infrastructure. A lot of this work is spent with larger amounts of data in order to implement the batch layer of the Lambda architecture. Due to this, the largest concern is that the behaviour is consistent across both the batch layer and the realtime layer - naturally you wouldn't want sporadic behaviour across the two. The easiest way to do this is to share code across the layers, to avoid having to keep implementations in sync. We have recently been working with Rust, which has been a little difficult to integrate with Hadoop MapReduce flows due to the fact it's mainly written in Java. It's because of this that I began to work on a small library named Efflux. It's designed as a very small interface to the MapReduce pattern, and implemented in Rust to allow us to share code across the batch layer easily.",
      "url": "https://whitfin.io/writing-mapreduce-jobs-using-rust/",
      "date_published": "2018-11-28T07:00:49+00:00",
      "author": {
        "name": "Isaac Whitfield",
        "url": "https://whitfin.io/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "36dce8e1-2508-4e34-8aaf-1eb43a8b17e1",
      "title": "Building Alexa Skills in Rust",
      "content_text": "My favorite way to explore Lambdas is to build Alexa skills because of the immediate feedback: you write a little code, and a home device talks to you. It’s a peek into the long promised of world of easy service composition.\n\nUnfortunately, Rust didn’t have complete Alexa skill request/response handling (there is a crate from 2 years ago that handled only the basics), so I wrote one called alexa_sdk. (It’s basically a struct plus serde wrapper around the Alexa JSON spec, with some helpers.",
      "url": "https://medium.com/@amalec/building-alexa-skills-in-rust-4cf54a497ea4",
      "date_published": "2018-12-09T21:30:38.780+00:00",
      "author": {
        "name": "Arien Malec",
        "url": "https://medium.com/@amalec"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "fd9c743c-fb89-4e75-8a46-a837c02174a1",
      "title": "Implementing an EBNF grammar in pest",
      "content_text": "A recent project has led me to have a go at writing an XML parser. I thought I’d document my experiences using pest to implement a lexer using the EBNF-esque formal grammar.",
      "url": "https://compenguy.github.io/hobbies/rust/ebnf-to-pest.html",
      "date_published": "2018-11-22T05:46:00+11:00",
      "author": {
        "name": "Will Page",
        "url": "https://compenguy.github.io/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "8f8ef893-ae80-4991-9d17-93049ee0adc6",
      "title": "Spirit Tutorial",
      "content_text": "In short, when writing a daemon or a service, we have the „muscle“ of the application ‒ whatever we write the daemon for. And we have a whole lot of infrastructure around that: logging, command line parsing, configuration. And while there are Rust libraries for all that, one needs nontrivial amount of boilerplate code to bridge all this together. Spirit aims to be this bridge.",
      "url": "https://vorner.github.io/2018/12/09/Spirit-Tutorial.html",
      "date_published": "2018-12-09T00:00:00+00:00",
      "author": {
        "name": "Michal 'vorner' Vaner",
        "url": "https://vorner.github.io/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "c9feb6f2-ba42-42ca-a0a3-dc37f4ce69ff",
      "title": "Rust+GNOME Hackfest #4",
      "content_text": "Less than 2 weeks ago, I was working on improving the integration of Rust with GNOME libraries at the fourth Hackfest, which happened this time in Thessaloniki.",
      "url": "http://antoyo.ml/rust-gnome-hackfest-thessaloniki",
      "date_published": "2018-11-25T00:00:00+00:00",
      "author": {
        "name": "Antoni Boucher",
        "url": "http://antoyo.ml/"
      },
      "tags": [
        "Community",
        "Crates"
      ]
    },
    {
      "id": "3c9dc7f2-978e-4663-900e-8a49c10bf57f",
      "title": "Wait-Free Per-Object Thread-Local Storage",
      "content_text": "In this post, I present a wait-free thread-local storage using the Rust language.",
      "url": "https://bzim.gitlab.io/blog/posts/wait-free-per-object-thread-local-storage.html",
      "date_published": "2018-11-18T00:00:00+00:00",
      "author": {
        "name": "Bruno Corrêa Zimmermann",
        "url": "https://bzim.gitlab.io/blog/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "84353bd7-6977-4894-883f-b917ccef0b45",
      "title": "Introducing pest into glsl and hindsight about nom vs. pest (part 2)",
      "content_text": "This is the second article about my experience at supporting pest in my glsl crate – without, for now, removing the nom parser.",
      "url": "https://phaazon.net/blog/glsl-pest-part-2",
      "date_published": "2018-11-17T20:40:00+00:00",
      "author": {
        "name": "Dimitri Sabadie",
        "url": "http://phaazon.net/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "b21ca2e0-5670-4a7b-af11-3a6c1312d5e2",
      "title": "Rust, MongoDB & Wither 0.6",
      "content_text": "Hello everyone! I would like to share an update on an open source project which I have been developing for a little while now. It is a Rust project called Wither which attempts to “provide a simple, sane & predictable interface into MongoDB, based on data models”. This post is about the 0.6 release of this crate, and I would like to dive into some of the aspects of developing this release which I really enjoyed or which I found interesting.",
      "url": "https://medium.com/docql/https-medium-com-docql-rust-mongodb-wither-13e803c9ae72",
      "date_published": "2018-11-14T18:33:12.226+00:00",
      "author": {
        "name": "Anthony Dodd",
        "url": "https://medium.com/docql"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "2a3a85cf-b4ac-49ff-9a27-4d377cd3d0cb",
      "title": "Introducing pest into glsl and hindsight about nom vs. pest (part 1)",
      "content_text": "This is the first article out of a (I guess?!) series of upcoming articles about… parsing. More specifically, I’ve been writing the glsl crate for a while now and the current, in-use parser is backed with nom. nom is a parser combinator crate written originally by @geal and there has been a lot of fuzz around nom vs. pest lately.\n\nSoooooooooooo. Because glsl is written with nom in its third iteration and because nom is now at version 4, I decided it was time to update the parser code of glsl. I heard about the comparison between pest and nom and decided to write an implementation with pest.\n\nThis is the first article of a series about how writing a pest looks like is fun compared to writing the nom parser. I’ll post several articles as I advance and see interesting matter to discuss and share.",
      "url": "https://phaazon.net/blog/glsl-pest-part-1",
      "date_published": "2018-11-17T05:00:00+00:00",
      "author": {
        "name": "Dimitri Sabadie",
        "url": "http://phaazon.net/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "6b8f2916-9634-4d6b-ae64-02d565c58659",
      "title": "Gutenberg is out, Zola 0.5.0 is in",
      "content_text": "Gutenberg changes name to Zola and gets a big release to celebrate.",
      "url": "https://www.vincentprouillet.com/blog/releasing-zola-0-5-0/",
      "date_published": "2018-11-17T00:00:00+00:00",
      "author": {
        "name": "Vincent Prouillet",
        "url": "https://www.vincentprouillet.com/blog/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "b612b468-7306-4f7b-a09a-2b4f0bac5b55",
      "title": "Introducing Mundane, a new cryptography library for Rust",
      "content_text": "Mundane is a cryptography library written in Rust and backed by BoringSSL. It aims to be difficult to misuse, ergonomic, and performant (in that order). It was originally created to serve the cryptography needs of Fuchsia, but we’ve decided to split it off as a general-purpose crate.",
      "url": "https://joshlf.com/post/2018/11/06/introducing-mundane/",
      "date_published": "2018-11-06T00:00:00+00:00",
      "author": {
        "name": "Joshua Liebow-Feeser",
        "url": "https://joshlf.com/"
      },
      "tags": [
        "Security",
        "Crates"
      ]
    },
    {
      "id": "db47620d-045e-42dc-bc1a-6aedaed9d948",
      "title": "eyeoh: My first Rust library",
      "content_text": "I realized I kept copy and pasting (or re-writing) functions to take user input or read simple files into Rust variables. So I’ve been working on a Rust library that attempts to make these tasks easier.",
      "url": "https://sts10.github.io//2018/11/02/eyeoh-rust-library.html",
      "date_published": "2018-11-02T22:18:50+00:00",
      "author": {
        "name": "Sam Schlinkert",
        "url": "https://sts10.github.io/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "092a372d-fa4a-48e7-8382-c85069e9a425",
      "title": "Pyro - A fast, small and documented Entity Component System",
      "content_text": "In contrast to many other ECS, iteration in Pyro is fully linear. Different combinations of components always live in the same storage. The advantage is that iteration is always fully linear and no cache is wasted. The storage behind the scene is a SoA storage.",
      "url": "https://maikklein.github.io/pyro-ecs/",
      "date_published": "2018-10-30T00:00:00+00:00",
      "author": {
        "name": "Maik Klein",
        "url": "https://maikklein.github.io/"
      },
      "tags": [
        "Games and Graphics",
        "Crates"
      ]
    },
    {
      "id": "38c548bb-e3d4-428d-9a95-89ca0c8ce3c9",
      "title": "What is Rusty ECMA Script Scanner (RESS)",
      "content_text": "After releasing the Rusty ECMA Script Scanner (RESS) 0.5, my next big effort in the Rust+Javascript space is to increase the amount of documentation. This post is an effort to clarify what RESS does and how someone might use it.",
      "url": "https://wiredforge.com/blog/rusty_ecma/what-is-a-scanner/index.html",
      "date_published": "2018-10-02T00:00:00+00:00",
      "author": {
        "name": "Robert Masen",
        "url": "https://wiredforge.com/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "9ed3a1ea-2c0d-4508-a2d7-69e9bb07557a",
      "title": "New crate: pin-cell",
      "content_text": "Today I realized a new crate called pin-cell. This crate contains a type called PinCell, which is a kind of cell that is similar to RefCell, but only can allow pinned mutable references into its interior. Right now, the crate is nightly only and no-std compatible.\nHow is the API of PinCell different from RefCell? When you call borrow_mut on a RefCell, you get a type back that implements DerefMut, allowing you to mutate the interior value.",
      "url": "https://boats.gitlab.io/blog/post/pin-cell/",
      "date_published": "2018-10-09T00:00:00+00:00",
      "author": {
        "name": "withoutboats",
        "url": "https://boats.gitlab.io/blog/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "620115c2-e4f9-4c5c-953a-d891cc636b01",
      "title": "Rust SGX SDK v1.0.4 Released",
      "content_text": "Rust SGX SDK, maintained by Baidu X-Lab, is a convenient framework to develop secure trusted computing applications for Intel SGX enclaves. Based on it, developers can easily build trusted SGX enclaves with memory safety guarantees. This adds an extra strong (and strongest ever) security layer over the SGX isolation, further keeping attackers away from the secrets in enclave even if they compromised the privileged software environment (operating system, hypervisor, etc.). Rust SGX SDK thus means a lot to privacy protection and trusted computing on public cloud platforms and blockchains.",
      "url": "https://medium.com/baiduxlab/rust-sgx-sdk-v1-0-4-released-9c7d9056a888",
      "date_published": "2018-10-09T17:50:10.689+00:00",
      "author": {
        "name": "Baidu X-Lab",
        "url": "https://medium.com/@baidu.xlab"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "2e4df02b-88e0-4510-851a-d1dce6014568",
      "title": "Configuration envy",
      "content_text": "For many of my use cases for running Rust applications, storing configuration in file format is less attractive as I’m typically running Rust inside docker containers and container orchestrators typically encourage the use of standard interfaces like the env for configuration. So I pondered 🤔, “What if I could treat my program’s env parameterization with the same level of typing I treat my functions and enclosing types with while getting everything one get’s from using serde for free?” That would be the bee’s knees 🐝 . Enter: envy.",
      "url": "https://medium.com/@softprops/configuration-envy-a09584386705",
      "date_published": "2018-10-16T04:17:18.209+00:00",
      "author": {
        "name": "Doug Tangren",
        "url": "https://medium.com/@softprops"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "11700b19-9b9f-44c3-9708-2c4cd7f0d721",
      "title": "Reflections on Implementing the ndarray-csv Crate",
      "content_text": "Recently, I wrote ndarray-csv, a Rust crate for converting between CSV files and 2D arrays. There are already crates for CSV and arrays, so how exciting could this possibly be? Actually, there was a lot more to it than I had thought: although it started out as a two-hour project, I ended up rewriting the entire thing three times!",
      "url": "https://paulkernfeld.com/2018/10/13/ndarray-csv-reflections.html",
      "date_published": "2018-10-13T00:00:00+00:00",
      "author": {
        "name": "Paul Kernfeld",
        "url": "https://paulkernfeld.com/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "a708e2c2-f0bd-4691-88c0-d004bedd667a",
      "title": "pest Parser 2.0 Released",
      "content_text": "pest is a general purpose parser written in Rust with a focus on accessibility, correctness, and performance. It uses parsing expression grammars (or PEG) as input, which are similar in spirit to regular expressions, but which offer the enhanced expressivity needed to parse complex languages. ",
      "url": "https://pest.rs/",
      "date_published": "2018-10-04T00:00:00+00:00",
      "author": {
        "name": "Dragoș Tiselice",
        "url": "https://github.com/dragostis"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "2e26b090-21b9-42e2-9ac5-9664e79af88e",
      "title": "Merlin: flexible, composable transcripts for zero-knowledge proofs",
      "content_text": "Merlin is a small Rust library that performs the Fiat-Shamir transformation in software, maintaining a STROBE-based transcript of the proof protocol and allowing the prover to commit messages to the transcript and compute challenges bound to all previous messages. It also provides a transcript-based RNG for use by the prover, generalizing “deterministic” and “synthetic” nonces to arbitrarily complex zero-knowledge protocols.",
      "url": "https://medium.com/@hdevalence/merlin-flexible-composable-transcripts-for-zero-knowledge-proofs-28d9fda22d9a",
      "date_published": "2018-09-28T21:07:20.750+00:00",
      "author": {
        "name": "Henry de Valence",
        "url": "https://medium.com/@hdevalence"
      },
      "tags": [
        "Crates",
        "Security"
      ]
    },
    {
      "id": "96405556-ac98-433a-a0f8-c3de068e47d3",
      "title": "‘orion’ - yet another attempt at pure-Rust cryptography",
      "content_text": "orion is another attempt at cryptography implemented in pure Rust. Its main focus is usability. This is in part achieved by providing a thorough documentation of the library. High-level abstractions are also provided, which are an attempt at guiding the users towards safe usage of the lower-level functionality of the library.",
      "url": "https://brycx.github.io/2018/09/25/orion-pure-rust-crypto-lib.html",
      "date_published": "2018-09-25T00:00:00+00:00",
      "author": {
        "name": "brycx",
        "url": "https://brycx.github.io/"
      },
      "tags": [
        "Crates",
        "Security"
      ]
    },
    {
      "id": "956dab4d-a04e-4278-bb20-906f4eac7a82",
      "title": "GStreamer Rust bindings 0.12 and GStreamer Plugin 0.3 release",
      "content_text": "After almost 6 months, a new release of the GStreamer Rust bindings and the GStreamer plugin writing infrastructure for Rust is out. As usual this was coinciding with the release of all the gtk-rs crates to make use of all the new features they contain.",
      "url": "https://coaxion.net/blog/2018/09/gstreamer-rust-bindings-0-12-and-gstreamer-plugin-0-3-release/",
      "date_published": "2018-09-10T11:41:59+00:00",
      "author": {
        "name": "Sebastian Dröge",
        "url": "https://coaxion.net/blog/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "d1f041f8-f77b-404b-a776-5615afef85f4",
      "title": "GIR support in gnome-class",
      "content_text": "Recently I've been working again in the rust port of libgepub, libgepub is C code, but in the rust-migration branch almost all the real functionality is done with rust and the GepubDoc class is a GObject wrapper around that code. For this reason I was thinking about to use gnome-class to implement GepubDoc. Gnome-class is a rust lib to write GObject code in rust that's compatible with the C binary API so then you can call this new GObject code written with gnome-class from C. So, libgepub is the excuse to start to implement GIR in gnome-class.",
      "url": "http://danigm.net/gnome-class-gir.html",
      "date_published": "2018-09-01T00:00:00+02:00",
      "author": {
        "name": "danigm",
        "url": "http://danigm.net/category/blog.html"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "9572581f-4d30-4abb-9aa8-8f7842b37117",
      "title": "Sonnerie: A simple timeseries database",
      "content_text": "Sonnerie is a time-series database. Map a timestamp to a floating-point value. Store multiple of these series in a single database. Insert tens of millions of samples in minutes, on rotational media.",
      "url": "https://github.com/njaard/sonnerie",
      "date_published": "2018-09-08T00:00:00+00:00",
      "author": {
        "name": "Kalle Samuels",
        "url": "https://github.com/njaard"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "919b55ea-6ff7-4893-8c6f-1bd17b6cbab2",
      "title": "Announcing Spirit",
      "content_text": "Spirit is a crate that cuts down on boilerplate when creating unix daemons, with support for live configuration reloading.",
      "url": "https://vorner.github.io/2018/09/03/Announcing-Spirit.html",
      "date_published": "2018-09-03T00:00:00+00:00",
      "author": {
        "name": "Michal 'vorner' Vaner",
        "url": "https://vorner.github.io/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "99ecbdf0-983f-42d8-850a-5e0532770f17",
      "title": "Introducing windows-acl: working with ACLs in Rust",
      "content_text": "Access Control Lists (ACLs) are an integral part of the Microsoft Windows security model. In addition to controlling access to secured resources, they are also used in sandboxing, event auditing, and specifying mandatory integrity levels. They are also exceedingly painful to programmatically manipulate, especially in Rust. Today, help has arrived — we released windows-acl, a Rust crate that simplifies the manipulation of access control lists on Windows.",
      "url": "https://blog.trailofbits.com/2018/08/23/introducing-windows-acl-working-with-acls-in-rust/",
      "date_published": "2018-08-23T11:50:39+00:00",
      "author": {
        "name": "Trail of Bits",
        "url": "https://blog.trailofbits.com/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "d6f7c587-36f5-4276-8b5b-60cd8d857606",
      "title": "History of the Rand crate",
      "content_text": "I wrote this bit to give a some background about why Rand looks the way it does, and why it is time to make some changes. The new release, Rand 0.5, is getting almost ready fro release. Also I hope it is a bit entertaining to read about the history in combination with early Rust.",
      "url": "https://www.reddit.com/r/rust/comments/87qy40/history_of_the_rand_crate/",
      "date_published": "2018-03-28T21:52:43+11:00",
      "author": {
        "name": "u/pitdicker",
        "url": "https://www.reddit.com/user/pitdicker"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "e53853b1-a7ca-4ffc-bf71-510ed37ea402",
      "title": "Toykio, a toy event loop",
      "content_text": "In this blog post I’d like to present toykio, a simple futures executor intended for learning about how executors with an event loop work. Toykio only provides a very minimal feature set: An event loop and TCP streams and listeners. However, it turns out that due to the fact that futures are composable, this is enough to build complex clients and servers.",
      "url": "https://rust-lang-nursery.github.io/futures-rs/blog/2018/08/17/toykio.html",
      "date_published": "2018-08-17T00:00:00+00:00",
      "author": {
        "name": "Alexander Polakov",
        "url": "https://rust-lang-nursery.github.io/futures-rs/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "2105e8ca-6037-4dfa-86f7-644bdbec71bd",
      "title": "Futures 0.3.0-alpha.3",
      "content_text": "A compatibility layer between 0.3 an 0.1 was developed. It is now possible to convert an 0.3 future into an 0.1 future and vice versa. Similar conversions for streams and sinks are also supported. Additionally, it is now possible to run 0.3 futures and async functions on Tokio’s executor. We have a dedicated blog post coming up that explains this in more detail.",
      "url": "https://rust-lang-nursery.github.io/futures-rs/blog/2018/08/15/futures-0.3.0-alpha.3.html",
      "date_published": "2018-08-15T00:00:00+00:00",
      "author": {
        "name": "Josef Brandl",
        "url": "https://rust-lang-nursery.github.io/futures-rs/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "e9ddc1eb-5ab9-4f23-8b9a-a41cea991044",
      "title": "Tower Web 0.2 — Now 100% comment attribute free",
      "content_text": "The short version is, Tower Web 0.2 was just released and regular Rust attributes are now used instead of magic comments. The doc comment is replaced with #[get(\"/\")]. This is thanks to Rust macro wizard David Tolnay. I also thought that it would be best to immediately push out 0.2 and then we can all pretend 0.1 didn’t happen.",
      "url": "https://medium.com/@carllerche/tower-web-0-2-now-100-comment-attribute-free-3ed0633e47e5",
      "date_published": "2018-08-14T16:22:13.075+00:00",
      "author": {
        "name": "Carl Lerche",
        "url": "https://medium.com/@carllerche"
      },
      "tags": [
        "Web and Network Services",
        "Crates"
      ]
    },
    {
      "id": "02a5f7b7-0114-440d-9be0-d5aaf77bfa65",
      "title": "PrettySize for rust",
      "content_text": "We’ve just published a rust port of our PrettySize.NET library, now available via cargo and github. Like its .NET predecessor, PrettySize-rs aims to provide a comprehensive API for dealing with file sizes, covering both manipulation and human-readable formatting.",
      "url": "https://neosmart.net/blog/2018/prettysize-for-rust/",
      "date_published": "2018-08-11T20:56:39+00:00",
      "author": {
        "name": "Mahmoud Al-Qudsi",
        "url": "https://neosmart.net/blog/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "577e9c57-0455-41c6-9711-be71bf55e550",
      "title": "intl_pluralrules: A Rust Crate for Handling Plural Forms with CLDR Plural Rules",
      "content_text": "intl_pluralrules is a Rust crate, built to handle pluralization. Pluralization is the foundation for all localization and many internationalization APIs. With the addition of intl_pluralrules, any locale-aware date-, time- or unit-formatting (“1 second” vs “2 seconds”) and many other pluralization-dependent APIs can be added to Rust.",
      "url": "https://blog.mozilla.org/l10n/2018/08/03/intl_pluralrules-a-rust-crate-for-handling-plural-forms-with-cldr-plural-rules/",
      "date_published": "2018-08-03T23:30:19+00:00",
      "author": {
        "name": "Kekoa Riggin",
        "url": "https://blog.mozilla.org/l10n/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "2182c554-41eb-4ee7-a1de-11eb90a8223d",
      "title": "A small custom Bool Type in Diesel",
      "content_text": "I’ve been working with diesel and serde. I use diesel for my postgres datastore, and serde for serializing/deserializing data to the web. Recently I came across a situation where I needed to define my type in diesel as well as implement deserialize in serde. The example below is a fairly simple so it makes for a good example to share so others can learn (and so I can remember how all this works next time I need it).",
      "url": "https://noyez.gitlab.io/post/2018-08-05-a-small-custom-bool-type-in-diesel/",
      "date_published": "2018-08-05T00:00:00+00:00",
      "author": {
        "name": "Noyez",
        "url": "https://noyez.gitlab.io/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "a3f0bd42-0a42-4156-9fd6-74aebe5f0465",
      "title": "nphysics: 2D and 3D real-time physics engine",
      "content_text": "I’m excited to announce the brand new website/user-guide for the nphysics2d and nphysics3d crates: pure-rust 2D and 3D real-time physics engines with rigid bodies and joints! Online wasm-based demos are also provided (see for example the Multibody joints 34 demo).",
      "url": "http://nphysics.org/",
      "date_published": "2018-07-29T03:46:07+10:00",
      "author": {
        "name": "Sébastien Crozet",
        "url": "http://nphysics.org/"
      },
      "tags": [
        "Games and Graphics",
        "Crates"
      ]
    },
    {
      "id": "b5717efe-ad7b-4b02-8554-aba801aff909",
      "title": "Amethyst 0.8 has been released!",
      "content_text": "With a brand new tutorial and a ton of new features, including prefabs, controller support, MP3 audio, localisation and an even better ergonomics!",
      "url": "https://www.amethyst.rs/blog/release-0-8/",
      "date_published": "2018-08-05T00:00:00+00:00",
      "author": {
        "name": "Moxinilian (Théo Degioanni)",
        "url": "https://www.amethyst.rs/blog"
      },
      "tags": [
        "Games and Graphics",
        "Crates"
      ]
    },
    {
      "id": "c1718910-2677-4da4-a45f-a8bd055fe075",
      "title": "Gutenberg 0.4.0: custom taxonomies, image processing and more",
      "content_text": "Gutenberg 0.4.0 is out with custom taxonomies, image processing, improved shortcodes and more.",
      "url": "https://www.vincentprouillet.com/blog/releasing-gutenberg-0-4-0/",
      "date_published": "2018-08-04T00:00:00+00:00",
      "author": {
        "name": "Vincent Prouillet",
        "url": "https://www.vincentprouillet.com/blog/"
      },
      "tags": [
        "Tools and Applications",
        "Crates"
      ]
    },
    {
      "id": "0a171d26-74e1-491c-befd-e02ac528c1ff",
      "title": "#[derive(Debug)] on serde steroids",
      "content_text": "In this post I'd like to introduce a serdebug helper which is a drop-in replacement for #[derive(Debug)] with some of the advanced features that serde can provide.",
      "url": "https://rreverser.com/derive-serdebug/",
      "date_published": "2018-07-31T16:00:45+00:00",
      "author": {
        "name": "Ingvar Stepanyan",
        "url": "https://rreverser.com/#open"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "81096070-a563-47a0-8f09-2e5fb3c1b984",
      "title": "Sequoia, a new OpenPGP implementation",
      "content_text": "This past fall, three former GnuPG developers began working on a new OpenPGP implementation in Rust called Sequoia. As it’s starting to shape up and become useful, I feel now is a good time to announce the project to the larger Rust community, and hopefully get some feedback before our first release.",
      "url": "https://www.reddit.com/r/rust/comments/93mng5/ann_sequoia_a_new_openpgp_implementation/",
      "date_published": "2018-08-01T16:50:12+10:00",
      "author": {
        "name": "/u/nwalfield",
        "url": "https://sequoia-pgp.org/"
      },
      "tags": [
        "Tools and Applications",
        "Crates"
      ]
    },
    {
      "id": "55adde79-edfa-433f-8c4f-40f2baee7cd9",
      "title": "warp",
      "content_text": "Over the past several months, I’ve been working a web framework in Rust. I wanted to make use of the new hyper 0.12 changes, so the framework is just as fast, is asynchronous, and benefits from all the improvements found powering Linkerd. More importantly, I wanted there to be a reason for making a new framework; it couldn’t just be yet another framework with the only difference being I’ve written it. Instead, the way this framework is used is quite different than many that exist. In doing so, it expresses a strong opinion, which might not match your previous experiences, but I believe it manages to do something really special.\n\nI’m super excited to reveal warp, a joint project with @carllerche.",
      "url": "http://seanmonstar.com/post/176530511587/warp",
      "date_published": "2018-08-01T00:00:00+00:00",
      "author": {
        "name": "Sean McArthur",
        "url": "http://seanmonstar.com/"
      },
      "tags": [
        "Web and Network Services",
        "Crates"
      ]
    },
    {
      "id": "e29e550b-7c05-4625-9a81-513b316b5675",
      "title": "Futures 0.3.0-alpha.2",
      "content_text": "Several new changes while working towards 0.3.",
      "url": "https://rust-lang-nursery.github.io/futures-rs/blog/2018/07/30/futures-0.3.0-alpha.2.html",
      "date_published": "2018-07-30T00:00:00+00:00",
      "author": {
        "name": "Josef Brandl",
        "url": "http://rust-lang-nursery.github.io/futures-rs/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "e0622344-66a9-4b93-a59f-1b5250ba8c98",
      "title": "Using C libraries in Rust: make a sys crate",
      "content_text": "Using C libraries in a portable way involves a bit of work: finding the library on the system or building it if it's not available, checking if it is compatible, finding C headers and converting them to Rust modules, and giving Cargo correct linking instructions. Often every step of this is tricky, because operating systems, package managers and libraries have their unique quirks that need special handling.\n\nFortunately, all this work can be done once in a build script, and published as a <insert library name>-sys Rust crate. This way other Rust programmers will be able to use the C library without having to re-invent the build script themselves.",
      "url": "https://kornel.ski/rust-sys-crate",
      "date_published": "2018-07-30T00:00:00+00:00",
      "author": {
        "name": "Kornel",
        "url": "https://kornel.ski/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "e5caa9df-4d3f-46be-a8ce-79369f0cad32",
      "title": "Wayland-rs 0.21: Pure Rust implementation",
      "content_text": "wayland-rs is a set of crates providing generic APIs to manipulate the Wayland protocol, successor of X11 for linux windowing.\n\nHere I am finally, after having hinted at the possibility and finally taken the time to write and merge quite an epic pull request, I can finally say it: wayland-rs is now a pure rust implementation of the protocol, rather than a crate of bindings to the wayland system C libraries.",
      "url": "https://smithay.github.io/wayland-rs-v-0-21.html",
      "date_published": "2018-07-18T22:00:00+02:00",
      "author": {
        "name": "Victor Berger",
        "url": "https://smithay.github.io/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "2a8864ba-0872-45d2-89f4-87e9f368374b",
      "title": "Futures 0.3.0-alpha.1",
      "content_text": "Welcome to the inaugural post of the new futures-rs blog!\n\nAfter several months of work, we’re happy to announce an alpha release of the new edition of future-rs, version 0.3. The immediate goal of this work is to support async/await notation (with borrowing) in Rust itself, which has entailed significant changes to the futures crate.",
      "url": "https://rust-lang-nursery.github.io/futures-rs/blog/2018/07/19/futures-0.3.0-alpha.1.html",
      "date_published": "2018-07-19T17:00:00+00:00",
      "author": {
        "name": "Aaron Turon",
        "url": "https://rust-lang-nursery.github.io/futures-rs/"
      },
      "tags": [
        "Language",
        "Crates"
      ]
    },
    {
      "id": "9c9c6dda-6538-4088-8123-e1ad213082e5",
      "title": "What I Learned: Porting Dateutil Parser to Rust",
      "content_text": "Hi. I’m Bradlee. I’ve mostly been a lurker in Rust for a while, making a couple small contributions here and there. So launching dtparse feels like nice step towards becoming a functioning member of society. But not too much, because then you know people start asking you to pay bills, and ain’t nobody got time for that.\n\nBut I built dtparse, and you can read about my thoughts on the process. Or don’t. I won’t tell you what to do with your life (but you should totally keep reading).",
      "url": "https://speice.io/2018/06/dateutil-parser-to-rust.html",
      "date_published": "2018-06-25T00:00:00+00:00",
      "author": {
        "name": "Bradlee Speice",
        "url": "https://speice.io/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "989d2bb2-c78b-4844-92ab-45509164c182",
      "title": "Zapper: A Very Fast Templating Engine",
      "content_text": "Thirty times faster than Handlebars, half the features! I am introducing a new templating engine for Rust that is designed to be robust and very fast! Why Zapper? Runtime templating is amazing, since you can reload templates on the fly or even allow users to provide their own templates, yet runtime templating engines are rarely fast. Templates that are statically compiled into your application can be super fast, but are completely inflexible. Recompiling and restarting your application just to change a template is especially boring. Zapper combines the flexibility of runtime templating with great performance!",
      "url": "https://ceres1.space/posts/zapper/",
      "date_published": "2018-06-25T19:28:22-07:00",
      "author": {
        "name": "Josh Leverette",
        "url": "https://ceres1.space/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "faf1a345-9eaf-4d00-a7f7-9fa3afaa51ac",
      "title": "Better HTTP Upgrades with hyper",
      "content_text": "Better HTTP Upgrades with hyper It’s been possible to handle HTTP Upgrades (like Websockets) in hyper if you made use of the low-level APIs in the server and client, but it wasn’t especially nice to...",
      "url": "http://seanmonstar.com/post/175280388657/better-http-upgrades-with-hyper",
      "date_published": "2018-06-26T00:00:00+00:00",
      "author": {
        "name": "Sean McArthur",
        "url": "http://seanmonstar.com/"
      },
      "tags": [
        "Web and Network Services",
        "Crates"
      ]
    },
    {
      "id": "ced93c25-32fb-4e74-a5e4-5fb7cd60e8ee",
      "title": "Building an Event Sourcing Crate for Rust",
      "content_text": "In one of my recent blog posts, I talked about Event Sourcing with Aggregates in Rust. In that post, I was just beginning to explore how the Rust language and its strongly typed native data structures would allow me to express event sourcing concepts and primitives. I have now created an initial version of an Event Sourcing crate that you can explore on crates.io",
      "url": "https://medium.com/@KevinHoffman/building-an-event-sourcing-crate-for-rust-2c4294eea165",
      "date_published": "2018-06-25T13:30:42.993+00:00",
      "author": {
        "name": "Kevin Hoffman",
        "url": "https://medium.com/@KevinHoffman"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "afc3d2f1-e848-4c25-af60-89cf7209b3ba",
      "title": "Writing Python Extensions In Rust Using PyO3",
      "content_text": "I've been writing some code in Rust recently, and I thought it would be cool if I could take some of this Rust code and provide it as a native extension that I can call from Python. It turns out there are some amazing tools like PyO3 that make it easy to write fully featured Python extensions in Rust, with considerably less effort than writing a CPython extension manually.\n\nTo test out PyO3 I wrote a small Python extension in Rust, and I thought I would share some of the tips and tricks I encountered in getting this going. This post aims to serve as a quick tutorial showing how to write extensions in Rust, talking about why you might want to use something more powerful than just exposing a C library called using CFFI, and how PyO3 lets you write Python aware extensions in Rust. ",
      "url": "https://www.benfrederickson.com/writing-python-extensions-in-rust-using-pyo3/",
      "date_published": "2018-06-21T00:00:00-07:00",
      "author": {
        "name": "Ben Frederickson",
        "url": "https://www.benfrederickson.com/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "31acdf03-3f59-4102-81ba-edafd6f2cfad",
      "title": "Fast and Simple Rendering in Rust using Proc Macros",
      "content_text": "I’ve been working on a project called Thruster recently, and needed a way that a developer could reasonably use templates. Thruster is a middleware based web server written in Rust (get it, th-rust-er? I’m working on my tight 5 for amateur night at The Apollo,) and as such, I needed a way to load HTML templates and insert variables into them in a performant way. Rather than poking around the numerous existing libraries and choosing one made by someone I don’t know — stranger danger! — I decided to make it myself. This article is about that journey, the unbelievably thrilling adventures of writing my first proc_macro_derive in Rust.",
      "url": "https://medium.com/@MertzAlertz/fast-and-simple-rendering-in-rust-using-proc-macros-f0d919eb6475",
      "date_published": "2018-06-19T13:22:54.045+00:00",
      "author": {
        "name": "Pete Mertz",
        "url": "https://medium.com/@MertzAlertz"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "edd88db5-3f05-4171-9159-de17a3a4db8a",
      "title": "Let's Talk About Vector Graphics (In Rust)",
      "content_text": "I gave a talk about lyon at RustFest Paris. This post is the introduction of the talk, wherein I introduce vector graphics and try to get the audience somewhat excited about it. Things will get technical in the follow-up posts.",
      "url": "https://nical.github.io/posts/rustfest-paris-01.html",
      "date_published": "2018-06-18T00:00:00+02:00",
      "author": {
        "name": "Nical",
        "url": "https://nical.github.io/index.html"
      },
      "tags": [
        "Crates",
        "Games and Graphics"
      ]
    },
    {
      "id": "ff081914-cb16-4004-bc20-53e494477b8c",
      "title": "Building better compression together with DivANS",
      "content_text": "Compressing your files is a good way to save space on your hard drive. At Dropbox’s scale, it’s not just a good idea; it is essential. Even a 1% improvement in compression efficiency can make a huge difference. That’s why we conduct research into lossless compression algorithms that are highly tuned for certain classes of files and storage, like Lepton for jpeg images, and Pied-Piper-esque lossless video encoding. For other file types, Dropbox currently uses the zlib compression format, which saves almost 8% of disk storage.\n\nWe introduce DivANS, our latest open-source contribution to compression, in this blog post.",
      "url": "https://blogs.dropbox.com/tech/2018/06/building-better-compression-together-with-divans/",
      "date_published": "2018-06-19T16:00:24+00:00",
      "author": {
        "name": "Daniel Reiter Horn and Jongmin Baek",
        "url": "https://blogs.dropbox.com/tech/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "4548e0ef-697b-414c-8bf5-9a63a707bafb",
      "title": "A Trick For Test Maintenance",
      "content_text": "This is a post about an interesting testing technique which feels like it should be well known. However, I haven’t seen it mentioned anywhere. I don’t even have a good name for it, I’ve semi-discovered it in the wild. If you know how this thing is called, please leave a comment!",
      "url": "https://matklad.github.io/2018/06/18/a-trick-for-test-maintenance.html",
      "date_published": "2018-06-18T15:00:16+00:00",
      "author": {
        "name": "Aleksey Kladov",
        "url": "https://matklad.github.io/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "27c8b7ed-32ab-4390-8be8-58678541dfb8",
      "title": "Tarpaulin Past Present Future",
      "content_text": "Tarpaulin (or cargo-tarpaulin) is a code coverage tool for Rust. Last year was pretty busy with the launch of the project and the rush of issues as people started to use it so this is just a chance to look at what’s new with version 0.6.0 and what’s planned for the rest of this year.",
      "url": "https://xd009642.github.io/2018/06/11/Tarpaulin-past-present-future.html",
      "date_published": "2018-06-11T00:00:00+00:00",
      "author": {
        "name": "xd009642",
        "url": "https://xd009642.github.io/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "f98c539d-bf5c-4329-a4b2-bba3c4816350",
      "title": "Integrating QML and Rust: Creating a QMetaObject at Compile Time",
      "content_text": "In this blog post, I would like to present a research project I have been working on: Trying to use QML from Rust, and in general, using a C++ library from Rust. The project is a Rust crate which allows to create QMetaObject at compile time from pure Rust code. It is available here: https://github.com/woboq/qmetaobject-rs",
      "url": "https://woboq.com/blog/qmetaobject-from-rust.html",
      "date_published": "2018-06-07T00:00:00+00:00",
      "author": {
        "name": "Olivier Goffart",
        "url": "https://woboq.com/blog/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "01dd6aee-aa4b-46b9-a4dc-5d2550a96356",
      "title": "Crates.rs — a new, faster crate index website",
      "content_text": "Crates.rs, an alternative opinionated front-end to crates.io:\n\nIt’s fast.\n\nAll readmes are displayed whenever possible, and if there’s no or poor readme, doc comments are shown too.\n\nIt combines information from multiple sources, e.g. byline is a compact amalgamation of Cargo.toml, crates.io, and GitHub contributors, so you get an idea who wrote the code even if authors forgot to keep Cargo.toml up to date.\n\nCrate popularity is displayed as top-N position in its most relevant category, e.g. “#5 in Cryptography”, which is more meaningful than absolute download numbers.\n\nOptional dependencies display which feature or platform they’re for.\n\nVersion history is summarized to help see at a glance whether a crate gets regular updates and how often it has breaking changes.\n\nRecognizes sys crates even if they’re not called -sys and shows when build.rs is used.\n\nCategory pages fit more crates on screen despite looking less cluttered and having easier to read descriptions.\n\nAll categories and their representative crates are right there on the homepage.\n\nSyntax highlighting everywhere, including code blocks.\n\nEverything works without JS and gets indexed by search engines, so I’m hoping the site will help find crates.",
      "url": "https://crates.rs/index",
      "date_published": "2018-06-04T23:27:00+00:00",
      "author": {
        "name": "Kornel",
        "url": "https://kornel.ski/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "9bf3f488-ace2-43b6-9f6b-3071241f7ed2",
      "title": "hyper v0.12",
      "content_text": "Today sees the release of hyper v0.12.0, a fast and correct HTTP library for the Rust language.\n\nThis release adds support for several new features, while taking the opportunity to fix some annoyances, and improve the extreme speeds!",
      "url": "http://seanmonstar.com/post/174480374517/hyper-v012",
      "date_published": "2018-06-01T00:00:00+00:00",
      "author": {
        "name": "Sean McArthur",
        "url": "http://seanmonstar.com/"
      },
      "tags": [
        "Web and Network Services",
        "Crates"
      ]
    },
    {
      "id": "d7340b81-5e94-4123-b830-c5cbbfa154d2",
      "title": "HTTP Crate with URL Support & a Simple HTTP Client",
      "content_text": "While the http crate generally has a great API I have been unsatisfied how it handles URLs. To create a HTTP request a full URL is needed with a scheme (http/https), authority (example.org) and a path (/search?q=rust) but http does enforce this and allows you to only state the path. This means both clients and servers are either unable to determine protocol and and authority information or have to do this manually.",
      "url": "https://pyfisch.org/blog/http-with-url/",
      "date_published": "2018-06-01T00:00:00+00:00",
      "author": {
        "name": "Pyfisch",
        "url": "https://pyfisch.org/blog/"
      },
      "tags": [
        "Web and Network Services",
        "Crates"
      ]
    },
    {
      "id": "d517cda7-1102-49bb-ab34-d14f5f0d09c0",
      "title": "Learn Rust by project",
      "content_text": "More than a year ago a friend of mine wanted to learn a bit more about Rust by trying out a project. He had a nice project in mind which suits Rust quite well I think. For fun I joined his effort and created an implementation at the same time as he did, discussing and comparing along the way. In this post I’ll tell you about the project specifics, but the point of the post is more an encouragement. If you’ve read about Rust before but haven’t tried it yet, find a small project like the one below, and learn Rust in a fun and hands-on way yourself. It’s a great programming language, I highly recommend it.",
      "url": "http://blog.jeffsmits.net/compsci/2018/04/30/learn-rust-by-project/",
      "date_published": "2018-04-30T00:00:00+00:00",
      "author": {
        "name": "Jeff Smits",
        "url": "http://blog.jeffsmits.net/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "600945e6-9cca-43fc-abe3-8b39f5eb1766",
      "title": "nom 4.0: faster, safer, simpler parsers",
      "content_text": "It took nearly 6 months of development and the library went through nearly 5 entire rewrites. Compare that to previous major releases, which took a month at most to do. But it was worth it! This new release cleans up a lot of old bugs and unintuitive behaviours, simplifies some common patterns, is faster, uses less memory, gives better errors, but the way parsers are written stay the same. It’s like an entirely new engine under the same body work!",
      "url": "http://unhandledexpression.com/general/2018/05/14/nom-4-0-faster-safer-simpler-parsers.html",
      "date_published": "2018-05-14T13:00:00+02:00",
      "author": {
        "name": "Geoffroy Couprie",
        "url": "https://unhandledexpression.com/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "df6d6cbf-58fc-49e6-a582-446c255a3d39",
      "title": "gtk-test - A crate for testing GTK UIs",
      "content_text": "Currently, testing UIs is difficult, but with gtk-test you can test basically everything UI-related way more simply.",
      "url": "http://gtk-rs.org/blog/2018/05/02/who-talked-about-testing.html",
      "date_published": "2018-05-02T00:00:00+00:00",
      "author": {
        "name": "Gtk-rs",
        "url": "http://gtk-rs.org/blog"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "83c972be-a658-4858-9277-474eebee81a1",
      "title": "Introducing Sentry for Rust",
      "content_text": "As happy Rust users ourselves, it makes us even happier to be able to say that we now have a Sentry Rust SDK. This means you and your Fungiculture can now report panics, failures, and other types of incidents to Sentry.\n\nNot only is the SDK new and fancy, it is also one of the first ones that follows our new API guidelines for Sentry SDKs, which makes it even newer and fancier than you might normally expect.",
      "url": "https://blog.sentry.io/2018/05/01/sentry-for-rust",
      "date_published": "2018-05-01T00:00:00+00:00",
      "author": {
        "name": "Armin Ronacher",
        "url": "https://blog.sentry.io/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "bcdee764-328b-440f-b1de-d4f4d4c14604",
      "title": "New Tokio release, now with filesystem support",
      "content_text": "It took a bit longer than I had initially hoped (as it always does), but a new Tokio version has been released. This release includes, among other features, a new set of APIs that allow performing filesystem operations from an asynchronous context.",
      "url": "https://tokio.rs/blog/2018-05-tokio-fs/",
      "date_published": "2018-05-02T00:00:00+00:00",
      "author": {
        "name": "Carl Lerche",
        "url": "https://tokio.rs/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "8576f0a6-2866-4ac7-af07-dffd8e4ea019",
      "title": "Rust+GNOME Hackfest #3",
      "content_text": "Last week, I was working on improving the integration of Rust with GNOME libraries at the third Hackfest, which happened this time in Madrid.",
      "url": "http://antoyo.ml/rust-gnome-hackfest-madrid",
      "date_published": "2018-04-24T00:00:00+00:00",
      "author": {
        "name": "Antoni Boucher",
        "url": "http://antoyo.ml/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "ef7fa499-a585-491d-9700-38962a125092",
      "title": "dalek cryptography",
      "content_text": "A suite of cryptographic libraries and protocol implementations, written in the systems programming language Rust, for creating blazingly-fast, production-quality cryptographic applications.",
      "url": "https://dalek.rs/",
      "date_published": "2018-01-24T00:07:02+00:00",
      "author": {
        "name": "isis agora lovecruft",
        "url": "https://dalek.rs/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "318f9d08-d86a-4799-ac08-75014d089475",
      "title": "im - Immutable Data Structures for Rust",
      "content_text": "This library implements several of the more commonly useful immutable data structures for Rust. They rely on structural sharing to keep most operations fast without needing to mutate the underlying data store, leading to more predictable code without necessarily sacrificing performance.",
      "url": "https://docs.rs/im/10.0.0/im/",
      "date_published": "2018-04-06T21:06:00+00:00",
      "author": {
        "name": "Bodil Stokke",
        "url": "http://immutable.rs/"
      },
      "tags": [
        "Computer Science",
        "Crates"
      ]
    },
    {
      "id": "afc97289-36f8-4acb-ab80-28e7770ea126",
      "title": "MesaLink memory-safe and OpenSSL-compatible TLS library",
      "content_text": "MesaLink is a memory-safe and OpenSSL-compatible TLS library. Since 2014, the industry has seen a huge loss due to memory vulnerabilities in TLS stacks, such as the infamous \"Heartbleed\" bug. MesaLink is created with the goal of eliminating memory vulnerabilities in TLS stacks. MesaLink is written in Rust, a programming language that guarantees memory safety. This significantly reduces the attack surfaces, which facilitates auditing and restricting the remaining attack surfaces. MesaLink is cross-platform and provides OpenSSL-compatible APIs. It works seamlessly in desktop, mobile, and IoT devices. With the growth of the ecosystem, MesaLink would also be adopted in the server environment in the future.",
      "url": "https://github.com/mesalock-linux/mesalink",
      "date_published": "2018-04-06T07:00:00+10:00",
      "author": {
        "name": "MesaLock Linux",
        "url": "https://github.com/mesalock-linux"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "0cb16bc7-daff-4747-81e5-d4455d33fc43",
      "title": "HTTP upgrades with hyper",
      "content_text": "The newest release of hyper includes some lower-level connection APIs for both the server and client. Notably, this allows using hyper send and receive HTTP upgrade requests. The most popular of these is Websockets.",
      "url": "http://seanmonstar.com/post/172531530657/http-upgrades-with-hyper",
      "date_published": "2018-04-02T14:34:53-07:00",
      "author": {
        "name": "Sean McArthur",
        "url": "http://seanmonstar.com/"
      },
      "tags": [
        "Web and Network Services",
        "Crates"
      ]
    },
    {
      "id": "effc3ea9-0e61-4b47-ad1b-20782addb1bd",
      "title": "Analysing crates.io data",
      "content_text": "I am learning Clojure for the past one year and I thought making open source contributions is a great way to interact with the community. I made a post previously on using Clojars metadata to analyse JDK 9 and Clojure 1.9 issues that helped me file issues to ensure compatibility. I used the same method here to find the modules that were broken on a nightly version of a rustc due to a recent stabilisation.",
      "url": "https://tirkarthi.github.io/rust/2018/03/30/analyzing-crates-data.html",
      "date_published": "2018-03-30T18:30:29+00:00",
      "author": {
        "name": "Karthikeyan",
        "url": "https://tirkarthi.github.io/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "cca40bed-4eaf-46c6-ae72-1e49ed3ef2ad",
      "title": "New Timer implementation in Tokio",
      "content_text": "To close out a great week, there is a new release of Tokio. This release includes a brand new timer implementation.",
      "url": "https://tokio.rs/blog/2018-03-timers/",
      "date_published": "2018-03-30T00:00:00+00:00",
      "author": {
        "name": "Carl Lerche",
        "url": "https://tokio.rs/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "fd8646cf-2689-4bd8-b065-4708388250d2",
      "title": "Announcing the Tokio runtime",
      "content_text": "I’m happy to announce a new release of Tokio. This release includes the first iteration of the Tokio Runtime.",
      "url": "https://tokio.rs/blog/2018-03-tokio-runtime/",
      "date_published": "2018-03-08T00:00:00+00:00",
      "author": {
        "name": "Carl Lerche",
        "url": "https://tokio.rs/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "067e3ce9-6e69-499c-93f8-a9c4e0f99ce9",
      "title": "Futures 0.2 is nearing release",
      "content_text": "On behalf of the futures-rs team, I’m very happy to announce that the master branch is now at 0.2: we have a release candidate! Barring any surprises, we expect to publish to crates.io in the next week or two.\n\nYou can peruse the 0.2 API via the hosted crate docs, or dive right in to the master branch. Note that Tokio is not currently compatible with Futures 0.2; see below for more detail.",
      "url": "http://aturon.github.io/2018/02/27/futures-0-2-RC/",
      "date_published": "2018-02-27T00:00:00+00:00",
      "author": {
        "name": "Aaron Turon",
        "url": "http://aturon.github.io/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "b079d66f-d08e-4593-80cc-e0060133d12e",
      "title": "Failure 1.0.0 on March 15",
      "content_text": "I’m planning to release a 1.0.0 version of failure on March 15. Once this happens, I don’t plan to release any further breaking changes to the failure crate (though maybe someday in the distant future).\nBreaking changes in 1.0 failure is in a somewhat unique position as being a significant part of the public API of other libraries that depend on it. Whether they use the Error struct or derive Fail for a custom error type, this becomes a part of the API they expose to other users.",
      "url": "https://boats.gitlab.io/blog/post/2018-02-22-failure-1.0/",
      "date_published": "2018-02-22T00:00:00+00:00",
      "author": {
        "name": "withoutboats",
        "url": "https://boats.gitlab.io/blog/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "a2946d73-a2c7-4d2a-899c-080258552b07",
      "title": "Mutation Testing Rust in Earnest",
      "content_text": "It’s been a while since I last suggested Mutation Testing in Rust, almost two years ago. Since then I got sidetracked a lot, and later lost interest. Just one more cool project I couldn’t afford to take on. But as things go, my interest in mutation testing was rekindled, and I decided to give it a shot and do more than blogging about it.",
      "url": "http://llogiq.github.io/2018/02/14/mutagen.html",
      "date_published": "2018-02-14T00:00:00+00:00",
      "author": {
        "name": "Llogiq",
        "url": "http://llogiq.github.io/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "c780f270-e190-4987-aff1-ff20ebe108bf",
      "title": "Improved User Interface 0.2.0 Released!",
      "content_text": "iui, the Improved User Interface crate, has just gotten its 0.2 release. Improved User Interface is a set of safe, idiomatic Rust bindings to platform native GUI libraries (Win32API, Cocoa, and GTK+) via libui and ui-sys. Highlights of this release include: Correct, semantic use of mutability, GTK+ theme application per window, and menu bars and file open/create modal support.",
      "url": "https://www.patreon.com/posts/17016887",
      "date_published": "2018-02-16T04:16:00+00:00",
      "author": {
        "name": "Leo Tindall",
        "url": "https://www.patreon.com/leotindall"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "6a1644f0-2b9e-4c82-9ccd-ef69815f560f",
      "title": "Bincode 1.0.0, fast binary serialization with Serde",
      "content_text": "Bincode is a serializer implementation for Serde. If you stick a #[derive(Deserialize, Serialize)] on your struct, Bincode can efficiently serialize and deserialize those structs to and from bytes. Bincode is unique in that it’s a format that was built specifically for the Rust serialization ecosystem. Tight coupling with Serde allows Bincode to be very fast and serialize to very small payloads.",
      "url": "http://tyoverby.com/posts/bincode_release.html",
      "date_published": "2018-02-15T18:49:27+00:00",
      "author": {
        "name": "Ty Overby",
        "url": "http://tyoverby.com/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "35c70f95-6097-47df-a470-bb92e99b27e5",
      "title": "First release of TQL: the easy-to-use ORM for Rust",
      "content_text": "After a couple of weeks of work, I'm now happy to release the first version of tql, the easy-to-use ORM for Rust. While the focus was to make tql work on the stable version of the compiler, I also added some new features. The most notable new feature is the support for SQLite: now tql supports SQLite as well as PostgreSQL. The support for SQLite is almost as complete as the one for PostgreSQL: the only missing function is not implemented because the backend (SQLite) does not support it.",
      "url": "http://tql-rs.ml/first-release/",
      "date_published": "2018-02-10T00:00:00+00:00",
      "author": {
        "name": "Antoni",
        "url": "http://tql-rs.ml/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "019b1da3-b979-478b-89ed-7824c75df122",
      "title": "Corona: If you want to get async out out of your way",
      "content_text": "For some time now I develop a Rust library for asynchronous programming with coroutines, called Corona (note there’s a version 0.4.0-pre.1, but Crates prefer the „stable“ 0.3.1). I believe it is starting to be useful, so I wrote this description to show what it is good for and how it fits into the big picture of Rust. There’ll be some more changes, though, at least because Tokio just released a new version (and Futures plan to do so soon), so Corona will have to adapt.",
      "url": "https://vorner.github.io/corona-04.html",
      "date_published": "2018-02-11T19:51:00+11:00",
      "author": {
        "name": "Michal 'vorner' Vaner",
        "url": "https://vorner.github.io/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "29eb1ede-d551-4b8d-aeec-c673aafb7e8f",
      "title": "Combine 3 - Partial parsing in Rust",
      "content_text": "Combine is a parser combinator library for the Rust programming language. I first announced version 3 of Combine back in August and back then I definitely expected to have a stable version by now. However other projects (cough gluon cough) got in the way and Combine fell to the wayside. It didn’t help that I didn’t have a killer feature for 3.0 either, user-defined error types make it possible to define parsers usable in #[no_std] crates which is great when you need it but it is still a fairly niche use-case.",
      "url": "https://marwes.github.io/2018/02/08/combine-3.html",
      "date_published": "2018-02-08T00:00:00+00:00",
      "author": {
        "name": "Markus Westerlind",
        "url": "https://marwes.github.io/"
      },
      "tags": [
        "Crates",
        "Computer Science"
      ]
    },
    {
      "id": "b0a2bc9c-effa-4859-b804-cbe839060855",
      "title": "Tokio Reform is Shipped and the Road to 0.2",
      "content_text": "I'm happy to announce that today, the changes proposed in the reform RFC have been released to crates.io as tokio 0.1. The primary changes are: Add a default global event loop, eliminating the need for setting up and managing your own event loop in the vast majority of cases, and decouple all task execution functionality from Tokio.",
      "url": "https://tokio.rs/blog/2018-02-tokio-reform-shipped/",
      "date_published": "2018-02-07T00:00:00+00:00",
      "author": {
        "name": "Carl Lerche",
        "url": "https://tokio.rs/"
      },
      "tags": [
        "Crates"
      ]
    },
    {
      "id": "5e5df82f-aba3-4832-bbe6-e995b2e544ef",
      "title": "Criterion.rs v0.2 - a statistics-driven benchmarking library for Rust",
      "content_text": "Criterion.rs is a statistics-driven benchmarking library for Rust. It provides precise measurements of changes in the performance of benchmarked code, and gives strong statistical confidence that apparent performance changes are real and not simply noise. Clear output, a simple API and reasonable defaults make it easy to use even for developers without a background in statistics. Unlike the benchmarking harness provided by Rust, Criterion.rs can be used with stable versions of the compiler.",
      "url": "https://bheisler.github.io/post/criterion-rs-0-2/",
      "date_published": "2018-02-05T07:00:00-06:00",
      "author": {
        "name": "Brook Heisler",
        "url": "https://bheisler.github.io/"
      },
      "tags": [
        "Performance",
        "Crates"
      ]
    },
    {
      "id": "e1a29851-ab4c-4739-a41f-56e9c783f5e4",
      "title": "Faster Progress Report 2",
      "content_text": "faster began as a yak shave, created to aid base💯 in its quest to become the fastest meme on Github. Writing an explicit AVX2-accelerated version of base💯's encoder and decoder, then realizing I'd have to do the same thing again to see the speedups on my Ivy Bridge desktop, pushed me to make this library. Months later, it has blossomed into its own project, and has eclipsed base💯 in both popularity and promise.",
      "url": "https://adamniederer.com/blog/faster-pr-2.html",
      "date_published": "2018-01-28T22:14:41+00:00",
      "author": {
        "name": "Adam Niederer",
        "url": "https://adamniederer.com/blog/blog.html"
      },
      "tags": [
        "Performance",
        "Crates"
      ]
    }
  ]
}