{
  "version": "https://jsonfeed.org/version/1",
  "title": "Read Rust - Embedded",
  "home_page_url": "https://readrust.net/",
  "feed_url": "https://readrust.net/embedded/feed.json",
  "description": "Embedded posts on Read Rust",
  "author": {
    "name": "Wesley Moore",
    "url": "http://www.wezm.net/"
  },
  "items": [
    {
      "id": "133f5906-759e-4a83-b188-fc18eda31cc0",
      "title": "BetaFPV F3 Drone Flight Controller - Hello Rust",
      "content_text": "One of the most exciting areas of hobbyist embedded programming, in my opinion, is flight controllers for remote controlled aircraft. In the particular case of a multi-rotor drone, the flight controller is responsible for converting the UP command from the transmitter into specific outputs for each of the motors. Maintaining the stability of a drone involves carefully adjusting the output of each motor thousands of times per second based on feedback from on-board sensors.\n\nThere are several great C-based open source drone flight controller firmware projects, but as far as I can see there are none written in Rust. The good news is that most drone flight controllers are based on STM32 MCUs, which Rust has strong support for. Robust flight controller firmware is quite complex, and there are a number of challenges to be solved before even getting the rotors spinning. The first of those challenges is building a Rust project for a particular flight controller board, and flashing the board with the compiled code. A single blinking LED is our goal for today.",
      "url": "https://www.joshmcguigan.com/blog/betafpv-drone-flight-controller-hello-rust/",
      "date_published": "2018-07-11T00:00:00+00:00",
      "author": {
        "name": "Josh Mcguigan",
        "url": "https://www.joshmcguigan.com/"
      },
      "tags": [
        "Embedded"
      ]
    },
    {
      "id": "bef012dd-518b-4a24-9acd-d0d68b3bead3",
      "title": "Embedded development with Yocto and Rust",
      "content_text": "Customized Linux distribution and a safe systems programming language sounds like a very interesting combination for embedded development. That is what makes Yocto and Rust such a good match. So, I wanted to see how Rust projects could be cross-compiled with Yocto-generated toolchain and root filesystem. The steps are described in this post.",
      "url": "https://pagefault.blog/2018/07/04/embedded-development-with-yocto-and-rust/",
      "date_published": "2018-07-04T17:06:32+00:00",
      "author": {
        "name": "Sami Pietikäinen",
        "url": "https://pagefault.blog/"
      },
      "tags": [
        "Embedded"
      ]
    },
    {
      "id": "44759beb-04e0-4524-898b-5ba007a80e10",
      "title": "RSoC: Porting Redox to AArch64–0x01",
      "content_text": "All excited. A first calendar entry to describe my attempt on arm64 support in Redox OS. Specifically, looking into the Raspberry Pi2/3b/3+(all of them having a Cortex-A53 ARMv8 64-bit microprocessor, although for all my experiments I am going to use the Raspberry Pi 3b.",
      "url": "https://medium.com/@wizofe/rsoc-porting-redox-to-aarch64-0x01-3dee87644c97",
      "date_published": "2018-06-26T17:26:31.958+00:00",
      "author": {
        "name": "ioannis valasakis",
        "url": "https://medium.com/@wizofe"
      },
      "tags": [
        "Operating Systems",
        "Embedded"
      ]
    },
    {
      "id": "e063329a-32df-4f01-92b0-38d5999f9a6e",
      "title": "Rust Thermometer – Part 2",
      "content_text": "Thermometer adventure continuous with some progress over the last weekend. Little bit of refactoring, rewiring, X.org, matchbox, Piston, ... and some ugly (but working!) UI :)",
      "url": "https://www.robertvojta.com/rust-thermometer-part-2/",
      "date_published": "2018-06-25T13:51:53+00:00",
      "author": {
        "name": "Robert Vojta",
        "url": "https://www.robertvojta.com/"
      },
      "tags": [
        "Embedded"
      ]
    },
    {
      "id": "d93b968d-f8fb-4ba9-b7eb-1879ec63807d",
      "title": "Rust Thermometer – Part 1",
      "content_text": "I’ve decided to build a thermometer from scratch. I know, I can buy it, but it’s not fun. I found it as a perfect occasion to please my wife (she wants it) and to try new things. What new things? Mainly resin.io and resinOS.",
      "url": "https://www.robertvojta.com/rust-thermometer-part-1/",
      "date_published": "2018-06-20T09:23:29+00:00",
      "author": {
        "name": "Robert Vojta",
        "url": "https://www.robertvojta.com/"
      },
      "tags": [
        "Embedded"
      ]
    },
    {
      "id": "fb7909fb-5c7d-4360-a9fe-4620e04262d8",
      "title": "Running Rust and FreeRTOS on the PADI IoT Stamp",
      "content_text": "In this article we’ll explore a better way to build and test programs for microcontroller platforms. Specifically we’ll look at Rust, FreeRTOS and Visual Studio Code. And how I made them run on the PADI IoT Stamp.",
      "url": "https://medium.com/@ly.lee/running-rust-and-freertos-on-the-padi-iot-stamp-fb36c5ef4844",
      "date_published": "2018-06-18T05:45:28.579+00:00",
      "author": {
        "name": "Lup Yuen Lee",
        "url": "https://medium.com/@ly.lee"
      },
      "tags": [
        "Embedded"
      ]
    },
    {
      "id": "df7df3a9-1519-4453-963e-fb69d766798d",
      "title": "Bobbin SDK: Richer Hardware Abstractions for Embedded Systems Programming",
      "content_text": "Bobbin SDK is a suite of tools and code that has been used in embedded development projects running on a variety of ARM Cortex-M MCUs over the last year and a half. It exists to bridge the gap between the existing Rust ecosystem centered around svd2rust and rich but proprietary vendor SDKs.",
      "url": "http://www.bobbin.io/blog/post/bobbin_sdk_richer_hardware/",
      "date_published": "2018-05-25T00:00:00+00:00",
      "author": {
        "name": "Jonathan Soo",
        "url": "http://www.bobbin.io/blog/"
      },
      "tags": [
        "Embedded"
      ]
    },
    {
      "id": "4c0ea01d-c011-49aa-b6a6-10178e03c627",
      "title": "Neural networks on a micro controller - Preparation and math",
      "content_text": "I've been playing around with the idea of running a neural network on a micro controller. This project is not designed to be the most efficient neural network, but rather one that runs on a micro controller with very limited resources.",
      "url": "http://trangar.blogspot.com.au/2018/05/neural-networks-on-micro-controller.html?m=1",
      "date_published": "2018-05-23T10:04:00-07:00",
      "author": {
        "name": "Trangar",
        "url": "http://trangar.blogspot.com.au/"
      },
      "tags": [
        "Embedded"
      ]
    },
    {
      "id": "3d49dcaa-90bd-4749-82a8-83a272d0864b",
      "title": "Memory-Mapped Registers in Tock",
      "content_text": "Microcontrollers typically use memory-mapped I/O interfaces to control hardware peripherals. Driver code uses these memory-mapped registers and fields to interact with the peripheral while providing a higher-level interface to the rest of the system. This post describes how Tock deals with register memory maps and a new tool that can automatically generate memory maps for many ARM microcontrollers.",
      "url": "https://www.tockos.org/blog/2018/mmio-registers/",
      "date_published": "2018-05-07T00:00:00+00:00",
      "author": {
        "name": "Branden Ghena",
        "url": "https://www.tockos.org/blog/"
      },
      "tags": [
        "Embedded"
      ]
    },
    {
      "id": "97c03488-1331-4858-baf0-26e1d0fca6f0",
      "title": "Embedded Rust: Peripherals (and low-level stuffs) - take 1",
      "content_text": "First of all, low level stuffs such as peripheral drivers should be hidden from the application developer. They should not be able to access directly the registers and mess with the peripheral states/control. The wrong flag in the wrong register can lead to dramatic failures and even damages to the products.",
      "url": "https://ithinuel.me/embedded-rust-peripherals-take-1/",
      "date_published": "2018-04-28T00:00:00+00:00",
      "author": {
        "name": "Wilfried Chauveau",
        "url": "https://ithinuel.me/"
      },
      "tags": [
        "Embedded"
      ]
    },
    {
      "id": "47521515-a430-41a1-bcdc-bb68b3f9d646",
      "title": "Cross compiling rust with docker",
      "content_text": "I am giving embedded systems another go with a side project of mine. The device has a single purpose. It captures network packets, and forwards them to a server. It is easily achieved with LIBpcap, but the device makes it interesting.\n\nThe GL-AR150 sells as a mini smart router. The limited storage makes it hard to install language interpreters, or virtual machines. This pushed me to look into standalone executables, and how to compile them for other devices.",
      "url": "https://medium.com/@pvinchon/cross-compiling-rust-with-docker-17d846adae4d",
      "date_published": "2018-04-30T23:01:01.249+00:00",
      "author": {
        "name": "Philippe",
        "url": "https://medium.com/@pvinchon"
      },
      "tags": [
        "Embedded"
      ]
    },
    {
      "id": "73443ff7-2113-490d-9249-430c95c1534a",
      "title": "Flipping some bits high on STM32VLDISCOVERY board",
      "content_text": "Here I will document the steps to get started with STM32VLDISCOVERY board. We will take my favourite “from scratch” approach. That way, we build the final thing step by step while building our understanding of how it all fits together.",
      "url": "http://nercury.github.io/rust/embedded/experiments/2018/04/29/rust-embedded-01-discovery-vl-flipping-bits.html",
      "date_published": "2018-04-29T00:00:00+00:00",
      "author": {
        "name": "Nerijus Arlauskas",
        "url": "http://nercury.github.io/"
      },
      "tags": [
        "Embedded"
      ]
    },
    {
      "id": "b4ecd378-f152-4049-b281-8b519cdb870d",
      "title": "c3r3s - Serial 64-bit bootloader for the Raspberry Pi 3",
      "content_text": "c3r3s is a tiny (1KB binary) serial bootloader for loading \"bare metal\" 64-bit kernels on the Raspberry Pi 3. You can iterate on your own kernel code without constantly moving the SD card back and forth.",
      "url": "https://github.com/robey/c3r3s",
      "date_published": "2018-05-01T07:22:00+10:00",
      "author": {
        "name": "Robey Pointer",
        "url": "https://github.com/robey"
      },
      "tags": [
        "Embedded"
      ]
    },
    {
      "id": "9cb9976f-4023-496c-9bdf-b5eff31fe5bb",
      "title": "Flipper - A new embedded development paradigm",
      "content_text": "Flipper is a new kind of development board that redefines the embedded software development cycle by offloading development/debugging into higher level languages + tools. One of the languages that we're putting the most focus into adding support for is Rust. We would love to see more embedded done with Rust and Flipper provides a great springboard for existing Rust developers to familiarize themselves with embedded hardware using the tools they already know how to use.",
      "url": "https://www.reddit.com/r/rust/comments/8d8vqn/flipper_a_new_embedded_development_paradigm/",
      "date_published": "2018-04-18T20:28:34+00:00",
      "author": {
        "name": "George Morgan",
        "url": "https://www.reddit.com/user/george-morgan"
      },
      "tags": [
        "Embedded"
      ]
    },
    {
      "id": "5230134e-6bfc-4a88-9cee-7bec1f15e099",
      "title": "Embedded Rust: Why?",
      "content_text": "I will try to publish here a series of articles about my approach to embedded development and how I plan to achieve that in Rust.",
      "url": "http://ithinuel.me/embedded-rust-why/",
      "date_published": "2018-03-30T08:26:00+00:00",
      "author": {
        "name": "Wilfried Chauveau",
        "url": "http://ithinuel.me/"
      },
      "tags": [
        "Embedded"
      ]
    },
    {
      "id": "277652ec-bbeb-454c-85da-766438600d47",
      "title": "Cargo, Xargo, and Rustup",
      "content_text": "Another topic of discussion at the Berlin Rust All Hands was the long-term story around Cargo, Xargo, and Rustup. The latter two tools are both involved in managing your Rust toolchain, with Xargo allowing you to build custom stds and Rustup managing pre-built artifacts for mainstream targets. Xargo is most commonly used for cross-compiling to less common platforms, but can also be used to customize the standard library on mainstream platforms.",
      "url": "http://aturon.github.io/2018/04/06/rustup-xargo/",
      "date_published": "2018-04-06T00:00:00+00:00",
      "author": {
        "name": "Aaron Turon",
        "url": "http://aturon.github.io/"
      },
      "tags": [
        "Embedded",
        "Language"
      ]
    },
    {
      "id": "6419c6a3-a47d-4ce5-93ef-11f17be5eecd",
      "title": "Building Tiny Rust Binaries for Embedded Linux",
      "content_text": "At the recent 2018 Rust All Hands, I met up with Katharina @spacekookie, who works on an open source project that creates software for Embedded Linux Devices. She had talked with the other engineers on the project about including some Rust components, however with their limited flash storage space (8MB for the whole firmware, including operating system and all other software), she was worried that the Rust binaries wouldn’t fit. The current webserver component for their project was measured in the 100’s of KB, while the Rust binary she produced was already multiple MBs, even with a --release build!",
      "url": "https://jamesmunns.com/update/2018/04/01/tinyrocket.html",
      "date_published": "2018-04-01T09:30:00+00:00",
      "author": {
        "name": "James Munns",
        "url": "https://jamesmunns.com/"
      },
      "tags": [
        "Embedded"
      ]
    },
    {
      "id": "2f7b942d-1a59-40bc-bc92-a1e2e85803ee",
      "title": "Weekly Driver: Using the SGP30 Gas Sensor from Rust",
      "content_text": "After the MCP3425 ADC driver I published last month as part of the the weekly driver initiative, I wrote a second Rust embedded-hal driver, this time for the SGP30. The Sensirion SGP30 is a tiny low-power gas sensor (produced in Switzerland) for indoor air quality applications with good long-term stability. It has an I²C interface with TVOC (Total Volatile Organic Compounds) and CO₂ equivalent signals.",
      "url": "https://blog.dbrgn.ch/2018/4/1/rust-sgp30-driver/",
      "date_published": "2018-04-01T00:00:00+02:00",
      "author": {
        "name": "Danilo Bargen",
        "url": "https://blog.dbrgn.ch/"
      },
      "tags": [
        "Embedded"
      ]
    },
    {
      "id": "348de5bf-0fa7-48d1-b112-20cd13cfd3f3",
      "title": "Writing A Driver in Rust Using Embedded-Hal Traits for the RN4870 BLE Module",
      "content_text": "This post will document my process and thoughts on writing a driver for a bluetooth module using Rust and the embedded-hal crate. The specific bluetooth device I will be using is the RN4870 BLE castellated module. It features a simple UART interface and handles most of the complexities of BLE itself, making it very easy to get a simple BLE connection up and running.",
      "url": "http://byronwasti.com/post/writing_a_ble_driver_in_rust/",
      "date_published": "2018-03-25T20:15:57+00:00",
      "author": {
        "name": "Byron Wasti",
        "url": "http://byronwasti.com/"
      },
      "tags": [
        "Embedded"
      ]
    },
    {
      "id": "c57dc18b-48b9-453e-b44a-46da4dce6d8e",
      "title": "Safe Peripheral Management",
      "content_text": "This post describes the recently merged PeripheralManager, which helps software ensure it always accesses hardware correctly, and cleans up after it’s done.",
      "url": "https://www.tockos.org/blog/2018/peripheral-management/",
      "date_published": "2018-03-21T00:00:00+00:00",
      "author": {
        "name": "Pat Pannuto",
        "url": "https://www.tockos.org/blog/"
      },
      "tags": [
        "Embedded"
      ]
    },
    {
      "id": "f860801f-7b99-4fe3-88cc-a6c00ca7d97a",
      "title": "HTS221 Humidity and Temperature Sensor",
      "content_text": "ST Micro’s HTS221 is a “capacitive digital sensor for relative humidity and temperature” that can be used over either I²C or SPI. It is factory-calibrated, so there is no end-user calibration to incorporate into your application. The driver provides a simple, high-level API to configure the chip once on startup, then read the temperature and humidity.",
      "url": "https://medium.com/@pdanielgallagher/hts221-humidity-and-temperature-sensor-88056ea9e5fa",
      "date_published": "2018-03-20T04:16:48.453+00:00",
      "author": {
        "name": "Daniel Gallagher",
        "url": "https://medium.com/@pdanielgallagher"
      },
      "tags": [
        "Embedded"
      ]
    },
    {
      "id": "f1b7c59f-fff8-4000-ac97-2be742b86760",
      "title": "Achieving memory safety without compromise",
      "content_text": "A new generation of safe programming languages is leaving garbage collectors and runtimes behind, delivering memory safety and control.",
      "url": "https://www.embedded.com/electronics-blogs/say-what-/4460422/Achieving-memory-safety-without-compromise",
      "date_published": "2018-03-13T16:32:00+00:00",
      "author": {
        "name": "Adam Foltzer",
        "url": "https://www.embedded.com/"
      },
      "tags": [
        "Embedded"
      ]
    },
    {
      "id": "a4faa45e-f24e-4ce9-822c-5c4623919e17",
      "title": "Tock 1.0 Kernel Released",
      "content_text": "We silently tag our first rolling release of the Tock kernel in February. If you’re building applications with Tock or porting to a new board, and want to be immune from updating your code everyday, you can work from that tag. We’ll also upload binary kernel images for the supported board sometime soon.",
      "url": "https://www.tockos.org/blog/2018/talking-tock-35/",
      "date_published": "2018-03-06T00:00:00+00:00",
      "author": {
        "name": "Amit Levy",
        "url": "https://www.tockos.org/blog/"
      },
      "tags": [
        "Embedded"
      ]
    },
    {
      "id": "249e8bc3-a836-4b71-89b6-8d7c4d1b0977",
      "title": "Weekly Driver: Using the MCP3425 ADC from Rust",
      "content_text": "Announing the MCP3425 Rust driver.",
      "url": "https://blog.dbrgn.ch/2018/3/13/rust-mcp3425-driver/",
      "date_published": "2018-03-13T00:00:00+01:00",
      "author": {
        "name": "Danilo Bargen",
        "url": "https://blog.dbrgn.ch/"
      },
      "tags": [
        "Embedded"
      ]
    },
    {
      "id": "a48d8156-7f0f-4731-a17b-e36678b86f5f",
      "title": "Weekly driver 4: ENC28J60, Ethernet for your microcontroller",
      "content_text": "This week I’m releasing a driver for the ENC28J60, an Ethernet controller with SPI interface. This IC lets you connect your microcontroller, if it has a SPI interface, to a Local Area Network or, with more work, to the internet. Apart from the IC you need a RJ45 connector and a few other components so I’m using this module which has the ENC28J60 and all the required components on a single board.",
      "url": "http://blog.japaric.io/wd-4-enc28j60/",
      "date_published": "2018-03-13T04:32:18+01:00",
      "author": {
        "name": "Jorge Aparicio",
        "url": "http://blog.japaric.io/"
      },
      "tags": [
        "Embedded"
      ]
    },
    {
      "id": "3907940b-eb06-4f2a-a3ff-6df4ae5ac9ca",
      "title": "Rust on the STMicro Nucleo",
      "content_text": "For the embedded portion of my project, I had two decisions to make: which processors and chips to use, and which language to write the firmware in. Since this personal project is about learning new skills, I decided to use Rust instead of C. I opted to use STMicro’s Nucleo boards, since their ecosystem has shields that do all of the things I would like (WiFi, BLE, and environmental sensing), and there was also a great Rust tutorial for a similar board. However, since I’ve never really done any embedded development, I decided to start with the old standby: copying code off the internet!",
      "url": "https://medium.com/@pdanielgallagher/rust-on-the-stmicro-nucleo-7a66b97be549",
      "date_published": "2018-03-01T05:50:42.487+00:00",
      "author": {
        "name": "Daniel Gallagher",
        "url": "https://medium.com/@pdanielgallagher"
      },
      "tags": [
        "Embedded"
      ]
    },
    {
      "id": "75898724-f900-46ae-877b-36d87b440ac1",
      "title": "Let's write an embedded-hal-driver",
      "content_text": "Mid January japaric started \"The weekly driver initiative\" with the goal to kick-start releases of platform agnostic embedded-hal based driver crates. In this post we'll build an embedded-hal-driver for the AT24C32-EEPROM chip.",
      "url": "http://zuendmasse.de/blog/2018/02/23/lets-write-an-embedded-hal-driver/",
      "date_published": "2018-02-25T00:00:00+00:00",
      "author": {
        "name": "Sebastian Wötzel",
        "url": "http://zuendmasse.de/blog/"
      },
      "tags": [
        "Embedded"
      ]
    },
    {
      "id": "0cb6b35f-0d4f-4e71-bcae-66d4cd115d41",
      "title": "Discovery: Discover the world of microcontrollers through Rust! - 2018 edition",
      "content_text": "This is an mdbook I wrote more than a year ago for a workshop and it's an introductory course to embedded systems that uses Rust as the teaching language. I just updated the starter code to use the latest versions of everything so it's now easier to jump from the book to use the latest developments in the Cortex-M ecosystem; there's no new content, though -- the exercises remain unchanged in terms of goals; just the code has changed.",
      "url": "https://www.reddit.com/r/rust/comments/80doqg/discovery_discover_the_world_of_microcontrollers/",
      "date_published": "2018-02-26T15:12:44+00:00",
      "author": {
        "name": "Jorge Aparicio",
        "url": "http://blog.japaric.io/"
      },
      "tags": [
        "Embedded"
      ]
    },
    {
      "id": "504ed65c-1efe-4cbd-b655-b17e89110936",
      "title": "Transcript: Should you Rust in embedded yet?",
      "content_text": "This is a transcript of a talk I gave at the Vilnius Rust meetup.\n\nIt would not be an exaggeration to say that embedded is omnipresent. You can find embedded firmware everywhere from fridges, microwaves and personal computers to safety-critical applications in automotive, medical fields, etc.\n\nMost of this software is still written in C or C++, and neither of these, given their non-ideal track record in relation to security critical software, are the most confidence inspiring choice for safety-critical systems.\n\nIn my experience, bugs occurring in embedded firmware tend to be fairly similar to those commonly found in the user-space software.",
      "url": "https://kazlauskas.me/entries/rust-embedded-ready.html",
      "date_published": "2018-02-24T20:09:27+00:00",
      "author": {
        "name": "Simonas Kazlauskas",
        "url": "https://kazlauskas.me/index.html"
      },
      "tags": [
        "Embedded"
      ]
    },
    {
      "id": "34ee0b77-cabd-47a8-bb6c-00e8a34046c7",
      "title": "An introduction to writing platform agnostic drivers in Rust using the MCP3008",
      "content_text": "Here is how a device like an accelerometer works: you send the device commands over a serial interface (SPI, I2C), say something like: “get me the X-axis reading”; the device responds by sending back some data.\n\nThe way the SPI/I2C/GPIO (and other) interfaces are programmed is very much dependent on the specific microcontroller family. But the actions you need to perform to interface with a device like a temperature sensor / accelerometer etc depend only on the device and are independent of the controller being used. What if you can write a generic accelerometer driver and use it on any microcontroller platform - right from low-end ARM Cortex-M, AVR, MSP430 etc to complex Embedded Linux platforms like the Raspberry Pi? What if you can distribute these drivers on crates.io so that you only have to include one line in your Cargo.toml to use it in your code?",
      "url": "http://pramode.in/2018/02/24/an-introduction-to-writing-embedded-hal-based-drivers-in-rust/",
      "date_published": "2018-02-24T00:00:00-05:00",
      "author": {
        "name": "Pramode C.E",
        "url": "http://pramode.in/"
      },
      "tags": [
        "Embedded"
      ]
    },
    {
      "id": "b2eb24c3-d7ee-438c-b041-0446dd551abe",
      "title": "I decided to make an 1980's Home Computer in Rust - Part 1",
      "content_text": "My first attempt at Rust programming was the stellaris-launchpad crate. This has a few demos that either blink the LED or roll it through an RGB rainbow using the PWM timers. Recently I've started a new version of the lm4f120 crate called tm4c123x-hal. The name change reflects TI's new name for basically the exact same part, while the -hal indicates that it's based upon the output of svd2rust and @japaric's new Embedded Hal crate. At the same time, I was watching videos on Youtube about a new wave of 1980's style 'retro' computing boards - text output, BASIC interpreter, etc. An idea started to form that I could put all three of these things together.",
      "url": "http://railwayelectronics.blogspot.com.au/2018/02/i-decided-to-make-1980s-home-computer.html?m=1",
      "date_published": "2018-02-20T22:16:00+00:00",
      "author": {
        "name": "theJPster",
        "url": "http://railwayelectronics.blogspot.com.au/"
      },
      "tags": [
        "Embedded"
      ]
    },
    {
      "id": "f2bf66c3-52bf-4a3c-b508-96bbd3385e8d",
      "title": "Programming an ARM microcontroller in Rust at four different levels of abstraction",
      "content_text": "Covering: Why Rust on Microcontrollers, Level 1: Direct register access in an unsafe block, Level 2: No unsafe blocks, use the API provided by svd2rust, A problem, Level 3: The embedded HAL to the rescue, Level 4: Use a board support crate.",
      "url": "http://pramode.in/2018/02/20/programming-a-microcontroller-in-rust-at-four-levels-of-abstraction/",
      "date_published": "2018-02-20T00:00:00-05:00",
      "author": {
        "name": "Pramode C.E",
        "url": "http://pramode.in/"
      },
      "tags": [
        "Embedded"
      ]
    },
    {
      "id": "25d98aac-94a1-4cda-bbdb-7b22b76ed032",
      "title": "Weekly driver 1 & 2: L3GD20, LSM303DLHC and Madgwick - Embedded in Rust",
      "content_text": "Oh, time flies. It’s already week 8 and we have zero weekly driver posts out there – don’t worry though because there’s plenty of drivers and embedded-hal implementations in the works. To play catch up in this post I’ll cover two embedded-hal drivers: the l3gd20 and the lsm303dlhc. The L3GD20 is an IC that contains a gyroscope and exposes I2C and SPI interfaces; the LSM303DLHC is an IC that contains an accelerometer and a magnetometer, and exposes an I2C interface. You can find these two ICs on the STM32F3DISCOVERY board.",
      "url": "http://blog.japaric.io/wd-1-2-l3gd20-lsm303dlhc-madgwick/",
      "date_published": "2018-02-19T15:57:59+01:00",
      "author": {
        "name": "Jorge Aparicio",
        "url": "http://blog.japaric.io/"
      },
      "tags": [
        "Embedded"
      ]
    },
    {
      "id": "45c32609-24ef-4288-b361-57ca8b5a34cd",
      "title": "Zero cost stack overflow protection for ARM Cortex-M devices",
      "content_text": "One of the core features of Rust is memory safety. Whenever possible the compiler enforces memory safety at compile. One example of this is the borrow checker which prevents data races, iterator invalidation, pointer invalidation and other issues at compile time. Other memory problems like buffer overflows can’t be prevented at compile time. In those cases the compiler inserts runtime checks, bounds checks in this case, to enforce memory safety at runtime. What about stack overflows? For quite a long time Rust didn’t have stack overflow checking but that wasn’t much of a problem on tier 1 platforms since these platforms have an OS and a MMU (Memory Management Unit) that prevents stack overflows from wreaking havoc.",
      "url": "http://blog.japaric.io/stack-overflow-protection/",
      "date_published": "2018-02-17T18:16:39+01:00",
      "author": {
        "name": "Jorge Aparicio",
        "url": "http://blog.japaric.io/"
      },
      "tags": [
        "Embedded"
      ]
    },
    {
      "id": "b7290658-fff8-4ee5-b8e5-eceefdc6beb6",
      "title": "Memory safe DMA transfers - Embedded in Rust",
      "content_text": "A blog about Rust and embedded stuff",
      "url": "http://blog.japaric.io/safe-dma/",
      "date_published": "2018-02-09T11:47:30+01:00",
      "author": {
        "name": "Jorge Aparicio",
        "url": "http://blog.japaric.io/"
      },
      "tags": [
        "Embedded"
      ]
    },
    {
      "id": "d4191312-2442-4eb8-b313-67ba224829b6",
      "title": "Experimenting with the New I/O Framework (in Rust) for embedded systems",
      "content_text": "Notes on Code, by Pramode C.E",
      "url": "http://pramode.in/2018/01/31/ti-launchpad-with-rust-new-io/",
      "date_published": "2018-01-31T00:00:00-05:00",
      "author": {
        "name": "Pramode C.E",
        "url": "http://pramode.in/"
      },
      "tags": [
        "Embedded"
      ]
    },
    {
      "id": "d2189bca-0b13-451d-b70c-70ec43f7a207",
      "title": "Rust 2018: Improving Safety and Ergonomics for Low-Level Programming - Bobbin Blog",
      "content_text": "There’s been a lot written about what can be done to make Rust’s tooling, libraries and infrastructure better for embedded programming, but I’d like to cover a slightly different topic: what can be done to make Rust the language itself safer and easier to use for low-level programming?",
      "url": "http://www.bobbin.io/blog/post/rust_2018_low_level/",
      "date_published": "2018-01-26T14:00:00-04:00",
      "author": {
        "name": "Jonathan Soo",
        "url": "http://www.bobbin.io/blog/"
      },
      "tags": [
        "Rust 2018",
        "Embedded"
      ]
    },
    {
      "id": "ae85973e-7540-4027-b53a-ee41a249d124",
      "title": "Rust 2018: Core, Embedded+SIMD, Intermesiate documenation, Async • r/rust",
      "content_text": "Hi there! I'm Nico, and I've been lurking around these parts for about a year now. I thought I'd give my 2 cents on Rust's 2018 plans. Note: this...",
      "url": "https://www.reddit.com/r/rust/comments/7syxw4/rust_2018_core_embeddedsimd_intermesiate/",
      "date_published": "2018-01-25T20:12:01+00:00",
      "author": {
        "name": "Nico",
        "url": "https://www.reddit.com/user/nicoburns"
      },
      "tags": [
        "Rust 2018",
        "Embedded"
      ]
    },
    {
      "id": "a59a299c-28d1-4c41-9563-47faea69a0b7",
      "title": "Embedded Rust in 2018 - Embedded in Rust",
      "content_text": "A blog about Rust and embedded stuff",
      "url": "http://blog.japaric.io/embedded-rust-in-2018/",
      "date_published": "2018-01-21T22:10:38+01:00",
      "author": {
        "name": "Jorge Aparicio",
        "url": "http://blog.japaric.io/"
      },
      "tags": [
        "Rust 2018",
        "Embedded"
      ]
    },
    {
      "id": "f3f500d5-d108-4f83-808e-e15ad520cce7",
      "title": "Embedded Rust in 2018",
      "content_text": "I recently picked up an embedded project that I hadn't touched for a few months, so I could add some new features. I was disappointed to not...",
      "url": "http://railwayelectronics.blogspot.com.au/2018/01/i-recently-picked-up-embedded-project.html",
      "date_published": "2018-01-14T00:00:00+00:00",
      "author": {
        "name": "theJPster",
        "url": "http://railwayelectronics.blogspot.com.au/"
      },
      "tags": [
        "Rust 2018",
        "Embedded"
      ]
    },
    {
      "id": "c506e8b8-69f1-4f39-803a-6e3a34c06145",
      "title": "Pollen Robotics call for #Rust2018: toward stability on embedded systems",
      "content_text": "Robotics developers face two main problems:",
      "url": "https://medium.com/pollenrobotics/rust-for-robotics-and-embedded-systems-in-2018-96e9be8464",
      "date_published": "2018-01-12T13:32:49.383+00:00",
      "author": {
        "name": "Pierre Rouanet",
        "url": "https://medium.com/@pierre.rouanet"
      },
      "tags": [
        "Rust 2018",
        "Embedded"
      ]
    }
  ]
}