<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/"><channel><title>Read Rust - Embedded</title><link>https://readrust.net/</link><description>Embedded posts on Read Rust</description><item><title>Hello world in morse code</title><link>https://idursun.com/posts/hello_world_in_morse_code/</link><description><![CDATA[I do love working with Rust. I deliberately create excuses to work on mini projects that ultimately involves coding in Rust. Recently, I have bought a blue pill which is a little board that costs about 1$. Although, I have zero experience in embedded programming I always wanted to give it a try with Rust which, in my case, boils down to blinking a LED on the board. I know there are excellent materials about embedded programming with Rust out there, but things do change very rapidly.]]></description><guid isPermaLink="false">e2e96d6e-78ce-43fe-a9b7-95fce36b169c</guid><pubDate>Thu, 25 Apr 2019 19:29:42 +0100</pubDate><dc:creator>Ibrahim Dursun</dc:creator></item><item><title>Using DMA to transfer data with Embedded Rust</title><link>https://flowdsp.io/blog/stm32f3-02-dac-dma/</link><description><![CDATA[In this article you will learn how to use the Direct Memory Access (DMA) controller to transfer data from memory to the built-in Digital to Analog Converter (DAC) on the STM32F3DISCOVERY board.]]></description><guid isPermaLink="false">fc88b6c6-cf80-4546-b03a-94bcdebf6232</guid><pubDate>Tue, 23 Apr 2019 00:00:00 +0000</pubDate><dc:creator>Antoine van Gelder</dc:creator></item><item><title>What I learned from my failed attempt of writing baremetal android in Rust</title><link>https://onatm.dev/2019/04/22/what-i-learned-from-my-failed-attempt-of-writing-baremetal-android-in-rust/</link><description><![CDATA[Every year I define a super ambitious goal for my learning process to keep myself motivated on the way. This year I defined my goal as writing a bootable kernel image for my old HTC One X android smartphone. I knew it was going to be hard but I never thought I’d fail in the end. It was clearly the Dunning–Kruger effect that made me think that I can achieve what I want to do with my limited knowledge/experience on the subject.]]></description><guid isPermaLink="false">3e1e598a-b186-40d1-b03c-bae1444a6ee7</guid><pubDate>Mon, 22 Apr 2019 12:35:34 +0000</pubDate><dc:creator>Onat Mercan</dc:creator></item><item><title>The Embedded Working Group Newsletter - 17</title><link>https://rust-embedded.github.io/blog/newsletter-17/</link><description><![CDATA[This week's highlights: The Embedded Rust Showcase, Oxidize speakers announced, docs on interrupts, and Life before Main!]]></description><guid isPermaLink="false">d226973e-f9e9-46e7-8395-d63272cd6f61</guid><pubDate>Fri, 22 Mar 2019 00:00:00 +0000</pubDate><dc:creator>The Embedded Working Group</dc:creator></item><item><title>Programming GPIO Interrupts in Rust</title><link>https://flowdsp.io/blog/stm32f3-01-interrupts/</link><description><![CDATA[Using Embedded Rust to configure and service a hardware interrupt on the STM32F3 Discovery board.]]></description><guid isPermaLink="false">4ba1b199-045c-4ba4-80e2-6741bc648f06</guid><pubDate>Sun, 17 Mar 2019 00:00:00 +0000</pubDate><dc:creator>Antoine van Gelder</dc:creator></item><item><title>Implementing a static stack usage analysis tool</title><link>https://blog.japaric.io/stack-analysis/</link><description><![CDATA[This blog covers the implementation details of cargo-call-stack v0.1.2. So, why would you ever want to analyze the stack usage of your program at compile time? The obvious answer is when you want to know if your application can stack overflow at runtime without actually running your program. This is important for embedded applications where stack overflows can corrupt memory, and it’s actually a hard requirement for certifying the functional safety of embedded applications.]]></description><guid isPermaLink="false">349a5a06-2dd8-475d-9911-4d777ca6250f</guid><pubDate>Wed, 13 Mar 2019 00:00:00 +0000</pubDate><dc:creator>Jorge Aparicio</dc:creator></item><item><title>A Coding Retreat and Getting Embedded Rust Running on a SensorTag</title><link>https://www.wezm.net/technical/2019/03/sensortag-embedded-rust-coding-retreat/</link><description><![CDATA[This past long weekend some friends on I went on a coding retreat inspired by John Carmack doing similar in 2018. During the weekend I worked on adding support for the Texas Instruments SensorTag to the embedded Rust ecosystem. This post is a summary of the weekend and what I was able to achieve code wise.]]></description><guid isPermaLink="false">0febede4-eee9-43df-bd74-dd2a44dcb4fb</guid><pubDate>Tue, 12 Mar 2019 08:45:00 +0000</pubDate><dc:creator>Wesley Moore</dc:creator></item><item><title>Hardware Debugging a Raspberry Pi using JTAG</title><link>https://github.com/rust-embedded/rust-raspi3-OS-tutorials/tree/master/0B_hw_debug_JTAG</link><description><![CDATA[Functionally, this tutorial is the same as the previous one, where we reset or power down the RPi. Around that, we add infrastructure for JTAG debugging.]]></description><guid isPermaLink="false">ae65ad4b-c966-483f-a57a-965ab7ba7d28</guid><pubDate>Sun, 10 Mar 2019 13:59:01 +0000</pubDate><dc:creator>Andre Richter</dc:creator></item><item><title>The Embedded Working Group Newsletter - 16</title><link>https://rust-embedded.github.io/blog/newsletter-16/</link><description><![CDATA[This is the sixteenth newsletter of the Embedded WG where we highlight new progress, celebrate cool projects, thank the community, and advertise projects that need help!]]></description><guid isPermaLink="false">c2a5636f-d083-4e22-94d7-5b26df1b173d</guid><pubDate>Wed,  6 Mar 2019 00:00:00 +0000</pubDate><dc:creator>The Embedded Working Group</dc:creator></item><item><title>Embedded Graphics 0.4.7 and TinyBMP 0.1.0</title><link>https://wapl.es/rust/2019/03/04/embedded-graphics-0.4.7-bmp-support.html</link><description><![CDATA[Embedded graphics 0.4.7 has been released, along with a new sister crate, tinybmp! TinyBMP aims to parse BMP-format image data using no dynamic allocations. It targets embedded environments but can be used in any place a small BMP parser is required. Thanks to TinyBMP, Embedded Graphics now supports loading this simple image format. The header photo was made using Embedded Graphics and the SSD1331 driver in pure Rust. In this post, I’ll talk through how the BMP file is parsed in no_std environments with nom and how to get BMP images working with embedded_graphics.]]></description><guid isPermaLink="false">25b303a5-4e11-416b-a5a5-db8f7d35db8c</guid><pubDate>Tue,  5 Mar 2019 08:51:11 +0000</pubDate><dc:creator>James Waples</dc:creator></item><item><title>Releasing rust_gpiozero v0.2.0</title><link>https://rahul-thakoor.github.io/releasing-rust_gpiozero-v0.2.0/</link><description><![CDATA[A new version packed with new features and improvements: Blink leds without blocking main thread and adjust brightness. ⚙️ Work with servo motors and adjust motor speed. 〜 Work with software PWM.]]></description><guid isPermaLink="false">e0caaf97-6980-4421-afbe-3fca31872c73</guid><pubDate>Wed, 27 Feb 2019 17:43:48 +0400</pubDate><dc:creator>Rahul Thakoor</dc:creator></item><item><title>Firmware examples that make use of the jnet embedded TCP/IP crate</title><link>https://github.com/japaric/jnet/tree/master/firmware</link><description><![CDATA[[Experiment] JNeT: japaric's network thingies.]]></description><guid isPermaLink="false">34d09d33-17ae-4799-9026-f41fc6d95fe4</guid><pubDate>Tue, 26 Feb 2019 04:35:00 +0000</pubDate><dc:creator>Jorge Aparicio</dc:creator></item><item><title>Introducing embedded-sdmmc - a pure-Rust #[no_std] SD card and FAT16/FAT32 library</title><link>https://www.reddit.com/r/rust/comments/ascvls/introducing_embeddedsdmmc_a_purerust_no_std_sd/</link><description><![CDATA[161 votes and 6 comments so far on Reddit]]></description><guid isPermaLink="false">fe990782-d611-46a2-a6c1-4048707e61df</guid><pubDate>Wed, 20 Feb 2019 04:32:00 +0000</pubDate><dc:creator>Jonathan Pallant</dc:creator></item><item><title>The Embedded Working Group Newsletter - 15</title><link>https://rust-embedded.github.io/blog/newsletter-15/</link><description><![CDATA[This is the fifteenth newsletter of the Embedded WG where we highlight new progress, celebrate cool projects, thank the community, and advertise projects that need help!]]></description><guid isPermaLink="false">e7d75d4a-b84d-41fd-a164-016bb9e9d99c</guid><pubDate>Wed, 20 Feb 2019 00:00:00 +0000</pubDate><dc:creator>The Embedded Working Group</dc:creator></item><item><title>First release of ieee802154 crate - Partial implementation of the IEEE 802.15.4 standard</title><link>https://users.rust-lang.org/t/first-release-of-ieee802154-0-1-partial-implementation-of-the-ieee-802-15-4-standard/25094</link><description><![CDATA[I’ve released the ieee802154 crate, a partial implementation of the IEEE 802.15.4 standard, earlier this week.  IEEE 802.15.4 is a standard for low-rate wireless personal area networks. It is used as the basis for higher-level protocols like 6LoWPAN, Zigbee, or Thread. The ieee802154 crate is only a partial implementation of this standard, but I hope it can be used as a basis for future work by extending it as required.]]></description><guid isPermaLink="false">5e8e4feb-2bb8-4337-bfba-a71003c797ed</guid><pubDate>Fri,  8 Feb 2019 14:24:56 +0000</pubDate><dc:creator>Hanno Braun</dc:creator></item><item><title>Rust on STM32: Blinking an LED</title><link>https://jonathanklimt.de/electrics/programming/rust-STM32F103-blink/</link><description><![CDATA[All tutorials I found felt somehow outdated and I don't have the board used in the embedded Rust book. So I wanted to document how I got some Rust code running on the BluePill.]]></description><guid isPermaLink="false">5e9f0f9a-99dc-4971-a8a2-9bd2a2cf4cce</guid><pubDate>Wed,  6 Feb 2019 01:00:00 +0100</pubDate><dc:creator>Jonathan Klimt</dc:creator></item><item><title>Building an Embedded Futures Executor II</title><link>https://josh.robsonchase.com/embedded-executor-2/</link><description><![CDATA[Part 2 of my embedded executor journey! Part 1 ended up getting a little long, so I cut it short while still missing some key features like more flexible task spawning and putting the executor to sleep when there's nothing needing to be polled. This time, we'll fill in those gaps!]]></description><guid isPermaLink="false">28a325bb-994b-4dad-9d6f-e92393b5eae0</guid><pubDate>Sun, 27 Jan 2019 15:00:00 -0500</pubDate><dc:creator>Josh Robson Chase</dc:creator></item><item><title>Building an Embedded Futures Executor</title><link>https://josh.robsonchase.com/embedded-executor/</link><description><![CDATA[After discovering that the embedded-hal ecosystem wasn't quite what I wanted it to be, I set out to build the abstractions that I wanted to use, namely: async-first and core::future compatible. The first thing on the list? A way to run the Futures of course!]]></description><guid isPermaLink="false">3efffa85-74d0-41d1-8d14-c5933470cf0a</guid><pubDate>Sat, 26 Jan 2019 22:00:00 -0500</pubDate><dc:creator>Josh Robson Chase</dc:creator></item><item><title>Embedded Rust Experiments - Is my STM32 MCU running fast?</title><link>https://nercury.github.io/rust/embedded/experiments/2019/01/27/rust-embedded-02-measuring-the-clock.html</link><description><![CDATA[So, I have this STM32VLDISCOVERY dev board. It has the STM32F100RBT6B MCU, capable of running at 24MHz. On the board, there is a 8MHz crystal. Naturally, when you are new to microcontrollers (like me), you may have a few questions: When we upload a program on this development board, at what speed it is actually running? Is it using this external crystal? Why is this crystal 8MHz if the MCU is capable of 24MHz? If our program is not running at the maximum speed, how do we make it run at the maximum speed?]]></description><guid isPermaLink="false">c032fc9f-79b2-454f-914f-a32fda90092d</guid><pubDate>Sun, 27 Jan 2019 00:00:00 +0000</pubDate><dc:creator>Nerijus Arlauskas</dc:creator></item><item><title>My Rust Powered linux.conf.au e-Paper Badge</title><link>http://www.wezm.net/technical/2019/01/linux-conf-au-rust-epaper-badge/</link><description><![CDATA[I attended linux.conf.au (for the first time) in Christchurch, New Zealand. It’s a week long conference covering Linux, open source software and hardware, privacy, security and much more. The theme this year was IoT. In line with the theme I built a digital conference badge to take to the conference. It used a tri-colour e-Paper display and was powered by a Rust program I built running on Raspbian Linux. This post describes how it was built, how it works, and how it fared at the conference. The source code is on GitHub.]]></description><guid isPermaLink="false">b4901fae-b805-4020-b425-47d2fc82b14d</guid><pubDate>Sun, 27 Jan 2019 00:00:00 +0000</pubDate><dc:creator>Wesley Moore</dc:creator></item><item><title>Manage security vulnerabilities in embedded IoT devices with Rust</title><link>https://medium.com/@flundstrom2/manage-security-vulnerabilities-in-embedded-iot-devices-with-rust-14aeabada68b</link><description><![CDATA[The Rust programming language’s rich type system and ownership model guarantee memory-safety and thread-safety — and eliminate many classes of bugs and security vulnerabilities at compile-time.]]></description><guid isPermaLink="false">84b2eb06-712b-4d63-b899-c91e16e1b0ee</guid><pubDate>Wed, 23 Jan 2019 12:18:11 +0000</pubDate><dc:creator>Fredrik Lundström</dc:creator></item><item><title>Rustduino pt. I: setting up the development environment</title><link>https://treesandrobots.com/2018/12/rustduino-pt-1-setting-up-development-environment.html</link><description><![CDATA[This post details the steps needed to start programming an Arduino UNO board using the Rust programming language and working on Mac OS.]]></description><guid isPermaLink="false">7d13bc11-63fd-48bd-bef2-459379a5e6c4</guid><pubDate>Sun, 30 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Jacopo Scazzosi</dc:creator></item><item><title>gbl: A typestate-powered zero-copy crate for GBL firmware update files</title><link>https://blog.1aim.com/post/gbl-release/</link><description><![CDATA[After a few weeks of reverse-engineering, internal dogfooding, and API design discussion, we're finally publishing our gbl crate for good.

The library implements a parser and writer for GBL firmware update containers, which are used to perform secure OTA updates for certain microcontrollers.]]></description><guid isPermaLink="false">aa59c999-cba6-4f20-80cc-888e8e257a73</guid><pubDate>Wed, 19 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Jonas Schievink</dc:creator></item><item><title>RTFM v0.4: +stable, software tasks, message passing and a timer queue</title><link>https://blog.japaric.io/rtfm-v4/</link><description><![CDATA[Today I’m pleased to announce v0.4.0 of the Real Time for The Masses framework (AKA RTFM), a concurrency framework for building real time applications. This release also packs quite a few new features which I’ll briefly cover in this post. For a more throughout explanation of RTFM’s task model and its capabilities check out the RTFM book, which includes examples you can run on your laptop (yay for emulation), and the API documentation.]]></description><guid isPermaLink="false">72e699cc-6b46-4f3b-9295-fef767681af8</guid><pubDate>Wed, 19 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Jorge Aparicio</dc:creator></item><item><title>cargo-call-stack: Whole program static stack analysis</title><link>https://github.com/japaric/cargo-call-stack#cargo-call-stack</link><description><![CDATA[The tool produces a call graph of the selected program as a dot file. Each node (function) in the call graph includes the local stack usage of the function, if provided by LLVM (see -Z emit-stack-sizes). If the call graph contains no cycles then the tool also computes the maximum stack usage of each function, that is the stack usage that includes the stack usage of the functions the function may invoke.]]></description><guid isPermaLink="false">afa2fbf0-9866-4be5-aa97-247c58bbccf7</guid><pubDate>Mon,  3 Dec 2018 23:31:00 +0000</pubDate><dc:creator>Jorge Aparicio</dc:creator></item><item><title>Bootstrapping My Embedded Rust Development Environment</title><link>https://josh.robsonchase.com/embedded-bootstrapping/</link><description><![CDATA[After watching James Munns' Something for Nothing talk at RustConf about all of the cool things in the embedded Rust world that have been going on, I decided to take a crack at some embedded work. I built an ErgoDox a while back and already had some basic understanding of how its keyboard controller operates, so I thought "why not design my own keyboard?"]]></description><guid isPermaLink="false">1184c74a-bcbf-4aee-ae13-70dd37a6d68a</guid><pubDate>Sun, 25 Nov 2018 22:15:00 -0500</pubDate><dc:creator>Josh Robson Chase</dc:creator></item><item><title>WIP: A no_std Rust crate for reading SD/MMC cards</title><link>https://www.reddit.com/r/rust/comments/a07k6e/wip_a_no_std_rust_crate_for_reading_sdmmc_cards/</link><description><![CDATA[To make it easier to load programs on to the Monotron, I've been working on a crate to make it really simple to read data from SD and SDHC cards formatted with FAT16 or FAT32. The crate is written without `alloc` so it uses zero heap, and I try to keep no more than one 512 byte block on the stack at a time.]]></description><guid isPermaLink="false">30b59cbd-a9ce-4f67-846b-93a30d134e5d</guid><pubDate>Sun, 25 Nov 2018 00:00:00 +0000</pubDate><dc:creator>Jonathan Pallant</dc:creator></item><item><title>Rusty clock: An alarm clock with environment stats in pure bare metal embedded Rust</title><link>https://github.com/TeXitoi/rusty-clock/blob/master/README.md</link><description><![CDATA[This alarm clock is programed in bare metal rust (no OS). It features pressure, temperature, humidity, monophonic alarm on a e-paper display.]]></description><guid isPermaLink="false">4c4ca2bc-0e59-4c24-92c1-2b37630f2280</guid><pubDate>Wed, 21 Nov 2018 23:03:26 +0000</pubDate><dc:creator>Guillaume P.</dc:creator></item><item><title>This Year in Embedded Rust</title><link>https://rust-embedded.github.io/blog/2018-11-14-this-year-in-embedded-rust/</link><description><![CDATA[This year the Embedded WG set out to build the solid foundation that the embedded Rust ecosystem requires to thrive. As we approach the date of the 2018 edition release we reflect on our progress and share our achievements with you in this post.]]></description><guid isPermaLink="false">68074e79-2747-4170-970f-0e56b936578c</guid><pubDate>Wed, 14 Nov 2018 00:00:00 +0000</pubDate><dc:creator>The Embedded Working Group</dc:creator></item><item><title>Monotron at Rust Belt Rust</title><link>https://railwayelectronics.blogspot.com/2018/11/monotron-at-rust-belt-rust.html</link><description><![CDATA[So now @rustbeltrust is over, I thought it was worth writing down a few details about what Monotron can do. It's had a few upgrades since @RustFest Paris! I tried to keep them under wraps to avoid spoilers but I can share them now. This is an un-roll and re-edit of my Twitter thread, and the features listed here are in no particular order.]]></description><guid isPermaLink="false">e8029bd5-78ca-4797-bf1b-9f909f132a4b</guid><pubDate>Sun,  4 Nov 2018 20:49:00 +0000</pubDate><dc:creator>Jonathan Pallant</dc:creator></item><item><title>The Embedded Working Group Newsletter - Embedded on Stable!</title><link>https://rust-embedded.github.io/blog/2018-10-28-newsletter-14/</link><description><![CDATA[This is a special "spotlight" edition of the newsletter, where we look at a few topics in a bit more detail: Embedded Rust Applications on Stable, Cortex-A team, shared-bus, and more.]]></description><guid isPermaLink="false">13502f64-39c2-4eae-9825-b68c2056bc66</guid><pubDate>Sun, 28 Oct 2018 00:00:00 +0000</pubDate><dc:creator>The Embedded Working Group</dc:creator></item><item><title>Bluetooth Low Energy with Rust</title><link>https://219design.com/bluetooth-low-energy-with-rust/</link><description><![CDATA[For a change of pace, I have been learning embedded development using Rust in my spare time, which has been an exciting challenge. A core component of my project is to have two devices communicating wirelessly, and (at the time I started working on this) there were no “no-std” Rust Bluetooth crates available. So I started to write my own. I had already chosen to work on the Nucleo, and to use the IDB05A1 shield, which contains a BlueNRG-MS module.]]></description><guid isPermaLink="false">af77ca8e-342a-450b-90e8-a6b1d485c8b8</guid><pubDate>Thu, 27 Sep 2018 19:52:09 +0000</pubDate><dc:creator>Daniel Gallagher</dc:creator></item><item><title>RSoC: Porting Redox to ARM (AArch64) — 0x02</title><link>https://medium.com/@wizofe/rsoc-porting-redox-to-arm-aarch64-0x02-c566ee22f377</link><description><![CDATA[At the time of writing the previous blog the plan was to target the Raspberry Pi 3 (Cortex A53) as a development platform because of its availability, popularity and community. Sadly, it seems that Broadcom went through a lot of shortcuts while implementing this specific design, which means features like GIC are half-there or completely missing, like in this case.

After a discussion with @microcolonel, he proposed and kindly sent me a HiKey960 reference SoC from the awesome Linaro 96Boards initiative. The quality of this board is definitely a lot better than the Raspberry Pi and the documentation is detailed and open. Great stuff.]]></description><guid isPermaLink="false">382f988d-9fe3-4525-9b21-0c6cb4373303</guid><pubDate>Sun,  5 Aug 2018 22:39:42 +0000</pubDate><dc:creator>ioannis valasakis</dc:creator></item><item><title>Working on the Embedded Rust Book</title><link>https://jamesmunns.com/blog/working-on-the-book/</link><description><![CDATA[TL;DR: Up to now, I haven't had as much time or motivation as I would have like to contribute to the Embedded Rust Book. However, I am excited to see the initial version of the book launch with the 2018 edition of Rust (which will ship with stable support for embedded)!, so I will be committing to write one chapter per two weeks, until the end of the year.

Read below for my plan, and how you can help!]]></description><guid isPermaLink="false">e20d8f7a-53c3-45c8-b16e-ac25a20ff548</guid><pubDate>Sat,  4 Aug 2018 00:00:00 +0000</pubDate><dc:creator>James Munns</dc:creator></item><item><title>BetaFPV F3 Drone Flight Controller - Board Support Crate</title><link>https://www.joshmcguigan.com/blog/betafpv-drone-flight-controller-board-support-crate/</link><description><![CDATA[In a previous blog post I described how to get a very simple Rust program compiling for and running on the BetaFPV F3 drone flight controller. Since that time I’ve been working to create a board support crate to provide a high level API for the board.]]></description><guid isPermaLink="false">5473f9e8-40a8-43fe-956e-e84678267c90</guid><pubDate>Tue, 31 Jul 2018 00:00:00 +0000</pubDate><dc:creator>Josh Mcguigan</dc:creator></item><item><title>Bringing Rust to Ledger hardware wallets</title><link>https://medium.com/@roosmaa/bringing-rust-to-ledger-hardware-wallet-ccf1356a7de1</link><description><![CDATA[Beginning of this year I wanted to experiment with some embedded development. I ended up looking into Ledger cryptocurrency hardware wallet application development. I wouldn’t actually consider this true embedded development as a lot of the heavy lifting has been done and abstracted away by Ledger, but it’s still writing software for a very constrained environment. Ledger applications only get 4KB of RAM to utilise and most of the embedded development practices still apply (no heap allocations for instance).]]></description><guid isPermaLink="false">41e44eb5-79db-4f16-83c2-a126c4d43286</guid><pubDate>Thu, 26 Jul 2018 12:01:48 +0000</pubDate><dc:creator>Mart Roosmaa</dc:creator></item><item><title>Where next for the Monotron</title><link>http://railwayelectronics.blogspot.com/2018/07/where-next-for-monotron.html?m=1</link><description><![CDATA[It's a couple of months on from my talk at RustFest on Monotron, so I thought it was worth a quick catch up on where we're going next. As a recap, Monotron currently generates an 800 x 600 VGA signal at 60 Hz (with a pixel clock of 40 MHz). It does this using three synchronised SPI peripherals, a timer generating the horizontal-sync pulse and a GPIO pin for the vertical-sync. With the CPU running at a clock speed of 80 MHz, the SPI peripherals are clocked at 20 MHz producing 400 horizontal pixels per line. This is half the nominal 800 pixels, but we needed to sacrifice resolution to double the amount of CPU time we have to 4 clocks per pixel (i.e. 32 clocks per 8-bit character column).]]></description><guid isPermaLink="false">669e3447-5dac-4fe9-a87a-0b315ae3062d</guid><pubDate>Tue, 24 Jul 2018 22:40:00 +0100</pubDate><dc:creator>Jonathan Pallant</dc:creator></item><item><title>TSL256X Light Intensity Sensor Driver</title><link>https://www.joshmcguigan.com/blog/tsl256x-light-intensity-sensor-driver/</link><description><![CDATA[It is an exciting time to be working in embedded Rust. After writing my first driver, I mostly had the feeling that for driver writers there was a clear expectation and an obvious standard for how things should be done. My experience writing this driver, which uses I2C rather than GPIO, exposed me to a few topics of active discussion within the embedded Rust working group which I hadn’t seen before.]]></description><guid isPermaLink="false">2ebd5fc5-6e3a-4933-8775-a7a190539f8b</guid><pubDate>Sun, 15 Jul 2018 00:00:00 +0000</pubDate><dc:creator>Josh Mcguigan</dc:creator></item><item><title>How we built a Visual Studio Code extension for IoT prototyping</title><link>https://cultivatehq.com/posts/how-we-built-a-visual-studio-code-extension-for-iot-prototyping/</link><description><![CDATA[We recently had the opportunity to make a Visual Studio Code extension that needed to communicate with an embedded device. This post explains the architecture we chose to achieve that and the decisions that led to it.]]></description><guid isPermaLink="false">a9a551b0-07a6-48a2-944f-b956438fecc0</guid><pubDate>Fri, 13 Jul 2018 22:39:00 +0000</pubDate><dc:creator>Dan Munckton</dc:creator></item><item><title>Electrosmog trapping with CC1101</title><link>https://dsvensson.github.io/posts/2018-07-13-Electrosmog-trapping-with-CC1101.html</link><description><![CDATA[A couple of months ago I moved to a house, and the need to monitor-all-the-things guided me towards the affordable IKEA Sparsnäs energy display. Sparsnäs is made up of two parts, one being the transmitter that is attached to your electricity meter, and the other; the display that stores usage, and presents a variety of graphs. The downside is that there is no way of getting the data out of the display so you have to accept how it’s presented, and that it may get lost, or build something on your own. Thankfully the protocol has been thoroughly reverse engineered and documented in a very elaborate manner.]]></description><guid isPermaLink="false">c5d017d6-de45-4099-9272-19fe01441fdc</guid><pubDate>Fri, 13 Jul 2018 20:06:53 +0000</pubDate><dc:creator>Daniel Svensson</dc:creator></item><item><title>Multi target Rust builds with auto deployment in Travis-CI</title><link>https://medium.com/@tyrf/multi-target-rust-builds-with-auto-deployment-in-travis-ci-ab5214fb73ba</link><description><![CDATA[This is just a small build script to automatically compile and create Rust binaries for your i86 32 and 64 bit machine and your Raspberry Pi(ARM) with Travis-CI. On the right side I added a little explanation of the following script.]]></description><guid isPermaLink="false">fbdcd657-aab5-4d28-aa3a-ab04294f49eb</guid><pubDate>Fri, 13 Jul 2018 18:44:17 +0000</pubDate><dc:creator>Hendrik Teuber</dc:creator></item><item><title>Physical Computing With Rust On Raspberry Pi</title><link>https://medium.com/@rahulthakoor/physical-computing-with-rust-on-raspberry-pi-a7b6f34261a6</link><description><![CDATA[A couple of months ago I released the rust_gpiozero¹ crate. It is a port of the GPIO Zero² library by the Raspberry Pi Foundation. The library provides a simple interface to control GPIO devices with a Raspberry Pi. Following this, recently ported the Raspberry Pi Foundation’s Physical Computing with Python³ guide for Rust.]]></description><guid isPermaLink="false">34fa3257-4ea8-4ade-8cad-353aa02239d3</guid><pubDate>Thu, 12 Jul 2018 14:52:13 +0000</pubDate><dc:creator>Rahul Thakoor</dc:creator></item><item><title>BetaFPV F3 Drone Flight Controller - Hello Rust</title><link>https://www.joshmcguigan.com/blog/betafpv-drone-flight-controller-hello-rust/</link><description><![CDATA[One of the most exciting areas of hobbyist embedded programming, in my opinion, is flight controllers for remote controlled aircraft. In the particular case of a multi-rotor drone, the flight controller is responsible for converting the UP command from the transmitter into specific outputs for each of the motors. Maintaining the stability of a drone involves carefully adjusting the output of each motor thousands of times per second based on feedback from on-board sensors.

There are several great C-based open source drone flight controller firmware projects, but as far as I can see there are none written in Rust. The good news is that most drone flight controllers are based on STM32 MCUs, which Rust has strong support for. Robust flight controller firmware is quite complex, and there are a number of challenges to be solved before even getting the rotors spinning. The first of those challenges is building a Rust project for a particular flight controller board, and flashing the board with the compiled code. A single blinking LED is our goal for today.]]></description><guid isPermaLink="false">133f5906-759e-4a83-b188-fc18eda31cc0</guid><pubDate>Wed, 11 Jul 2018 00:00:00 +0000</pubDate><dc:creator>Josh Mcguigan</dc:creator></item><item><title>Rustberry 0.1.0 has been released, and I need more testers!</title><link>https://www.reddit.com/r/rust/comments/8x1ayd/calling_all_raspberry_pi_owners_rustberry_010_has/</link><description><![CDATA[After many laborious hours of reading and interpreting the various online references, I've published the first release of my latest project, a crate to safely abstract Raspberry Pi's platform-specific features in Rust. I've (very creatively) named it Rustberry, and it's finally stable and clean enough that I'm able to publish it and receive initial feedback.]]></description><guid isPermaLink="false">54c6e230-51fa-42c2-bcab-26b75e699bb3</guid><pubDate>Sun,  8 Jul 2018 23:06:00 +1000</pubDate><dc:creator>/u/ninja_tokumei</dc:creator></item><item><title>Cross compiling Rust for ARM (e.g. Raspberry Pi) using any OS!</title><link>https://medium.com/@wizofe/cross-compiling-rust-for-arm-e-g-raspberry-pi-using-any-os-11711ebfc52b</link><description><![CDATA[Here is a small walkthrough, on how to use Mac OSx, Linux or even Windows (hey not tested but I am sure you can make it work, the tools are the same) to compile your Rust marvellousness and run the binary directly on the Raspberry Pi (2/3/3+).]]></description><guid isPermaLink="false">ecb8cd2e-5804-4876-a5c6-c30cbf1c93fa</guid><pubDate>Sat,  7 Jul 2018 21:54:26 +0000</pubDate><dc:creator>ioannis valasakis</dc:creator></item><item><title>Embedded development with Yocto and Rust</title><link>https://pagefault.blog/2018/07/04/embedded-development-with-yocto-and-rust/</link><description><![CDATA[Customized Linux distribution and a safe systems programming language sounds like a very interesting combination for embedded development. That is what makes Yocto and Rust such a good match. So, I wanted to see how Rust projects could be cross-compiled with Yocto-generated toolchain and root filesystem. The steps are described in this post.]]></description><guid isPermaLink="false">bef012dd-518b-4a24-9acd-d0d68b3bead3</guid><pubDate>Wed,  4 Jul 2018 17:06:32 +0000</pubDate><dc:creator>Sami Pietikäinen</dc:creator></item><item><title>RSoC: Porting Redox to AArch64–0x01</title><link>https://medium.com/@wizofe/rsoc-porting-redox-to-aarch64-0x01-3dee87644c97</link><description><![CDATA[All excited. A first calendar entry to describe my attempt on arm64 support in Redox OS. Specifically, looking into the Raspberry Pi2/3b/3+(all of them having a Cortex-A53 ARMv8 64-bit microprocessor, although for all my experiments I am going to use the Raspberry Pi 3b.]]></description><guid isPermaLink="false">44759beb-04e0-4524-898b-5ba007a80e10</guid><pubDate>Tue, 26 Jun 2018 17:26:31 +0000</pubDate><dc:creator>ioannis valasakis</dc:creator></item><item><title>Rust Thermometer – Part 2</title><link>https://www.robertvojta.com/rust-thermometer-part-2/</link><description><![CDATA[Thermometer adventure continuous with some progress over the last weekend. Little bit of refactoring, rewiring, X.org, matchbox, Piston, ... and some ugly (but working!) UI :)]]></description><guid isPermaLink="false">e063329a-32df-4f01-92b0-38d5999f9a6e</guid><pubDate>Mon, 25 Jun 2018 13:51:53 +0000</pubDate><dc:creator>Robert Vojta</dc:creator></item><item><title>Rust Thermometer – Part 1</title><link>https://www.robertvojta.com/rust-thermometer-part-1/</link><description><![CDATA[I’ve decided to build a thermometer from scratch. I know, I can buy it, but it’s not fun. I found it as a perfect occasion to please my wife (she wants it) and to try new things. What new things? Mainly resin.io and resinOS.]]></description><guid isPermaLink="false">d93b968d-f8fb-4ba9-b7eb-1879ec63807d</guid><pubDate>Wed, 20 Jun 2018 09:23:29 +0000</pubDate><dc:creator>Robert Vojta</dc:creator></item><item><title>Running Rust and FreeRTOS on the PADI IoT Stamp</title><link>https://medium.com/@ly.lee/running-rust-and-freertos-on-the-padi-iot-stamp-fb36c5ef4844</link><description><![CDATA[In this article we’ll explore a better way to build and test programs for microcontroller platforms. Specifically we’ll look at Rust, FreeRTOS and Visual Studio Code. And how I made them run on the PADI IoT Stamp.]]></description><guid isPermaLink="false">fb7909fb-5c7d-4360-a9fe-4620e04262d8</guid><pubDate>Mon, 18 Jun 2018 05:45:28 +0000</pubDate><dc:creator>Lup Yuen Lee</dc:creator></item><item><title>Bobbin SDK: Richer Hardware Abstractions for Embedded Systems Programming</title><link>http://www.bobbin.io/blog/post/bobbin_sdk_richer_hardware/</link><description><![CDATA[Bobbin SDK is a suite of tools and code that has been used in embedded development projects running on a variety of ARM Cortex-M MCUs over the last year and a half. It exists to bridge the gap between the existing Rust ecosystem centered around svd2rust and rich but proprietary vendor SDKs.]]></description><guid isPermaLink="false">df7df3a9-1519-4453-963e-fb69d766798d</guid><pubDate>Fri, 25 May 2018 00:00:00 +0000</pubDate><dc:creator>Jonathan Soo</dc:creator></item><item><title>Neural networks on a micro controller - Preparation and math</title><link>http://trangar.blogspot.com.au/2018/05/neural-networks-on-micro-controller.html?m=1</link><description><![CDATA[I've been playing around with the idea of running a neural network on a micro controller. This project is not designed to be the most efficient neural network, but rather one that runs on a micro controller with very limited resources.]]></description><guid isPermaLink="false">4c0ea01d-c011-49aa-b6a6-10178e03c627</guid><pubDate>Wed, 23 May 2018 10:04:00 -0700</pubDate><dc:creator>Trangar</dc:creator></item><item><title>Memory-Mapped Registers in Tock</title><link>https://www.tockos.org/blog/2018/mmio-registers/</link><description><![CDATA[Microcontrollers typically use memory-mapped I/O interfaces to control hardware peripherals. Driver code uses these memory-mapped registers and fields to interact with the peripheral while providing a higher-level interface to the rest of the system. This post describes how Tock deals with register memory maps and a new tool that can automatically generate memory maps for many ARM microcontrollers.]]></description><guid isPermaLink="false">3d49dcaa-90bd-4749-82a8-83a272d0864b</guid><pubDate>Mon,  7 May 2018 00:00:00 +0000</pubDate><dc:creator>Branden Ghena</dc:creator></item><item><title>Cross compiling rust with docker</title><link>https://medium.com/@pvinchon/cross-compiling-rust-with-docker-17d846adae4d</link><description><![CDATA[I am giving embedded systems another go with a side project of mine. The device has a single purpose. It captures network packets, and forwards them to a server. It is easily achieved with LIBpcap, but the device makes it interesting.

The GL-AR150 sells as a mini smart router. The limited storage makes it hard to install language interpreters, or virtual machines. This pushed me to look into standalone executables, and how to compile them for other devices.]]></description><guid isPermaLink="false">47521515-a430-41a1-bcdc-bb68b3f9d646</guid><pubDate>Mon, 30 Apr 2018 23:01:01 +0000</pubDate><dc:creator>Philippe</dc:creator></item><item><title>c3r3s - Serial 64-bit bootloader for the Raspberry Pi 3</title><link>https://github.com/robey/c3r3s</link><description><![CDATA[c3r3s is a tiny (1KB binary) serial bootloader for loading "bare metal" 64-bit kernels on the Raspberry Pi 3. You can iterate on your own kernel code without constantly moving the SD card back and forth.]]></description><guid isPermaLink="false">b4ecd378-f152-4049-b281-8b519cdb870d</guid><pubDate>Tue,  1 May 2018 07:22:00 +1000</pubDate><dc:creator>Robey Pointer</dc:creator></item><item><title>Flipping some bits high on STM32VLDISCOVERY board</title><link>http://nercury.github.io/rust/embedded/experiments/2018/04/29/rust-embedded-01-discovery-vl-flipping-bits.html</link><description><![CDATA[Here I will document the steps to get started with STM32VLDISCOVERY board. We will take my favourite “from scratch” approach. That way, we build the final thing step by step while building our understanding of how it all fits together.]]></description><guid isPermaLink="false">73443ff7-2113-490d-9249-430c95c1534a</guid><pubDate>Sun, 29 Apr 2018 00:00:00 +0000</pubDate><dc:creator>Nerijus Arlauskas</dc:creator></item><item><title>Embedded Rust: Peripherals (and low-level stuffs) - take 1</title><link>https://ithinuel.me/embedded-rust-peripherals-take-1/</link><description><![CDATA[First of all, low level stuffs such as peripheral drivers should be hidden from the application developer. They should not be able to access directly the registers and mess with the peripheral states/control. The wrong flag in the wrong register can lead to dramatic failures and even damages to the products.]]></description><guid isPermaLink="false">97c03488-1331-4858-baf0-26e1d0fca6f0</guid><pubDate>Sat, 28 Apr 2018 00:00:00 +0000</pubDate><dc:creator>Wilfried Chauveau</dc:creator></item><item><title>Flipper - A new embedded development paradigm</title><link>https://www.reddit.com/r/rust/comments/8d8vqn/flipper_a_new_embedded_development_paradigm/</link><description><![CDATA[Flipper is a new kind of development board that redefines the embedded software development cycle by offloading development/debugging into higher level languages + tools. One of the languages that we're putting the most focus into adding support for is Rust. We would love to see more embedded done with Rust and Flipper provides a great springboard for existing Rust developers to familiarize themselves with embedded hardware using the tools they already know how to use.]]></description><guid isPermaLink="false">9cb9976f-4023-496c-9bdf-b5eff31fe5bb</guid><pubDate>Wed, 18 Apr 2018 20:28:34 +0000</pubDate><dc:creator>George Morgan</dc:creator></item><item><title>Cargo, Xargo, and Rustup</title><link>http://aturon.github.io/2018/04/06/rustup-xargo/</link><description><![CDATA[Another topic of discussion at the Berlin Rust All Hands was the long-term story around Cargo, Xargo, and Rustup. The latter two tools are both involved in managing your Rust toolchain, with Xargo allowing you to build custom stds and Rustup managing pre-built artifacts for mainstream targets. Xargo is most commonly used for cross-compiling to less common platforms, but can also be used to customize the standard library on mainstream platforms.]]></description><guid isPermaLink="false">277652ec-bbeb-454c-85da-766438600d47</guid><pubDate>Fri,  6 Apr 2018 00:00:00 +0000</pubDate><dc:creator>Aaron Turon</dc:creator></item><item><title>Building Tiny Rust Binaries for Embedded Linux</title><link>https://jamesmunns.com/update/2018/04/01/tinyrocket.html</link><description><![CDATA[At the recent 2018 Rust All Hands, I met up with Katharina @spacekookie, who works on an open source project that creates software for Embedded Linux Devices. She had talked with the other engineers on the project about including some Rust components, however with their limited flash storage space (8MB for the whole firmware, including operating system and all other software), she was worried that the Rust binaries wouldn’t fit. The current webserver component for their project was measured in the 100’s of KB, while the Rust binary she produced was already multiple MBs, even with a --release build!]]></description><guid isPermaLink="false">6419c6a3-a47d-4ce5-93ef-11f17be5eecd</guid><pubDate>Sun,  1 Apr 2018 09:30:00 +0000</pubDate><dc:creator>James Munns</dc:creator></item><item><title>Weekly Driver: Using the SGP30 Gas Sensor from Rust</title><link>https://blog.dbrgn.ch/2018/4/1/rust-sgp30-driver/</link><description><![CDATA[After the MCP3425 ADC driver I published last month as part of the the weekly driver initiative, I wrote a second Rust embedded-hal driver, this time for the SGP30. The Sensirion SGP30 is a tiny low-power gas sensor (produced in Switzerland) for indoor air quality applications with good long-term stability. It has an I²C interface with TVOC (Total Volatile Organic Compounds) and CO₂ equivalent signals.]]></description><guid isPermaLink="false">2f7b942d-1a59-40bc-bc92-a1e2e85803ee</guid><pubDate>Sun,  1 Apr 2018 00:00:00 +0200</pubDate><dc:creator>Danilo Bargen</dc:creator></item><item><title>Embedded Rust: Why?</title><link>http://ithinuel.me/embedded-rust-why/</link><description><![CDATA[I will try to publish here a series of articles about my approach to embedded development and how I plan to achieve that in Rust.]]></description><guid isPermaLink="false">5230134e-6bfc-4a88-9cee-7bec1f15e099</guid><pubDate>Fri, 30 Mar 2018 08:26:00 +0000</pubDate><dc:creator>Wilfried Chauveau</dc:creator></item><item><title>Writing A Driver in Rust Using Embedded-Hal Traits for the RN4870 BLE Module</title><link>http://byronwasti.com/post/writing_a_ble_driver_in_rust/</link><description><![CDATA[This post will document my process and thoughts on writing a driver for a bluetooth module using Rust and the embedded-hal crate. The specific bluetooth device I will be using is the RN4870 BLE castellated module. It features a simple UART interface and handles most of the complexities of BLE itself, making it very easy to get a simple BLE connection up and running.]]></description><guid isPermaLink="false">348de5bf-0fa7-48d1-b112-20cd13cfd3f3</guid><pubDate>Sun, 25 Mar 2018 20:15:57 +0000</pubDate><dc:creator>Byron Wasti</dc:creator></item><item><title>Safe Peripheral Management</title><link>https://www.tockos.org/blog/2018/peripheral-management/</link><description><![CDATA[This post describes the recently merged PeripheralManager, which helps software ensure it always accesses hardware correctly, and cleans up after it’s done.]]></description><guid isPermaLink="false">c57dc18b-48b9-453e-b44a-46da4dce6d8e</guid><pubDate>Wed, 21 Mar 2018 00:00:00 +0000</pubDate><dc:creator>Pat Pannuto</dc:creator></item><item><title>HTS221 Humidity and Temperature Sensor</title><link>https://medium.com/@pdanielgallagher/hts221-humidity-and-temperature-sensor-88056ea9e5fa</link><description><![CDATA[ST Micro’s HTS221 is a “capacitive digital sensor for relative humidity and temperature” that can be used over either I²C or SPI. It is factory-calibrated, so there is no end-user calibration to incorporate into your application. The driver provides a simple, high-level API to configure the chip once on startup, then read the temperature and humidity.]]></description><guid isPermaLink="false">f860801f-7b99-4fe3-88cc-a6c00ca7d97a</guid><pubDate>Tue, 20 Mar 2018 04:16:48 +0000</pubDate><dc:creator>Daniel Gallagher</dc:creator></item><item><title>Achieving memory safety without compromise</title><link>https://www.embedded.com/electronics-blogs/say-what-/4460422/Achieving-memory-safety-without-compromise</link><description><![CDATA[A new generation of safe programming languages is leaving garbage collectors and runtimes behind, delivering memory safety and control.]]></description><guid isPermaLink="false">f1b7c59f-fff8-4000-ac97-2be742b86760</guid><pubDate>Tue, 13 Mar 2018 16:32:00 +0000</pubDate><dc:creator>Adam Foltzer</dc:creator></item><item><title>Weekly driver 4: ENC28J60, Ethernet for your microcontroller</title><link>http://blog.japaric.io/wd-4-enc28j60/</link><description><![CDATA[This week I’m releasing a driver for the ENC28J60, an Ethernet controller with SPI interface. This IC lets you connect your microcontroller, if it has a SPI interface, to a Local Area Network or, with more work, to the internet. Apart from the IC you need a RJ45 connector and a few other components so I’m using this module which has the ENC28J60 and all the required components on a single board.]]></description><guid isPermaLink="false">a48d8156-7f0f-4731-a17b-e36678b86f5f</guid><pubDate>Tue, 13 Mar 2018 04:32:18 +0100</pubDate><dc:creator>Jorge Aparicio</dc:creator></item><item><title>Weekly Driver: Using the MCP3425 ADC from Rust</title><link>https://blog.dbrgn.ch/2018/3/13/rust-mcp3425-driver/</link><description><![CDATA[Announing the MCP3425 Rust driver.]]></description><guid isPermaLink="false">249e8bc3-a836-4b71-89b6-8d7c4d1b0977</guid><pubDate>Tue, 13 Mar 2018 00:00:00 +0100</pubDate><dc:creator>Danilo Bargen</dc:creator></item><item><title>Tock 1.0 Kernel Released</title><link>https://www.tockos.org/blog/2018/talking-tock-35/</link><description><![CDATA[We silently tag our first rolling release of the Tock kernel in February. If you’re building applications with Tock or porting to a new board, and want to be immune from updating your code everyday, you can work from that tag. We’ll also upload binary kernel images for the supported board sometime soon.]]></description><guid isPermaLink="false">a4faa45e-f24e-4ce9-822c-5c4623919e17</guid><pubDate>Tue,  6 Mar 2018 00:00:00 +0000</pubDate><dc:creator>Amit Levy</dc:creator></item><item><title>Rust on the STMicro Nucleo</title><link>https://medium.com/@pdanielgallagher/rust-on-the-stmicro-nucleo-7a66b97be549</link><description><![CDATA[For the embedded portion of my project, I had two decisions to make: which processors and chips to use, and which language to write the firmware in. Since this personal project is about learning new skills, I decided to use Rust instead of C. I opted to use STMicro’s Nucleo boards, since their ecosystem has shields that do all of the things I would like (WiFi, BLE, and environmental sensing), and there was also a great Rust tutorial for a similar board. However, since I’ve never really done any embedded development, I decided to start with the old standby: copying code off the internet!]]></description><guid isPermaLink="false">3907940b-eb06-4f2a-a3ff-6df4ae5ac9ca</guid><pubDate>Thu,  1 Mar 2018 05:50:42 +0000</pubDate><dc:creator>Daniel Gallagher</dc:creator></item><item><title>Discovery: Discover the world of microcontrollers through Rust! - 2018 edition</title><link>https://www.reddit.com/r/rust/comments/80doqg/discovery_discover_the_world_of_microcontrollers/</link><description><![CDATA[This is an mdbook I wrote more than a year ago for a workshop and it's an introductory course to embedded systems that uses Rust as the teaching language. I just updated the starter code to use the latest versions of everything so it's now easier to jump from the book to use the latest developments in the Cortex-M ecosystem; there's no new content, though -- the exercises remain unchanged in terms of goals; just the code has changed.]]></description><guid isPermaLink="false">0cb6b35f-0d4f-4e71-bcae-66d4cd115d41</guid><pubDate>Mon, 26 Feb 2018 15:12:44 +0000</pubDate><dc:creator>Jorge Aparicio</dc:creator></item><item><title>Let&apos;s write an embedded-hal-driver</title><link>http://zuendmasse.de/blog/2018/02/23/lets-write-an-embedded-hal-driver/</link><description><![CDATA[Mid January japaric started "The weekly driver initiative" with the goal to kick-start releases of platform agnostic embedded-hal based driver crates. In this post we'll build an embedded-hal-driver for the AT24C32-EEPROM chip.]]></description><guid isPermaLink="false">75898724-f900-46ae-877b-36d87b440ac1</guid><pubDate>Sun, 25 Feb 2018 00:00:00 +0000</pubDate><dc:creator>Sebastian Wötzel</dc:creator></item><item><title>Transcript: Should you Rust in embedded yet?</title><link>https://kazlauskas.me/entries/rust-embedded-ready.html</link><description><![CDATA[This is a transcript of a talk I gave at the Vilnius Rust meetup.

It would not be an exaggeration to say that embedded is omnipresent. You can find embedded firmware everywhere from fridges, microwaves and personal computers to safety-critical applications in automotive, medical fields, etc.

Most of this software is still written in C or C++, and neither of these, given their non-ideal track record in relation to security critical software, are the most confidence inspiring choice for safety-critical systems.

In my experience, bugs occurring in embedded firmware tend to be fairly similar to those commonly found in the user-space software.]]></description><guid isPermaLink="false">504ed65c-1efe-4cbd-b655-b17e89110936</guid><pubDate>Sat, 24 Feb 2018 20:09:27 +0000</pubDate><dc:creator>Simonas Kazlauskas</dc:creator></item><item><title>An introduction to writing platform agnostic drivers in Rust using the MCP3008</title><link>http://pramode.in/2018/02/24/an-introduction-to-writing-embedded-hal-based-drivers-in-rust/</link><description><![CDATA[Here is how a device like an accelerometer works: you send the device commands over a serial interface (SPI, I2C), say something like: “get me the X-axis reading”; the device responds by sending back some data.

The way the SPI/I2C/GPIO (and other) interfaces are programmed is very much dependent on the specific microcontroller family. But the actions you need to perform to interface with a device like a temperature sensor / accelerometer etc depend only on the device and are independent of the controller being used. What if you can write a generic accelerometer driver and use it on any microcontroller platform - right from low-end ARM Cortex-M, AVR, MSP430 etc to complex Embedded Linux platforms like the Raspberry Pi? What if you can distribute these drivers on crates.io so that you only have to include one line in your Cargo.toml to use it in your code?]]></description><guid isPermaLink="false">34ee0b77-cabd-47a8-bb6c-00e8a34046c7</guid><pubDate>Sat, 24 Feb 2018 00:00:00 -0500</pubDate><dc:creator>Pramode C.E</dc:creator></item><item><title>I decided to make an 1980&apos;s Home Computer in Rust - Part 1</title><link>http://railwayelectronics.blogspot.com.au/2018/02/i-decided-to-make-1980s-home-computer.html?m=1</link><description><![CDATA[My first attempt at Rust programming was the stellaris-launchpad crate. This has a few demos that either blink the LED or roll it through an RGB rainbow using the PWM timers. Recently I've started a new version of the lm4f120 crate called tm4c123x-hal. The name change reflects TI's new name for basically the exact same part, while the -hal indicates that it's based upon the output of svd2rust and @japaric's new Embedded Hal crate. At the same time, I was watching videos on Youtube about a new wave of 1980's style 'retro' computing boards - text output, BASIC interpreter, etc. An idea started to form that I could put all three of these things together.]]></description><guid isPermaLink="false">b2eb24c3-d7ee-438c-b041-0446dd551abe</guid><pubDate>Tue, 20 Feb 2018 22:16:00 +0000</pubDate><dc:creator>Jonathan Pallant</dc:creator></item><item><title>Programming an ARM microcontroller in Rust at four different levels of abstraction</title><link>http://pramode.in/2018/02/20/programming-a-microcontroller-in-rust-at-four-levels-of-abstraction/</link><description><![CDATA[Covering: Why Rust on Microcontrollers, Level 1: Direct register access in an unsafe block, Level 2: No unsafe blocks, use the API provided by svd2rust, A problem, Level 3: The embedded HAL to the rescue, Level 4: Use a board support crate.]]></description><guid isPermaLink="false">f2bf66c3-52bf-4a3c-b508-96bbd3385e8d</guid><pubDate>Tue, 20 Feb 2018 00:00:00 -0500</pubDate><dc:creator>Pramode C.E</dc:creator></item><item><title>Weekly driver 1 &amp; 2: L3GD20, LSM303DLHC and Madgwick - Embedded in Rust</title><link>http://blog.japaric.io/wd-1-2-l3gd20-lsm303dlhc-madgwick/</link><description><![CDATA[Oh, time flies. It’s already week 8 and we have zero weekly driver posts out there – don’t worry though because there’s plenty of drivers and embedded-hal implementations in the works. To play catch up in this post I’ll cover two embedded-hal drivers: the l3gd20 and the lsm303dlhc. The L3GD20 is an IC that contains a gyroscope and exposes I2C and SPI interfaces; the LSM303DLHC is an IC that contains an accelerometer and a magnetometer, and exposes an I2C interface. You can find these two ICs on the STM32F3DISCOVERY board.]]></description><guid isPermaLink="false">25d98aac-94a1-4cda-bbdb-7b22b76ed032</guid><pubDate>Mon, 19 Feb 2018 15:57:59 +0100</pubDate><dc:creator>Jorge Aparicio</dc:creator></item><item><title>Zero cost stack overflow protection for ARM Cortex-M devices</title><link>http://blog.japaric.io/stack-overflow-protection/</link><description><![CDATA[One of the core features of Rust is memory safety. Whenever possible the compiler enforces memory safety at compile. One example of this is the borrow checker which prevents data races, iterator invalidation, pointer invalidation and other issues at compile time. Other memory problems like buffer overflows can’t be prevented at compile time. In those cases the compiler inserts runtime checks, bounds checks in this case, to enforce memory safety at runtime. What about stack overflows? For quite a long time Rust didn’t have stack overflow checking but that wasn’t much of a problem on tier 1 platforms since these platforms have an OS and a MMU (Memory Management Unit) that prevents stack overflows from wreaking havoc.]]></description><guid isPermaLink="false">45c32609-24ef-4288-b361-57ca8b5a34cd</guid><pubDate>Sat, 17 Feb 2018 18:16:39 +0100</pubDate><dc:creator>Jorge Aparicio</dc:creator></item><item><title>Memory safe DMA transfers - Embedded in Rust</title><link>http://blog.japaric.io/safe-dma/</link><description><![CDATA[A blog about Rust and embedded stuff]]></description><guid isPermaLink="false">b7290658-fff8-4ee5-b8e5-eceefdc6beb6</guid><pubDate>Fri,  9 Feb 2018 11:47:30 +0100</pubDate><dc:creator>Jorge Aparicio</dc:creator></item><item><title>Experimenting with the New I/O Framework (in Rust) for embedded systems</title><link>http://pramode.in/2018/01/31/ti-launchpad-with-rust-new-io/</link><description><![CDATA[Notes on Code, by Pramode C.E]]></description><guid isPermaLink="false">d4191312-2442-4eb8-b313-67ba224829b6</guid><pubDate>Wed, 31 Jan 2018 00:00:00 -0500</pubDate><dc:creator>Pramode C.E</dc:creator></item><item><title>Rust 2018: Improving Safety and Ergonomics for Low-Level Programming - Bobbin Blog</title><link>http://www.bobbin.io/blog/post/rust_2018_low_level/</link><description><![CDATA[There’s been a lot written about what can be done to make Rust’s tooling, libraries and infrastructure better for embedded programming, but I’d like to cover a slightly different topic: what can be done to make Rust the language itself safer and easier to use for low-level programming?]]></description><guid isPermaLink="false">d2189bca-0b13-451d-b70c-70ec43f7a207</guid><pubDate>Fri, 26 Jan 2018 14:00:00 -0400</pubDate><dc:creator>Jonathan Soo</dc:creator></item><item><title>Rust 2018: Core, Embedded+SIMD, Intermesiate documenation, Async • r/rust</title><link>https://www.reddit.com/r/rust/comments/7syxw4/rust_2018_core_embeddedsimd_intermesiate/</link><description><![CDATA[Hi there! I'm Nico, and I've been lurking around these parts for about a year now. I thought I'd give my 2 cents on Rust's 2018 plans. Note: this...]]></description><guid isPermaLink="false">ae85973e-7540-4027-b53a-ee41a249d124</guid><pubDate>Thu, 25 Jan 2018 20:12:01 +0000</pubDate><dc:creator>Nico</dc:creator></item><item><title>Embedded Rust in 2018 - Embedded in Rust</title><link>http://blog.japaric.io/embedded-rust-in-2018/</link><description><![CDATA[A blog about Rust and embedded stuff]]></description><guid isPermaLink="false">a59a299c-28d1-4c41-9563-47faea69a0b7</guid><pubDate>Sun, 21 Jan 2018 22:10:38 +0100</pubDate><dc:creator>Jorge Aparicio</dc:creator></item><item><title>Embedded Rust in 2018</title><link>http://railwayelectronics.blogspot.com.au/2018/01/i-recently-picked-up-embedded-project.html</link><description><![CDATA[I recently picked up an embedded project that I hadn't touched for a few months, so I could add some new features. I was disappointed to not...]]></description><guid isPermaLink="false">f3f500d5-d108-4f83-808e-e15ad520cce7</guid><pubDate>Sun, 14 Jan 2018 00:00:00 +0000</pubDate><dc:creator>Jonathan Pallant</dc:creator></item><item><title>Pollen Robotics call for #Rust2018: toward stability on embedded systems</title><link>https://medium.com/pollenrobotics/rust-for-robotics-and-embedded-systems-in-2018-96e9be8464</link><description><![CDATA[Robotics developers face two main problems:]]></description><guid isPermaLink="false">c506e8b8-69f1-4f39-803a-6e3a34c06145</guid><pubDate>Fri, 12 Jan 2018 13:32:49 +0000</pubDate><dc:creator>Pierre Rouanet</dc:creator></item></channel></rss>