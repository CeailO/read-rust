<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/"><channel><title>Read Rust - All Posts</title><link>https://readrust.net/</link><description>All Posts posts on Read Rust</description><item><title>A Trick For Test Maintenance</title><link>https://matklad.github.io/2018/06/18/a-trick-for-test-maintenance.html</link><description><![CDATA[This is a post about an interesting testing technique which feels like it should be well known. However, I haven’t seen it mentioned anywhere. I don’t even have a good name for it, I’ve semi-discovered it in the wild. If you know how this thing is called, please leave a comment!]]></description><guid isPermaLink="false">4548e0ef-697b-414c-8bf5-9a63a707bafb</guid><pubDate>Mon, 18 Jun 2018 15:00:16 +0000</pubDate><dc:creator>Aleksey Kladov</dc:creator></item><item><title>Running Rust and FreeRTOS on the PADI IoT Stamp</title><link>https://medium.com/@ly.lee/running-rust-and-freertos-on-the-padi-iot-stamp-fb36c5ef4844</link><description><![CDATA[In this article we’ll explore a better way to build and test programs for microcontroller platforms. Specifically we’ll look at Rust, FreeRTOS and Visual Studio Code. And how I made them run on the PADI IoT Stamp.]]></description><guid isPermaLink="false">fb7909fb-5c7d-4360-a9fe-4620e04262d8</guid><pubDate>Mon, 18 Jun 2018 05:45:28 +0000</pubDate><dc:creator>Lup Yuen Lee</dc:creator></item><item><title>Rust + Diesel + GitLab + CI</title><link>https://noyez.gitlab.io/post/2018-06-15-rust-plus-diesel-plus-gitlab/</link><description><![CDATA[It is very straightforward to get Rust projects to build within a CI environment. This post is going to take that build process one small step further, we’re going to build a Rust project that uses the Diesel ORM. This adds a step of complexity since to compile a Diesel project you need to have a postgresql database accessible if you’re using the infer_schema!() macro.]]></description><guid isPermaLink="false">67f2f6f8-75f9-458c-969f-4bcbe9c0223f</guid><pubDate>Mon, 18 Jun 2018 00:00:00 +0000</pubDate><dc:creator>noyez</dc:creator></item><item><title>Listening and trust, part 3</title><link>http://aturon.github.io/2018/06/18/listening-part-3/</link><description><![CDATA[In this this post in the listening and trust series, I’m going to talk through one of the most intense discussions the Rust community has had: the module system changes that were part of last year’s ergonomics initiative.]]></description><guid isPermaLink="false">c81413e6-7dc3-4a06-95dc-846a2cfa268a</guid><pubDate>Mon, 18 Jun 2018 00:00:00 +0000</pubDate><dc:creator>Aaron Turon</dc:creator></item><item><title>Writing an OS in Rust: CPU Exceptions</title><link>https://os.phil-opp.com/cpu-exceptions/</link><description><![CDATA[In this post, we start exploring CPU exceptions. Exceptions occur in various erroneous situations, for example when accessing an invalid memory address or when dividing by zero. To catch them, we have to set up an interrupt descriptor table that provides handler functions. At the end of this post, our kernel will be able to catch breakpoint exceptions and to resume normal execution afterwards.]]></description><guid isPermaLink="false">e75667af-3d07-40cb-a610-4c7a6786064b</guid><pubDate>Sun, 17 Jun 2018 00:00:00 +0000</pubDate><dc:creator>Philipp Oppermann</dc:creator></item><item><title>Writing a Web API Client in Rust (Part 3)</title><link>https://theomn.com/rust-web-api-client-part-03/</link><description><![CDATA[The 3rd of a multi-part series where we build a small REST client for the Marvel Comics Web API using Rust. This time we focus on how to use the hyper and futures crates to make HTTP requests to a Web API, then use serde to parse JSON data from the response.]]></description><guid isPermaLink="false">4ebce195-067c-45fa-be45-7c589426953b</guid><pubDate>Sun, 17 Jun 2018 00:00:00 +0000</pubDate><dc:creator>Owen Nelson</dc:creator></item><item><title>C2Rust Demonstration</title><link>https://c2rust.com/</link><description><![CDATA[The C2Rust project is being developed by Galois and Immunant. This tool is able to translate most C modules into semantically equivalent Rust code. These modules are intended to be compiled in isolation in order to produce compatible object files. We are developing several tools that help transform the initial Rust sources into idiomatic Rust. ]]></description><guid isPermaLink="false">f12b593d-9a94-4571-8fe8-08ef5059d68f</guid><pubDate>Sun, 17 Jun 2018 00:00:00 +0000</pubDate><dc:creator>Galois and Immunant</dc:creator></item><item><title>Rust Is Not So Hairy</title><link>https://nevi.me/rust-is-not-so-hairy/</link><description><![CDATA[TL;DR I decided to learn Rust on my nth attempt. Writing small programs helped me get stuff done. I converted a Java gRPC service into Rust for comparison I'm super-impressed with Rust's low CPU and memory footprint.]]></description><guid isPermaLink="false">41722089-9cfe-413c-aa51-02c244fb4d67</guid><pubDate>Sat, 16 Jun 2018 14:05:48 +0000</pubDate><dc:creator>Neville</dc:creator></item><item><title>My Emacs Rust IDE</title><link>http://www.admintome.com/blog/my-emacs-rust-ide/</link><description><![CDATA[In this post, I will walk you through configuring an EMACS Rust IDE to get syntax highlighting and code completion for the Rust programming language.]]></description><guid isPermaLink="false">48c70c0e-5ce7-415b-8264-6e7a6dd02a8f</guid><pubDate>Sat, 16 Jun 2018 01:26:03 +0000</pubDate><dc:creator>Bill Ward</dc:creator></item><item><title>Dynamic Casting for Traits</title><link>http://idubrov.name/rust/2018/06/16/dynamic-casting-traits.html</link><description><![CDATA[In Rust, traits are a powerful tool to use polymorphism, both static and dynamic. I’m going to skip the basics about the traits and just link to another blog post with a good explanation about static and dynamic dispatch in Rust: Traits and Trait Objects in Rust.

Instead, I would like to do an experiment of making dynamic dispatch even more dynamic! Like in Java1.]]></description><guid isPermaLink="false">977aa3cd-7136-4d69-84ac-0c15c6396ae4</guid><pubDate>Sat, 16 Jun 2018 00:00:00 +0000</pubDate><dc:creator>Ivan Dubrov</dc:creator></item><item><title>Rust review: The match keyword</title><link>http://julio.meroh.net/2018/06/rust-review-match-keyword.html</link><description><![CDATA[A commonly-acclaimed feature of Rust is its match keyword: a “conditional on steroids”. match lets you take the value of an expression and compare it against a bunch of values—or, more generally, patterns.

As you write and read Rust, you will notice that this keyword is used everywhere because it’s the way to access certain types, like Option values or error codes.]]></description><guid isPermaLink="false">b5fe7539-f996-4c57-9fc1-5fa06b6a68b2</guid><pubDate>Fri, 15 Jun 2018 09:00:00 -0400</pubDate><dc:creator>Julio Merino</dc:creator></item><item><title>MIR-based borrow check (NLL) status update</title><link>http://smallcultfollowing.com/babysteps/blog/2018/06/15/mir-based-borrow-check-nll-status-update/</link><description><![CDATA[I’ve been getting a lot of questions about the status of “Non-lexical lifetimes” (NLL) – or, as I prefer to call it these days, the MIR-based borrow checker – so I wanted to post a status update.

The single most important fact is that the MIR-based borrow check is feature complete and available on nightly. What this means is that the behavior of #![feature(nll)] is roughly what we intend to ship for “version 1”, except that (a) the performance needs work and (b) we are still improving the diagnostics.]]></description><guid isPermaLink="false">c55b518c-125b-4fb9-82c5-08c3367bb6c6</guid><pubDate>Fri, 15 Jun 2018 00:00:00 -0700</pubDate><dc:creator>Niko Matsakis</dc:creator></item><item><title>Running Rust on the GPU with Accel</title><link>https://bheisler.github.io/post/rust-on-the-gpu-with-accel/</link><description><![CDATA[For the past month or so, I’ve been working on a follow-up to my series on Writing a Raytracer in Rust. This time around, I’ll be talking about writing a GPU-accelerated Path Tracer. As always, I’m writing it in Rust - including the GPU kernel code. Compiling Rust for GPUs at this point is difficult and error-prone, so I thought it would be good to start with some documentation on that aspect of the problem before diving into path tracing.]]></description><guid isPermaLink="false">e62fbda5-e357-4870-a483-9dcf833b31ad</guid><pubDate>Thu, 14 Jun 2018 19:00:00 -0600</pubDate><dc:creator>Brook Heisler</dc:creator></item><item><title>Writing an OS in Rust: Integration Tests</title><link>https://os.phil-opp.com/integration-tests/</link><description><![CDATA[In this post we complete the testing picture by implementing a basic integration test framework, which allows us to run tests on the target system. The idea is to run tests inside QEMU and report the results back to the host through the serial port.]]></description><guid isPermaLink="false">d8b1216b-bc74-43c1-9ce3-958e0e2b4154</guid><pubDate>Fri, 15 Jun 2018 00:00:00 +0000</pubDate><dc:creator>Philipp Oppermann</dc:creator></item><item><title>Conspiracies, Dissemination, and REST APIs</title><link>https://medium.com/@rippinrobr_66849/3-conspiracies-dissemination-and-rest-apis-41858f8d9850</link><description><![CDATA[Welcome to the third post in a series where I share my experience learning Rust. I’m building out a conspiracy theories API to help me get more familiar with Rust and have a little fun. Since I am new to Rust, I welcome all feedback, especially from developers who have been using Rust for quite some time. Leave a comment below or send your feedback via Twitter. Now it’s time to draw the blackout curtains, put on your foil-lined hat on and start serving up conspiracies from a REST API.]]></description><guid isPermaLink="false">36eccf86-2b85-4ffc-b7e7-7af422cb10ac</guid><pubDate>Thu, 14 Jun 2018 12:28:03 +0000</pubDate><dc:creator>Rob Rowe</dc:creator></item><item><title>What do you think are the most interesting/exciting projects using Rust?</title><link>https://www.ncameron.org/blog/interesting_projects/</link><description><![CDATA[Last week I tweeted "What do you think are the most interesting/exciting projects using Rust? (No self-promotion :-) )". The response was awesome! Jonathan Turner suggested I write up the responses as a blog post, and here we are.]]></description><guid isPermaLink="false">f6f3b55c-c39c-4366-9de1-ebf3b230ee6c</guid><pubDate>Wed, 13 Jun 2018 16:26:29 +0000</pubDate><dc:creator>Nick Cameron</dc:creator></item><item><title>Rust review: Expressions, expressions, expressions</title><link>http://julio.meroh.net/2018/06/rust-review-expressions.html</link><description><![CDATA[Rust resembles a functional language in many ways although it does not claim to be one. In fact, I have been thinking of Rust as a “pragmatic Haskell” or as a “well-balanced mixture between C++ and Haskell”.

One of the ways the functional aspects show up is via expressions and how pretty much any construct in Rust can be treated as an expression. But before we begin, a little warning: the examples below are, by no means, idiomatic Rust—I just hope they are simple enough to illustrate what I want to show.]]></description><guid isPermaLink="false">8e5085a4-0057-4ed8-81dc-93242e35b6e9</guid><pubDate>Tue, 12 Jun 2018 09:00:00 -0400</pubDate><dc:creator>Julio Merino</dc:creator></item><item><title>From Go to Rust - JSON and YAML</title><link>http://technosophos.com/2018/06/12/from-go-to-rust-json-and-yaml.html</link><description><![CDATA[One of Go's big selling points for me was its novel approach to JSON encoding. Learning about Rust's encoding has made me even more excited. In this post, we'll start with Go's JSON encoder, and then see how Rust does encoding. And we'll even through in some YAML!]]></description><guid isPermaLink="false">79d23f1b-0e7b-4d75-a061-9e5b9930424b</guid><pubDate>Tue, 12 Jun 2018 00:00:00 +0000</pubDate><dc:creator>Matt Butcher</dc:creator></item><item><title>Automatic Type Coercions with Procedural Macros in Rust</title><link>http://willcrichton.net/notes/automatic-type-coercions-macros-rust/</link><description><![CDATA[I briefly demonstrate how to use procedural macros to automatically perform type coercion in Rust, mimicking the behavior of dynamic languages.]]></description><guid isPermaLink="false">4749d178-b87d-4946-b8e2-0a6d17d7495e</guid><pubDate>Tue, 12 Jun 2018 00:00:00 +0000</pubDate><dc:creator>Will Crichton</dc:creator></item><item><title>Traits and Trait Objects in Rust</title><link>https://joshleeb.com/posts/rust-traits-and-trait-objects/</link><description><![CDATA[I’ve been really confused lately about Rust’s trait objects. Specifically when it comes to questions about the difference between &Trait, Box<Trait>, impl Trait, and dyn Trait.]]></description><guid isPermaLink="false">2b4b4efe-3a50-4ceb-ac4c-267b708c2ce8</guid><pubDate>Tue, 12 Jun 2018 00:00:00 +0000</pubDate><dc:creator>Josh Leeb-du Toit</dc:creator></item><item><title>actix – an actor framework for the Rust programming language</title><link>https://simplabs.com/blog/2018/06/11/actix.html</link><description><![CDATA[The “actor model” is the main primitive that powers the Erlang programming language and its descendant, Elixir. It describes a programming model that simplifies the development of concurrent and multi-threaded applications or even applications that run distributed on multiple machines.

The complexity of actors is relatively low, and that is because the complexity is usually hidden in the actor frameworks that are used to run these types of primitives in the end. One example of such an actor framework is actix, which we will have a closer look at now.]]></description><guid isPermaLink="false">a9263a5d-5853-4f5b-8556-28d18dda0f7d</guid><pubDate>Mon, 11 Jun 2018 00:00:00 +0000</pubDate><dc:creator>Tobias Bieniek</dc:creator></item><item><title>Tarpaulin Past Present Future</title><link>https://xd009642.github.io/2018/06/11/Tarpaulin-past-present-future.html</link><description><![CDATA[Tarpaulin (or cargo-tarpaulin) is a code coverage tool for Rust. Last year was pretty busy with the launch of the project and the rush of issues as people started to use it so this is just a chance to look at what’s new with version 0.6.0 and what’s planned for the rest of this year.]]></description><guid isPermaLink="false">27c8b7ed-32ab-4390-8be8-58678541dfb8</guid><pubDate>Mon, 11 Jun 2018 00:00:00 +0000</pubDate><dc:creator>xd009642</dc:creator></item><item><title>Actix::From(Rocket)</title><link>https://noyez.gitlab.io/post/2018-06-11-rocket-to-actix/</link><description><![CDATA[I was inspired by Nick’s post to migrate my code from Rocket to Actix. I have also been nagged by recent struggles with the nightly compiler and its compatibility with all the other crates that I use and other the platforms that I use; my code runs on 32⁄64 bit arm and 32⁄64 bit x86. When I started using Rocket around a year ago, the nightly compiler was just as stable as the stable compiler, but things have changed as rust is a growing eco system.

For me, once the differences below were addressed, porting the code was relatively straightforward. The vast majority of my code remained the same.]]></description><guid isPermaLink="false">70c7595e-f384-40d3-a8c9-9f00466fe5d5</guid><pubDate>Mon, 11 Jun 2018 00:00:00 +0000</pubDate><dc:creator>noyez</dc:creator></item><item><title>Design Guideline Problem Statement</title><link>https://vorner.github.io/2018/06/10/design-guideline-problem-statement.html</link><description><![CDATA[There were some heated discussions in Rust community as of late. During that discussions, I argued that some best practices for RFC authors would improve both on the results as well as the discussions and I promised to give it a try.]]></description><guid isPermaLink="false">afe4d926-caf9-4709-95f0-3bf0249b60e2</guid><pubDate>Sun, 10 Jun 2018 00:00:00 +0000</pubDate><dc:creator>Michal &apos;vorner&apos; Vaner</dc:creator></item><item><title>Where do Rust threads come from?</title><link>http://squidarth.com/rc/rust/concurrency/2018/06/09/rust-threads-detach.html</link><description><![CDATA[Last week, I wrote a post in which I discussed some of the things that I learned about Rust concurrency. One of the things that I pointed out was that when you spawn a thread within another thread, they both have the main process as their parent.]]></description><guid isPermaLink="false">34b26ba8-daa3-431f-ba53-9c0d9d873459</guid><pubDate>Sat,  9 Jun 2018 09:00:38 -0400</pubDate><dc:creator>Sid Shanker</dc:creator></item><item><title>To do a Rust GUI</title><link>https://www.vandenoever.info/blog/2018/06/09/to-do-a-rust-gui.html</link><description><![CDATA[Rust Qt Binding Generator lets you combine Rust code with a Qt1 graphical application. A previous blog shows how to make a simple clock. It’s a good idea to read that post before reading this more advanced post, because in this post we are getting serious.

This blog post shows how to write a to-do application. The data model is a list of to-do items. The source code for this example is available in the folder examples/todos in the Rust Qt Binding Generator repository.]]></description><guid isPermaLink="false">9448ee63-32da-42f1-bd2e-1ef737d9b971</guid><pubDate>Sat,  9 Jun 2018 00:00:00 +0000</pubDate><dc:creator>Jos van den Oever</dc:creator></item><item><title>First Impressions of the Rust Programming Language</title><link>http://jakob.space/blog/post/First+Impressions+of+the+Rust+Programming+Language</link><description><![CDATA[C is almost 50 years old, and C++ is almost 40 years old. While age is usually indicative of mature implementations with decades of optimization under their belts, it also means that the language's feature set is mostly devoid of modern advancements in programming language design. For that reason, you see a great deal of encouragement nowadays to move to newer languages - they're designed with contemporary platforms in mind, rather than working within the limitations of platforms like the PDP-11. Among said "new languages" are Zig, Myrddin, Go, Nim, D, Rust.. even languages like Java and Elixir that run on a virtual machine are occasionally suggested as alternatives to the AOT-compiled C and C++.

I have plans to look into the characteristics that distinguish each and every one of these new programming languages, learning them and documenting my first impressions in the form of blog posts. This post is the beginning of that adventure: my first impressions of Rust.]]></description><guid isPermaLink="false">4ab9c39f-72ed-4b84-a5e7-abe4c594c019</guid><pubDate>Fri,  8 Jun 2018 13:02:33 -0500</pubDate><dc:creator>Jakob</dc:creator></item><item><title>Rust review: Learning curve</title><link>http://julio.meroh.net/2018/06/rust-review-learning-curve.html</link><description><![CDATA[Writing Rust code is not restricted to programming gurus—but there is no denying that the learning curve is steeper than that of other languages. Or is it? In this post, I'll try to convince you that the curve does feel steep, but it isn't when taken into perspective.
Let's first start by stating that learning a language is not the same as learning its syntax. Learning a language involves learning the syntax, of course, but it also involves familiarizing oneself with its common idioms and grabbing a good sense of what the standard libraries provide.]]></description><guid isPermaLink="false">644f8b30-47a3-4da8-b4e9-1b72755d69b0</guid><pubDate>Fri,  8 Jun 2018 09:00:00 -0400</pubDate><dc:creator>Julio Merino</dc:creator></item><item><title>Rust Distilled: An Expressive Tower of Languages</title><link>https://arxiv.org/abs/1806.02693</link><description><![CDATA[Rust represents a major advancement in production programming languages because of its success in bridging the gap between high-level application programming and low-level systems programming. At the heart of its design lies a novel approach to ownership that remains highly programmable.

In this talk, we will describe our ongoing work on designing a formal semantics for Rust that captures how programmers can understand ownership and borrowing without trying to grasp the details of lifetime analysis.]]></description><guid isPermaLink="false">a07d66f5-dfd3-41d4-b2d8-16bf1b0f4886</guid><pubDate>Thu,  7 Jun 2018 00:00:00 +0000</pubDate><dc:creator>Aaron Weiss, Daniel Patterson, Amal Ahmed</dc:creator></item><item><title>Integrating QML and Rust: Creating a QMetaObject at Compile Time</title><link>https://woboq.com/blog/qmetaobject-from-rust.html</link><description><![CDATA[In this blog post, I would like to present a research project I have been working on: Trying to use QML from Rust, and in general, using a C++ library from Rust. The project is a Rust crate which allows to create QMetaObject at compile time from pure Rust code. It is available here: https://github.com/woboq/qmetaobject-rs]]></description><guid isPermaLink="false">f98c539d-bf5c-4329-a4b2-bba3c4816350</guid><pubDate>Thu,  7 Jun 2018 00:00:00 +0000</pubDate><dc:creator>Olivier Goffart</dc:creator></item><item><title>Modern Parser Generator</title><link>https://matklad.github.io/2018/06/06/modern-parser-generator.html</link><description><![CDATA[During the last couple of years, I’ve spent a lot of time writing parsers and parser generators, and I want to write down my thoughts about this topic. Specifically, I want to describe some properties of a parser generator that I would enjoy using. Note that this is not an “introduction to parsing” blog post, some prior knowledge is assumed.]]></description><guid isPermaLink="false">6f104d56-9b00-4748-a04f-0c77ec89a1d2</guid><pubDate>Wed,  6 Jun 2018 16:03:25 +0000</pubDate><dc:creator>Aleksey Kladov</dc:creator></item><item><title>RSoC: Porting tokio to redox - week 3</title><link>https://www.redox-os.org/news/rsoc-porting-tokio-3/</link><description><![CDATA[Last week I ended off stating that the redox netstack might soon switch to an edge-triggered model. Well, I ended up feeling bad about the idea of letting others do my work and decided to stop being lazy and just do it myself.]]></description><guid isPermaLink="false">54270fa0-69d3-4ec1-8aca-c77191e164e5</guid><pubDate>Wed,  6 Jun 2018 00:00:00 +0000</pubDate><dc:creator>jD91mZM2</dc:creator></item><item><title>A Rust-based Unikernel</title><link>https://hermitcore.org/2018/06/06/A-Rust-based-Unikernel/</link><description><![CDATA[Rust is an extremely interesting language for the development of system software. This was the motivation to evaluate Rust for HermitCore and to develop an experimental version of our libOS in Rust. Components like the IP stack and uhyve (our unikernel hypervisor) are still written in C. In addition, the user applications are still compiled by our cross-compiler, which is based on gcc and supports C, C++, Fortran, and Go. The core of the kernel, however, is now written in Rust and published at GitHub. Our experiences so far are really good and we are looking into possibly new Rust activities, e.g., the support for Rust’s userland.]]></description><guid isPermaLink="false">d70a58d9-d528-41e3-a91c-605c58465d45</guid><pubDate>Wed,  6 Jun 2018 00:00:00 +0000</pubDate><dc:creator>Stefan Lankes</dc:creator></item><item><title>Sponsor work on Rust!</title><link>http://aturon.github.io/sponsor/</link><description><![CDATA[This page is a first attempt at facilitating sponsorship. This is not an officially endorsed list, but it is a list of Rustaceans that I have personally vetted and sponsored, and encourage you to support. Each of them has a long, public history of impactful work in the community.]]></description><guid isPermaLink="false">16518cb2-ca9f-4b67-b4d3-bc9042a23ea2</guid><pubDate>Wed,  6 Jun 2018 00:00:00 +0000</pubDate><dc:creator>Aaron Turon</dc:creator></item><item><title>Rust review: Protect the data</title><link>http://julio.meroh.net/2018/06/rust-review-protect-the-data.html</link><description><![CDATA[The one thing that blew my mind about Rust is its approach to data sharing in concurrent situations.

I had always thought of mutexes as something that is easy to get wrong and was convinced that the use of a RAII pattern to prevent lock leaks never happen (like with Abseil’s MutexLock) was the panacea. (I’m a fan of RAII in C++ by the way, in case you haven’t noticed.)]]></description><guid isPermaLink="false">046762b0-c3da-4f38-8d4a-7bb515f73d4b</guid><pubDate>Tue,  5 Jun 2018 09:00:00 -0400</pubDate><dc:creator>Julio Merino</dc:creator></item><item><title>Why PhantomData</title><link>http://troubles.md/posts/why-phantomdata/</link><description><![CDATA[We’re not allowed to have a type parameter that goes unused. If we want to have a type that looks like the one above we have to add a marker to it like so: struct Tagged<T>(usize, PhantomData<T>);]]></description><guid isPermaLink="false">cebd59fa-c884-49cd-9de7-4da401e26642</guid><pubDate>Tue,  5 Jun 2018 13:41:30 +0200</pubDate><dc:creator>troubles.md</dc:creator></item><item><title>How to speed up the Rust compiler some more in 2018</title><link>https://blog.mozilla.org/nnethercote/2018/06/05/how-to-speed-up-the-rust-compiler-some-more-in-2018/</link><description><![CDATA[Since my last post, rustc-perf — the benchmark suite, harness and visualizer — has seen some improvements. First, some new benchmarks were added: cargo, ripgrep, sentry-cli, and webrender. Also, the parser benchmark has been removed because it was a toy program and thus not a good benchmark.]]></description><guid isPermaLink="false">9a7909ce-8831-4f06-b32e-55a4a3df9116</guid><pubDate>Tue,  5 Jun 2018 00:05:01 +0000</pubDate><dc:creator>Nicholas Nethercote</dc:creator></item><item><title>Announcing Rust 1.26.2</title><link>https://blog.rust-lang.org/2018/06/05/Rust-1.26.2.html</link><description><![CDATA[This patch release fixes a bug in the borrow checker verification of match expressions. This bug was introduced in 1.26.0 with the stabilization of match ergonomics. Specifically, it permitted code which took two mutable borrows of the bar path at the same time.]]></description><guid isPermaLink="false">901dde63-68f7-45d0-b161-cf585e47d266</guid><pubDate>Tue,  5 Jun 2018 00:00:00 +0000</pubDate><dc:creator>The Rust Core Team</dc:creator></item><item><title>The Future of Clippy (the Rust Linter)</title><link>https://manishearth.github.io/blog/2018/06/05/the-future-of-clippy-the-rust-linter/</link><description><![CDATA[We’ve recently been making lots of progress on future plans for clippy and I thought I’d post an update.]]></description><guid isPermaLink="false">2b743aaf-6ae4-4bda-8de9-6bef817e9a4d</guid><pubDate>Tue,  5 Jun 2018 00:00:00 +0000</pubDate><dc:creator>Manish Goregaokar</dc:creator></item><item><title>Crates.rs — a new, faster crate index website</title><link>https://crates.rs/index</link><description><![CDATA[Crates.rs, an alternative opinionated front-end to crates.io:

It’s fast.

All readmes are displayed whenever possible, and if there’s no or poor readme, doc comments are shown too.

It combines information from multiple sources, e.g. byline is a compact amalgamation of Cargo.toml, crates.io, and GitHub contributors, so you get an idea who wrote the code even if authors forgot to keep Cargo.toml up to date.

Crate popularity is displayed as top-N position in its most relevant category, e.g. “#5 in Cryptography”, which is more meaningful than absolute download numbers.

Optional dependencies display which feature or platform they’re for.

Version history is summarized to help see at a glance whether a crate gets regular updates and how often it has breaking changes.

Recognizes sys crates even if they’re not called -sys and shows when build.rs is used.

Category pages fit more crates on screen despite looking less cluttered and having easier to read descriptions.

All categories and their representative crates are right there on the homepage.

Syntax highlighting everywhere, including code blocks.

Everything works without JS and gets indexed by search engines, so I’m hoping the site will help find crates.]]></description><guid isPermaLink="false">01dd6aee-aa4b-46b9-a4dc-5d2550a96356</guid><pubDate>Mon,  4 Jun 2018 23:27:00 +0000</pubDate><dc:creator>Kornel</dc:creator></item><item><title>Safe Concurrency with Rust</title><link>http://www.squidarth.com/rc/rust/2018/06/04/rust-concurrency.html</link><description><![CDATA[Last week, I started learning Rust, and published a post about the “ownership” system. One of the places where Rust’s ownership system really shines is in threading and concurrency. Kevin and I decided to dig into this more on Friday, and did some work on the dining philosophers problem.

In this post I’ll be covering what we learned, and how the Rust compiler saves you from some scary concurrency issues.]]></description><guid isPermaLink="false">314ba2b8-5ace-4348-b96a-b704c628e2b3</guid><pubDate>Mon,  4 Jun 2018 09:00:38 -0400</pubDate><dc:creator>Sid Shanker</dc:creator></item><item><title>Optimising path tracing with SIMD</title><link>https://bitshifter.github.io/blog/2018/06/04/simd-path-tracing/</link><description><![CDATA[Following on from path tracing in parallel with Rayon I had a lot of other optimisations I wanted to try. In particular I want to see if I could match the CPU performance of @aras_p’s C++ path tracer in Rust. He’d done a fair amount of optimising so it seemed like a good target to aim for. To get a better comparison I copied his scene and also added his light sampling approach which he talks about here. I also implemented a live render loop mimicking his.]]></description><guid isPermaLink="false">019cfc86-4560-40cc-8619-30d04e30699b</guid><pubDate>Mon,  4 Jun 2018 00:00:00 +0000</pubDate><dc:creator>bitshifter</dc:creator></item><item><title>Async Methods II: object safety</title><link>https://boats.gitlab.io/blog/post/async-methods-ii/</link><description><![CDATA[Last time, we introduced the idea of async methods, and talked about how they would be implemented: as a kind of anonymous associated type on the trait that declares the method, which corresponds to a different, anonymous future type for each implementation of that method. Starting this week we’re going to look at some of the implications of that. The first one we’re going to look at is object safety.]]></description><guid isPermaLink="false">d4896054-d302-4629-8679-7456e1a741ef</guid><pubDate>Mon,  4 Jun 2018 00:00:00 +0000</pubDate><dc:creator>boats</dc:creator></item><item><title>Newtype Index Pattern</title><link>https://matklad.github.io//2018/06/03/newtype-index-pattern.html</link><description><![CDATA[Similarly to the previous post, we will once again add types to the Rust code which works perfectly fine without them. This time, we’ll try to improve the pervasive pattern of using indexes to manage cyclic data structures.]]></description><guid isPermaLink="false">e672721a-5577-4897-b440-619731384ac1</guid><pubDate>Sun,  3 Jun 2018 21:21:45 +0000</pubDate><dc:creator>Aleksey Kladov</dc:creator></item><item><title>Listening and trust, part 2</title><link>http://aturon.github.io/2018/06/02/listening-part-2/</link><description><![CDATA[In the previous post in this series, I recounted an early lesson for the Rust Core Team about working in the open. In this post, I want to talk about the delicate interplay between listening and trust when doing design in the open.]]></description><guid isPermaLink="false">c8e154fc-96f0-4c63-99fb-ba62c7cc689f</guid><pubDate>Sat,  2 Jun 2018 00:00:00 +0000</pubDate><dc:creator>Aaron Turon</dc:creator></item><item><title>The Secret Life of Cows</title><link>https://deterministic.space/secret-life-of-cows.html</link><description><![CDATA[A lot of people at RustFest Paris mentioned Cows – which may be surprising if you’ve never seen std::borrow::Cow!

Cow in this context stands for “Clone on Write” and is a type that allows you to reuse data if it is not modified. Somehow, these bovine super powers of Rust’s standard library appear to be a well-kept secret even though they are not new. This post will dig into this very useful pointer type by explaining why in systems programming languages you need such fine control, explain Cows in detail, and compare them to other ways of organizing your data.]]></description><guid isPermaLink="false">d8c6d9c0-38eb-4656-a28e-0125ca9e5cd1</guid><pubDate>Sat,  2 Jun 2018 00:00:00 +0200</pubDate><dc:creator>Pascal Hertleif</dc:creator></item><item><title>Rust review: The borrow checker</title><link>http://julio.meroh.net/2018/06/rust-review-borrow-checker.html</link><description><![CDATA[Aaaah, the borrow checker: the dreaded enemy lurking within the Rust compiler, ready to make its move to bring pain to your life by preventing your code from compiling. Or that’s what everyone seems to say, which is one of the reasons I put off learning Rust for so long. In reality… the borrow checker is a blessing, but it is true that getting past its gates is difficult at first.]]></description><guid isPermaLink="false">09d6be59-4bee-49e0-aa34-d43622422cb8</guid><pubDate>Fri,  1 Jun 2018 09:00:00 -0400</pubDate><dc:creator>Julio Merino</dc:creator></item><item><title>Infinite Negative Utility: The Rust Language and Special Cases</title><link>https://blog.infinitenegativeutility.com/2018/6/the-rust-language-and-special-cases</link><description><![CDATA[I first came across Rust back in 2010 or 2011, and it was a very different language than the one it is today, both syntactically and semantically. I remember at the time that newcomers would often complain loudly about the terse keywords—like the fact that the return keyword had been shortened to ret—and the omnipresent tildes scattered throughout the language like fallen leaves in autumn. My programming background was in functional languages—specifically in Scheme and Haskell—and I found this language fascinating, sitting in an interesting and unexplored place in the spectrum of programming languages and bringing something genuinely new to the table.]]></description><guid isPermaLink="false">19239f2e-41c0-44cb-8b3d-02199eaa57b1</guid><pubDate>Fri,  1 Jun 2018 00:00:00 +0000</pubDate><dc:creator>Getty Ritter</dc:creator></item><item><title>Tricking the HashMap</title><link>https://idubrov.github.io/rust/2018/06/01/tricking-the-hashmap.html</link><description><![CDATA[Is it possible to find something in a hashmap if the key you are looking for is not exactly the same as the one you put into that hashmap? At first glance, this might not make any sense at all. The whole purpose of a hashmap is to store something under some key and then look it up using the same key. Right?]]></description><guid isPermaLink="false">ab635755-efd4-432a-8407-7b1c94649f8f</guid><pubDate>Fri,  1 Jun 2018 00:00:00 +0000</pubDate><dc:creator>Ivan Dubrov</dc:creator></item><item><title>Assignment Semantics in Python, JavaScript, Java, C++, and Rust</title><link>https://www.apress.com/us/blog/all-blog-posts/assignment-semantics/15805464</link><description><![CDATA[What happens when a data collection is copied and then the new copy is changed? Does the original remain the same, or does it change too?

If you think of copying as creating a completely new object, of course you expect that any change to the new copy does not affect the original object. But if you think of copying as creating a new name for the same, single object, then you expect that any change to the object through the new name appears also when you access the same object through the old name.

Let's see how is the behavior of Python, Javascript, Java, C++, and Rust regarding the assignment operator ("=") between collection variables.]]></description><guid isPermaLink="false">80930880-f4a9-4485-b372-648928490dca</guid><pubDate>Fri,  1 Jun 2018 00:00:00 +0000</pubDate><dc:creator>Carlo Milanesi</dc:creator></item><item><title>hyper v0.12</title><link>http://seanmonstar.com/post/174480374517/hyper-v012</link><description><![CDATA[Today sees the release of hyper v0.12.0, a fast and correct HTTP library for the Rust language.

This release adds support for several new features, while taking the opportunity to fix some annoyances, and improve the extreme speeds!]]></description><guid isPermaLink="false">9bf3f488-ace2-43b6-9f6b-3071241f7ed2</guid><pubDate>Fri,  1 Jun 2018 00:00:00 +0000</pubDate><dc:creator>Sean McArthur</dc:creator></item><item><title>HTTP Crate with URL Support &amp; a Simple HTTP Client</title><link>https://pyfisch.org/blog/http-with-url/</link><description><![CDATA[While the http crate generally has a great API I have been unsatisfied how it handles URLs. To create a HTTP request a full URL is needed with a scheme (http/https), authority (example.org) and a path (/search?q=rust) but http does enforce this and allows you to only state the path. This means both clients and servers are either unable to determine protocol and and authority information or have to do this manually.]]></description><guid isPermaLink="false">d7340b81-5e94-4123-b830-c5cbbfa154d2</guid><pubDate>Fri,  1 Jun 2018 00:00:00 +0000</pubDate><dc:creator>Pyfisch</dc:creator></item><item><title>Fishing in an Abyss: Building a Password Cracker in Rust</title><link>https://sts10.github.io//2018/05/31/1password-cracking-challenge.html</link><description><![CDATA[Ahead of this year’s World Password Day, 1Password – maker of password management software – announced a password cracking challenge. The company ostensibly wanted to find out how hard it would be to crack a three-word passphrase master password on one of their vaults, assuming that the attacker had the derived hash of the passphrase.]]></description><guid isPermaLink="false">e0e1ff6c-452a-442e-a3d5-93203569fa58</guid><pubDate>Thu, 31 May 2018 23:28:50 +0000</pubDate><dc:creator>Sam Schlinkert</dc:creator></item><item><title>Fear not the Rust Borrow Checker</title><link>http://www.squidarth.com/rc/rust/2018/05/31/rust-borrowing-and-ownership.html</link><description><![CDATA[I spent pretty much the whole day banging my head against the wall trying to figure out how ownership and borrowing work in Rust, and finally have a grasp on what’s going on.

In this post I’m going to demonstrate how these concepts work through some examples of code that break Rust’s rules, and explain why they’re problematic. I assume very little knowledge of the Rust programming language. I’ve also added comments to all of the code blocks that indicate whether the code is valid Rust or not.]]></description><guid isPermaLink="false">1f808812-4e70-4dcb-90a0-c45964863cd5</guid><pubDate>Thu, 31 May 2018 12:00:38 -0400</pubDate><dc:creator>Sid Shanker</dc:creator></item><item><title>Writing a Simple Github Webhook Responder With actix-web</title><link>http://danielwelch.github.io/rust-web-service.html</link><description><![CDATA[Creating a simple web service for automating Travis builds across repositories using actix-web and Github webhooks.]]></description><guid isPermaLink="false">86c89dda-a4f0-45bd-a0d0-616b8d687957</guid><pubDate>Thu, 31 May 2018 11:05:00 -0400</pubDate><dc:creator>Daniel Welch</dc:creator></item><item><title>Async Methods I: generic associated types</title><link>https://boats.gitlab.io/blog/post/async-methods-i/</link><description><![CDATA[Async/await continues to move along swimmingly. We’ve accepted an RFC describing how the async/await syntax will work in Rust, and work is underway on implementing support for it in the compiler. We’re hopeful that users will be able to start experimenting with the syntax on nightly by early July.

The RFC for async/await didn’t address one important thing: async methods. It is very important for people defining libraries to be able to define traits that contain async functions, like this:]]></description><guid isPermaLink="false">d5a4da56-2e7e-4f30-bd1a-d0211958a00a</guid><pubDate>Thu, 31 May 2018 00:00:00 +0000</pubDate><dc:creator>boats</dc:creator></item><item><title>My Rust Story</title><link>https://ricky.hosfelt.io/blog/rust_reach.html</link><description><![CDATA[With #RustReach starting soon I have ran into a few "My Rust Story" posts. My path to Rust certainly is not typical (I studied HR Management in undergrad…).

The journey really started for me back in middle/high school as I was very interested in video games, computers, and how things worked. So with a few friends started a computer repair "business" that serviced the local (Western Pennsylvania) area. By the time my sophomore year of highschool rolled around we had lined up a few of the parents who owned local businesses/churches and were doing some pretty serious consulting/maintenance for our ages (also installing Halo and Half-life 2: Deathmatch on the school's servers...).]]></description><guid isPermaLink="false">469533e2-7193-41b3-a754-adb5281e276f</guid><pubDate>Thu, 31 May 2018 00:00:00 +0000</pubDate><dc:creator>Ricky Hosfelt</dc:creator></item><item><title>Learning Rust — Conspiracies, Databases, and Diesel.rs</title><link>https://medium.com/@rippinrobr_66849/2-conspiracies-databases-and-diesel-rs-ac1d8d3499b3</link><description><![CDATA[This post is the second in a series of posts where I share my experience learning Rust. I’m building out a conspiracy theories API to help me get more familiar with Rust and to have a little fun. Since I am new to Rust, I welcome any and all feedback, especially from developers who have been using Rust for quite some time, leave a comment below or contact me on Twitter. With that out of the way, it is time to put your foil lined hat on and start storing the conspiracies in a database.]]></description><guid isPermaLink="false">325fc83d-bba5-48c8-8443-fdd5dd21f8ed</guid><pubDate>Wed, 30 May 2018 21:04:06 +0000</pubDate><dc:creator>Rob Rowe</dc:creator></item><item><title>RSoC: Porting Redox to AArch64 - 0x01</title><link>https://www.redox-os.org/news/rsoc-arm64-0x01/</link><description><![CDATA[A first calendar entry to describe my attempt on ARM64 support in Redox OS. Specifically, looking into the Raspberry Pi2/3(B)/3+ (all of them having a Cortex-A53 ARMv8 64-bit microprocessor, although for all my experiments I am going to use the Raspberry Pi 3(B)).]]></description><guid isPermaLink="false">49d19c19-5c1c-4a2e-9b5f-fa17c81e2ed3</guid><pubDate>Wed, 30 May 2018 00:00:00 +0000</pubDate><dc:creator>wizofe</dc:creator></item><item><title>Mutagen - An Inopportune Consumption</title><link>https://llogiq.github.io/2018/05/30/inop.html</link><description><![CDATA[I just failed to implement what looked to be a relatively simple opportunistic replacement so that the compiler would accept the mutated code. But I’m getting ahead of myself.]]></description><guid isPermaLink="false">aea72b83-8f56-4c8d-a9d7-c88fded0cfc7</guid><pubDate>Wed, 30 May 2018 00:00:00 +0000</pubDate><dc:creator>Llogiq</dc:creator></item><item><title>Rust review: Immutable by default</title><link>http://julio.meroh.net/2018/05/rust-review-immutable-by-default.html</link><description><![CDATA[Let’s start the deep dive by looking into a powerful feature of Rust: all variables and references are immutable by default unless qualified with mut.
To understand why this is important, let’s cover some context first. One of my pet peeves when reviewing C++ code is to ask authors to sprinkle the const qualifier everywhere: if something ain’t mutated, say so explicitly. This includes marking local variables, function arguments, function return values, class attributes, etc.]]></description><guid isPermaLink="false">d9877c7d-7175-490d-89a8-46fad05d9903</guid><pubDate>Tue, 29 May 2018 09:00:00 -0400</pubDate><dc:creator>Julio Merino</dc:creator></item><item><title>Evolving Rust</title><link>https://blog.shivoa.net/2018/05/evolving-rust.html</link><description><![CDATA[When you're just building some very basic tool programs, I'd probably not even think about threading in C, but here it is so easy that I've been quick to drop a (for example, typically) 30ms loop down to 3.5ms. One of the things I've been somewhat missing is easy access to SIMD intrinsics, but this brings me to something else I've been enjoying this year: Rust is evolving.]]></description><guid isPermaLink="false">da46cfde-97b2-4e16-9e08-4308a34d6826</guid><pubDate>Tue, 29 May 2018 12:11:00 +0100</pubDate><dc:creator>Shivoa Birch</dc:creator></item><item><title>RSoC: Implementing a FAT32 Filesystem in Redox</title><link>https://www.redox-os.org/news/rsoc-fat32-1/</link><description><![CDATA[This is a blog post about the work which I have done so far in implementing a FAT32 filesystem in Redox. Currently the Redox bootloader as well as the userspace filesystem daemon supports only RedoxFS.]]></description><guid isPermaLink="false">b9a686f1-3136-4307-a6ac-0f596babc6b5</guid><pubDate>Tue, 29 May 2018 00:00:00 +0000</pubDate><dc:creator>Deepak Sirone</dc:creator></item><item><title>Announcing Rust 1.26.1</title><link>https://blog.rust-lang.org/2018/05/29/Rust-1.26.1.html</link><description><![CDATA[A couple of issues were found in 1.26.0 which were deemed sufficient for a patch release.

A quick summary of the changes:

RLS no longer interferes with command line builds
Rustfmt stopped badly formatting text in some cases
Returning from main via impl Trait where the Trait is not Termination is no longer permitted
::<> (turbofish) no longer works for method arguments whose type is impl Trait

NaN > NaN no longer returns true in const contexts
rustup should no longer fail due to missing documentation on some platforms]]></description><guid isPermaLink="false">ae63f930-3568-433f-b8e6-35feb516b4c2</guid><pubDate>Tue, 29 May 2018 00:00:00 +0000</pubDate><dc:creator>The Rust Core Team</dc:creator></item><item><title>Exploring Rust fat pointers</title><link>https://iandouglasscott.com/2018/05/28/exploring-rust-fat-pointers/</link><description><![CDATA[Beware that at any point the code here may stop compiling, segfault, and otherwise behave in weird ways, some of which involve Velociraptors.

Now that that’s out of the way, what is a fat pointer anyway? All pointers are the same right? Just a number indicating an address in memory. Well, yes and no.]]></description><guid isPermaLink="false">95a6f9d4-dcfa-4b20-8ee7-f240cde435b1</guid><pubDate>Mon, 28 May 2018 02:46:00 -0700</pubDate><dc:creator>Ian Douglas Scott</dc:creator></item><item><title>Gfx, windows, and resizing</title><link>https://falseidolfactory.com/2018/05/28/gfx-windows-and-resizing.html</link><description><![CDATA[These early posts will mostly be me trying to work out how to use gfx-rs. I was previously using glium which is fantastic, but is sadly no longer being developed. So my choices are: Learn Vulkan, Use raw OpenGL bindings, Use gfx.

I opted to use the current released version (v0.17.1) but it’s currently undergoing a significant rearchitecture so I may move to that whenever it releases.]]></description><guid isPermaLink="false">9f6686d4-a03b-4420-82b0-e2c66b8b5e11</guid><pubDate>Mon, 28 May 2018 00:00:00 +0100</pubDate><dc:creator>Mistodon</dc:creator></item><item><title>The Go Developer&apos;s Quickstart Guide to Rust</title><link>http://technosophos.com/2018/05/27/the-go-developers-quickstart-guide-to-rust.html</link><description><![CDATA[As the co-author of Go in Practice, I have felt a certain obligation to Go. But I'm ready for a change. Rust topped the satisfaction survey in Stack Overflow's survey of languages (screenshot above). I've decided to give it a try. While Go and Rust are often compared, they are remarkably different languages.

Coming from a Go background, there are things about Rust that feel very natural, and things (like memory management) that feel utterly foreign. And so as I learn Rust, I am cataloging how it feels for a Go programmer. And rather than leading others to "dive in at the deep end" as I did (when I tried to write a full web service), I decided to approach Rust by starting with similarities and working toward differences.]]></description><guid isPermaLink="false">1572c586-709c-44a9-9232-ae4d3b9466ec</guid><pubDate>Sun, 27 May 2018 00:00:00 +0000</pubDate><dc:creator>Matt Butcher</dc:creator></item><item><title>TensorScript Type Inference: Hindley-Milner in Rust</title><link>http://rickyhan.com/jekyll/update/2018/05/26/hindley-milner-tutorial-rust.html</link><description><![CDATA[Type-inferred gradually typed languages are a joy to use: easy to write, analyze, and refactor. In this blog post, I will showcase to the other dozen of programmers who are interested in the obscure art of programming language type inference.]]></description><guid isPermaLink="false">bfb80762-37e6-4337-83c9-52f371839e60</guid><pubDate>Sat, 26 May 2018 04:00:00 +0000</pubDate><dc:creator>Ricky Han</dc:creator></item><item><title>Rust review: Introduction</title><link>http://julio.meroh.net/2018/05/rust-review-introduction.html</link><description><![CDATA[I had been meaning to learn Rust since I first toyed with Go a couple of years ago. During this period, I’ve written a non-trivial amount of Go code both inside and outside Google, but never found the chance to sit back and learn Rust.

This changed a month ago during my yearly family trip to Korea. This time around, I decided upfront that I would not work on any personal or work projects for the 2-week long vacation. Instead, I would focus all spare time in reading. And I would read “The Rust Programming Language”, second edition. The plan worked: getting through the book took the two weeks and I barely wrote any code.]]></description><guid isPermaLink="false">d25787d1-089e-4455-ac6a-1183548d48cd</guid><pubDate>Fri, 25 May 2018 09:00:00 -0400</pubDate><dc:creator>Julio Merino</dc:creator></item><item><title>Fuzz testing in Rust with Cargo-fuzz</title><link>https://medium.com/@seasoned_sw/fuzz-testing-in-rust-with-cargo-fuzz-13b89feecc30</link><description><![CDATA[In this post, I go through how I added the first automated fuzz test for my hobby project Hat — a snapshotting backup system written in Rust. I’ll briefly go through what a fuzz test is and how it works. In a follow-up post, I will share how I made the test more effective by running it through Seasoned Software.]]></description><guid isPermaLink="false">e0370259-0204-491d-9bd1-3769a682f6e1</guid><pubDate>Fri, 25 May 2018 10:08:45 +0000</pubDate><dc:creator>Seasoned Software</dc:creator></item><item><title>Bobbin SDK: Richer Hardware Abstractions for Embedded Systems Programming</title><link>http://www.bobbin.io/blog/post/bobbin_sdk_richer_hardware/</link><description><![CDATA[Bobbin SDK is a suite of tools and code that has been used in embedded development projects running on a variety of ARM Cortex-M MCUs over the last year and a half. It exists to bridge the gap between the existing Rust ecosystem centered around svd2rust and rich but proprietary vendor SDKs.]]></description><guid isPermaLink="false">df7df3a9-1519-4453-963e-fb69d766798d</guid><pubDate>Fri, 25 May 2018 00:00:00 +0000</pubDate><dc:creator>Jonathan Soo</dc:creator></item><item><title>Listening and trust, part 1</title><link>http://aturon.github.io/2018/05/25/listening-part-1/</link><description><![CDATA[For me, most weeks working on Rust are fun — exhilarating, even. But, just like with anything else, some weeks are hard.

As this week draws to a close, I feel troubled. On the one hand, things are looking strong for the 2018 Edition (which I want to write more about soon). But on the other hand, this week I locked two RFC threads, flagged a bunch of comments for moderation, and generally absorbed a lot of emotion from a lot of different quarters of the community. There’s a sense of simmering distrust.]]></description><guid isPermaLink="false">8e49045f-dc48-4471-bc83-353183d6c4f8</guid><pubDate>Fri, 25 May 2018 00:00:00 +0000</pubDate><dc:creator>Aaron Turon</dc:creator></item><item><title>Mix Rust Code (WebAssembly) with Vue Component</title><link>https://busy.org/@drsensor/mix-rust-code-webassembly-with-vue-component-basic</link><description><![CDATA[In this tutorials, we will try mixing Rust code with Javascript by compiling Rust code as .wasm then use it in Vue Component.]]></description><guid isPermaLink="false">342c3a2c-88a7-4e26-a6ea-97c3257daf2d</guid><pubDate>Thu, 24 May 2018 19:01:00 +0000</pubDate><dc:creator>drsensor</dc:creator></item><item><title>Typed Key Pattern</title><link>https://matklad.github.io/2018/05/24/typed-key-pattern.html</link><description><![CDATA[In this post, I’ll talk about a pattern for extracting values from a weakly typed map. This pattern applies to all statically typed languages, and even to dynamically typed ones, but the post is rather Rust-specific.]]></description><guid isPermaLink="false">5b8ae1bc-5625-4115-ab3a-3f399e157314</guid><pubDate>Thu, 24 May 2018 10:18:13 +0000</pubDate><dc:creator>Aleksey Kladov</dc:creator></item><item><title>A shared, mutable ecosystem</title><link>https://kodraus.github.io/rust/2018/05/23/a-shared-mutable-ecosystem.html</link><description><![CDATA[Ownership is a fundamental piece of Rust’s story. It amounts to a tight set of rules about who owns a value in a program, how that value can be aliased and mutated, and when that value is dropped. It prevents shared mutable state, which is the root cause of major bugs in software written without the same guarantees.

In this post I’d like to talk about a different kind ownership in though. I’d like to talk about ownership of libraries in the Rust ecosystem and the problem of sustainable maintainership.]]></description><guid isPermaLink="false">e1fd2a84-e451-4299-9327-eb39f3a1ca8f</guid><pubDate>Wed, 23 May 2018 21:49:12 +0000</pubDate><dc:creator>Ashley Mannix</dc:creator></item><item><title>Neural networks on a micro controller - Preparation and math</title><link>http://trangar.blogspot.com.au/2018/05/neural-networks-on-micro-controller.html?m=1</link><description><![CDATA[I've been playing around with the idea of running a neural network on a micro controller. This project is not designed to be the most efficient neural network, but rather one that runs on a micro controller with very limited resources.]]></description><guid isPermaLink="false">4c0ea01d-c011-49aa-b6a6-10178e03c627</guid><pubDate>Wed, 23 May 2018 10:04:00 -0700</pubDate><dc:creator>Trangar</dc:creator></item><item><title>impl Trait in Rust explanation</title><link>https://medium.com/@iopguy/impl-trait-in-rust-explanation-efde0d94946a</link><description><![CDATA[In Rust 1.26 a new feature called impl Trait was stabilized. How does it work? Instead of specifying an exact type, you can say that your function either returns or takes something that implements a trait.]]></description><guid isPermaLink="false">80818d94-c29b-47b1-8307-f5c9e1d03808</guid><pubDate>Wed, 23 May 2018 04:37:08 +0000</pubDate><dc:creator>Igor Polyakov</dc:creator></item><item><title>Wicked Fast Web Servers in Rust</title><link>https://medium.com/@MertzAlertz/wicked-fast-web-servers-in-rust-4947688426bc</link><description><![CDATA[I write code for the web every day, and as such, I naturally wanted to find a web server that I could write some beautiful code in Rust with. There are a few options out there, Actix, Rocket, but none of them are quite as simple and succinct as KoaJS for node. As such, I wanted to write something as simple as Koa and as performant as a Rust framework, and I did. With that, I give you Thruster, an elegant, performant, web server written in Rust.]]></description><guid isPermaLink="false">4b44fb81-4b16-4681-a09a-a93cb82ccbc0</guid><pubDate>Tue, 22 May 2018 23:26:19 +0000</pubDate><dc:creator>Pete Mertz</dc:creator></item><item><title>Moving out of a Drop struct in Rust?</title><link>http://phaazon.netkblog/rust-no-drop</link><description><![CDATA[Rust doesn’t allow you to move out of a value which type implements Drop, and this is quite logical. When Foo::take returns, because of self going out of scope, it must call its Drop::drop implementation. If you have moved out of it – both a: A and b: B fields, the Drop::drop implementation is now a complete UB. So Rust is right here and doesn’t allow you to do this.

But imagine that we have to do this. For insance, we need to hand over both the scarce resources a and b to another struct (in our case, a (A, B), but you could easily imagine a better type for this).

There’s a way to, still, implement Foo::take with Foo implementing Drop. Here’s how:]]></description><guid isPermaLink="false">7518f181-39ba-4c9c-a76d-1a07b697d264</guid><pubDate>Tue, 22 May 2018 22:22:00 +0000</pubDate><dc:creator>Dimitri Sabadie</dc:creator></item><item><title>RustFest Paris Workshop: Fastware</title><link>http://troubles.md/posts/rustfest-2018-workshop/</link><description><![CDATA[It’s often said1 that the slowest code is that which has been optimised without benchmarks. You wouldn’t expect your code to work if you never ran it, so why should you expect it to be fast if you never benchmarked it? Writing good benchmarks is a bit of an art, because it’s really easy to accidentally write benchmarks that make your code seem fast, when really the compiler is applying some optimisations that work in the side-effect-free world of the benchmark but can no longer get applied when you put it out into the wild.]]></description><guid isPermaLink="false">cb90dbcf-0621-4e96-83ca-62deac7e8a3d</guid><pubDate>Tue, 22 May 2018 11:22:48 +0200</pubDate><dc:creator>troubles.md</dc:creator></item><item><title>Snowhash in Rust with WASM</title><link>https://joshleeb.com/posts/rust-wasm-snowhash/</link><description><![CDATA[A little while ago I came across this Snowflake generator. It’s a project by Raph Levein that takes a hash string and uses it to procedurally generate a unique snowflake. He explains that the original motivation was as a cryptographically secure visual hash, so that people would reliably be able to tell by visual inspection whether two hashes were identical. I thought that was a pretty cool idea.]]></description><guid isPermaLink="false">e67229c7-9d09-49e8-9558-ca8e89a53d4f</guid><pubDate>Tue, 22 May 2018 00:00:00 +0000</pubDate><dc:creator>Josh Leeb-du Toit</dc:creator></item><item><title>Implement Raft in Rust</title><link>https://pingcap.com/blog/implement-raft-in-rust/</link><description><![CDATA[Consensus is one of the most important challenges in designing and building distributed systems–how to make sure multiple nodes (or agents, processes, threads, tasks, participants, etc.) in a group agree on a specific value proposed by at least one of the nodes. As an open-source distributed scalable HTAP database, TiDB uses the Raft Consensus Algorithm in its distributed transactional key-value storage engine, TiKV, to ensure data consistency, auto-failover, and fault tolerance.]]></description><guid isPermaLink="false">91a4f766-391d-43fc-a2ce-66354ac78bd4</guid><pubDate>Tue, 22 May 2018 00:00:00 +0000</pubDate><dc:creator>Siddon Tang</dc:creator></item><item><title>Oblix: An Efficient Oblivious Search Index [pdf]</title><link>https://people.eecs.berkeley.edu/~raluca/oblix.pdf</link><description><![CDATA[Abstract—Search indices are fundamental building blocks of many systems, and there is great interest in running them on encrypted data. Unfortunately, many known schemes that enable search queries on encrypted data achieve efficiency at the expense of security, as they reveal access patterns to the encrypted data.  In this paper we present Oblix, a search index for encrypted data that is oblivious (provably hides access patterns), is dynamic (supports inserts and deletes), and has good efficiency.  Oblix relies on a combination of novel oblivious-access tech- niques and recent hardware enclave platforms (e.g., Intel SGX).  In particular, a key technical contribution is the design and implementation of doubly-oblivious data structures, in which the client’s accesses to its internal memory are oblivious, in addition to accesses to its external memory at the server. These algorithms are motivated by hardware enclaves like SGX, which leak access patterns to both internal and external memory.  We demonstrate the usefulness of Oblix in several applications: private contact discovery for Signal, private retrieval of public keys for Key Transparency, and searchable encryption that hides access patterns and result sizes.]]></description><guid isPermaLink="false">e2724828-a6e9-4383-9614-bea31e743784</guid><pubDate>Mon, 21 May 2018 00:00:00 +0000</pubDate><dc:creator>Pratyush Mishra, Rishabh Poddar, Jerry Chen, Alessandro Chiesa, Raluca Ada Popa</dc:creator></item><item><title>RSoC: Porting tokio to Redox</title><link>https://www.redox-os.org/news/rsoc-porting-tokio-to-redox/</link><description><![CDATA[This is the weekly summary for my Redox Summer of Code project: Porting tokio to redox. Most of the time was spent on one bug, and after that one was figured out and fixed it ended up being relatively easy! As of now, 11⁄13 tokio examples seem to work on redox. The remaining examples are UDP and seem to fail because of something either with the rust standard library or my setup.]]></description><guid isPermaLink="false">4c951443-54b3-4187-8791-b27502ff193b</guid><pubDate>Mon, 21 May 2018 00:00:00 +0000</pubDate><dc:creator>jD91mZM2</dc:creator></item><item><title>Migrating to Actix Web from Rocket for Stability</title><link>https://nbsoftsolutions.com/blog/migrating-to-actix-web-from-rocket-for-stability</link><description><![CDATA[I previously wrote an article back in November 2017: Replacing Elasticsearch with Rust and SQLite. In it, I needed to create a few HTTP endpoints that ingested JSON, perform a database lookup, and return JSON. Very simple. No query / path parameters, authentication, authorization, H2, or TLS. I didn’t understand how stability was such an important feature. I was familiar with needing new versions of the nightly compiler to stay current with clippy and rustfmt, but it was a blindspot when it came to dependencies.<Paste>]]></description><guid isPermaLink="false">35d0dec8-e4fb-4be0-b87c-ed5dd39056b8</guid><pubDate>Mon, 21 May 2018 00:00:00 +0000</pubDate><dc:creator>Nick Babcock</dc:creator></item><item><title>Creating a Rusty Rocket fuelled with Diesel</title><link>https://lankydanblog.com/2018/05/20/creating-a-rusty-rocket-fuelled-with-diesel/</link><description><![CDATA[Here I go with my first post that fully focuses on Rust. After spending a few months doing a bit here and there I decided to just dive right in as I was going through the Rust book at too slow a pace to keep myself interested. So, in this post I decided to write about setting up a simple REST API which is something that I have done in Java plenty of times but with Rust it is a different story.]]></description><guid isPermaLink="false">f993c9a2-3b8e-455b-ad6e-354051f38863</guid><pubDate>Sun, 20 May 2018 17:53:11 +0000</pubDate><dc:creator>Dan Newton</dc:creator></item><item><title>Rust is Incredibly Productive for CLIs</title><link>https://www.chriskrycho.com/2018/rust-is-incredibly-productive-for-clis.html</link><description><![CDATA[I built a little tool in Rust to convert an Evernote export file to Markdown. It was impressively easy.]]></description><guid isPermaLink="false">d2971f3f-a40d-45c9-a544-ed94f3b962f6</guid><pubDate>Sun, 20 May 2018 08:35:00 -0400</pubDate><dc:creator>Chris Krycho</dc:creator></item><item><title>madparts-rs 1.0 release</title><link>https://damad.be/joost/blog/madparts-rs-1-0-release.html</link><description><![CDATA[Back in Februari 2013 then coworker Romain S. showed me the new trend of programming editors that do continuous compilation while you type, showing you immediate feedback on your code. In parallel I also worked on 3D modeling for my 3D printer using the OpenSCAD program. OpenSCAD works by writing code in its custom language and then have it rendered. I had this idea of combining these two approaches to make an electronics footprint generator. And so the development of the original madparts program started. In August 2016 I had been playing with the then pretty new rust programming language and decided a rewrite in it and simplifying the program even further would be fun to do.]]></description><guid isPermaLink="false">e81240c1-c783-4113-9df8-27755677e929</guid><pubDate>Sun, 20 May 2018 00:00:00 +0000</pubDate><dc:creator>Joost Yervante Damad</dc:creator></item><item><title>Rust for Android games using SDL2</title><link>https://lliwynd.blogspot.com.au/2018/05/rust-for-android-games-using-sdl2.html</link><description><![CDATA[I've been wanting to write a simple Android game for my daughter, and decided to use it as an excuse to learn Rust.  Thus began an odyssey.

I'll ignore the game itself in this post in favour of describing how to get a simple Rust on Android game environment.  For my game I didn't want anything fancy - I wanted to load some jpg files and blit rectangles from those textures to the screen.  But I don't know OpenGL, and I don't really feel the need to learn for this project - if I hit the need to use a shader, then I backtracked and tried another approach.  The plan was to get a simple, high-level graphics API for Rust running on Android.]]></description><guid isPermaLink="false">6e5c626c-f240-41fa-9520-a3d5586523b3</guid><pubDate>Sat, 19 May 2018 16:15:00 +1000</pubDate><dc:creator>William Uther</dc:creator></item><item><title>Writing a Web API Client in Rust (Part 2)</title><link>https://theomn.com/rust-web-api-client-part-02/</link><description><![CDATA[The 2nd of a multi-part series where we build a small REST client for the Marvel Comics Web API using Rust. This time we focus on how to use the hyper and futures crates to make HTTP requests to a Web API, then use serde to parse JSON data from the response.]]></description><guid isPermaLink="false">502f20f5-50e1-4741-a852-2c65ef867bba</guid><pubDate>Sat, 19 May 2018 00:00:00 +0000</pubDate><dc:creator>Owen Nelson</dc:creator></item><item><title>A boolean&apos;s story</title><link>https://dmerej.info/blog/post/a-booleans-story/</link><description><![CDATA[Earlier this month I told you about my pet project in Rust.

As a reminder, it’s a tool named rusync which contains some of the functionality offered by the rsync command-line tool.

Today I’d like to talk about a feature I’ve added recently, and take this opportunity to show you a few principles of good design along the way.]]></description><guid isPermaLink="false">999b0809-c97d-42c2-b102-d8d2567e8979</guid><pubDate>Fri, 18 May 2018 13:50:38 +0000</pubDate><dc:creator>Dimitri Merejkowsky</dc:creator></item><item><title>Porting Rust Benchmarks To Criterion</title><link>https://llogiq.github.io/2018/05/18/criterion.html</link><description><![CDATA[A few weeks ago, I set out to convert bytecount’s benchmarks to criterion, a statistics-driven benchmarking framework started by Jorge Aparicio and maintained by Brook Heisler.

Before, bytecount used bencher for its benchmarks, which is a straight port of the unstable, nightly-only std::test benchmark framework, extended to work with stable Rust. This was a great benefit compared to std::test, because now we could benchmark on all Rust versions (stable, beta, nightly, some specific version) without needing to fear regressions.]]></description><guid isPermaLink="false">51352c9c-dac9-4e94-a90f-5e953057a01a</guid><pubDate>Fri, 18 May 2018 00:00:00 +0000</pubDate><dc:creator>Llogiq</dc:creator></item><item><title>Compile Time Prevention of SQL-Injections in Rust</title><link>https://polyfloyd.net/post/compile-time-prevention-of-sql-injections/</link><description><![CDATA[SQL injection vulnerabilities have been a plague ever since such databases have been combined with user facing applications. Such vulnerabilities arise when a SQL query string is naively combined with data that is controlled by an attacker.

To mitigate, people should make use of placeholders and prepared statements provided by SQL client libraries. This separates the variable data from the actual query, ensuring that these two never mix. Pretty much all modern SQL client libraries offer this functionality, but of course, it’s still possible to mix variable data and SQL by means of string concatenation.]]></description><guid isPermaLink="false">c1e5c8e3-46e1-412d-98fe-6735ad9e4f19</guid><pubDate>Fri, 18 May 2018 00:00:00 +0000</pubDate><dc:creator>polyfloyd</dc:creator></item><item><title>FizzBuzz Can Finally Be Implemented in Stable Rust</title><link>https://medium.com/@iopguy/fizzbuzz-can-finally-be-implemented-in-stable-rust-87649a882f2d</link><description><![CDATA[I have been editing my FizzBuzz repository since 2014. After four years, I was finally able to switch from nightly to stable due to the 1.26 release. Let’s back up a little bit and appreciate the changes since the first revision.]]></description><guid isPermaLink="false">2bdd1638-e211-477d-8bb8-3ae0de703661</guid><pubDate>Thu, 17 May 2018 17:23:27 +0000</pubDate><dc:creator>Igor Polyakov</dc:creator></item><item><title>Cannoli: A Python Compiler Written in Rust [pdf]</title><link>https://github.com/joncatanio/cannoli/raw/master/resources/papers/cannoli-thesis-paper.pdf</link><description><![CDATA[I just finished my Master's Thesis and part of it was writing a Python compiler in Rust. The goal of the thesis was to evaluate language features of Python that were hypothesized to cause performance issues. Quantifying the cost of these features could be valuable to language designers moving forward. Some interesting results were observed when implementing compiler optimizations for Python. An average speedup of 51% was achieved across a number of benchmarks.]]></description><guid isPermaLink="false">c7a4923a-2a12-4f88-82fc-4b99b94080e9</guid><pubDate>Thu, 17 May 2018 16:00:59 +0000</pubDate><dc:creator>Jonathan Catanio</dc:creator></item><item><title>Improving SmallVec&apos;s speed by 60% and why that shouldn&apos;t matter to you</title><link>http://troubles.md/posts/improving-smallvec/</link><description><![CDATA[smallvec is a library by the Servo team for reducing the number of allocations for dynamic arrays in the case that most of those arrays are below a certain size. Because malloc is fast, for many cases it’s actually slower to use SmallVec than just using Vec because the one-time cost of the initial allocation is dwarfed by the lifetime cost of SmallVec’s increased complexity. You can see that switching to Vec actually improves speed on many of SmallVec’s own benchmarks.]]></description><guid isPermaLink="false">da6bf82a-304e-42bd-9209-fbb8ee975fcd</guid><pubDate>Thu, 17 May 2018 14:44:51 +0200</pubDate><dc:creator>troubles.md</dc:creator></item><item><title>The Rust compiler is getting faster</title><link>https://blog.mozilla.org/nnethercote/2018/05/17/the-rust-compiler-is-getting-faster/</link><description><![CDATA[TL;DR: The Rust compiler has gotten 1.06x–4x faster over the past month.]]></description><guid isPermaLink="false">a9218983-121e-4d4f-a02f-fd30cb6cf9b2</guid><pubDate>Thu, 17 May 2018 04:08:48 +0000</pubDate><dc:creator>Nicholas Nethercote</dc:creator></item><item><title>Dropping drops</title><link>https://barrielle.cedeela.fr/research_page/dropping-drops.html</link><description><![CDATA[Recently, a benchmark made it to the top of /r/programming, featuring Rust among other languages, and I was a bit surprised to see that the idiomatic Rust program was not competitive with the best-tuned C++ solution. The benchmark implements a binary tree, and the C++ solution leverages raw pointers while Rust would use an Option<Box<Node>> to represent its tree. Since Option knows that Box is non-nullable, it should compile down to a raw pointer. Quickly inspecting the Rust and C++ versions would not let me find where the performance difference came from.]]></description><guid isPermaLink="false">f676f9eb-ea74-4dc5-a393-1f23a7886678</guid><pubDate>Thu, 17 May 2018 00:00:00 +0200</pubDate><dc:creator>Vincent Barrielle</dc:creator></item><item><title>On learning Rust</title><link>https://medium.com/@AugustinLF/on-learning-rust-69ba956a63e3</link><description><![CDATA[But recently I decided to give Rust a go. And I must admit that I’m extremely surprised. Rust, like OCaml is a pretty low level language (it is a system programming language). After six years without seeing any pointers, I can’t say that I was happy. But the Rust compiler, by being extremely safe actually makes that easy.]]></description><guid isPermaLink="false">4ae850d3-305a-4fb4-826d-853972364683</guid><pubDate>Wed, 16 May 2018 14:01:05 +0000</pubDate><dc:creator>Augustin Le Fèvre</dc:creator></item><item><title>How I got into rust</title><link>https://liv.cat/how-i-got-into-rust</link><description><![CDATA[There’s currently a campaign around the #RustReach program where it’s people post their, uh, Rust “origin stories”, so to say. Mine is not nearly as long as some other peoples’, but I thought I’d try my hand at this regardless.]]></description><guid isPermaLink="false">9626a0ad-d7d5-4b09-b642-a273b535504f</guid><pubDate>Wed, 16 May 2018 00:00:00 +0000</pubDate><dc:creator>liv hugger</dc:creator></item></channel></rss>