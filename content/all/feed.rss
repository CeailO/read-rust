<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/"><channel><title>Read Rust - All Posts</title><link>https://readrust.net/</link><description>All Posts posts on Read Rust</description><item><title>Async Rust - A gentle introduction</title><link>https://thomashartmann.dev/blog/async-rust/</link><description><![CDATA[In which we explore Rust's newly stabilized async/.await language feature by creating a simple, asynchronous application. We look at what you need to do asynchronous programming in Rust and how it differs from other languages. And we talk a little bit about Pokémon!]]></description><guid isPermaLink="false">506523e4-4ec3-4da0-b2d0-cc176c0e06a7</guid><pubDate>Mon, 18 Nov 2019 00:00:00 +0000</pubDate><dc:creator>Thomas Hartmann</dc:creator></item><item><title>Custom Implementation of Blockchain In Rust</title><link>https://blog.knoldus.com/custom-implementation-of-blockchain-in-rustpart-1/</link><description><![CDATA[Hello folks, in this blog, we will be learning how to create our own Blockchain, which is a technology behind Bitcoin. Blockchain technology has been called the]]></description><guid isPermaLink="false">0428bdf3-8d01-4bfc-ac54-7f97460917ef</guid><pubDate>Sun, 17 Nov 2019 17:57:58 +0000</pubDate><dc:creator>Ayush Mishra</dc:creator></item><item><title>Rust, wasm, and tetris</title><link>http://klotzandrew.com/blog/rust-wasm-tetris</link><description><![CDATA[WASM has been making a lot of progress recently so I was looking for a small project to run through and tetris with rust came to mind. Its small enough to understand easily and complicated enough that it is not quite a ‘hello world’ program. We are mostly going to be looking at the interaction between WASM and the browser, there is interesting stuff happening on top of WASM like WASI. The code for tetris is not relevant to the main goal (maybe a later article).]]></description><guid isPermaLink="false">3a914bfd-1956-49a0-968f-cffce4da6685</guid><pubDate>Sun, 17 Nov 2019 12:00:00 +0000</pubDate><dc:creator>Andrew Klotz</dc:creator></item><item><title>Sneak Peek of PineTime Smart Watch… And why it’s perfect for teaching IoT</title><link>https://medium.com/swlh/sneak-peek-of-pinetime-smart-watch-and-why-its-perfect-for-teaching-iot-81b74161c159</link><description><![CDATA[I’m one of the lucky few who received the developer preview version of the PineTime Smart Watch by Pine64. After coding on PineTime for a few days (in Rust), it suddenly struck me… I felt really comfortable and productive coding the new gadget. Even though I have never coded a smart watch. PineTime is a terrific tool for teaching IoT! And I have taught IoT with so many different gadgets.]]></description><guid isPermaLink="false">e8a3e376-9c53-44f6-b4ab-0cd67ff6aec6</guid><pubDate>Sun, 17 Nov 2019 08:19:56 +0000</pubDate><dc:creator>Lup Yuen Lee</dc:creator></item><item><title>Palette 0.5.0</title><link>https://ogeon.github.io/2019/11/17/palette-0-5-0.html</link><description><![CDATA[Well, here it is. The (by some, at least) long awaited Palette 0.5.0 release. This one has been brewing for quite some time while waiting for the ecosystem to really support one of its main additions1. That addition is #[no_std] support.

First, what is Palette? It’s a Rust library for working with colors and color spaces. It uses the type system to prevent mistakes, like mixing incompatible colors or working with non-linear RGB. It encodes the color spaces and their meta data (such as RGB primaries and white point) into the types to help making color processing less error prone and hopefully more accessible to those who don’t want to dive into the rabbit hole that is colors in computing.]]></description><guid isPermaLink="false">f9d49eda-fad3-4ac9-9c8b-5aecf24d6f5e</guid><pubDate>Sun, 17 Nov 2019 00:00:00 +0000</pubDate><dc:creator>Ogeon</dc:creator></item><item><title>Understanding Serde</title><link>https://www.joshmcguigan.com/blog/understanding-serde/</link><description><![CDATA[Serde is one of the most popular Rust crates, and deservedly so. If you aren’t familiar, Serde describes itself as “a framework for serializing and deserializing Rust data structures efficiently and generically.” What is most impressive to me is how robust the Serde data model has proven to be, allowing it to support human readable protocols like JSON and YAML, but also binary formats like Bincode. Its really a bonus that Serde does this while remaining exceptionally performant.

This blog posts dives into how Serde (along with the ecosystem of Serde data formats) is able to pull this off. To limit the scope of this post I am going to focus on Serde serialization to JSON, and skip any discussion of deserialization. If you are interested in deserialization (or a different data format) I believe you will be able to perform a similar analysis yourself after reading this post.]]></description><guid isPermaLink="false">ce12c4d6-aa8d-4278-9772-4ab55dc2925b</guid><pubDate>Sun, 17 Nov 2019 00:00:00 +0000</pubDate><dc:creator>Josh Mcguigan</dc:creator></item><item><title>Bastion v0.3.0 is here with a new API and faster execution!</title><link>https://bastion.rs/</link><description><![CDATA[Bastion is a highly-available, fault-tolerant runtime system with dynamic dispatch oriented lightweight process model.]]></description><guid isPermaLink="false">113d436f-484b-4779-9428-6bde87acd07b</guid><pubDate>Fri, 15 Nov 2019 03:52:14 +0000</pubDate><dc:creator>Mahmut Bulut</dc:creator></item><item><title>Announcing the Bytecode Alliance: Building a secure by default, composable future for WebAssembly</title><link>https://bytecodealliance.org/articles/announcing-the-bytecode-alliance</link><description><![CDATA[Today we announce the formation of the Bytecode Alliance, a new industry partnership coming together to forge WebAssembly’s outside-the-browser future by collaborating on implementing standards and proposing new ones. Our founding members are Mozilla, Fastly, Intel, and Red Hat, and we’re looking forward to welcoming many more.]]></description><guid isPermaLink="false">78e05702-3363-4e6d-a530-a874fc2e939f</guid><pubDate>Fri, 15 Nov 2019 03:04:13 +0000</pubDate><dc:creator>Lin Clark</dc:creator></item><item><title>Building Art: Management in Game Engines</title><link>https://medium.com/@jjspira/building-art-management-in-game-engines-9f4efa2f00b6</link><description><![CDATA[I’ve been making a game engine in my spare time for a game called The Clockwork. I’ve been loving it, but recently have decided that I need to rework the build process. Let me walk you through that here, show you ways to hook into Cargo, Rust’s build system, and the pros and cons of my approach.]]></description><guid isPermaLink="false">9e5865b7-5088-461a-ac34-c8dbaa680ca8</guid><pubDate>Fri, 15 Nov 2019 00:40:49 +0000</pubDate><dc:creator>Jack Spira</dc:creator></item><item><title>Implementing ArrayVec Using Const Generics</title><link>http://adventures.michaelfbryan.com/posts/const-arrayvec/</link><description><![CDATA[If you’ve ever done much embedded programming in Rust, you’ve most probably run across the arrayvec crate before. It’s awesome. The main purpose of the crate is to provide the ArrayVec type, which is essentially like Vec<T> from the standard library, but backed by an array instead of some memory on the heap.

One of the problems I ran into while writing the Motion Planning chapter of my Adventures in Motion Control was deciding how far ahead my motion planner should plan.]]></description><guid isPermaLink="false">ad358e1b-53e5-4665-b1e6-21a3b40d19e8</guid><pubDate>Fri, 15 Nov 2019 00:57:00 +0800</pubDate><dc:creator>Michael-F-Bryan</dc:creator></item><item><title>Rust 2020 - Embrace and Extend</title><link>https://samsieber.tech/posts/2019/11/14/rust-2020/</link><description><![CDATA[I’ve used Rust a couple times at work for small tools, and written a couple of experiments in Rust. So before saying what I want out of Rust, I’d just like to say thanks to the wonderful community. I liked the Rust 2019 progress, and I can put most of my wants for 2020 under two main labels: Embrace and Extend.]]></description><guid isPermaLink="false">815de63e-91bf-4440-8a71-c346bbc55e70</guid><pubDate>Thu, 14 Nov 2019 08:46:32 -0700</pubDate><dc:creator>Sam Sieber</dc:creator></item><item><title>Types Are for People, not Computers</title><link>https://ethankent.dev/posts/types_are_for_people/</link><description><![CDATA[Types—in the static-typing sense—are useful because they help people, not computers. Oh sure, we use them, in part, to subdue the compiler or meet some need peculiarly arising from our computer. But types are valuable because they are a way of communicating.

Type systems are a way of communicating. Type systems are a way of announcing what you understand, expect, or intend. Good type systems let you do so at the level of abstraction you choose.]]></description><guid isPermaLink="false">4a3e4de8-26ad-499f-8d9f-3cc0938adea0</guid><pubDate>Thu, 14 Nov 2019 09:00:00 -0600</pubDate><dc:creator>Ethan Kent</dc:creator></item><item><title>Thoughts on Error Handling in Rust</title><link>https://lukaskalbertodt.github.io/2019/11/14/thoughts-on-error-handling-in-rust.html</link><description><![CDATA[A programming language’s solution to error handling significantly influences the robustness, brevity, readability and – to an extent – the runtime performance of your code. Consequently, the error handling story is an important part of PL design. So it should not come as a surprise that the Rust community constantly discusses this topic. Given some recent discussions and the emergence of more and more error handling crates, this article shares some of my thoughts (not solutions!) on this.]]></description><guid isPermaLink="false">ee1d5ff4-a7ff-4676-9713-5421d4601c5a</guid><pubDate>Thu, 14 Nov 2019 00:00:00 +0000</pubDate><dc:creator>Lukas Kalbertodt</dc:creator></item><item><title>Rust 2020: Scalability</title><link>https://mun-lang.org/blog/2019/11/14/rust-2020-scalability/</link><description><![CDATA[In my Rust 2020 blog I tried to shy away from specific feature requests, instead zooming out to look at the Rust ecosystem as a whole. As a community, we've achieved great things but we should take care not to crumble under the weight of a scaling language and ecosystem. We all need to come together to ensure that Rust can sustainably scale - be it in large organisations, communities, or codebases.]]></description><guid isPermaLink="false">e664c68c-e8f1-4ed9-91a0-96ac9efbdfee</guid><pubDate>Thu, 14 Nov 2019 00:00:00 +0000</pubDate><dc:creator>Remco (Wodann)</dc:creator></item><item><title>RustFest 2019 - A retrospective</title><link>https://www.lpalmieri.com/posts/2019-11-14-rustfest-2019-a-retrospective/</link><description><![CDATA[It has been a couple of days since the curtains closed on RustFest - given that I am roaming around the region, I might as well leverage my time on Catalan trains to collect my thoughts on the whole event in a digestible format.]]></description><guid isPermaLink="false">c19ac34d-de6f-4b15-ba7d-de4be39eff47</guid><pubDate>Thu, 14 Nov 2019 00:00:00 +0000</pubDate><dc:creator>Luca Palmieri</dc:creator></item><item><title>Global Executors</title><link>https://boats.gitlab.io/blog/post/global-executors/</link><description><![CDATA[One of the big sources of difficulty on the async ecosystem is spawning tasks. Because there is no API in std for spawning tasks, library authors who want their library to spawn tasks have to depend on one of the multiple executors in the ecosystem to spawn a task, coupling the library to that executor in undesirable ways.
Ideally, many of these library authors would not need to spawn tasks at all.]]></description><guid isPermaLink="false">f4e093f3-7ebd-4513-9fa2-d50fee10872f</guid><pubDate>Thu, 14 Nov 2019 00:00:00 +0000</pubDate><dc:creator>boats</dc:creator></item><item><title>Evaluating GitHub Actions</title><link>https://blog.rust-lang.org/inside-rust/2019/11/14/evaluating-github-actions.html</link><description><![CDATA[The Rust Infrastructure team is happy to announce that we’re starting an evaluation of GitHub Actions as a replacement for Azure Pipelines as the CI provider of the rust-lang/rust repository.]]></description><guid isPermaLink="false">75836bba-aa9f-4ff0-bb29-c88b5666d695</guid><pubDate>Thu, 14 Nov 2019 00:00:00 +0000</pubDate><dc:creator>Pietro Albini</dc:creator></item><item><title>Rust in 2020, one more thing</title><link>https://www.ncameron.org/blog/rust-in-2020-one-more-thing/</link><description><![CDATA[We need to work on error handling.]]></description><guid isPermaLink="false">85649990-38e0-4194-94ca-efd377aadb68</guid><pubDate>Wed, 13 Nov 2019 22:41:39 +0000</pubDate><dc:creator>Nick Cameron</dc:creator></item><item><title>Optimizing CI/CD Pipeline for Rust Projects (Gitlab &amp; Docker)</title><link>https://medium.com/@hatemtayeb2/optimizing-ci-cd-pipeline-for-rust-projects-gitlab-docker-98df64ae3bc4</link><description><![CDATA[We can make a lot of things with Rust like web apps, system drivers and much more but there is one problem, which is the time that Rust takes to make a binary by downloading dependencies and compile them.

We need to make a pipeline using the Gitlab CI/CD and Docker to make the deployment faster.]]></description><guid isPermaLink="false">acf26cbd-2183-4617-b0ab-45d6f2b88a1e</guid><pubDate>Wed, 13 Nov 2019 20:49:25 +0000</pubDate><dc:creator>Hatem ben tayeb</dc:creator></item><item><title>The GTK Rust bindings are not ready yet? Yes they are!</title><link>https://coaxion.net/blog/2019/11/the-gtk-rust-bindings-are-not-ready-yet-yes-they-are/</link><description><![CDATA[When talking to various people at conferences in the last year or at conferences, a recurring topic was that they believed that the GTK Rust bindings are not ready for use yet.

I don’t know where that perception comes from but if it was true, there wouldn’t have been applications like Fractal, Podcasts or Shortwave using GTK from Rust, or I wouldn’t be able to do a workshop about desktop application development in Rust with GTK and GStreamer at the Linux Application Summit in Barcelona this Friday (code can be found here already) or earlier this year at GUADEC.]]></description><guid isPermaLink="false">09c52285-f854-44ec-a925-43ad22b06d84</guid><pubDate>Wed, 13 Nov 2019 15:02:57 +0000</pubDate><dc:creator>Sebastian Dröge</dc:creator></item><item><title>Find Usages implemented</title><link>https://rust-analyzer.github.io/2019/11/13/find-usages.html</link><description><![CDATA[Last month, rust-analyzer gained an exciting new feature: find usages. It was implemented by @viorina in #1892.]]></description><guid isPermaLink="false">41aebf2a-5466-4cc7-8456-4750ceb3052a</guid><pubDate>Wed, 13 Nov 2019 09:00:00 +0000</pubDate><dc:creator>rust-analyzer</dc:creator></item><item><title>Governance WG Call For Participation</title><link>https://blog.rust-lang.org/inside-rust/2019/11/13/goverance-wg-cfp.html</link><description><![CDATA[Hello everyone, the governance working group has been working a few efforts, but we haven't made as much progress as we would have liked over the past few months, so we are going to try out a new process and meeting agenda aimed at trying to get more work done in the time we know we have.]]></description><guid isPermaLink="false">a290d347-47a3-41ef-989c-4468a2fed7fe</guid><pubDate>Wed, 13 Nov 2019 00:00:00 +0000</pubDate><dc:creator>Erin Power</dc:creator></item><item><title>Answering the call for #Rust2020</title><link>https://haurchefant.fr/posts/answering-the-call-rust-2020/</link><description><![CDATA[Another year already and I’m still knocking myself out using Rust. It is also the year where I can use Rust in a professional environment with people interested in the technology. Let’s review my last year post and try to come up with what I think Rust should focused on for the next year. ]]></description><guid isPermaLink="false">01689f1b-555c-4334-8e11-914fb5036628</guid><pubDate>Wed, 13 Nov 2019 00:00:00 +0000</pubDate><dc:creator>Geobert Quach</dc:creator></item><item><title>Rust 2020: Scientific Rust</title><link>https://github.com/willi-kappler/rust_2020</link><description><![CDATA[Rust could make the lives of (data-) scientists a lot easier, but as with most new programming languages it's a chicken and egg problem: When the applications and libraries are missing people will not use it and when there are no people with domain knowledge there won't be any applications / libraries. We do have some good projects like ndarray, RustSim, uom, etc. but we definitely need more (some stuff is also mentioned here Not-Yet-Awesome Rust). I'll try to work on more Rust stuff in 2020 and hope that more people will recognize Rust as a good candidate for scientific / numeric / high performance computing.]]></description><guid isPermaLink="false">1e059bb8-243b-49e7-8367-3e6b4558393f</guid><pubDate>Wed, 13 Nov 2019 00:00:00 +0000</pubDate><dc:creator>Willi Kappler</dc:creator></item><item><title>Rust 2020: Tropes and Jargon</title><link>https://dev.to/e_net4/rust-2020-tropes-and-jargon-5f07</link><description><![CDATA[I am writing this to announce a lame, but hopefully fruitful confession through this post. I had originally intended to make this a Twitter thread, but eventually the Rust 2020 call for posts emerged, and I saw it as an opportunity to expand this.]]></description><guid isPermaLink="false">a1a793e1-1f56-43aa-81f9-79954a144b3c</guid><pubDate>Tue, 12 Nov 2019 23:37:02 +0000</pubDate><dc:creator>Eduardo Pinho</dc:creator></item><item><title>Search for Rust crates with Meili</title><link>https://blog.meilisearch.com/search-rust-crates-meili/</link><description><![CDATA[Today, I am about to guide you in the depths of crates.io and how I made an alternative search bar using our instant search engine: MeiliDB.]]></description><guid isPermaLink="false">0e066b31-fcf8-4e2b-8f2f-80d33dbaa3ac</guid><pubDate>Tue, 12 Nov 2019 13:29:12 +0000</pubDate><dc:creator>Clément Renault</dc:creator></item><item><title>Rustlings 2.0 and human-centered versioning</title><link>https://write.as/mokou/rustlings-2-0-and-human-centered-versioning</link><description><![CDATA[Today we released Rustlings 2.0. There's some interesting things in this release: Exercises are now indexed by name, not by file name, rustlings watch will now require the user to delete a comment called // I AM NOT DONE to proceed, There is a new way to interact with hints, and Rustlings now self-checks for the existence of rustc before running.]]></description><guid isPermaLink="false">529f9620-32b1-4c98-b28c-d618d8427256</guid><pubDate>Tue, 12 Nov 2019 10:48:57 +0000</pubDate><dc:creator>marisa</dc:creator></item><item><title>CSS in librsvg is now in Rust, courtesy of Mozilla Servo</title><link>https://people.gnome.org/~federico/blog/css-in-librsvg-is-now-in-rust.html</link><description><![CDATA[After an epic amount of refactoring, librsvg now does all CSS parsing and matching in Rust, without using libcroco. In addition, the CSS engine comes from Mozilla Servo, so it should be able to handle much more complex CSS than librsvg ever could before. This is the story of CSS support in librsvg.]]></description><guid isPermaLink="false">2f92e5a1-d218-459f-a417-c5e4f58be832</guid><pubDate>Mon, 11 Nov 2019 19:36:04 -0600</pubDate><dc:creator>Federico Mena Quintero</dc:creator></item><item><title>Rust and 2020</title><link>https://vorner.github.io/2019/11/12/rust-2020.html</link><description><![CDATA[In general I tend to be conservative about adding things to the language and want to push as much „downstream“ ‒ it’s better to add something to the standard library (or core, if applicable) than directly into the language ‒ a new function is better than new keyword or operator. A new crate is better than a lot of new stuff in the standard library. My view here reflects that.]]></description><guid isPermaLink="false">11476a1d-33f3-4077-919f-fa64f68d2020</guid><pubDate>Tue, 12 Nov 2019 00:00:00 +0000</pubDate><dc:creator>Michal &apos;vorner&apos; Vaner</dc:creator></item><item><title>Neotron - The Embedded Rust Home Computer Platform</title><link>https://neotron-compute.github.io/Neotron-Book/</link><description><![CDATA[Neotron is an attempt to make computers simple again, whilst also taking advantage of the very latest in programming language development. It is based around four simple concepts: The ARM Thumb-v7M instruction set, A standardised OS interface, A standardised BIOS interface, and Use of the Rust Programming Language.]]></description><guid isPermaLink="false">f178fe2d-82b8-4e04-ad1e-6e90bc4299c3</guid><pubDate>Mon, 11 Nov 2019 05:07:11 +0000</pubDate><dc:creator>Jonathan Pallant</dc:creator></item><item><title>Learning Rust</title><link>https://dnlserrano.dev/2019/11/11/learning-rust.html</link><description><![CDATA[I’ve been learning Rust lately. I have also got back to playing futsal with some friends. Weirdly enough, these two worlds intersected a few weeks ago. This is a summary of my experience learning Rust. Starting with reading about it here and there, eventually getting the book, doing a Hackathon project at Onfido using it and then spinning up my own personal project as a way to further experiment with the language.]]></description><guid isPermaLink="false">3fc3ff70-1adf-4bd5-bb8a-15b77a658805</guid><pubDate>Mon, 11 Nov 2019 00:00:00 +0000</pubDate><dc:creator>Daniel Serrano</dc:creator></item><item><title>Generalizing Coroutines in Rust</title><link>https://samsartor.com/coroutines-1/</link><description><![CDATA[Now that async/await has been released, attention has drifted back to refining stackless coroutines (the unstable language feature that makes async/await possible). Alas, the latest RFC has shown that there is still a lot of disagreement on what exactly coroutines in Rust should look like beyond async/await. I felt like it will be useful to flesh out what coroutines could be so we can better discuss what they should be.]]></description><guid isPermaLink="false">453d4192-89ee-43ad-b2c9-2d462c94f009</guid><pubDate>Mon, 11 Nov 2019 00:00:00 +0000</pubDate><dc:creator>Sam Sartor</dc:creator></item><item><title>Announcing async-std 1.0</title><link>https://async.rs/blog/announcing-async-std-1-0/</link><description><![CDATA[async-std is a port of Rust’s standard library to the async world. It comes with a fast runtime and is a pleasure to use. We’re happy to finally announce async-std 1.0. As promised in our first announcement blog post, the stable release coincides with the release of Rust 1.39, the release adding async/.await. We would like to thank the active community around async-std for helping get the release through the door.]]></description><guid isPermaLink="false">7e260d4f-38ce-456b-be84-83ad8c13f4df</guid><pubDate>Mon, 11 Nov 2019 00:00:00 +0000</pubDate><dc:creator>Florian Gilcher</dc:creator></item><item><title>Release - Mun v0.1.0</title><link>https://mun-lang.org/blog/2019/11/11/release-mun-v0-1-0/</link><description><![CDATA[We are proud to present Mun v0.1.0 - our first milestone release. As a language, Mun is still far from production-ready, but this release gives you a glimpse of what natively supported hot reloading will look like in the future. The purpose of this release is to showcase our progress and gather feedback from those brave souls willing to try out Mun at this early stage.]]></description><guid isPermaLink="false">8147f2fb-fdcf-4382-9a84-ad4e935c220a</guid><pubDate>Mon, 11 Nov 2019 00:00:00 +0000</pubDate><dc:creator>The Mun Team</dc:creator></item><item><title>The Demystifying Asynchronous Rust Book</title><link>https://teh-cmc.github.io/rust-async/html/</link><description><![CDATA[This book is targeted towards experienced programmers that already feel somewhat comfortable with vanilla Rust (you definitely do not need to be an "expert" though, I certainly am not) and would like to dip their toes into its async ecosystem.

As the title indicates, this is not so much a book about how to use async Rust as much as it is about trying to build a solid understanding of how it all works under the hood. From there, efficient usage should come naturally.]]></description><guid isPermaLink="false">b6cc68e0-c563-4eb0-a374-7c11dad01824</guid><pubDate>Mon, 11 Nov 2019 00:00:00 +0000</pubDate><dc:creator>Clement Rey</dc:creator></item><item><title>Rust 2020 Suggestions</title><link>https://www.reddit.com/r/rust/comments/ducnqy/rust_2020_suggestions/?utm_source=share&amp;utm_medium=ios_app&amp;utm_name=iossmf</link><description><![CDATA[I like Rust and I'm looking forward to more improvements. My suggestions: RLS should be better and faster, Const genrics, and Accept more correct programs.]]></description><guid isPermaLink="false">c8c2efa0-e798-4951-b23d-7df4075c3b51</guid><pubDate>Mon, 11 Nov 2019 00:00:00 +0000</pubDate><dc:creator>u/AnyPolicy</dc:creator></item><item><title>Sulis - a turn based tactical RPG written in Rust</title><link>https://sulisgame.com/</link><description><![CDATA[Sulis, a turn based tactical RPG written in Rust. Sulis is open source with turn based, tactical combat, deep character customization and an engaging storyline. The game has been built from the ground up with modding and custom content in mind. Currently supported on Windows and Linux platforms.]]></description><guid isPermaLink="false">e49868f7-34ff-4d50-a55d-39eec1e36f37</guid><pubDate>Mon, 11 Nov 2019 00:00:00 +0000</pubDate><dc:creator>Jared Stephen</dc:creator></item><item><title>ptail - Stream and display a fixed number of lines from a processes output</title><link>https://github.com/orf/ptail</link><description><![CDATA[ptail is a small, and likely useless, utility that truncates the output from processes. Unlike tail -f it will not show more than the specified number of lines in your terminal. This could be useful if you are executing a command as part of a shell script and you do not wish to show the full and verbose output, but you do want to be able to see what is happening.]]></description><guid isPermaLink="false">7c3d9c87-a7a2-47b7-9e75-f23648d7de14</guid><pubDate>Mon, 11 Nov 2019 00:00:00 +0000</pubDate><dc:creator>Tom Forbes</dc:creator></item><item><title>Rust 2020: Finish what we started and a bit about proc macros</title><link>https://repnop.dev/posts/rust-2020/</link><description><![CDATA[Its that time of year again and its been exciting watching the language grow over this past year! Looking back through the Rust releases for the entire year, starting with 1.32.0 there’s been some fantastic progress, which is pretty easy to forget! So why not start with a bit of a recap of some of the big things from each release.]]></description><guid isPermaLink="false">dbe27f0a-48ce-492f-9200-688fc471a263</guid><pubDate>Sun, 10 Nov 2019 15:00:00 -0500</pubDate><dc:creator>repnop</dc:creator></item><item><title>First Shortwave Internet Radio Player Beta</title><link>https://blogs.gnome.org/haeckerfelix/2019/11/10/first-shortwave-beta/</link><description><![CDATA[Shortwave is an internet radio player that lets you search for stations, listen to them and record songs automatically.]]></description><guid isPermaLink="false">08c1b771-fd3b-4408-bb1d-2c076e443698</guid><pubDate>Sun, 10 Nov 2019 16:24:38 +0000</pubDate><dc:creator>Felix Häcker</dc:creator></item><item><title>OPT300x Ambient Light Sensor Driver in Rust</title><link>https://blog.eldruin.com//opt300x-ambient-light-sensor-driver-in-rust/</link><description><![CDATA[Platform-agnostic driver for the OPT300x ambient light sensor written in Rust.]]></description><guid isPermaLink="false">8e3473bc-8737-442a-9e9a-42eb9ab5c8bb</guid><pubDate>Sat,  9 Nov 2019 16:22:18 +0000</pubDate><dc:creator>Diego Barrios Romero</dc:creator></item><item><title>Wasmtime — a small and efficient runtime for WebAssembly &amp; WASI</title><link>https://wasmtime.dev/</link><description><![CDATA[Wasmtime is a standalone wasm-only optimizing runtime for WebAssembly and WASI, using Cranelift. It runs WebAssembly code outside of the Web, and can be used both as a command-line utility or as a library embedded in a larger application.]]></description><guid isPermaLink="false">48b43e12-00d0-4eb5-aff6-b57873cc6533</guid><pubDate>Sat,  9 Nov 2019 08:56:22 +0000</pubDate><dc:creator>Wasmtime Developers</dc:creator></item><item><title>Posititivity and the RustConf keynote</title><link>https://yakshav.es/rustconf-keynote-thoughts/</link><description><![CDATA[I wrote down some rough thoughts on the RustConf keynote together with Steve Klabnik on my personal snippet space. Had we gone with our initial idea for it, it would maybe have been more "reflective", but also a disservice to many.]]></description><guid isPermaLink="false">f1e28b81-6178-4b2d-88ca-f1b242e2c6cd</guid><pubDate>Sat,  9 Nov 2019 06:30:17 +0000</pubDate><dc:creator>Florian Gilcher</dc:creator></item><item><title>Roguelike Tutorial - In Rust</title><link>http://bfnightly.bracketproductions.com/rustbook/</link><description><![CDATA[This tutorial is primarily about learning to make roguelikes (and by extension other games), but it should also help you get used to Rust and RLTK - The Roguelike Tool Kit we'll be using to provide input/output. Even if you don't want to use Rust, my hope is that you can benefit from the structure, ideas and general game development advice.]]></description><guid isPermaLink="false">cd4ffee6-edb3-4ef3-8dbe-1a9b7f4ba199</guid><pubDate>Sat,  9 Nov 2019 04:26:11 +0000</pubDate><dc:creator>Herbert Wolverson</dc:creator></item><item><title>VeoLuz: A generative art tool visualizing the paths of photons</title><link>https://jaredforsyth.com/veoluz/</link><description><![CDATA[VeoLuz is an exploration-focused playground and an artistic tool. It attempts to mimic the behavior of photons as they interact with barriers of various kinds − those that absorb light, those that reflect light, and those that refract light.]]></description><guid isPermaLink="false">b5ef3ed4-ac3e-4483-8a04-abe7cd4afa92</guid><pubDate>Sat,  9 Nov 2019 04:26:11 +0000</pubDate><dc:creator>Jared Forsyth</dc:creator></item><item><title>Osgood is a secure, fast, and simple platform for running JavaScript HTTP servers</title><link>https://github.com/IntrinsicLabs/osgood</link><description><![CDATA[Osgood is a secure, fast, and simple platform for running JavaScript HTTP servers. It is written using Rust and V8. Services written today share a common flaw: Being over-privileged. Osgood is an attempt to build a platform from the ground up, one which applies the Principle of Least Privilege at its very core. Osgood requires that policies be written ahead of time describing the I/O requirements of an application. If such an operation hasn't been whitelisted, it will fail. Developers familiar with JavaScript development in the web browser should feel right at home with the APIs provided in Osgood.]]></description><guid isPermaLink="false">6cb73c7e-777a-4c23-b279-4e94c8cf70cf</guid><pubDate>Sat,  9 Nov 2019 03:48:13 +0000</pubDate><dc:creator>Thomas Hunter II</dc:creator></item><item><title>My first ever zine, titled &quot;String and &amp;str in Rust&quot;</title><link>https://github.com/jeenalee/zines/blob/master/string-and-andstr-in-rust.pdf</link><description><![CDATA[Zines (pronounced “zeens") are small publications that come in the form of mini pamphlets or magazines!]]></description><guid isPermaLink="false">6fcfe5a8-280a-4f20-a269-7f1354c314e8</guid><pubDate>Sat,  9 Nov 2019 00:33:18 +0000</pubDate><dc:creator>Jeena Lee</dc:creator></item><item><title>Tutorial: Profiling Rust applications in Docker with perf</title><link>https://gendignoux.com/blog/2019/11/09/profiling-rust-docker-perf.html</link><description><![CDATA[With Moore’s law coming to an end, optimizing code to avoid performance pitfalls is becoming more and more useful. To this end, programming languages like Rust are designed to produce fast and memory-efficient programs out-of-the-box. When that is not sufficient, profilers like perf are useful to measure where the code is slow and therefore which algorithms and data structures should be optimized.]]></description><guid isPermaLink="false">2de8fbcd-1a56-4eea-8f6d-54cb843418e2</guid><pubDate>Sat,  9 Nov 2019 00:00:00 +0000</pubDate><dc:creator>Guillaume Endignoux</dc:creator></item><item><title>Rust 2020 - Loose Ends and Small Details</title><link>https://crepererum.net/rust-2020/</link><description><![CDATA[This is my answer to call for blogs 2020 and somewhat an update to my post from last year. You don't need to read the old post though, since this post is written in way that it incorporates that content as well.

For every topic, I will present my personal favorite parts, split into Completed (compared to the post from last year or was not on the list but is nice anyway), Open (existed last year and is still relevant), and New (got relevant or new idea).]]></description><guid isPermaLink="false">f7f1b3da-3847-4653-9410-cadb223b8e06</guid><pubDate>Sat,  9 Nov 2019 00:00:00 +0000</pubDate><dc:creator>Marco Neumann</dc:creator></item><item><title>iou: Rust bindings for liburing</title><link>https://boats.gitlab.io/blog/post/iou/</link><description><![CDATA[Today I’m releasing a library called iou. This library provides idiomatic Rust bindings to the C library called liburing, which itself is a higher interface for interacting with the io_uring Linux kernel interface. Here are the answers to some questions I expect that may provoke.

What is io_uring? io_uring is an interface added to the Linux kernel in version 5.1. Concurrent with that, the primary maintainer of that interface has also been publishing a library for interacting with it called liburing.]]></description><guid isPermaLink="false">eab14a89-9177-44ce-8259-07c6ae33bdfa</guid><pubDate>Fri,  8 Nov 2019 00:00:00 +0000</pubDate><dc:creator>boats</dc:creator></item><item><title>Using Rust in Windows</title><link>https://msrc-blog.microsoft.com/2019/11/07/using-rust-in-windows/</link><description><![CDATA[This blog describes part of the story of Rust adoption at Microsoft. Recently, I’ve been tasked with an experimental rewrite of a low-level system component of the Windows codebase (sorry, we can’t say which one yet). Instead of rewriting the code in C++, I was asked to use Rust, a memory-safe alternative. Though the project is not yet finished, I can say that my experience with Rust has been generally positive. It’s a good choice for those looking to avoid common mistakes that often lead to security vulnerabilities in C++ code bases. ]]></description><guid isPermaLink="false">fe4ddd77-07fd-4693-a8e4-684b4b0d825c</guid><pubDate>Thu,  7 Nov 2019 16:11:27 +0000</pubDate><dc:creator>Adam Burch</dc:creator></item><item><title>Rust 2020: towards a 1.0 crate ecosystem</title><link>https://tonyarcieri.com/rust-2020-towards-a-1-0-crate-ecosystem</link><description><![CDATA[The Rust language itself went 1.0 in 2015. And yet, almost 5 years later, at least in my anecdotal assessment talking to and reading things written by current or potential users, there is still a sense that the language is still in some way unfinished and a bit rough around the edges. I sympathize with these concerns.]]></description><guid isPermaLink="false">27428e03-39e4-450a-9e5d-2337865349d1</guid><pubDate>Thu,  7 Nov 2019 07:30:37 -0800</pubDate><dc:creator>Tony Arcieri</dc:creator></item><item><title>Learning Rust by Contrasting with TypeScript: Part 1</title><link>https://codeburst.io/learning-rust-by-contrasting-with-typescript-part-1-afb2e3f6ead8</link><description><![CDATA[Seeing Rust as a potential successor to TypeScript, we go through through the Rust Book with TypeScript in mind.]]></description><guid isPermaLink="false">276689b1-ba19-4308-9168-21951f3f372c</guid><pubDate>Thu,  7 Nov 2019 14:28:54 +0000</pubDate><dc:creator>John Tucker</dc:creator></item><item><title>Putting Rust in the kernel with eBPF</title><link>https://blog.redsift.com/labs/putting-rust-in-the-kernel-with-ebpf/</link><description><![CDATA[During the product development process monitoring our pipelines proved challenging, and we wanted more visibility into our containers. After a short period of exploration, we found that eBPF would address most of the pain points and dark spots we were encountering.

There was one catch: no eBPF tooling would help us deploy and maintain new probes within our small, but focused ops team. BCC, while great for tinkering, requires significant effort to roll out to production. It also makes it difficult to integrate our toolkit into our usual CI/CD deployment models.

Faced with this dilemma, we decided the only option was for us to write our own Rust-based agent that integrated well with our testing and deployment strategies.]]></description><guid isPermaLink="false">f735529c-9db9-454e-802d-82e7367e6b92</guid><pubDate>Thu,  7 Nov 2019 11:34:52 +0000</pubDate><dc:creator>Peter Parkanyi</dc:creator></item><item><title>Battle of the Serverless — Part 2: AWS Lambda Cold Start Times</title><link>https://medium.com/@shouldroforion/battle-of-the-serverless-part-2-aws-lambda-cold-start-times-1d770ef3a7dc</link><description><![CDATA[This experiment continues the work done in our pretend suite of microservices exposed via API Gateway to form an API with a code name of Slipspace in a mock company called STG. Slipspace drives are how the ships in the Halo universe travel so quickly to different sectors of the galaxy through something called Slipstream Space, so thought it was cool for a name requiring awesome warp API speeds.]]></description><guid isPermaLink="false">48cf21ce-5244-4667-82c3-9c54bb469bbf</guid><pubDate>Thu,  7 Nov 2019 03:15:40 +0000</pubDate><dc:creator>Mark Fowler</dc:creator></item><item><title>How Swift Achieved Dynamic Linking Where Rust Couldn&apos;t</title><link>https://gankra.github.io/blah/swift-abi/</link><description><![CDATA[For those who don't follow Swift's development, ABI stability has been one of its most ambitious projects and possibly it's defining feature, and it finally shipped in Swift 5. The result is something I find endlessly fascinating, because I think Swift has pushed the notion of ABI stability farther than any language without much compromise.

So I decided to write up a bunch of the interesting high-level details of Swift's ABI. This is not a complete reference for Swift's ABI, but rather an abstract look at its implementation strategy. If you really want to know exactly how it allocates registers or mangles names, look somewhere else.

Also for context on why I'm writing this, I'm just naturally inclined to compare the design of Swift to Rust, because those are the two languages I have helped develop. Also some folks like to complain that Rust doesn't bother with ABI stability, and I think looking at how Swift does helps elucidate why that is.]]></description><guid isPermaLink="false">225f7f8a-4d16-4eee-9022-bbb1d35e26a9</guid><pubDate>Thu,  7 Nov 2019 00:00:00 +0000</pubDate><dc:creator>Alexis Beingessner</dc:creator></item><item><title>This Month in Rust GameDev #3 - October 2019</title><link>https://rust-gamedev.github.io/2019/11/07/newsletter-003.html</link><description><![CDATA[Huge round-up of updates to Rust games, libraries, and tools.]]></description><guid isPermaLink="false">5e3bc6b8-53e2-4b7a-966b-901727f317c8</guid><pubDate>Thu,  7 Nov 2019 00:00:00 +0000</pubDate><dc:creator>Rust Game Development Working Group</dc:creator></item><item><title>Simple data stitching</title><link>http://segfaultsourcery.s3-website.eu-central-1.amazonaws.com/snippets/rust/stitching/landing.html#simple-data-stitching</link><description><![CDATA[I found myself in a situation where I had a number of CSV files that all shared some key data, and all had to be put together to a larger dataset. I figured that the easiest way to do this would be to deserialize the files, then stitch them together using a portion of their data as a key.

I decided to try my hand at writing a macro to solve the issue, and I ended up with two of them; one for one-to-one relations, and one for one-to-many.]]></description><guid isPermaLink="false">a09f683f-9aec-46cc-83e8-0aa1acf20f31</guid><pubDate>Thu,  7 Nov 2019 00:00:00 +0000</pubDate><dc:creator>Kim Hå</dc:creator></item><item><title>Comparing parallel Rust and C++</title><link>https://parallel-rust-cpp.github.io/</link><description><![CDATA[In this tutorial, we will implement a Rust program that attempts to utilize 100% of the theoretical capacity of three relatively modern, mid-range CPUs. We'll use an existing, highly efficient C++ implementation as a reference point to compare how our Rust program is doing. We start with a simple baseline solution of 3 nested for-loops, and keep improving on the baseline solution incrementally, implementing 8 versions in total, until the program is going so fast it can hardly go faster. We'll approach the problem from the point of view of a C++ programmer who already knows how the reference implementation solves the problem, but is interested in an approach using the Rust language.]]></description><guid isPermaLink="false">9e49b1b3-2b2a-46f0-951e-bda659adca6e</guid><pubDate>Thu,  7 Nov 2019 00:00:00 +0000</pubDate><dc:creator>Matias Lindgren</dc:creator></item><item><title>Async-await on stable Rust!</title><link>https://blog.rust-lang.org/2019/11/07/Async-await-stable.html</link><description><![CDATA[On Thursday, November 7, async-await syntax hit stable Rust, as part of the 1.39.0 release. This work has been a long time in development -- the key ideas for zero-cost futures, for example, were first proposed by Aaron Turon and Alex Crichton in 2016! -- and we are very proud of the end result. We believe that Async I/O is going to be an increasingly important part of Rust's story.]]></description><guid isPermaLink="false">35e06989-4cc4-4d3b-ab76-5830da233ebd</guid><pubDate>Thu,  7 Nov 2019 00:00:00 +0000</pubDate><dc:creator>Niko Matsakis</dc:creator></item><item><title>Announcing Rust 1.39.0</title><link>https://blog.rust-lang.org/2019/11/07/Rust-1.39.0.html</link><description><![CDATA[The Rust team is happy to announce a new version of Rust, 1.39.0. The highlights of Rust 1.39.0 include async/.await, shared references to by-move bindings in match guards, and attributes on function parameters.]]></description><guid isPermaLink="false">dfcf2420-e465-4c62-8b31-f7e2792c2e94</guid><pubDate>Thu,  7 Nov 2019 00:00:00 +0000</pubDate><dc:creator>The Rust Release Team</dc:creator></item><item><title>Rust 2020 - Rust needs to be boring</title><link>https://andygrove.io/2019/11/rust-2020-rust-needs-to-be-boring/</link><description><![CDATA[I’ve been following Rust for long enough that I remember the early days (pre 1.0) where the language would keep changing from under me and I’d have to regularly rewrite parts of my project using the latest syntax. Fun times!

Of course, things have changed a lot since then. The language has stabilized and we have Rust Editions to rely on for major releases. However, even though changes to the language are backwards compatible, there is still quite a lot of churn due to new features being added.]]></description><guid isPermaLink="false">d06968c3-bc41-4dda-966b-e46850d76549</guid><pubDate>Thu,  7 Nov 2019 00:00:00 +0000</pubDate><dc:creator>Andy Grove</dc:creator></item><item><title>Rust focus for 2020</title><link>https://gist.github.com/starkat99/32fd5156e5c744c30dde61e82ed7bcd9</link><description><![CDATA[In response to Rust's call for blogs about Rust development in 2020, here's a few of my own thoughts: Improve Error ergonomics, Stabilize existing approved features, Stabilize more ecosystem libraries.]]></description><guid isPermaLink="false">7d25a259-4131-4a03-8d9a-cea51b7790cb</guid><pubDate>Wed,  6 Nov 2019 19:07:44 +0000</pubDate><dc:creator>Kathryn Long</dc:creator></item><item><title>Rust 2020: Funding</title><link>https://fasterthanli.me/blog/2019/rust-2020-funding/</link><description><![CDATA[Blog posts that praise Rust are many but funding is generally in short supply. If even a small percentage of the money Rust saves companies was put back into the ecosystem it would help secure the future of the platform tremendously.]]></description><guid isPermaLink="false">3b951b73-7ad8-448c-8c25-27d745fae481</guid><pubDate>Wed,  6 Nov 2019 17:30:02 +0000</pubDate><dc:creator>Amos</dc:creator></item><item><title>Rust in 2020: A User’s Perspective</title><link>https://flocknetworks.com/rust2020/</link><description><![CDATA[I’m a Rust user rather than a Rust developer. I have been writing Rust code since just before the 1.0 release, and have followed the development of the language since then. I believe the future of systems programming is likely to be in Rust. I am certainly invested in the Rust language. Last month I resigned from my job writing embedded C, so I could start my own company, producing IP Networking software in Rust.]]></description><guid isPermaLink="false">10b9ba68-29df-4218-b086-e17e4d8894cc</guid><pubDate>Wed,  6 Nov 2019 15:05:41 +0000</pubDate><dc:creator>Nick Carter</dc:creator></item><item><title>2020 : Milestones?</title><link>https://internals.rust-lang.org/t/2020-milestones/11246</link><description><![CDATA[When I read the Nick Cameron's 2020 blog post, I thought about something that might be interesting about editions. One of the Nick points was that a 2021 edition would be useful as a rallying point to highlight progress on “async”. I agree that a rallying point is desirable, but I believe the edition system is a terrible way to do that...]]></description><guid isPermaLink="false">53feabca-bda0-4d45-8dff-ee1a898c36c4</guid><pubDate>Wed,  6 Nov 2019 06:12:46 +0000</pubDate><dc:creator>Uther</dc:creator></item><item><title>Rust 2020</title><link>https://hsivonen.fi/rust2020/</link><description><![CDATA[It’s again the time of year when the Rust Core Team calls for blog posts for input into the next year’s roadmap. This is my contribution. It’s mostly a re-run of my Rust 2018 and Rust 2019 posts. Apart from the LLVM bound check optimization item, the theme here continues to be: Please mark features that have worked since 2015 as done.]]></description><guid isPermaLink="false">e13462c4-9629-4a6a-9118-c6f918a4bae3</guid><pubDate>Wed,  6 Nov 2019 00:00:00 +0000</pubDate><dc:creator>Henri Sivonen</dc:creator></item><item><title>Rust 2020: are we compile yet? are we cache yet? are we doc yet?</title><link>https://www.reddit.com/r/rust/comments/dsfi5m/rust_2020_are_we_compile_yet_are_we_cache_yet_are/</link><description><![CDATA[I'm using Rust actively and it's mostly great. That said, there are some pain points: We are not compile just yet, We aren't cache yet, and We are mostly doc already, but not completely.]]></description><guid isPermaLink="false">49edb12f-3491-4965-abd5-dd2f936a5ea4</guid><pubDate>Wed,  6 Nov 2019 00:00:00 +0000</pubDate><dc:creator>u/unpleasant_truthz</dc:creator></item><item><title>My Rust adventure begins: building the WinRT language projection for Rust</title><link>https://kennykerr.ca/2019/11/05/rust/</link><description><![CDATA[I have come to the point with C++/WinRT where I am largely satisfied with how it works and leverages C++ to the best of its ability. There is always room for improvement and I will continue to evolve and optimize C++/WinRT as the C++ language itself advances. But as a technology, the Windows Runtime has always been about more than just one language and we have started working on a few different projects to add support for various languages. None of these efforts could however draw me away from C++… that is until Rust showed up on my radar.

Rust is an intriguing language for me. It closely resembles C++ in many ways, hitting all the right notes when it comes to compilation and runtime model, type system and deterministic finalization, that I could not help but get a little excited about this fresh new take on language design. And so it is that I have started building the WinRT language projection for Rust.]]></description><guid isPermaLink="false">94453690-596e-423d-afa4-6fbcb91594a1</guid><pubDate>Tue,  5 Nov 2019 15:05:41 +0000</pubDate><dc:creator>Kenny Kerr</dc:creator></item><item><title>Nushell 0.5.0</title><link>http://www.jonathanturner.org/2019/11/nushell-0_5_0.html</link><description><![CDATA[We've just released Nushell 0.5.0! New - login shell support, recycle bin support, better string matching, parameter help, new commands, and more!]]></description><guid isPermaLink="false">2add05cc-7028-465f-baee-42535290fc10</guid><pubDate>Tue,  5 Nov 2019 00:00:00 +0000</pubDate><dc:creator>Jonathan Turner</dc:creator></item><item><title>Rust 2021: Confidence</title><link>https://swatinem.de/blog/rust-2020/</link><description><![CDATA[It is that time of year again. The Rust Team is soliciting ideas about rusts roadmap for the next years, so here goes mine. Thinking about the tagline I would give the coming editions, it is this: Rust 2015: Stability, Rust 2018: Productivity, Rust 2021: Confidence. I will explain what this means for me, but lets digress a bit first]]></description><guid isPermaLink="false">3cd6a436-b878-4ccd-82d2-75231ed6ed1a</guid><pubDate>Tue,  5 Nov 2019 00:00:00 +0000</pubDate><dc:creator>Arpad Borsos</dc:creator></item><item><title>Rust 2020</title><link>https://www.ncameron.org/blog/rust-2020/</link><description><![CDATA[I'll start by arguing in favour of an edition in 2021. Then I will indulge in some rumination on the nature and necessity of roadmaps. Finally I'll make some probably obvious points in a long-winded way. Tl;dr, money is a thing we need to think about, async programming and WASM are important, and the compiler should be faster. For good measure, I will re-open a can of worms concerning the standard library.]]></description><guid isPermaLink="false">dc4dd0c3-6f8b-4450-b779-7ed4f60024a0</guid><pubDate>Mon,  4 Nov 2019 20:24:52 +0000</pubDate><dc:creator>Nick Cameron</dc:creator></item><item><title>Rust concurrency patterns: condvars and locks</title><link>https://medium.com/@polyglot_factotum/rust-concurrency-patterns-condvars-and-locks-e278f18db74f</link><description><![CDATA[I’ve spent quite a lot of time extolling the virtues of message-passing in concurrent Rust. However, there are times when shared-state is the right approach, sometimes just because it’s the historical approach chosen in a module and you want to add something to it without refactoring the whole thing. So today we’re going to talk about using shared-state, with the help of condvars and locks.]]></description><guid isPermaLink="false">155c1b1a-4660-4feb-8ab9-3dc8c211afb2</guid><pubDate>Mon,  4 Nov 2019 14:52:14 +0000</pubDate><dc:creator>Gregory Terzian</dc:creator></item><item><title>My share on Rust 2020</title><link>https://dev.to/augustocdias/my-share-on-rust-2020-27m8</link><description><![CDATA[Some weeks ago the rust-lang team made a blog post asking for opinions on what the priorities for the next year should be. It really amazes me how the team hears everybody and how friendly the community is.

I have been learning rust for more than a year already, but this year was the first where I tried to write something real and production ready with it. I've gotta say I had a lot of ups and downs with it, but I'm still amazed by the language and its ecosystem. ]]></description><guid isPermaLink="false">b42bc892-2146-4ac9-b2a1-5e1536abcddc</guid><pubDate>Mon,  4 Nov 2019 12:14:01 +0000</pubDate><dc:creator>Augusto</dc:creator></item><item><title>After completing Rust.Tokyo</title><link>https://medium.com/@dorayakikun/after-completing-rust-tokyo-fc4db37d2652</link><description><![CDATA[I would like to write about my gratitude to each person who was involved in Rust.Tokyo, and my thoughts about Rust.Tokyo.]]></description><guid isPermaLink="false">189fd57c-47f6-4854-8ca2-0c5b07af21e8</guid><pubDate>Mon,  4 Nov 2019 02:41:29 +0000</pubDate><dc:creator>dorayakikun</dc:creator></item><item><title>Rust 2020: the RFC process and distributions</title><link>https://spacekookie.de/blog/rust-2020-the-rfc-process-and-distributions/</link><description><![CDATA[I must have missed an e-mail in my inbox, because recently I started seeing people publish Rust 2020 blogposts so I thought, why not. I haven't been incredibly involved in the development of Rust in the last few months, (navigating the delicate balance of being self employed, working on free software and not burning out) but I feel like that might change again. And also, I still have feelings about software.

This post was also largely inspired by my friend XAMPPRocky's post, as well as attending NixCon a few weeks ago, and generally interacting with the NixOS RFC process.]]></description><guid isPermaLink="false">2df19538-8f67-4338-9eb8-9536c03a77c9</guid><pubDate>Mon,  4 Nov 2019 00:00:00 +0000</pubDate><dc:creator>Katharina Fey</dc:creator></item><item><title>Yet another HackerNews CLI written in Rust</title><link>https://github.com/yayoc/hn</link><description><![CDATA[Yet another HackerNews CLI written in Rust.]]></description><guid isPermaLink="false">a1e98a1c-84fa-4aad-8b14-03762ad6079b</guid><pubDate>Mon,  4 Nov 2019 00:00:00 +0000</pubDate><dc:creator>yayoc</dc:creator></item><item><title>Rust 2020</title><link>https://thomashartmann.dev/blog/rust-2020/</link><description><![CDATA[In which I respond to the recent call for blogs put out by the Rust core team and write down my wishes for Rust in 2020. Yup, GATs and const generics are there, but also slice patterns and a request for better documentation around async development.]]></description><guid isPermaLink="false">2e31e9ad-357b-4a9a-b76b-fe8c5b5e993a</guid><pubDate>Mon,  4 Nov 2019 00:00:00 +0000</pubDate><dc:creator>Thomas Hartmann</dc:creator></item><item><title>Rust 2020: Discoverability</title><link>https://apiraino.github.io/2019/11/04/call-for-2020-roadmap.html</link><description><![CDATA[Here we come with the "Request for Comment" about Rust for the next 2020 year. I'm sure 2020 will be a great year, also because it's easy and fast to write :) My wishlist will be short and to the point. Looking back to what I wished for 2019 I'd like first to see what has changed, from my point of view.]]></description><guid isPermaLink="false">d2c358d7-aae8-4cb8-93ac-edfaa975072b</guid><pubDate>Mon,  4 Nov 2019 00:00:00 +0100</pubDate><dc:creator>apiraino</dc:creator></item><item><title>How to make your C codebase rusty: rewriting keyboard firmware keymap in Rust</title><link>https://about.houqp.me/posts/rusty-c/</link><description><![CDATA[Recently, my colleague introduced me to QMK 1, an open-source keyboard firmware. Like many non-trivia C projects, macro is heavily used everywhere, especially in keymap files 2. It didn’t bother me much since I have been programming C for many years. But I kept thinking to myself, “what would it look like if I can start from scratch and redesign everything using Rust’s more powerful macro system?” After couple nights of hacking, I was able to come up with something I am quite happy with.]]></description><guid isPermaLink="false">6880443a-d817-4bb3-b7b6-aeaee053df1c</guid><pubDate>Sat,  2 Nov 2019 21:56:49 -0700</pubDate><dc:creator>Hou, Qingping (QP)</dc:creator></item><item><title>Mental experiments with io_uring</title><link>https://vorner.github.io/2019/11/03/io-uring-mental-experiments.html</link><description><![CDATA[Recently, a new Linux kernel interface, called io_uring, appeared. I have been looking into it a little bit and I can’t help but wondering about it. Unfortunately, I’ve had only enough time to keep thinking and reading about it. Nevertheless, I’ve decided to share what I’ve been thinking about so far in case someone wants to write some actual code and experiment. Basically, I have an idea for a crate and I’d love someone else to write it 😇.]]></description><guid isPermaLink="false">2fa36367-ad2e-4773-a3c8-9eea6f166a01</guid><pubDate>Sun,  3 Nov 2019 00:00:00 +0000</pubDate><dc:creator>Michal &apos;vorner&apos; Vaner</dc:creator></item><item><title>Runtime Diagnostics</title><link>https://blog.yoshuawuyts.com/runtime-diagnostics/</link><description><![CDATA[Rust is well-known for its helpful error messages, good tooling, and generally empathic compiler interface. If something goes wrong, Rust tries hard to help you get back on track. In this post I'd like to talk about the runtime aspect of debugging errors.]]></description><guid isPermaLink="false">02e9c871-0bac-4650-8fc3-1c8c64e95c7e</guid><pubDate>Sun,  3 Nov 2019 00:00:00 +0000</pubDate><dc:creator>Yoshua Wuyts</dc:creator></item><item><title>My Rust 2020 wish list: playing nice</title><link>https://blog.dend.ro/my-rust-2020-wishlist/</link><description><![CDATA[This year I decided to jot down some thoughts for the Rust 2020 call for blog posts. I think the general theme here will be integration or "playing well", on different levels. A lot of these here are not language changes, and most of them already exist in some form. Probably none of them are new ideas.]]></description><guid isPermaLink="false">4177b33f-0805-4527-b833-259cf518761a</guid><pubDate>Sun,  3 Nov 2019 00:00:00 +0000</pubDate><dc:creator>Laurențiu Nicola</dc:creator></item><item><title>Rust 2020: Write Once, Run Anywhere</title><link>https://www.boringcactus.com/2019/11/03/rust-2020.html</link><description><![CDATA[Thing that is cool: writing the same codebase and having it run on desktop, mobile, and web thing that is lame: JavaScript is the only language where people really do that right now, outside of big commercial game engines things that need to happen for Rust to get there…]]></description><guid isPermaLink="false">eeeecc4b-3e3d-43f1-b362-1fb59995d8c0</guid><pubDate>Sun,  3 Nov 2019 00:00:00 +0000</pubDate><dc:creator>Melody Horn</dc:creator></item><item><title>mrustc 0.9 - Now with rust 1.29.0 support</title><link>https://www.reddit.com/r/rust/comments/dqi1u1/mrustc_09_now_with_rust_1290_support/</link><description><![CDATA[I'm finally happy to announce that I've "finished" the 1.29 branch of mrustc (for those who don't know, mrustc is my attempt at making a rust compiler, primarily for breaking the bootstrap chain).

This version is capable of compiling both rustc 1.29 (and packaged cargo) AND rustc 1.19, both of which can compile their successors (1.20 and 1.30 - and 1.30 results in a binary equal output).]]></description><guid isPermaLink="false">3e6e0860-0ced-48d0-9f44-a2cfe3355a63</guid><pubDate>Sat,  2 Nov 2019 00:00:00 +0000</pubDate><dc:creator>John Hodge (Mutabah)</dc:creator></item><item><title>Announcing safety-dance: removing unnecessary unsafe code from popular crates</title><link>https://www.reddit.com/r/rust/comments/dq8df4/announcing_safetydance_removing_unnecessary/</link><description><![CDATA[One of the main selling points of Rust is memory safety. However, it is undermined every time people opt out of the checks and write an unsafe block.

A while ago I decided to check just how prevalent that is in widely used code, and I was astonished by what I've found: many popular and widely used Rust crates contain quite a few unsafe blocks, even when they're not doing anything inherently unsafe, and a surprising number of them can be converted into safe code without losing performance.]]></description><guid isPermaLink="false">7c53cfec-7842-4ca1-a1bb-183b2d6c1444</guid><pubDate>Sat,  2 Nov 2019 00:00:00 +0000</pubDate><dc:creator>Sergey &quot;Shnatsel&quot; Davidoff</dc:creator></item><item><title>Rust 2020: Generics &amp; cargo features</title><link>https://blog.turbo.fish/rust-2020/</link><description><![CDATA[This is my personal wishlist of things I'd like to see in 2020 relating to Rust. It only contains technical items, not because I disagree with the people who say we should prioritize some non-technical things, but because I feel like I don't have much of value to add to that topic.]]></description><guid isPermaLink="false">2c81b74e-4e60-42e9-961d-be0ebb810c87</guid><pubDate>Sat,  2 Nov 2019 00:00:00 +0000</pubDate><dc:creator>Jonas Platte</dc:creator></item><item><title>Rust 2020: what about feedbacks?</title><link>https://blog.guillaume-gomez.fr/articles/2019-11-01+Rust+2020%3A+what+about+feedbacks%3F</link><description><![CDATA[I've been working on the Rust compiler for years. It got stabilized, then matured through the years. From my point of view, it now has most of the features I wanted. So what would I want for Rust 2020 and what's coming after? To sum it up: feedbacks.]]></description><guid isPermaLink="false">15458bd0-19bb-4bf6-8460-5857ec6aecdc</guid><pubDate>Fri,  1 Nov 2019 21:30:00 +0000</pubDate><dc:creator>Guillaume Gomez</dc:creator></item><item><title>Rust 2020 - Libraries, Libraries, Libraries!</title><link>https://beyermatthias.de/blog/2019/11/01/rust-2020-libraries-libraries-libraries/</link><description><![CDATA[The call for blogs was just issues a few days ago - and here I am writing about my biggest pains this year… because that’s what the call for blogs basically is for me… I write down my pains with Rust and hope things get better slowly next year.

Don’t misunderstand what I want to say here though: Rust is awesome, has an awesome community, awesome tooling, awesome everything… well not completely (because otherwise I wouldn’t have to write this article, right?]]></description><guid isPermaLink="false">702fd8df-1263-4a2b-ae50-ea9b5e27e35a</guid><pubDate>Fri,  1 Nov 2019 20:45:00 +0000</pubDate><dc:creator>Matthias Beyer</dc:creator></item><item><title>Rust 2020: A better ecosystem</title><link>https://omarabid.com/rust-2020</link><description><![CDATA[I’m fairly new to Rust, and thus my perspective is that of someone who is not quite sophisticated with the language. I think Rust is hard to learn but should be manageable for your average software developer given enough persistence. Once you are over that barrier, you start thinking of building something in Rust. Probably, for the web, or a desktop application, or a mobile application; because that’s largely what many developers are building today.]]></description><guid isPermaLink="false">b2e770a7-f957-470a-8d0b-e5ba86c9872e</guid><pubDate>Fri,  1 Nov 2019 13:37:48 -0700</pubDate><dc:creator>Abid Omar</dc:creator></item><item><title>Linearity among the toctou</title><link>https://www.cloudatomiclab.com/toctou/</link><description><![CDATA[I have been reading a lot of papers on linear types recently. Originally it was to understand better why Rust went down the path it did, but I found a lot more interesting stuff there. While some people now are familiar with linear typesas the basis for Rust’s memory management, they have been around for a long time and have lots of other potential uses. In particular they are interesting for improving resource allocation in functional programming languages by reusing storage in place where possible. Generally they are useful for reasoning about resource allocation. While the Rust implementation is probably the most widely used at present, it kind of obscures the underlying simple principles by adding borrowing, so I will only mention it a little in this post.]]></description><guid isPermaLink="false">511a9fb7-b477-4d17-9c06-fd507b580a21</guid><pubDate>Fri,  1 Nov 2019 17:27:00 +0000</pubDate><dc:creator>Justin Cormack</dc:creator></item><item><title>Always Bump Downwards</title><link>https://fitzgeraldnick.com/2019/11/01/always-bump-downwards.html</link><description><![CDATA[When writing a bump allocator, always bump downwards. That is, allocate from high addresses, down towards lower addresses by decrementing the bump pointer. Although it is perhaps less natural to think about, it is more efficient than incrementing the bump pointer and allocating from lower addresses up to higher ones.]]></description><guid isPermaLink="false">a251550c-42ad-42d6-8780-eae69e3bc85f</guid><pubDate>Fri,  1 Nov 2019 00:00:00 -0700</pubDate><dc:creator>Nick Fitzgerald</dc:creator></item><item><title>This month in rustsim #8 (August − September - October 2019)</title><link>https://www.rustsim.org/blog/2019/11/01/this-month-in-rustsim/</link><description><![CDATA[Welcome to the eighth edition of This month in rustsim! This monthly newsletter will provide you with a summary of important update that occurred within the rustsim community. This includes in particular updates about the nphysics (physics engine), salva (fluid simulation), ncollide (for collision-detection), nalgebra (for linear algebra), and alga (for abstract algebra) crates. This eighth edition will actually contain updates for the past three months (I got sick between the second and third month so I did not get the time to write a new post then. Sorry!)]]></description><guid isPermaLink="false">6b61d3a8-a487-4399-a347-43e16c50abc1</guid><pubDate>Fri,  1 Nov 2019 00:00:00 +0000</pubDate><dc:creator>Sébastien Crozet</dc:creator></item><item><title>Bayard is a full-text search and indexing server written in Rust</title><link>https://github.com/bayard-search/bayard</link><description><![CDATA[Bayard is a full-text search and indexing server written in Rust built on top of Tantivy that implements The Raft Consensus Algorithm (raft-rs) and The gRPC (grpc-rs). Achieves consensus across all the nodes, ensures every change made to the system is made to a quorum of nodes. Bayard makes easy for programmers to develop search applications with advanced features and high availability.]]></description><guid isPermaLink="false">fb00840d-e1ce-4791-9b05-7e1567701082</guid><pubDate>Fri,  1 Nov 2019 00:00:00 +0000</pubDate><dc:creator>Bayard Search</dc:creator></item><item><title>Completing the transition to the new borrow checker</title><link>https://blog.rust-lang.org/2019/11/01/nll-hard-errors.html</link><description><![CDATA[For most of 2018, we've been issuing warnings about various bugs in the borrow checker that we plan to fix -- about two months ago, in the current Rust nightly, those warnings became hard errors. In about two weeks, when the nightly branches to become beta, those hard errors will be in the beta build, and they will eventually hit stable on December 19th, as part of Rust 1.40.0. If you're testing with Nightly, you should be all set -- but otherwise, you may want to go and check to make sure your code still builds. If not, we have advice for fixing common problems below.]]></description><guid isPermaLink="false">290147b3-4275-4b38-86d1-48ead00c7e9f</guid><pubDate>Fri,  1 Nov 2019 00:00:00 +0000</pubDate><dc:creator>Niko Matsakis</dc:creator></item><item><title>@notriddle&apos;s Rust 2020 wishlist, or, Rust 2021: Integration</title><link>http://txti.es/notriddle-rust-2020</link><description><![CDATA[This is just a brain dump. Doing all of this is not going to happen, but all of it is stuff I know of that impacts Rust's integration with the rest of the world and eventually becoming Too Big To Fail like C++ is.]]></description><guid isPermaLink="false">a2f9e31b-3a47-48f0-981b-0f00fe03471e</guid><pubDate>Fri,  1 Nov 2019 00:00:00 +0000</pubDate><dc:creator>notriddle</dc:creator></item><item><title>Rust 2021: Sustainability</title><link>https://xampprocky.github.io/public/blog/rust-2021/</link><description><![CDATA[For the 2019 roadmap Jonathan Turner wrote a blog post called the The Fallow Year that posited that we should let the new designs "field" rest (go fallow) while we focus on other areas. To extend that metaphor, I would say Rust has fallen into monocropping in 2019 by focusing too much on our technical debt, when we needed to be addressing our social debt.]]></description><guid isPermaLink="false">5458741c-97c2-4a8f-bb9e-73daf7317c81</guid><pubDate>Fri,  1 Nov 2019 00:00:00 +0000</pubDate><dc:creator>XAMPPRocky</dc:creator></item><item><title>Rust 2020: Let’s embrace the Eternal September</title><link>https://tim.mcnamara.nz/post/188733729327/rust-2020-lets-embrace-the-eternal-september</link><description><![CDATA[User growth means accepting people that haven’t been exposed to Rust’s norms yet. Let’s not fracture because of an argument over top-posting vs bottom-quoting or something equally trivial. We need to make sure that Rust is prepared to welcome people who are just learning about Rust today. We don’t want anyone to feel like they’re late to the party.]]></description><guid isPermaLink="false">05982a72-c4dd-49ff-8384-3af1783e7211</guid><pubDate>Fri,  1 Nov 2019 00:00:00 +0000</pubDate><dc:creator>Tim McNamara</dc:creator></item><item><title>Rust 2020: GUI and community</title><link>https://raphlinus.github.io/rust/druid/2019/10/31/rust-2020.html</link><description><![CDATA[In response to the call for blogs about the vision for Rust for 2020, I’m going to write about GUI. I believe the time is right for a native GUI toolkit written in Rust, and that such a thing would fill a very important niche. There is a demand for performance (which, to me, includes startup time, RAM footprint, and binary size), and Rust is in the best position to deliver on that.]]></description><guid isPermaLink="false">e6cb0f49-a174-4d58-9acd-2253bbf3bfbe</guid><pubDate>Thu, 31 Oct 2019 19:27:42 +0000</pubDate><dc:creator>Raph Levien</dc:creator></item><item><title>Rust 2020</title><link>https://bes.github.io/guide/2019/10/31/rust-2020-call-for-blogs.html</link><description><![CDATA[We have all been called upon by @rustlang to share our thoughts on what we want from Rust in 2020. My wants are centered around the developer/debug experience more than the language itself. I find the language to be expressive and attractive for many types of development, and I find the community to be very pleasant.]]></description><guid isPermaLink="false">688e00b5-4286-4181-af3e-31bf8090ae74</guid><pubDate>Thu, 31 Oct 2019 17:34:11 +0000</pubDate><dc:creator>Erik Zivkovic</dc:creator></item></channel></rss>