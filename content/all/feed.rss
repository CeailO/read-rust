<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/"><channel><title>Read Rust - All Posts</title><link>https://readrust.net/</link><description>All Posts posts on Read Rust</description><item><title>Rust: controlling side effects from the test</title><link>https://blog.cyplo.net/posts/2018/07/rust-injection.html</link><description><![CDATA[Imagine you want to write a timestamping repository of some sorts, that will associate the timestamp of when the storage operation was invoked with the stored value. How to write it in Rust ? And more importantly - how to test it ? I would like to share a solution I found and talk a bit about how it works.]]></description><guid isPermaLink="false">3b874195-0df6-40ca-8667-067d3440061b</guid><pubDate>Mon, 30 Jul 2018 00:00:00 +0000</pubDate><dc:creator>Cyryl Płotnicki</dc:creator></item><item><title>Futures 0.3.0-alpha.2</title><link>https://rust-lang-nursery.github.io/futures-rs/blog/2018/07/30/futures-0.3.0-alpha.2.html</link><description><![CDATA[Several new changes while working towards 0.3.]]></description><guid isPermaLink="false">e29e550b-7c05-4625-9a81-513b316b5675</guid><pubDate>Mon, 30 Jul 2018 00:00:00 +0000</pubDate><dc:creator>Josef Brandl</dc:creator></item><item><title>Using C libraries in Rust: make a sys crate</title><link>https://kornel.ski/rust-sys-crate</link><description><![CDATA[Using C libraries in a portable way involves a bit of work: finding the library on the system or building it if it's not available, checking if it is compatible, finding C headers and converting them to Rust modules, and giving Cargo correct linking instructions. Often every step of this is tricky, because operating systems, package managers and libraries have their unique quirks that need special handling.

Fortunately, all this work can be done once in a build script, and published as a <insert library name>-sys Rust crate. This way other Rust programmers will be able to use the C library without having to re-invent the build script themselves.]]></description><guid isPermaLink="false">e0622344-66a9-4b93-a59f-1b5250ba8c98</guid><pubDate>Mon, 30 Jul 2018 00:00:00 +0000</pubDate><dc:creator>Kornel</dc:creator></item><item><title>What is Rust 2018?</title><link>https://blog.rust-lang.org/2018/07/27/what-is-rust-2018.html</link><description><![CDATA[The release of Rust 1.31.0 on December 6th will be the first release of “Rust 2018.” This marks a culmination of the last three years of Rust’s development, and brings it together in one neat package. For example, there will be a 2018 edition of the book that incorporates features stabilized since the print edition was considered finalized.]]></description><guid isPermaLink="false">2c62015d-b849-4ab6-bbc9-e62255ca3473</guid><pubDate>Fri, 27 Jul 2018 00:00:00 +0000</pubDate><dc:creator>The Rust Core Team</dc:creator></item><item><title>Announcing the js-sys crate!</title><link>https://rustwasm.github.io/2018/07/26/announcing-the-js-sys-crate.html</link><description><![CDATA[The js-sys crate contains raw #[wasm_bindgen] bindings to all the global APIs guaranteed to exist in every JavaScript environment by the ECMAScript standard. It does not contain bindings to any Web- or Node-specific APIs. With the js-sys crate, we can work with Objects, Arrays, Functions, Maps, Sets, etc… without writing the #[wasm_bindgen] imports by hand.]]></description><guid isPermaLink="false">95c003ee-6a87-45cb-abd3-491bd965d65c</guid><pubDate>Thu, 26 Jul 2018 00:00:00 +0000</pubDate><dc:creator>rustwasm</dc:creator></item><item><title>Version selection in Cargo</title><link>http://aturon.github.io/2018/07/25/cargo-version-selection/</link><description><![CDATA[When there are multiple ways to resolve dependencies, Cargo generally chooses the newest possible version. The goal of this post is to explain why Cargo works this way, and how that rationale relates to several recent discussions, including:]]></description><guid isPermaLink="false">d0dc161e-3fcc-4fc7-9032-f9847bf4f3b8</guid><pubDate>Wed, 25 Jul 2018 00:00:00 +0000</pubDate><dc:creator>Aaron Turon</dc:creator></item><item><title>Where next for the Monotron</title><link>http://railwayelectronics.blogspot.com/2018/07/where-next-for-monotron.html?m=1</link><description><![CDATA[It's a couple of months on from my talk at RustFest on Monotron, so I thought it was worth a quick catch up on where we're going next. As a recap, Monotron currently generates an 800 x 600 VGA signal at 60 Hz (with a pixel clock of 40 MHz). It does this using three synchronised SPI peripherals, a timer generating the horizontal-sync pulse and a GPIO pin for the vertical-sync. With the CPU running at a clock speed of 80 MHz, the SPI peripherals are clocked at 20 MHz producing 400 horizontal pixels per line. This is half the nominal 800 pixels, but we needed to sacrifice resolution to double the amount of CPU time we have to 4 clocks per pixel (i.e. 32 clocks per 8-bit character column).]]></description><guid isPermaLink="false">669e3447-5dac-4fe9-a87a-0b315ae3062d</guid><pubDate>Tue, 24 Jul 2018 22:40:00 +0100</pubDate><dc:creator>theJPster</dc:creator></item><item><title>Pointers Are Complicated, or: What&apos;s in a Byte?</title><link>https://www.ralfj.de/blog/2018/07/24/pointers-and-bytes.html</link><description><![CDATA[This summer, I am again working on Rust full-time, and again I will work (amongst other things) on a “memory model” for Rust/MIR. However, before I can talk about the ideas I have for this year, I have to finally take the time and dispel the myth that “pointers are simple: they are just integers”. Both parts of this statement are false, at least in languages with unsafe features like Rust or C: Pointers are neither simple nor (just) integers.

I also want to define a piece of the memory model that has to be fixed before we can even talk about some of the more complex parts: Just what is the data that is stored in memory? It is organized in bytes, the minimal addressable unit and the smallest piece that can be accessed (at least on most platforms), but what are the possible values of a byte? Again, it turns out “it’s just an 8-bit integer” does not actually work as the answer.

I hope that by the end of this post, you will agree with me on both of these statements. :)]]></description><guid isPermaLink="false">b4133437-b69d-4491-a40f-a368a8847627</guid><pubDate>Tue, 24 Jul 2018 00:00:00 +0000</pubDate><dc:creator>Ralf Jung</dc:creator></item><item><title>Building Readable Tests with Fluent Testing APIs</title><link>https://leotindall.com/tutorial/building-readable-tests-with-fluent-testing-apis/</link><description><![CDATA[One of the biggest challenges in software testing is defining the input for code under test in a way that is expressive and powerful enough to test complex situations but doesn’t distract from the intent of the test or clutter the test code to a degree that makes it difficult to read.

Many dynamic languages have testing APIs which take advantage of their looser and later type checking to provide easy mocking and stubbing, but strict, statically typed languages can make it difficult to build up suitable instances of the types needed in the test.]]></description><guid isPermaLink="false">96eb15b8-5f51-403c-a699-805553293c16</guid><pubDate>Mon, 23 Jul 2018 09:56:24 -0500</pubDate><dc:creator>Leo Tindall</dc:creator></item><item><title>On impl blocks, injection and surjection in Rust</title><link>https://phaazon.net/blog/on-rust-impl-block</link><description><![CDATA[Rust has this cool feature called impl block. An impl block is just a scope that introduces a way to augment a type with methods – do not confuse impl blocks with trait impls, used to implement a given trait.]]></description><guid isPermaLink="false">4a0e6748-9562-4507-bbfe-3cdf49b6292b</guid><pubDate>Sun, 22 Jul 2018 22:05:00 +0000</pubDate><dc:creator>Dimitri Sabadie</dc:creator></item><item><title>Writing a GPU-Accelerated Path Tracer in Rust - Part 3</title><link>https://bheisler.github.io/post/writing-gpu-accelerated-path-tracer-part-3/</link><description><![CDATA[Hello! Welcome to my third and final post on my GPU-accelerated Path Tracer in Rust. In the last post, we implemented all of the logic necessary to build a true path tracer. Problem is, even on the GPU it’s terrifically slow. This post is (mostly) about fixing that.

But first, we need to fix a bug or two, because I goofed. *sad trombone*

Step -1: Fixing Bugs /u/anderslanglands on Reddit pointed out that, since I’m using Cosine-weighted Importance Sampling, I need to do some extra math to avoid biasing the results.]]></description><guid isPermaLink="false">0b53c7ea-570b-4595-b8eb-2f62d8e9cb96</guid><pubDate>Thu, 19 Jul 2018 18:30:00 -0600</pubDate><dc:creator>Brook Heisler</dc:creator></item><item><title>Announcing Rust 1.27.2</title><link>https://blog.rust-lang.org/2018/07/20/Rust-1.27.2.html</link><description><![CDATA[The Rust team is happy to announce a new version of Rust, 1.27.2.]]></description><guid isPermaLink="false">2d302e67-f458-4d07-b1f4-78cb9ed02914</guid><pubDate>Fri, 20 Jul 2018 00:00:00 +0000</pubDate><dc:creator>The Rust Core Team</dc:creator></item><item><title>Futures 0.3.0-alpha.1</title><link>https://rust-lang-nursery.github.io/futures-rs/blog/2018/07/19/futures-0.3.0-alpha.1.html</link><description><![CDATA[Welcome to the inaugural post of the new futures-rs blog!

After several months of work, we’re happy to announce an alpha release of the new edition of future-rs, version 0.3. The immediate goal of this work is to support async/await notation (with borrowing) in Rust itself, which has entailed significant changes to the futures crate.]]></description><guid isPermaLink="false">2a8864ba-0872-45d2-89f4-87e9f368374b</guid><pubDate>Thu, 19 Jul 2018 17:00:00 +0000</pubDate><dc:creator>Aaron Turon</dc:creator></item><item><title>Auditing popular Rust crates: how a one-line unsafe has nearly ruined everything</title><link>https://medium.com/@shnatsel/auditing-popular-rust-crates-how-a-one-line-unsafe-has-nearly-ruined-everything-fab2d837ebb1</link><description><![CDATA[Following the actix-web incident (which is fixed now, at least mostly) I decided to poke other popular Rust libraries and see what comes of it.

The good news is I’ve poked at 6 popular crates now, and I’ve got not a single actually exploitable vulnerability. I am impressed. When I poked popular C libraries a few years ago it quickly ended in tears. The bad news is I’ve found one instance that was not a security vulnerability by sheer luck, plus a whole slew of denial-of-service bugs. And I can’t fix all of them by myself. Read on to find out how I did it, and how you can help!]]></description><guid isPermaLink="false">80a9211d-dd65-4da8-b8d6-5d4223ee278d</guid><pubDate>Thu, 19 Jul 2018 01:38:11 +0000</pubDate><dc:creator>Sergey &quot;Shnatsel&quot; Davidoff</dc:creator></item><item><title>Thoughts on Compile-Time Function Evaluation and Type Systems</title><link>https://www.ralfj.de/blog/2018/07/19/const.html</link><description><![CDATA[For some time now (since the 1.26 release, to be precise), Rust has a very powerful machinery for CTFE, or compile-time function evaluation. Since then, there have been various discussions about which operations should be allowed during CTFE, which checks the compiler should do, how this all relates to promotion and which kinds of guarantees we should be able to expect around CTFE. This post is my take on those topics, and it should not be surprising that I am going to take a very type-system centric view. Expect something like a structured brain dump, so there are some unanswered questions towards the end as well.]]></description><guid isPermaLink="false">7e963a31-6451-4f7d-9817-1e8c33c4973d</guid><pubDate>Thu, 19 Jul 2018 00:00:00 +0000</pubDate><dc:creator>Ralf Jung</dc:creator></item><item><title>#[test] in 2018</title><link>https://blog.jrenner.net/rust/testing/2018/07/19/test-in-2018.html</link><description><![CDATA[Lately, I’ve been working implementing the Custom Test Frameworks eRFC for Rust. While exploring the compiler codebase, I’ve learned about the internals of testing in Rust and figured it would be interesting to share.]]></description><guid isPermaLink="false">f4903839-c307-4209-b760-15176676663f</guid><pubDate>Thu, 19 Jul 2018 00:00:00 +0000</pubDate><dc:creator>John Renner</dc:creator></item><item><title>RustSec Advisory Database</title><link>https://rustsec.org/</link><description><![CDATA[Security advisory database for Rust crates published through https://crates.io.]]></description><guid isPermaLink="false">db3cdc15-004b-4a41-9649-6ade4a8407eb</guid><pubDate>Thu, 19 Jul 2018 00:00:00 +0000</pubDate><dc:creator>Rust Project Developers</dc:creator></item><item><title>Wayland-rs 0.21: Pure Rust implementation</title><link>https://smithay.github.io/wayland-rs-v-0-21.html</link><description><![CDATA[wayland-rs is a set of crates providing generic APIs to manipulate the Wayland protocol, successor of X11 for linux windowing.

Here I am finally, after having hinted at the possibility and finally taken the time to write and merge quite an epic pull request, I can finally say it: wayland-rs is now a pure rust implementation of the protocol, rather than a crate of bindings to the wayland system C libraries.]]></description><guid isPermaLink="false">e5caa9df-4d3f-46be-a8ce-79369f0cad32</guid><pubDate>Wed, 18 Jul 2018 22:00:00 +0200</pubDate><dc:creator>Victor Berger</dc:creator></item><item><title>cargo-generate: create a new Rust project from a template </title><link>https://github.com/ashleygwilliams/cargo-generate</link><description><![CDATA[cargo-generate is a developer tool to help you get up and running quickly with a new Rust project by leveraging a pre-existing git repository as a template.]]></description><guid isPermaLink="false">9ceafb2d-9937-48c9-9deb-ff9d1ebd19d3</guid><pubDate>Wed, 18 Jul 2018 06:59:00 +0000</pubDate><dc:creator>Ashley Williams</dc:creator></item><item><title>How to help test the 2018 edition</title><link>https://www.ncameron.org/blog/how-to-help-test-the-2018-edition/</link><description><![CDATA[An edition brings together the features that have landed into a clear package, with fully updated documentation and tooling. By the end of the year we are planning to release the 2018 edition, our first since the Rust 1.0 release. You can currently opt-in to a preview of the 2018 edition to try it out and help test it.

In fact, we really need help testing it out! Once you’ve turned it on and seen its wonderful new features, what then? Here we’ve got some specific things we’d like you to test.]]></description><guid isPermaLink="false">a81b111b-b3d6-4515-81bc-00d00bf62fb9</guid><pubDate>Wed, 18 Jul 2018 03:08:04 +0000</pubDate><dc:creator>Nick Cameron</dc:creator></item><item><title>Deploying Rust with Docker and Kubernetes</title><link>https://www.fpcomplete.com/blog/2018/07/deploying-rust-with-docker-and-kubernetes</link><description><![CDATA[Using a tiny Rust app to demonstrate deploying Rust with Docker and Kubernetes.]]></description><guid isPermaLink="false">f53d06d7-6b22-4cb8-95f1-66f8ae0bdb8f</guid><pubDate>Tue, 17 Jul 2018 21:36:08 +0000</pubDate><dc:creator>Chris Allen</dc:creator></item><item><title>Hello Content-o-Tron</title><link>http://blog.community.rs/content-team/2018/07/16/hello-content-o-tron.html</link><description><![CDATA[Content-o-Tron is a project to help amplify the lesser heard voices in the Rust community.

We are able to do this by providing editorial assistance and technical reviews of draft blog posts.

Once your blog post is ready to publish, we will ensure it is disseminated through various channels such as Read Rust, MozHacks, social networks and of course the Rust Community’s own blog on community.rs.]]></description><guid isPermaLink="false">fbdc0364-12e8-49f4-914f-b3c4f17d43f0</guid><pubDate>Mon, 16 Jul 2018 00:00:00 +0000</pubDate><dc:creator>Mark Sta Ana</dc:creator></item><item><title>Flocking in Rust with Piston</title><link>https://blog.shine.rocks/posts/flocking-in-rust-with-piston/</link><description><![CDATA[Wikipedia states that flocking is a behavior exhibited when a group of birds, called a flock, are foraging or in flight. Flocking simulation are basically softwares which simulate this flocking behavior of birds. The original algorithm is developed by Craig Reynolds in 1986.]]></description><guid isPermaLink="false">a65d9a08-fc44-4976-b2ad-82b934b7961f</guid><pubDate>Sun, 15 Jul 2018 00:00:00 +0000</pubDate><dc:creator>Htet Aung Shine</dc:creator></item><item><title>How we built a Visual Studio Code extension for IoT prototyping</title><link>https://cultivatehq.com/posts/how-we-built-a-visual-studio-code-extension-for-iot-prototyping/</link><description><![CDATA[We recently had the opportunity to make a Visual Studio Code extension that needed to communicate with an embedded device. This post explains the architecture we chose to achieve that and the decisions that led to it.]]></description><guid isPermaLink="false">a9a551b0-07a6-48a2-944f-b956438fecc0</guid><pubDate>Fri, 13 Jul 2018 22:39:00 +0000</pubDate><dc:creator>Dan Munckton</dc:creator></item><item><title>Electrosmog trapping with CC1101</title><link>https://dsvensson.github.io/posts/2018-07-13-Electrosmog-trapping-with-CC1101.html</link><description><![CDATA[A couple of months ago I moved to a house, and the need to monitor-all-the-things guided me towards the affordable IKEA Sparsnäs energy display. Sparsnäs is made up of two parts, one being the transmitter that is attached to your electricity meter, and the other; the display that stores usage, and presents a variety of graphs. The downside is that there is no way of getting the data out of the display so you have to accept how it’s presented, and that it may get lost, or build something on your own. Thankfully the protocol has been thoroughly reverse engineered and documented in a very elaborate manner.]]></description><guid isPermaLink="false">c5d017d6-de45-4099-9272-19fe01441fdc</guid><pubDate>Fri, 13 Jul 2018 20:06:53 +0000</pubDate><dc:creator>Daniel Svensson</dc:creator></item><item><title>Multi target Rust builds with auto deployment in Travis-CI</title><link>https://medium.com/@tyrf/multi-target-rust-builds-with-auto-deployment-in-travis-ci-ab5214fb73ba</link><description><![CDATA[This is just a small build script to automatically compile and create Rust binaries for your i86 32 and 64 bit machine and your Raspberry Pi(ARM) with Travis-CI. On the right side I added a little explanation of the following script.]]></description><guid isPermaLink="false">fbdcd657-aab5-4d28-aa3a-ab04294f49eb</guid><pubDate>Fri, 13 Jul 2018 18:44:17 +0000</pubDate><dc:creator>Hendrik Teuber</dc:creator></item><item><title>Linux Container Internals (Part II)</title><link>https://rabbitstack.github.io/operating%20systems/containers/linux-container-internals-part-ii/</link><description><![CDATA[Containers are moving the world. Each passing day more and more organizations are embracing containers as first-class citizens for distribution and deployment of software components. Containers represent the core of the cloud native paradigm.]]></description><guid isPermaLink="false">5f84b8db-7379-4c08-9cae-d2a901caaab1</guid><pubDate>Fri, 13 Jul 2018 18:10:04 +0200</pubDate><dc:creator>Nedim Šabić</dc:creator></item><item><title>Rust vs. Go</title><link>http://julio.meroh.net/2018/07/rust-vs-go.html</link><description><![CDATA[Welcome to the Rust Review’s bonus post, which I had promised from the very beginning. I’m here to cover the big elephant in the room: Rust vs. Go. Which one is better?

There is no good answer to this question because this comparison is unfounded. I think people tend to bundle the two languages together because they were released at about the same time and the release of Rust felt like a response to the release of Go. Moreover, both languages are supposed to focus on systems software. But they are vastly different, and even as they both target systems software, they target different kinds of such software.]]></description><guid isPermaLink="false">40055859-95cc-47a0-89e3-fd3c8a000fba</guid><pubDate>Fri, 13 Jul 2018 10:45:00 +0200</pubDate><dc:creator>Julio Merino</dc:creator></item><item><title>Writing a GPU-Accelerated Path Tracer in Rust - Part 2</title><link>https://bheisler.github.io/post/writing-gpu-accelerated-path-tracer-part-2/</link><description><![CDATA[Hello, and welcome to part two of my series on writing a GPU-accelerated path tracer in Rust. I’d meant to have this post up sooner, but nothing ruins my productivity quite like Games Done Quick. I’m back now, though, so it’s time to turn the GPU ray-tracer from the last post into a real path tracer.

Tracing Paths As mentioned last time, Path Tracing is an extension to Ray Tracing which attempts to simulate global illumination.]]></description><guid isPermaLink="false">289bc607-7039-4931-838e-0451ee67e488</guid><pubDate>Thu, 12 Jul 2018 19:00:00 -0600</pubDate><dc:creator>Brook Heisler</dc:creator></item><item><title>The Tale of a Bug in Arc: Synchronization and Data Races</title><link>https://www.ralfj.de/blog/2018/07/13/arc-synchronization.html</link><description><![CDATA[While I was busy doing Rust-unrelated research, RustBelt continues to move and recently found another bug (after a missing impl !Sync that we found previously): It turns out that Arc::get_mut did not perform sufficient synchronization, leading to a data race.]]></description><guid isPermaLink="false">b2fbac94-27b1-4c37-8c21-ead67edecf43</guid><pubDate>Fri, 13 Jul 2018 00:00:00 +0000</pubDate><dc:creator>Ralf Jung</dc:creator></item><item><title>Physical Computing With Rust On Raspberry Pi</title><link>https://medium.com/@rahulthakoor/physical-computing-with-rust-on-raspberry-pi-a7b6f34261a6</link><description><![CDATA[A couple of months ago I released the rust_gpiozero¹ crate. It is a port of the GPIO Zero² library by the Raspberry Pi Foundation. The library provides a simple interface to control GPIO devices with a Raspberry Pi. Following this, recently ported the Raspberry Pi Foundation’s Physical Computing with Python³ guide for Rust.]]></description><guid isPermaLink="false">34fa3257-4ea8-4ade-8cad-353aa02239d3</guid><pubDate>Thu, 12 Jul 2018 14:52:13 +0000</pubDate><dc:creator>Rahul Thakoor</dc:creator></item><item><title>Ownership in Rust, Part 2</title><link>https://medium.com/@thomascountz/ownership-in-rust-part-2-c3e1da89956e</link><description><![CDATA[It’s still not problem.]]></description><guid isPermaLink="false">62456010-4ef4-4f1d-87f0-6e0c64929d82</guid><pubDate>Wed, 11 Jul 2018 16:55:03 +0000</pubDate><dc:creator>Thomas Countz</dc:creator></item><item><title>BetaFPV F3 Drone Flight Controller - Hello Rust</title><link>https://www.joshmcguigan.com/blog/betafpv-drone-flight-controller-hello-rust/</link><description><![CDATA[One of the most exciting areas of hobbyist embedded programming, in my opinion, is flight controllers for remote controlled aircraft. In the particular case of a multi-rotor drone, the flight controller is responsible for converting the UP command from the transmitter into specific outputs for each of the motors. Maintaining the stability of a drone involves carefully adjusting the output of each motor thousands of times per second based on feedback from on-board sensors.

There are several great C-based open source drone flight controller firmware projects, but as far as I can see there are none written in Rust. The good news is that most drone flight controllers are based on STM32 MCUs, which Rust has strong support for. Robust flight controller firmware is quite complex, and there are a number of challenges to be solved before even getting the rotors spinning. The first of those challenges is building a Rust project for a particular flight controller board, and flashing the board with the compiled code. A single blinking LED is our goal for today.]]></description><guid isPermaLink="false">133f5906-759e-4a83-b188-fc18eda31cc0</guid><pubDate>Wed, 11 Jul 2018 00:00:00 +0000</pubDate><dc:creator>Josh Mcguigan</dc:creator></item><item><title>Ownership in Rust, Part 1</title><link>https://medium.com/@thomascountz/ownership-in-rust-part-1-112036b1126b</link><description><![CDATA[It’s not my problem.]]></description><guid isPermaLink="false">c0f25118-a040-4f57-bd18-1594ce4e72f6</guid><pubDate>Mon,  9 Jul 2018 20:58:44 +0000</pubDate><dc:creator>Thomas Countz</dc:creator></item><item><title>Rust + actix-web power Atlas Weekend music festival</title><link>https://www.reddit.com/r/rust/comments/8xdsx5/rust_actixweb_in_the_on_of_the_biggest_music/</link><description><![CDATA[We've just finished music festival Atlas Weekend which took place in Kyiv, Ukraine. This year there were for about 450,000 visitors during 6 days. I'm glad to announce that Rust and actix-web are used as a backend for main technical purposes of festival.]]></description><guid isPermaLink="false">a95c25cb-0553-42ee-a81a-4a9cedce53e8</guid><pubDate>Tue, 10 Jul 2018 03:16:52 +1000</pubDate><dc:creator>/u/maxfrai</dc:creator></item><item><title>The Cheddar shading language</title><link>https://phaazon.net/blog/cheddar-0.1</link><description><![CDATA[Cheddar is a GLSL superset language. What it means is that most of the GLSL constructs and syntax you’re used to is valid in Cheddar – not all of it; most of it. Cheddar adds a set of features that I think are lacking to GLSL. Among them: Some non-valid GLSL constructions made valid in Cheddar to ease the writing of certain shader stages; A more functional approach to programming shaders on the GPU; Structures, types and GLSL-specific constructs sharing; Imports and modules with live reloading and transitive dependencies.]]></description><guid isPermaLink="false">5579acfe-3441-4097-9476-863e348858f5</guid><pubDate>Mon,  9 Jul 2018 01:00:00 +0000</pubDate><dc:creator>Dimitri Sabadie</dc:creator></item><item><title>Rustberry 0.1.0 has been released, and I need more testers!</title><link>https://www.reddit.com/r/rust/comments/8x1ayd/calling_all_raspberry_pi_owners_rustberry_010_has/</link><description><![CDATA[After many laborious hours of reading and interpreting the various online references, I've published the first release of my latest project, a crate to safely abstract Raspberry Pi's platform-specific features in Rust. I've (very creatively) named it Rustberry, and it's finally stable and clean enough that I'm able to publish it and receive initial feedback.]]></description><guid isPermaLink="false">54c6e230-51fa-42c2-bcab-26b75e699bb3</guid><pubDate>Sun,  8 Jul 2018 23:06:00 +1000</pubDate><dc:creator>/u/ninja_tokumei</dc:creator></item><item><title>A web application completely in Rust</title><link>https://medium.com/@saschagrunert/a-web-application-completely-in-rust-6f6bdb6c4471</link><description><![CDATA[My latest software architectural experiment is to write a complete real-world web application in Rust with as less as boilerplate as possible. Within this post I want to share my findings with you to answer the question on how much web Rust actually is.]]></description><guid isPermaLink="false">a16772c9-e5d4-4e73-8bec-934d8ae183c5</guid><pubDate>Sat,  7 Jul 2018 19:58:43 +0000</pubDate><dc:creator>Sascha Grunert</dc:creator></item><item><title>Why I love Rust</title><link>https://alexkitchens.net/2018/07/06/why-i-love-rust.html</link><description><![CDATA[I spent much of my free time over the past year learning Rust, and while it’s been a difficult language to fully grasp (it’s still a work in progress), I find it incredibly rewarding to write in. I also have had many conversations with people who don’t know much about Rust and are curious about the problems it solves.

This is my take on why Rust is important, and why I have fallen in love with the language.]]></description><guid isPermaLink="false">d52613f9-60c7-4448-89ed-72cd3da79346</guid><pubDate>Fri,  6 Jul 2018 08:46:39 +0000</pubDate><dc:creator>Alex Kitchens</dc:creator></item><item><title>Rust: Raw string literals</title><link>https://medium.com/@rahulthakoor/rust-raw-string-literals-9579c4feb231</link><description><![CDATA[While working with Rust, you will often come across r#"something like this"#, especially when working with JSON and TOML files. It defines a raw string literal. When would you use a raw string literal and what makes a valid raw string literal?]]></description><guid isPermaLink="false">ca7cc808-b6f7-4650-a219-b2c92be95460</guid><pubDate>Thu,  5 Jul 2018 13:26:49 +0000</pubDate><dc:creator>Rahul Thakoor</dc:creator></item><item><title>Tiny Planets</title><link>http://www.mattkeeter.com/projects/planets/</link><description><![CDATA[In the past few years, I've heard a lot about Rust. As someone that hacks on computer graphics and low-level infrastructure libraries, it seems relevant to my interests. I decided to make a small demo – of a procedural planet generator – and see how it went.]]></description><guid isPermaLink="false">306a1044-e3e5-4a20-b4df-6577fa6eadf5</guid><pubDate>Thu,  5 Jul 2018 02:45:00 +0000</pubDate><dc:creator>Matt Keeter</dc:creator></item><item><title>Surface Rust: The Missing IDE</title><link>https://medium.com/@wolfshirts/surface-rust-6470d0075721</link><description><![CDATA[This week I decided to do a little hacking on Rust. I thought I’d write down my first impressions of the language.]]></description><guid isPermaLink="false">54242603-6ea7-4c99-8826-bbda3f8f63db</guid><pubDate>Wed,  4 Jul 2018 21:45:48 +0000</pubDate><dc:creator>@wolfshirts</dc:creator></item><item><title>Embedded development with Yocto and Rust</title><link>https://pagefault.blog/2018/07/04/embedded-development-with-yocto-and-rust/</link><description><![CDATA[Customized Linux distribution and a safe systems programming language sounds like a very interesting combination for embedded development. That is what makes Yocto and Rust such a good match. So, I wanted to see how Rust projects could be cross-compiled with Yocto-generated toolchain and root filesystem. The steps are described in this post.]]></description><guid isPermaLink="false">bef012dd-518b-4a24-9acd-d0d68b3bead3</guid><pubDate>Wed,  4 Jul 2018 17:06:32 +0000</pubDate><dc:creator>Sami Pietikäinen</dc:creator></item><item><title>Let&apos;s code with the Roguelike tutorial - Part 3 - Making a dungeon</title><link>https://www.yosenspace.com/posts/lets-code-roguelike-tutorial-part3-making-dungeon.html</link><description><![CDATA[It's time to start making some rooms and connecting them together. These will require making modifications to the map, so I guess it's time to finally refactor the map code into its own legitimate class.]]></description><guid isPermaLink="false">35ed06d7-694b-4d04-ade3-5a8816619b78</guid><pubDate>Wed,  4 Jul 2018 09:42:00 +0000</pubDate><dc:creator>Yosen</dc:creator></item><item><title>Let&apos;s code with the Roguelike tutorial - Part 2 - Entities and the map</title><link>https://www.yosenspace.com/posts/lets-code-roguelike-tutorial-part2-entities-map.html</link><description><![CDATA[As I mentioned in the last post, until I got a better handle on the off screen console code, I temporarily made all the Rust bindings call out to the default root console. Now that there's a bit of discussion on how the off screen consoles work, it's time to refactor the code to enable their use. ]]></description><guid isPermaLink="false">5489d43b-5cbb-4f2b-964e-1aacba277cd6</guid><pubDate>Wed,  4 Jul 2018 07:53:00 +0000</pubDate><dc:creator>Yosen</dc:creator></item><item><title>Why Rust?</title><link>https://medium.com/paritytech/why-rust-846fd3320d3f</link><description><![CDATA[Programming is hard. Not because our hardware is complex, but simply because we’re all humans. Our attention span is limited, our memory is volatile — in other words, we tend to make mistakes.]]></description><guid isPermaLink="false">1b9d4f29-d237-4f3d-bc55-23b9ab2c5d77</guid><pubDate>Wed,  4 Jul 2018 07:43:11 +0000</pubDate><dc:creator>Dmitriy Kashitsyn</dc:creator></item><item><title>RSoC: FAT32 Filesystem in Redox - 2</title><link>https://www.redox-os.org/news/rsoc-fat32-2/</link><description><![CDATA[This is the second blog post about implementing a FAT32 filesystem in Redox.]]></description><guid isPermaLink="false">87ea8aa4-a134-4f8a-8ff2-fc33f4832020</guid><pubDate>Tue,  3 Jul 2018 00:00:00 +0000</pubDate><dc:creator>Deepak Sirone</dc:creator></item><item><title>Fullstack React: Rust, React and WebAssembly</title><link>https://www.fullstackreact.com/articles/rust-react-and-web-assembly/</link><description><![CDATA[A tutorial on how to compile Rust to WebAssembly and integrate it into a React application]]></description><guid isPermaLink="false">c700cc05-51d7-4599-b545-37f4db96f347</guid><pubDate>Tue,  3 Jul 2018 00:00:00 +0000</pubDate><dc:creator>Anders Pitman</dc:creator></item><item><title>Learning SIMD with Rust by finding planets</title><link>https://medium.com/@Razican/learning-simd-with-rust-by-finding-planets-b85ccfb724c3</link><description><![CDATA[Rust 1.27.0 has brought SIMD (Single Instruction Multiple Data), also known as vectorization, to stable Rust. If you read the announcement, you will see that SIMD should bring performance enhancements to our applications if we learn how to use it properly. But, for that let's first dive into how SIMD works.]]></description><guid isPermaLink="false">98469a08-b569-403f-a3ed-6049ff91c0b1</guid><pubDate>Mon,  2 Jul 2018 20:47:57 +0000</pubDate><dc:creator>Iban Eguia</dc:creator></item><item><title>Moving from the shell to Rust with commandspec</title><link>http://timryan.org/2018/07/02/moving-from-the-shell-to-rust-with-commandspec.html</link><description><![CDATA[Almost every project I’ve worked on has grown a shell script named “build.sh”, and not much later a “test.sh” and “run.sh”. At this point, you have to make a decision as a developer whether your goal is to accidentally reinvent make or if your codebase’s needs are better met by an executable to manage your workflow.]]></description><guid isPermaLink="false">504568b7-fb85-4ed5-b94d-1c96333d2c64</guid><pubDate>Mon,  2 Jul 2018 15:50:00 +0000</pubDate><dc:creator>Tim Ryan</dc:creator></item><item><title>Introducing PrrrStack</title><link>https://medium.com/@ccrsh/introducing-prrrstack-d617ff518ba6</link><description><![CDATA[This is the first part in a two-part introductory series to PRRR Stack (Postgres, Rust, Rocket, React) application.]]></description><guid isPermaLink="false">fc0e0a2b-6cec-420d-803c-2ac8770fc9e8</guid><pubDate>Mon,  2 Jul 2018 13:09:58 +0000</pubDate><dc:creator>Crash Springfield</dc:creator></item><item><title>Our Vision for wasm-bindgen</title><link>https://rustwasm.github.io/2018/07/02/vision-for-wasm-bindgen.html</link><description><![CDATA[The last blog post laid out the Rust and WebAssembly domain working group’s overall vision for Rust and WebAssembly. In this blog post, we will dive into the details of wasm-bindgen, the future we envision for it, and how you can help us build that future.]]></description><guid isPermaLink="false">7d6ed3b9-1295-4331-879f-514cbff7e5ba</guid><pubDate>Mon,  2 Jul 2018 00:00:00 +0000</pubDate><dc:creator>rustwasm</dc:creator></item><item><title>Idioms of Dynamic Languages</title><link>http://willcrichton.net/notes/idioms-of-dynamic-languages/</link><description><![CDATA[Programmers think dynamic languages like Python are easier to use than static ones, but why? I look at uniquely dynamic programming idioms and their static alternatives, identifying a few broad trends that impact language usability.]]></description><guid isPermaLink="false">f12f8561-c983-40b4-a7b4-9da8b350b33d</guid><pubDate>Sun,  1 Jul 2018 00:00:00 +0000</pubDate><dc:creator>Will Crichton</dc:creator></item><item><title>Logistic Regression in Rust</title><link>http://paulkernfeld.com/2018/07/01/logistic-regression-in-rust.html</link><description><![CDATA[This weekend, I implemented logistic regression in Rust. For me, the most interesting parts were learning how to implement a stopping condition and how to automatically set a step size.]]></description><guid isPermaLink="false">b63f8372-7dbc-4bf5-9ab3-e13a95a011be</guid><pubDate>Sun,  1 Jul 2018 00:00:00 +0000</pubDate><dc:creator>Paul Kernfeld</dc:creator></item><item><title>Genetic Algorithms in Rust for Autonomous Agents: An Introduction</title><link>https://medium.com/coinmonks/genetic-algorithms-in-rust-for-autonomous-agents-an-introduction-ac182de32aee</link><description><![CDATA[This article discusses a possible genetic algorithm implementation in Rust applied to the travelling salesman problem.]]></description><guid isPermaLink="false">16b43079-6e0d-4c7e-9ea3-00cf0405bf49</guid><pubDate>Sat, 30 Jun 2018 14:09:48 +0000</pubDate><dc:creator>Mithi</dc:creator></item><item><title>Scripting Language Cleanup</title><link>https://www.anthropicstudios.com/2018/06/30/language-cleanup/</link><description><![CDATA[When we built the original Monsters and Sprites demo, we only had 9 days to get it working before the Playcrafting expo we had signed up for, so we had to cut a lot of corners. Since then I’ve been doing bug fixes and working on a lot of miscellaneous engine/language features that I either couldn’t get done in time for the demo, or didn’t realize were important until I started building it. We’ve made a few game updates since then (we now have sound!), but this post is specifically going to explore some language updates I’ve made.]]></description><guid isPermaLink="false">3b8f7264-75f2-4483-bb45-16770a899291</guid><pubDate>Sat, 30 Jun 2018 00:00:00 +0000</pubDate><dc:creator>Mason Remaley</dc:creator></item><item><title>llvm-tools: a new rustup component for binary inspection and profiling</title><link>https://internals.rust-lang.org/t/llvm-tools-a-new-rustup-component-for-binary-inspection-objdump-nm-size-and-profiling-profdata/7830</link><description><![CDATA[Recent nightly releases provide an opt-in llvm-tools rustup component which you can install using the command: rustup component add llvm-tools. This component contains the following LLVM tools: llvm-nm, llvm-objcopy, llvm-objdump, llvm-profdata, and llvm-size. Most of these tools are LLVM alternatives to GNU binutils. The main advantage of these LLVM tools is that they support all the architectures that the Rust compiler supports.]]></description><guid isPermaLink="false">3b171674-7223-48e4-95da-5f268ec6fa1f</guid><pubDate>Fri, 29 Jun 2018 11:22:00 +0000</pubDate><dc:creator>Jorge Aparicio</dc:creator></item><item><title>Programming Servo: an HTTP cache</title><link>https://medium.com/programming-servo/programming-servo-an-http-cache-edb52a7f267f</link><description><![CDATA[In our previous post, we saw how combining channels with an event-loop could be a useful technique to ‘drive’ the concurrent logic of your system, and it was hinted at that shared mutable state might be more complicated. A good example of such ‘shared mutable state’ in Servo is the HTTP cache.]]></description><guid isPermaLink="false">9497ed78-6b59-4dd0-b1f8-725ca3c628d2</guid><pubDate>Fri, 29 Jun 2018 04:33:13 +0000</pubDate><dc:creator>Gregory Terzian</dc:creator></item><item><title>NES Emulator, Part 2: I sort of know what I’m doing</title><link>https://medium.com/@ltriant/nes-emulator-part-2-i-sort-of-know-what-im-doing-f64d5e61caed</link><description><![CDATA[In my first post about my journey to the center of the NES, I was at the point where I was still working on the CPU; implementing new addressing modes and instructions as I made my way through the nestest ROM. Well, I finally finished the CPU, including a handful of the illegal opcodes. The last of the illegal opcodes just need some placeholders, because, as I understand it, very few games use them.]]></description><guid isPermaLink="false">13dc5703-c3a5-4c10-b3a5-aa53c382c940</guid><pubDate>Fri, 29 Jun 2018 02:24:51 +0000</pubDate><dc:creator>Luke Triantafyllidis</dc:creator></item><item><title>[1807.00067] Josephine: Using JavaScript to safely manage the lifetimes of Rust data</title><link>https://arxiv.org/abs/1807.00067</link><description><![CDATA[This paper is about the interface between languages which use a garbage collector and those which use fancy types for safe manual memory management. Garbage collection is the traditional memory management scheme for functional languages, whereas type systems are now used for memory safety in imperative languages. We use existing techniques for linear capabilities to provide safe access to copyable references, but the application to languages with a tracing garbage collector, and to data with explicit lifetimes is new. This work is related to mixed linear/non-linear programming, but the languages being mixed are Rust and JavaScript.]]></description><guid isPermaLink="false">04445b84-5c91-467e-840c-45df1765c4e6</guid><pubDate>Fri, 29 Jun 2018 00:00:00 +0000</pubDate><dc:creator>Alan Jeffrey</dc:creator></item><item><title>Programming Servo: The script event-loop</title><link>https://medium.com/@polyglot_factotum/programming-servo-the-script-event-loop-be687b985b3e</link><description><![CDATA[One thing I have come to appreciate over time in the design of Servo, is the concurrency story. Basically, it’s pretty much all done using channels(and their multi-process counterpart).

What is so great about channels vs shared mutable state? One thing is, it makes it easier to reason about how various threads will synchronize their behavior as they go on about their business.

The way it’s done in Servo is by combining event-loops with multi-threading/processing. What does that mean?]]></description><guid isPermaLink="false">fa4c6fb5-3c9e-4831-86b1-3585c08398de</guid><pubDate>Thu, 28 Jun 2018 05:17:48 +0000</pubDate><dc:creator>Gregory Terzian</dc:creator></item><item><title>Signal Hook: Unix signal hanadling in Rust</title><link>https://vorner.github.io/2018/06/28/signal-hook.html</link><description><![CDATA[As promised in the previous article (thanks for all the valuable feedback ‒ I didn’t have the time to act on it yet, but I will), this talks about Unix signal handling.

Long story short, I wasn’t happy about the signal handling story in Rust and this is my attempt at improving it.]]></description><guid isPermaLink="false">a721af0b-e469-40ba-8ddc-f5f2a305483f</guid><pubDate>Thu, 28 Jun 2018 00:00:00 +0000</pubDate><dc:creator>Michal &apos;vorner&apos; Vaner</dc:creator></item><item><title>Nebulet: More answers</title><link>https://lsneff.me/more-answers.html</link><description><![CDATA[Over the last couple of weeks, Nebulet has progressed signifigantly. Because of that, I think it’s time to talk about why I made certain decisions when designing and writing Nebulet.]]></description><guid isPermaLink="false">3b9229a6-90a7-48f7-983f-c2eb1117115e</guid><pubDate>Thu, 28 Jun 2018 00:00:00 +0000</pubDate><dc:creator>Lachlan Sneff</dc:creator></item><item><title>A Self-ish Bug</title><link>https://llogiq.github.io/2018/06/28/self-bug.html</link><description><![CDATA[I recently found a bug in mutagen: The “exchange arguments” mutation was actually ineffective. I was in the process of refactoring the code to pull coverage reporting into the mutagen calls (to reduce the amount of code generated), so the report_coverage call was to go away anyway. Except this bug masked another, more insiduous one: When I refactored, I found that one of the test would no longer compile methods with self arguments, running into Error E0424 (self keyword used in static method). Consider me confused.]]></description><guid isPermaLink="false">696ba27d-cdab-400f-9e86-a138422c2154</guid><pubDate>Thu, 28 Jun 2018 00:00:00 +0000</pubDate><dc:creator>Llogiq</dc:creator></item><item><title>actix – a basic TCP client</title><link>https://simplabs.com/blog/2018/06/27/actix-tcp-client.html</link><description><![CDATA[In our last post about actix we introduced you to the Rust programming language and the actix actor framework. This week we will build a basic TCP client with actix.]]></description><guid isPermaLink="false">863992ef-fc2b-4235-a8bd-206d55fd416f</guid><pubDate>Wed, 27 Jun 2018 00:00:00 +0000</pubDate><dc:creator>Tobias Bieniek</dc:creator></item><item><title>New Photon Release of Eclipse IDE Ships With Full Rust Support | </title><link>https://www.eclipse.org/org/press-release/20180627_new-photon-release-of-eclipse-ide-ships-with-full-rust-support.php</link><description><![CDATA[The release delivers native Eclipse IDE experiences for Rust and C# through Language Server based plugins. The Language Server Protocol (LSP) ecosystem delivers editing support for popular and emerging programming languages. Combined with the move to a quarterly rolling release cadence, the LSP focus demonstrates a commitment to keeping pace with evolving developer and commercial needs.]]></description><guid isPermaLink="false">19aba600-95ff-4ba2-920f-0db67b3755e4</guid><pubDate>Wed, 27 Jun 2018 00:00:00 +0000</pubDate><dc:creator>The Eclipse Foundation</dc:creator></item><item><title>RSoC: Porting Redox to AArch64–0x01</title><link>https://medium.com/@wizofe/rsoc-porting-redox-to-aarch64-0x01-3dee87644c97</link><description><![CDATA[All excited. A first calendar entry to describe my attempt on arm64 support in Redox OS. Specifically, looking into the Raspberry Pi2/3b/3+(all of them having a Cortex-A53 ARMv8 64-bit microprocessor, although for all my experiments I am going to use the Raspberry Pi 3b.]]></description><guid isPermaLink="false">44759beb-04e0-4524-898b-5ba007a80e10</guid><pubDate>Tue, 26 Jun 2018 17:26:31 +0000</pubDate><dc:creator>ioannis valasakis</dc:creator></item><item><title>Why choose Rust?</title><link>https://blog.passfort.com/why-choose-rust/</link><description><![CDATA[Many of the candidates we interview for a position at PassFort are intrigued by the fact that we use Rust, a language which is only three years old (since its 1.0 release).

Despite its relatively young age, Rust has been voted the “most loved” language in the StackOverflow developer survey every one of those three years - an impressive feat!

However, it’s not enough for a language to be well liked: the programming ecosystem changes rapidly, and many of these developers are rightly afraid to jump blindly onto the latest bandwagon. We chose Rust not because it is popular, but because we believe it is the best tool for the job we have to do, and I hope to explain that reasoning now.]]></description><guid isPermaLink="false">e9ac81fa-8018-4bb1-91a2-cfd0b705f780</guid><pubDate>Tue, 26 Jun 2018 16:00:00 +0000</pubDate><dc:creator>PassFort</dc:creator></item><item><title>Zapper: A Very Fast Templating Engine</title><link>https://ceres1.space/posts/zapper/</link><description><![CDATA[Thirty times faster than Handlebars, half the features! I am introducing a new templating engine for Rust that is designed to be robust and very fast! Why Zapper? Runtime templating is amazing, since you can reload templates on the fly or even allow users to provide their own templates, yet runtime templating engines are rarely fast. Templates that are statically compiled into your application can be super fast, but are completely inflexible. Recompiling and restarting your application just to change a template is especially boring. Zapper combines the flexibility of runtime templating with great performance!]]></description><guid isPermaLink="false">989d2bb2-c78b-4844-92ab-45509164c182</guid><pubDate>Mon, 25 Jun 2018 19:28:22 -0700</pubDate><dc:creator>Josh Leverette</dc:creator></item><item><title>How Usable are Rust Cryptography APIs?</title><link>https://arxiv.org/abs/1806.04929</link><description><![CDATA[Poor usability of cryptographic APIs is a severe source of vulnerabilities. Aim: We wanted to find out what kind of cryptographic libraries are present in Rust and how usable they are. Method: We explored Rust's cryptographic libraries through a systematic search, conducted an exploratory study on the major libraries and a controlled experiment on two of these libraries with 28 student participants. Results: Only half of the major libraries explicitly focus on usability and misuse resistance, which is reflected in their current APIs. We found that participants were more successful using rust-crypto which we considered less usable than ring before the experiment. Conclusion: We discuss API design insights and make recommendations for the design of crypto libraries in Rust regarding the detail and structure of the documentation, higher-level APIs as wrappers for the existing low-level libraries, and selected, good-quality example code to improve the emerging cryptographic libraries of Rust.]]></description><guid isPermaLink="false">ab3d6484-4107-4555-a9b0-0f1aa6ae9a18</guid><pubDate>Tue, 26 Jun 2018 00:00:00 +0000</pubDate><dc:creator>Kai Mindermann, Philipp Keck, Stefan Wagner</dc:creator></item><item><title>Better HTTP Upgrades with hyper</title><link>http://seanmonstar.com/post/175280388657/better-http-upgrades-with-hyper</link><description><![CDATA[Better HTTP Upgrades with hyper It’s been possible to handle HTTP Upgrades (like Websockets) in hyper if you made use of the low-level APIs in the server and client, but it wasn’t especially nice to...]]></description><guid isPermaLink="false">faf1a345-9eaf-4d00-a7f7-9fa3afaa51ac</guid><pubDate>Tue, 26 Jun 2018 00:00:00 +0000</pubDate><dc:creator>Sean McArthur</dc:creator></item><item><title>Sustainability</title><link>https://yakshav.es/sustainability/</link><description><![CDATA[I’m at a fork again: my FOSS project responsibilities have grown so much that they encroach on other parts of my life. This includes time I should spend with company, clients and personal live. It leaves me with two options: shed many of my projects (as mxsash does) or find ways of making this more sustainable. Retreating would also mean that on the surviving projects, others would have to cover the resulting gap, often with less skills or experience.]]></description><guid isPermaLink="false">0e7e0d63-d08d-4b38-812b-d67b5b7f9d43</guid><pubDate>Tue, 26 Jun 2018 00:00:00 +0000</pubDate><dc:creator>Florian Gilcher</dc:creator></item><item><title>Rust Thermometer – Part 2</title><link>https://www.robertvojta.com/rust-thermometer-part-2/</link><description><![CDATA[Thermometer adventure continuous with some progress over the last weekend. Little bit of refactoring, rewiring, X.org, matchbox, Piston, ... and some ugly (but working!) UI :)]]></description><guid isPermaLink="false">e063329a-32df-4f01-92b0-38d5999f9a6e</guid><pubDate>Mon, 25 Jun 2018 13:51:53 +0000</pubDate><dc:creator>Robert Vojta</dc:creator></item><item><title>Building an Event Sourcing Crate for Rust</title><link>https://medium.com/@KevinHoffman/building-an-event-sourcing-crate-for-rust-2c4294eea165</link><description><![CDATA[In one of my recent blog posts, I talked about Event Sourcing with Aggregates in Rust. In that post, I was just beginning to explore how the Rust language and its strongly typed native data structures would allow me to express event sourcing concepts and primitives. I have now created an initial version of an Event Sourcing crate that you can explore on crates.io]]></description><guid isPermaLink="false">ced93c25-32fb-4e74-a5e4-5fb7cd60e8ee</guid><pubDate>Mon, 25 Jun 2018 13:30:42 +0000</pubDate><dc:creator>Kevin Hoffman</dc:creator></item><item><title>The Return of: Can Rust speed up your Azure Functions?</title><link>https://blog.x5ff.xyz/blog/azure-functions-wasm-rust-2/</link><description><![CDATA[A couple of weeks back I started using WASM on Azure’s FaaS (serverless/Functions as a Services) and unexpectedly the Rust version of my simple Monte Carlo estimation was considerably slower than its JavaScript counterpart. Clearly this needs more exploring! This time around the challenges will be harder and more practical. Let’s see how WASM and JavaScript perform.]]></description><guid isPermaLink="false">861a1228-9bbd-4d34-b08d-40b191f19abd</guid><pubDate>Mon, 25 Jun 2018 00:00:00 +0000</pubDate><dc:creator>Claus</dc:creator></item><item><title>What I Learned: Porting Dateutil Parser to Rust</title><link>https://speice.io/2018/06/dateutil-parser-to-rust.html</link><description><![CDATA[Hi. I’m Bradlee. I’ve mostly been a lurker in Rust for a while, making a couple small contributions here and there. So launching dtparse feels like nice step towards becoming a functioning member of society. But not too much, because then you know people start asking you to pay bills, and ain’t nobody got time for that.

But I built dtparse, and you can read about my thoughts on the process. Or don’t. I won’t tell you what to do with your life (but you should totally keep reading).]]></description><guid isPermaLink="false">9c9c6dda-6538-4088-8123-e1ad213082e5</guid><pubDate>Mon, 25 Jun 2018 00:00:00 +0000</pubDate><dc:creator>Bradlee Speice</dc:creator></item><item><title>Project Ice Puzzle</title><link>http://www.matthewmichelotti.com/games/project_ice_puzzle/</link><description><![CDATA[This game was coded in Rust and is playable in web browsers by means of WebAssembly, WebGL and Howler.js. The software I developed is partly open source in the form of Gate, which is the Rust library that powers this game and can power other similar games. Special thanks to the tools I used to create assets: Gimp, FL Studio and BFXR.]]></description><guid isPermaLink="false">645c96b0-5f66-4c4d-a8ee-d145298bc63d</guid><pubDate>Mon, 25 Jun 2018 00:00:00 +0000</pubDate><dc:creator>Matthew Michelotti</dc:creator></item><item><title>Our Vision for Rust and WebAssembly</title><link>https://rustwasm.github.io/2018/06/25/vision-for-rust-and-wasm.html</link><description><![CDATA[Rust and WebAssembly can combine in many delightful ways. To consolidate our efforts and have the largest, most-positive impact we can, the Rust and WebAssembly domain working group is focusing on one vision:

Surgically inserting Rust compiled to WebAssembly should be the best choice for speeding up the most performance-sensitive JavaScript code paths. Do not throw away your existing code base, because Rust plays well with others. Regardless of whether you are a Rust or Web developer, your natural workflow shouldn’t change because Rust compiled to wasm integrates seamlessly into your preferred tools.

This blog post will expand on these aspirations and describe where we stand in relation to them right now. In a series of follow up posts, we will talk about the next steps for each major component of the Rust and WebAssembly ecosystem.]]></description><guid isPermaLink="false">33738eab-7a95-4e28-b819-f22f8362100e</guid><pubDate>Mon, 25 Jun 2018 00:00:00 +0000</pubDate><dc:creator>rustwasm</dc:creator></item><item><title>A Rusty Go at Channels</title><link>https://gsquire.github.io/static/post/a-rusty-go-at-channels/</link><description><![CDATA[Channels Channels are a useful concurrency primitive that enable separate processes to safely communicate without the need for explicit synchronization. The term processes is used here to loosely describe independent threads of execution within a program. This can be an OS level thread or a runtime level thread. Channels can be seen as a pipe to connect these processes and allow them to share memory with one another. For example a program could spawn any number of processes along with a channel to transmit results that it gathers.]]></description><guid isPermaLink="false">0a781f91-aca4-47ac-81d4-f9f606f33d0f</guid><pubDate>Sun, 24 Jun 2018 10:44:31 -0700</pubDate><dc:creator>Garrett Squire</dc:creator></item><item><title>devtop: Command line parser</title><link>https://medium.com/journey-to-rust/devtop-command-line-parser-f08b72b02bea</link><description><![CDATA[As operator I found that existing tooling fails with large number of unusual devices. If you have server with >100 virtual machines, and each virtual machines have one or more additional disk and a few network interfaces, it’s hard to find which VM cause stress on the server. Normal atop simply couldn’t cope with hundreds of tap/tun interfaces, multitude of block devices, etc. When I found that I have no proper tooling (as an operator) I wrote a shabby tools to do my job: they are calling blktop and ifstop. Both were written dirty and fast, and they does not follow the usual Python conventions (but they work as standalone binaries). They do their job, and normally I would say that’s enough. But those utilities are simple and have no big complications under the hood, so they are perfect candidates for rewriting in Rust for the sake of writing in Rust (I’m learning it!). I decide to combine them into a single utility: devtop, which I want to develop properly, according to Rust conventions, and through all aspects of packaging.]]></description><guid isPermaLink="false">f6f626f4-47ff-427c-8d44-b63c457bed46</guid><pubDate>Sun, 24 Jun 2018 14:21:28 +0000</pubDate><dc:creator>George Shuklin</dc:creator></item><item><title>Oxy - A Security Focused Remote Access Tool</title><link>https://oxy-secure.app/</link><description><![CDATA[It's like SSH, but more secure, and with cool modern features. It is not an implementation of SSH, it is a new, modern protocol.]]></description><guid isPermaLink="false">81e1a990-ce97-4ab6-a943-720330b5db6e</guid><pubDate>Sun, 24 Jun 2018 23:58:43 +1000</pubDate><dc:creator>Jenna Magius</dc:creator></item><item><title>Compiler fuzzing, part 1</title><link>http://www.vegardno.net/2018/06/compiler-fuzzing.html</link><description><![CDATA[Much has been written about fuzzing compilers already, but there is not a lot that I could find about fuzzing compilers using more modern fuzzing techniques where coverage information is fed back into the fuzzer to find more bugs.

If you know me at all, you know I'll throw anything I can get my hands on at AFL. So I tried gcc. (And clang, and rustc -- but more about Rust in a later post.)]]></description><guid isPermaLink="false">34e39003-edb1-4232-ad2a-aae9d4868d81</guid><pubDate>Sun, 24 Jun 2018 15:02:00 +0200</pubDate><dc:creator>Vegard</dc:creator></item><item><title>How much of npm can you break?</title><link>https://mrandri19.github.io/2018/06/24/how-much-of-npm-will-you-break.html</link><description><![CDATA[The idea was simple, choose a package and recursively traverse npm to find all of the packages that depend upon it, after all the npm website offers a ‘Dependents’ tab on a package’s page. I had not anticipated the issues that made this an interesting technical problem.]]></description><guid isPermaLink="false">a928dd6a-2db7-4366-bd96-74134b4094b8</guid><pubDate>Sun, 24 Jun 2018 00:00:00 +0000</pubDate><dc:creator>Andrea Cognolato</dc:creator></item><item><title>Rust with Rocket + Elm running on Heroku</title><link>http://ethanfrei.com/posts/rust-with-rocket-elm-running-on-heroku.html</link><description><![CDATA[I had this goal of making a web app that was very fast, stable and easy to deploy. This is what I was hoping to accomplish: strongly typed server-side and client-side languages (Rust & Elm respectively), push-button deployments to the cloud with free hosting initially, and sub-second response times for API calls and page loads. With this setup, I think I'm well on my way to accomplishing each of these.]]></description><guid isPermaLink="false">f8a137b7-ce7d-4553-bcec-6170350dc1f2</guid><pubDate>Sun, 24 Jun 2018 00:00:00 +0000</pubDate><dc:creator>Ethan Frei</dc:creator></item><item><title>Making Arc more atomic</title><link>https://vorner.github.io/2018/06/24/arc-more-atomic.html</link><description><![CDATA[This is a story of a tiny feature I was missing in Rust… so I created it (partly because I like the feature, because it felt wrong for Rust not to have it, but mostly for the practice and fun of beating a hard and interesting problem). You can read the story if you are interested about the behind the scenes, about the feature itself, how to use it or just for fun ☺.]]></description><guid isPermaLink="false">03d374fc-9500-42d8-8515-7f98447fd62a</guid><pubDate>Sun, 24 Jun 2018 00:00:00 +0000</pubDate><dc:creator>Michal &apos;vorner&apos; Vaner</dc:creator></item><item><title>Rust 2018: an early preview</title><link>https://internals.rust-lang.org/t/rust-2018-an-early-preview/7776</link><description><![CDATA[The Rust teams having been working hard to implement features of the 2018 edition. Today we have reached an important milestone: we are announcing that we have an alpha-quality preview of the 2018 edition ready for testing and feedback.

The preview presents a great opportunity for those of you using the stable channel to switch to nightly and try out how it feels to code in the new edition, both to help us fix bugs and to provide feedback – positive and negative – on features. Unfortunately, today’s nightly doesn’t work due to infrastructure issues, so you’ll need to run rustup install nightly-2018-06-20 in order to get a nightly that’ll work. If you’re already on the nightly channel, it’s likely that there’s no need to update the compiler.]]></description><guid isPermaLink="false">698090f0-fa77-43b5-aaed-dcd2b71d3c39</guid><pubDate>Sat, 23 Jun 2018 08:19:19 +1000</pubDate><dc:creator>Rust Team Members</dc:creator></item><item><title>Musing About Communities Size And Activity</title><link>https://ervin.ipsquad.net/2018/06/22/musing-about-communities-size-and-activity/</link><description><![CDATA[I wanted to take a very quick peak at Rust. It's very different from our previous cases, no application or frameworks in the traditional sense but a language. It seems very popular toward developers using it, I'm personally interested in it hence why it is in that post.]]></description><guid isPermaLink="false">85a6b729-6bb3-4dc0-9a15-80ba9ff44f68</guid><pubDate>Fri, 22 Jun 2018 19:36:00 +0200</pubDate><dc:creator>Kevin Ottens</dc:creator></item><item><title>Rust review: The ecosystem</title><link>http://julio.meroh.net/2018/06/rust-review-ecosystem.html</link><description><![CDATA[In this part of the review, I would like to focus on Rust’s ecosystem: in other words, how Rust plays with other parts of a functioning system and how Rust’s standard library vs. external libraries interact with each other. There are a lot of pieces to cover in these areas and they have left me with mixed feelings. Let’s look at some.]]></description><guid isPermaLink="false">295dac4f-f095-4d04-b6ee-a6a2870cc7fb</guid><pubDate>Fri, 22 Jun 2018 09:00:00 -0400</pubDate><dc:creator>Julio Merino</dc:creator></item><item><title>Writing Python Extensions In Rust Using PyO3</title><link>https://www.benfrederickson.com/writing-python-extensions-in-rust-using-pyo3/</link><description><![CDATA[I've been writing some code in Rust recently, and I thought it would be cool if I could take some of this Rust code and provide it as a native extension that I can call from Python. It turns out there are some amazing tools like PyO3 that make it easy to write fully featured Python extensions in Rust, with considerably less effort than writing a CPython extension manually.

To test out PyO3 I wrote a small Python extension in Rust, and I thought I would share some of the tips and tricks I encountered in getting this going. This post aims to serve as a quick tutorial showing how to write extensions in Rust, talking about why you might want to use something more powerful than just exposing a C library called using CFFI, and how PyO3 lets you write Python aware extensions in Rust. ]]></description><guid isPermaLink="false">afc3d2f1-e848-4c25-af60-89cf7209b3ba</guid><pubDate>Thu, 21 Jun 2018 00:00:00 -0700</pubDate><dc:creator>Ben Frederickson</dc:creator></item><item><title>Generic associated types in iterators</title><link>https://boiethios.gitlab.io/blog/2018-06-21_GATs_iterators.html</link><description><![CDATA[In this article, I want to explain the term Generic Associated Types through a concrete example. I noticed that people (especially in video games development) need some tools to iterate in various manners mutably, efficiently and safely. I tried to write some convenient iterators over vectors and slices that solve those problems, but finally, I understood that some tools cannot be written with std::iter::Iterator. Doing so led me to the comprehension of generic associated types that I will abbreviate as GATs in this article. I will explain here what GATs are and why they are needed.]]></description><guid isPermaLink="false">6c71975e-3550-410a-99e7-2ee9635fb0e6</guid><pubDate>Thu, 21 Jun 2018 00:00:00 +0000</pubDate><dc:creator>Boiethios</dc:creator></item><item><title>Announcing Rust 1.27</title><link>https://blog.rust-lang.org/2018/06/21/Rust-1.27.html</link><description><![CDATA[This release has two big language features that people have been waiting for: SIMD, and dyn Trait. Additionally there is support for searching the Rust books, and a new book about rustc.]]></description><guid isPermaLink="false">41f94ae9-ac3a-42fe-bc78-fbc6dab42d85</guid><pubDate>Thu, 21 Jun 2018 00:00:00 +0000</pubDate><dc:creator>The Rust Core Team</dc:creator></item><item><title>Streaming gRPC with Rust</title><link>https://medium.com/@KevinHoffman/streaming-grpc-with-rust-d978fece5ef6</link><description><![CDATA[Lately I’ve been working on a side project that involves aggregating the indexes of media libraries and allowing one library to “lend” a file to another. For example, I might use this system if I want my home tower to “lend” a file to my laptop before I get on a plane. I’ll be committing my work-in-progress on this project to github shortly (just want to get an MVP working first and do some refactoring), but I thought I would take a step back for a moment and share my thoughts on one aspect of this project: gRPC. In particular: gRPC streaming.]]></description><guid isPermaLink="false">87c1e68b-e1e6-44d5-be4b-212eb2bdc88f</guid><pubDate>Wed, 20 Jun 2018 17:43:39 +0000</pubDate><dc:creator>Kevin Hoffman</dc:creator></item><item><title>Rust Thermometer – Part 1</title><link>https://www.robertvojta.com/rust-thermometer-part-1/</link><description><![CDATA[I’ve decided to build a thermometer from scratch. I know, I can buy it, but it’s not fun. I found it as a perfect occasion to please my wife (she wants it) and to try new things. What new things? Mainly resin.io and resinOS.]]></description><guid isPermaLink="false">d93b968d-f8fb-4ba9-b7eb-1879ec63807d</guid><pubDate>Wed, 20 Jun 2018 09:23:29 +0000</pubDate><dc:creator>Robert Vojta</dc:creator></item><item><title>Proposal for a staged RFC process</title><link>http://smallcultfollowing.com/babysteps/blog/2018/06/20/proposal-for-a-staged-rfc-process/</link><description><![CDATA[I consider Rust’s RFC process one of our great accomplishments, but it’s no secret that it has a few flaws. At its best, the RFC offers an opportunity for collaborative design that is really exciting to be a part of. At its worst, it can devolve into bickering without any real motion towards consensus. If you’ve not done so already, I strongly recommend reading aturon’s excellent blog posts on this topic.

The RFC process has also evolved somewhat organically over time. What began as “just open a pull request on GitHub” has moved into a process with a number of formal and informal stages (described below). I think it’s a good time for us to take a step back and see if we can refine those stages into something that works better for everyone.]]></description><guid isPermaLink="false">220b4649-e853-4f07-9773-e4ae3d286a4f</guid><pubDate>Wed, 20 Jun 2018 00:00:00 -0400</pubDate><dc:creator>Niko Matsakis</dc:creator></item><item><title>Finda Websocket Architecture</title><link>https://keminglabs.com/blog/finda-websocket-architecture/</link><description><![CDATA[Finda lets you search and instantly switch between tabs in browsers like Firefox and Chrome and editors like Sublime Text and Visual Studio Code. It does this by communicating with these programs over local websocket connections. This article describes the design tradeoffs of this system, focusing on Rust implementation details that may be helpful to others building similar systems.]]></description><guid isPermaLink="false">b93a3070-a495-46de-a9e1-a1c650cafec3</guid><pubDate>Wed, 20 Jun 2018 00:00:00 +0000</pubDate><dc:creator>Kevin J. Lynagh</dc:creator></item><item><title>Optimising path tracing: the last 10%</title><link>https://bitshifter.github.io/blog/2018/06/20/the-last-10-percent/</link><description><![CDATA[In my last post on optimising my Rust path tracer with SIMD I had got withing 10% of my performance target, that is Aras’s C++ SSE4.1 path tracer. From profiling I had determined that the main differences were MSVC using SSE versions of sinf and cosf and differences between Rayon and enkiTS thread pools. The first thing I tried was implement an SSE2 version of sin_cos based off of Julien Pommier’s code that I found via a bit of googling. This was enough to get my SSE4.1 implementation to match the performance of Aras’s SSE4.1 code. I had a slight advantage in that I just call sin_cos as a single function versus separate sin and cos functions, but meh, I’m calling my performance target reached.

The other part of this post is about Rust’s runtime and compile time CPU feature detection and some wrong turns I took along the way.]]></description><guid isPermaLink="false">495d9d83-2572-43cb-8f9d-c5c404ab83fe</guid><pubDate>Wed, 20 Jun 2018 00:00:00 +0000</pubDate><dc:creator>bitshifter</dc:creator></item><item><title>Building better compression together with DivANS</title><link>https://blogs.dropbox.com/tech/2018/06/building-better-compression-together-with-divans/</link><description><![CDATA[Compressing your files is a good way to save space on your hard drive. At Dropbox’s scale, it’s not just a good idea; it is essential. Even a 1% improvement in compression efficiency can make a huge difference. That’s why we conduct research into lossless compression algorithms that are highly tuned for certain classes of files and storage, like Lepton for jpeg images, and Pied-Piper-esque lossless video encoding. For other file types, Dropbox currently uses the zlib compression format, which saves almost 8% of disk storage.

We introduce DivANS, our latest open-source contribution to compression, in this blog post.]]></description><guid isPermaLink="false">ff081914-cb16-4004-bc20-53e494477b8c</guid><pubDate>Tue, 19 Jun 2018 16:00:24 +0000</pubDate><dc:creator>Daniel Reiter Horn and Jongmin Baek</dc:creator></item><item><title>Fast and Simple Rendering in Rust using Proc Macros</title><link>https://medium.com/@MertzAlertz/fast-and-simple-rendering-in-rust-using-proc-macros-f0d919eb6475</link><description><![CDATA[I’ve been working on a project called Thruster recently, and needed a way that a developer could reasonably use templates. Thruster is a middleware based web server written in Rust (get it, th-rust-er? I’m working on my tight 5 for amateur night at The Apollo,) and as such, I needed a way to load HTML templates and insert variables into them in a performant way. Rather than poking around the numerous existing libraries and choosing one made by someone I don’t know — stranger danger! — I decided to make it myself. This article is about that journey, the unbelievably thrilling adventures of writing my first proc_macro_derive in Rust.]]></description><guid isPermaLink="false">31acdf03-3f59-4102-81ba-edafd6f2cfad</guid><pubDate>Tue, 19 Jun 2018 13:22:54 +0000</pubDate><dc:creator>Pete Mertz</dc:creator></item><item><title>Extreme benchmark feedback using Gitlab CI</title><link>https://www.rubdos.be/linux/gitlab/automation/benchmarks/rust/2018/06/19/extreme-benchmark-feedback.html</link><description><![CDATA[I am quite notorious for exploiting Gitlab’s CI. Ever since I started playing with it at the start of 2016, I tended to make things worse.]]></description><guid isPermaLink="false">c1d20548-b510-4452-9d30-8088b65f626a</guid><pubDate>Tue, 19 Jun 2018 13:18:00 +0000</pubDate><dc:creator>Ruben De Smet</dc:creator></item><item><title>Rust review: The book</title><link>http://julio.meroh.net/2018/06/rust-review-book.html</link><description><![CDATA[“The Rust Programming Language” is one of the free books that the community has put together to teach the language. The book does a good job in general, but there are some things that could be better. Let’s cover these, but first, some background.]]></description><guid isPermaLink="false">0122445e-8a19-4a52-bcd6-4ee7e55feb7c</guid><pubDate>Tue, 19 Jun 2018 09:00:00 -0400</pubDate><dc:creator>Julio Merino</dc:creator></item></channel></rss>