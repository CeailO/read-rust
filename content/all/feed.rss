<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/"><channel><title>Read Rust - All Posts</title><link>https://readrust.net/</link><description>All Posts posts on Read Rust</description><item><title>Organizational Debt</title><link>https://boats.gitlab.io/blog/post/rust-2019/</link><description><![CDATA[We all know that classic aphorism: Year comes to an end, Rust blog post press send. This is mine.

There are lots of cool technical improvements to Rust that I want the project to achieve this year, and a few in particular that I’m definitely going to be putting a lot of time into. But this blog post is going to talk about none of them. Instead, I want to talk about organizational debt, and how badly the Rust project needs to deal with it in 2019.]]></description><guid isPermaLink="false">f0adf24b-6589-4306-a580-6cef894ad3b7</guid><pubDate>Mon, 16 Dec 2019 00:00:00 +0000</pubDate><dc:creator>withoutboats</dc:creator></item><item><title>Rust 2019: Towards Richer Language Extensions</title><link>https://internals.rust-lang.org/t/rust-2019-towards-richer-language-extensions/9151</link><description><![CDATA[As of Rust 1.30, the Rust language now has support for a very expressive feature called procedural macros 3. Procedural macros are great because they enable Rust to do more, without baking a lot of potentially domain-specific information into the language. For example, automatic serialization of data types 5 and expressive, type-safe abstractions for web servers 6 can both be implemented using procedural macros.

However, while expressive, procedural macros can’t do everything.]]></description><guid isPermaLink="false">5b89867c-1a66-4b88-ab28-5b04e6cda3f5</guid><pubDate>Sun,  6 Jan 2019 01:17:43 +0000</pubDate><dc:creator>Elliott Slaughter</dc:creator></item><item><title>Scannerless parsing of boolean grammars with derivatives in Rust</title><link>https://github.com/jameysharp/weighted-regexp-rs/blob/master/README.md</link><description><![CDATA[This is yet another library for writing parsers in Rust. What makes this one different is that I've combined some existing academic work in a way that I think is novel. The result is an unusually flexible parsing library while still offering competitive performance and memory usage.]]></description><guid isPermaLink="false">ad9d038f-52e6-4860-a264-61a795428b87</guid><pubDate>Sun,  6 Jan 2019 00:00:00 +0000</pubDate><dc:creator>Jamey Sharp</dc:creator></item><item><title>Scientific Rust #rust2019</title><link>https://blog.luizirber.org/2019/01/05/rust-2019/</link><description><![CDATA[The Rust community requested feedback last year for where the language should go in 2018, and now they are running it again for 2019. Last year I was too new in Rust to organize a blog post, but after an year using it I feel more comfortable writing this!

In this post I will be focusing more in two areas: array computing (what most people consider 'scientific programming' to be) and "data structures".]]></description><guid isPermaLink="false">23462803-be17-4a96-b8f1-64af9c0e79d8</guid><pubDate>Sat,  5 Jan 2019 17:00:00 -0200</pubDate><dc:creator>Luiz Irber</dc:creator></item><item><title>Rust 2019: Beat C++</title><link>https://www.reddit.com/r/rust/comments/acjcbp/rust_2019_beat_c/?st=JQIGPCJV&amp;sh=0e8b6ffc</link><description><![CDATA[I'm not a contributor outside a few issues here and there, but I have some thoughts about how Rust could be improved in 2019. There's been a lot of talk of the Fallow Year and limiting new features, and I think these are great ideas. With that in mind, a goal that follows along those lines is to "Beat C++." Rust doesn't have to beat C++ by performing better in benchmarks. Rather, Rust can beat C++ by making it easier to write optimized code, benchmark it, and profile it.]]></description><guid isPermaLink="false">51795148-94c2-4912-9e84-eb9502a80d4c</guid><pubDate>Sat,  5 Jan 2019 00:00:00 +0000</pubDate><dc:creator>u/Holy_City</dc:creator></item><item><title>Followups</title><link>https://raphlinus.github.io/curves/graphics/2019/01/04/followups.html</link><description><![CDATA[Here are some followups on previous blog postings. Including, Arclength, and 2D graphics.]]></description><guid isPermaLink="false">9cccb5d4-edfb-483f-ab75-0b099242fd69</guid><pubDate>Fri,  4 Jan 2019 16:54:42 +0000</pubDate><dc:creator>Raph Levien</dc:creator></item><item><title>Rust 2019 posts</title><link>https://yakshav.es/rust-2019/</link><description><![CDATA[When starting collecting ideas about this years Rust 2019 post, I had far to many to fit into one document. For that reasons, I’ll start writing multiple small pieces. I might come back to them at a later point this year. Most of my wishes are around the project structure, but I also have some technical ones. Most of them deal with the current growth and maturity of the project. All of these are living documents and even just drafts, so they might change at any time and might be released in draft form.]]></description><guid isPermaLink="false">e11a846b-3426-49af-b3b4-bc444adfe11b</guid><pubDate>Thu,  3 Jan 2019 23:57:00 +0000</pubDate><dc:creator>Florian Gilcher</dc:creator></item><item><title>Rust 2019</title><link>https://deterministic.space/rust-2019.html</link><description><![CDATA[Thinking about Rust’s evolution like a video game (heh), we have just reached level 2018. Our programming language is in a good state but there are a lot of progress bars for features where we need to get a few more experience points to unlock a new ability.]]></description><guid isPermaLink="false">275f95ad-70be-4870-bb50-0c5df78ed9be</guid><pubDate>Fri,  4 Jan 2019 00:00:00 +0100</pubDate><dc:creator>Pascal Hertleif</dc:creator></item><item><title>PyOxidizer: Make distributable Python applications using Rust</title><link>https://github.com/indygreg/pyoxidizer</link><description><![CDATA[PyOxidizer is a collection of Rust crates that facilitate building libraries and binaries containing Python interpreters. PyOxidizer is capable of producing a single file executable - with all dependencies statically linked and all resources (like .pyc files) embedded in the executable.]]></description><guid isPermaLink="false">ea33097d-8f78-4d8d-9f75-bc9305380398</guid><pubDate>Thu,  3 Jan 2019 00:00:00 +0000</pubDate><dc:creator>Gregory Szorc</dc:creator></item><item><title>Rust 2019: Compiler, Community, and Const Generics</title><link>https://nicoburns.com/blog/rust-2019/</link><description><![CDATA[This article is a repsponse to the call for 2019 wishlist blog posts for the Rust programming language.]]></description><guid isPermaLink="false">02aaa21e-53a6-4e80-9ad2-73fdfcab3569</guid><pubDate>Thu,  3 Jan 2019 00:00:00 +0000</pubDate><dc:creator>Nico Burns</dc:creator></item><item><title>Deriving Traits in Rust with Procedural Macros</title><link>https://naftuli.wtf/2019/01/02/rust-derive-macros/</link><description><![CDATA[Procedural macros in Rust are a really compelling feature that I didn’t understand until recently. There are a few gotchas, but they make it super easy to implement custom #[derive()] expansions for implementing traits with a single line of code. Let’s dive in.]]></description><guid isPermaLink="false">470de398-add8-4fdd-9b38-c79c781c58fa</guid><pubDate>Wed,  2 Jan 2019 00:00:00 +0000</pubDate><dc:creator>Naftuli Kay</dc:creator></item><item><title>I made MPD index SoundCloud, here&apos;s how I did it</title><link>https://polyfloyd.net/post/soundcloud-fuse-mpd/</link><description><![CDATA[The usual process of playing something on our music server is a bit cumbersome: I have to browse SoundCloud, download a track that seems interesting, upload it to the music server, let MPD index it, and then play it.

To make my life easier, I wanted to leverage Linux’s FUSE interface to expose the audio on SoundCloud as a bunch of files in a folder which MPD could then index and play from. I could have taken a couple of other approaches such as swapping MPD with Mopidy, an MPD-compatible music player with SoundCloud support, or a scraper that periodically downloads the latest audio from my feed. And while these alternatives were probably easier to implement, I went for the FUSE driver because I thought it was cool.]]></description><guid isPermaLink="false">4a2d72d8-3aa4-4c82-a95f-847f3e0c650d</guid><pubDate>Wed,  2 Jan 2019 00:00:00 +0000</pubDate><dc:creator>polyfloyd</dc:creator></item><item><title>My wishlist for Rust in 2019</title><link>https://www.pietroalbini.org/blog/rust-2019-wishlist/</link><description><![CDATA[It's starting to become a tradition to see a bunch of posts around the new year on what the community wants to see from Rust. For the second year in a row, the Rust core team asked for feedback for the 2019 roadmap and this is what I'd like: "rustfix all the things" and a better infrastructure.]]></description><guid isPermaLink="false">5ef7bb7d-ef60-4758-90e5-04c6cb63a544</guid><pubDate>Wed,  2 Jan 2019 00:00:00 +0000</pubDate><dc:creator>Pietro Albini</dc:creator></item><item><title>Rust in 2019</title><link>https://kodraus.github.io/rust/2019/01/01/rust-2019.html</link><description><![CDATA[These are some rough notes on things in the Rust project that are important to me, that I’d like to work on in 2019. I haven’t got a grand vision this time around (I tried that last year, but ran out of bandwidth to properly drive it).]]></description><guid isPermaLink="false">da6b6f38-a2c9-43df-a97b-6084e3a8ee7d</guid><pubDate>Tue,  1 Jan 2019 02:44:00 +0000</pubDate><dc:creator>Ashley Mannix</dc:creator></item><item><title>Russian AI Cup 2018</title><link>https://blog.kuviman.com/2019/01/01/russian-ai-cup-2018.html</link><description><![CDATA[Russian AI Cup — annual IT-oriented competition initiative, organized by Mail.Ru Group and Codeforces. Last year we started using Rust compiled to WebAssembly to show the games on web. This time, we went even further, and the game itself is now written in Rust. So, now web player, local game runner and testing suite is actually same application with same source code. This means that you can, among other things, play the game in browser, which was not possible before.]]></description><guid isPermaLink="false">3f5071e6-1c55-42fc-ac93-8b1d70958d25</guid><pubDate>Tue,  1 Jan 2019 00:00:00 +0000</pubDate><dc:creator>kuviman</dc:creator></item><item><title>My Personal Rust 2019</title><link>https://casualhacks.net/blog/2019-01-01/my-personal-rust-2019/</link><description><![CDATA[Many people have already posted their thoughts on the future of Rust. There are some excellent ideas in there that are probably more important than what I have to say. On the other hand my blog post covers my personal experiences I’ve had in the few years I’ve been writing Rust.]]></description><guid isPermaLink="false">24596458-21bc-4c81-af9c-957f439796b3</guid><pubDate>Tue,  1 Jan 2019 00:00:00 +0000</pubDate><dc:creator>Casper</dc:creator></item><item><title>Rust in 2019: The next year and edition</title><link>https://mgattozzi.com/rust-in-2019-the-next-year-and-edition/</link><description><![CDATA[This post is gonna be as much personal as it is both technical and people oriented. Buckle up, we’re gonna cover a lot of things, and a lot of it is not fun. This is definitely one of those, “We really need to look at ourselves in the mirror” hard truths posts. As I type this though, I’ve reflecting on the past few years with the Rust community I’m just in awe of the amount of work, dedication, and passion that’s gone into it. I started Rust when I was still starting my career and finishing up my CS degree and now we have a brand spanking new edition! So much has changed that it’s honestly mind boggling thinking about it. Even at work I gave a history of Rust presentation and it was wild being able to go “back in the day” for something that was just a regular day a few years ago.

Now I find myself thinking about the problems we face as we become an even bigger community. We have a lot of problems. They’re good problems to have, but problems that must be solved eventually. I’m gonna go through all of them, what I see as major pain points/issues we’ve solved up to now, the present problems, and ones on the horizon. I’ll cover what I think we should focus on in the upcoming year and where we can go towards for Rust’s 2nd Edition. Let’s get started!]]></description><guid isPermaLink="false">eb6cda74-6556-4a37-bd1e-0a6471b700e4</guid><pubDate>Mon, 31 Dec 2018 19:20:32 +0000</pubDate><dc:creator>Michael Gattozzi</dc:creator></item><item><title>Comparing Pythagorean triples in C++, D, and Rust</title><link>https://atilanevesoncode.wordpress.com/2018/12/31/comparing-pythagorean-triples-in-c-d-and-rust/</link><description><![CDATA[You may have recently encountered and/or read this blog post criticising a possible C++20 implementation of Pythagorean triples using ranges. In it the author benchmarks different implemetations of the problem, comparing readability, compile times, run times and binary sizes. My main language these days is D, and given that D also has ranges (and right now, as opposed to a future version of the language), I almost immediately reached for my keyboard. By that time there were already some D and Rust versions floating about as a result of the reddit thread, so fortunately for lazy me “all” I had to next was to benchmark the lot of them.]]></description><guid isPermaLink="false">6022c644-5499-422b-baab-9124f58a0c69</guid><pubDate>Mon, 31 Dec 2018 13:16:03 +0000</pubDate><dc:creator>Átila Alves Neves</dc:creator></item><item><title>What is &apos;Placement New&apos; in Rust?</title><link>http://blakesmith.me/2018/12/31/what-is-placement-new-in-rust.html</link><description><![CDATA[Placement new is a feature currently being discussed for the Rust programming language. It gives programmer control of memory allocation and memory placement, where current memory allocation implementations are hidden behind compiler internals via the Box::new interface. This is Rust’s answer to C++ placement new, allowing one to control not only when and how memory is freed, but also where it is allocated and freed from.]]></description><guid isPermaLink="false">793ef59c-ee13-4673-a06b-e65d461e7b1c</guid><pubDate>Mon, 31 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Blake Smith</dc:creator></item><item><title>Making and using C-compatible libraries in Rust: present and future</title><link>https://blogs.gentoo.org/lu_zero/2018/12/30/making-and-using-c-compatible-libraries-in-rust-present-and-future/</link><description><![CDATA[Since there are plenty of blogposts about what people would like to have or will implement in rust in 2019 here is mine.

I spent the last few weeks of my spare time making a C-api for rav1e called crav1e, overall the experience had been a mixed bag and there is large space for improvement.]]></description><guid isPermaLink="false">f96e4dca-7eb6-4855-849f-97007457148d</guid><pubDate>Sun, 30 Dec 2018 09:25:47 +0000</pubDate><dc:creator>Luca Barbato</dc:creator></item><item><title>Rustduino pt. I: setting up the development environment</title><link>https://treesandrobots.com/2018/12/rustduino-pt-1-setting-up-development-environment.html</link><description><![CDATA[This post details the steps needed to start programming an Arduino UNO board using the Rust programming language and working on Mac OS.]]></description><guid isPermaLink="false">7d13bc11-63fd-48bd-bef2-459379a5e6c4</guid><pubDate>Sun, 30 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Jacopo Scazzosi</dc:creator></item><item><title>All I Want for Rust 2019 is You (To Give a Talk)</title><link>https://optimistictypes.com/rust-2019/</link><description><![CDATA[A call to action for local Rust meetups.]]></description><guid isPermaLink="false">ee55b2d9-0365-406f-aaef-b4247d8fdf78</guid><pubDate>Sun, 30 Dec 2018 00:00:00 +0000</pubDate><dc:creator>J Haigh</dc:creator></item><item><title>cargo-crev and Rust 2019 fearless code reuse</title><link>https://dpc.pw/cargo-crev-and-rust-2019-fearless-code-reuse</link><description><![CDATA[In my opinion, one of the biggest reasons why Rust is so productive is that it's a superb language for code reuse. Despite all these strengths, there's one problem that sticks out like a sore thumb: trust. Every additional dependency is another piece of code that could be buggy, or even malicious. And in my opinion, it's problem so serious, that is entirely blocking the untapped potential of code reuse in Rust.]]></description><guid isPermaLink="false">ae506c52-88d5-4803-ade0-610f083298ae</guid><pubDate>Sat, 29 Dec 2018 04:43:26 +0000</pubDate><dc:creator>Dawid Ciężarkiewicz aka `dpc`</dc:creator></item><item><title>My Rust 2019 Dream: Dominate the Web</title><link>https://www.reddit.com/r/rust/comments/aac8zk/my_rust_2019_dream_dominate_the_web/?st=JQ8PQ5Z8&amp;sh=3ad6032f</link><description><![CDATA[A lot of people already know Rust is a great systems language. It can be put on embedded, feels better than C/C++ in many ways, and concurrency is way better than it was before. It's almost no doubt that Rust will continue to grow in these realms. The opportunity I see Rust has to lose though, is being the defacto language of the future of serious web programming. The dream I see is Rust as the language every one uses to create backend, front end, and perhaps even the distributed web ( wasm distributed apps on blockchain implementations).]]></description><guid isPermaLink="false">89df3ecf-8eeb-4da6-9945-3d69b6095f5e</guid><pubDate>Sat, 29 Dec 2018 00:04:23 +0000</pubDate><dc:creator>u/richardanaya</dc:creator></item><item><title>Debugging Rust with VSCode on FreeBSD</title><link>https://venshare.com/debugging-rust-with-vscode-on-freebsd/</link><description><![CDATA[The following is a set of notes for installing VSCode on FreeBSD and getting a debugger up and running in a step by step guide. I thought I would share them in a full post as having a full IDE with syntax and error highlighting along with detailed in-context explanations has been really useful as I get to grips with Rust.]]></description><guid isPermaLink="false">c4069a09-be22-45a1-a39b-3067584379a8</guid><pubDate>Fri, 28 Dec 2018 23:56:37 +0000</pubDate><dc:creator>Anton Whalley</dc:creator></item><item><title>Rust 2019 - Usability and Tools</title><link>https://crepererum.net/rust-2019-stabilization-and-ecosystem/</link><description><![CDATA[This is my personal answer to the call for Rust 2019 Roadmap blog posts. To make it easier to read I've separated the post into sections by topic: Cargo & Crates.io, Rustdoc, Language & Stdlib, Compiler & Analyzer.]]></description><guid isPermaLink="false">b6c3cfcb-a670-4295-8a94-a76931e60985</guid><pubDate>Fri, 28 Dec 2018 19:07:59 +0000</pubDate><dc:creator>Marco Neumann</dc:creator></item><item><title>Thoughts on Rust in 2019</title><link>https://medium.com/@bowlescompling/thoughts-on-rust-in-2019-6c0af39a6b76</link><description><![CDATA[2018 was a success with the stated goals of releasing “editions” and working on usability/ergonomics. My first encounter with Rust was pre-1.0 (early 2015) and I immediately saw that Rust would be my future, wherein I joked to colleagues that I’d use it to “make toasters talk”. Followed by a sizeable hiatus (lack of personal time), I came back mid-year 2018. I can say for certain that the focus on usability and ergonomics was successful. Rust is much easier to use now than it was then. Rust format (rustfmt), Rust language server (RLS), text editor support, cargo tooling, compiler messages, and ecosystem crates’ quality and diversity are all amazing. The community is crazy diverse (first language learners, experienced systems people, web-dev people, programming language theory people, etc…). The chaos is well-managed with self-organizing working groups.]]></description><guid isPermaLink="false">53e4c3d4-a70a-4caa-a4c8-17be048c93df</guid><pubDate>Fri, 28 Dec 2018 16:49:44 +0000</pubDate><dc:creator>Josh Bowles</dc:creator></item><item><title>Version 0.2 of Smithay, a library for making wayland compositors</title><link>https://smithay.github.io/smithay-v-0-2.html</link><description><![CDATA[Announcement of version 0.2 of smithay, now providing the fundamentals of a wayland compositor.]]></description><guid isPermaLink="false">bc334e2e-7ac8-4019-a197-da3d1d19edbf</guid><pubDate>Fri, 28 Dec 2018 17:00:00 +0100</pubDate><dc:creator>Victor Berger</dc:creator></item><item><title>My Wish List For Rust 2019</title><link>https://haurchefant.fr/posts/2018/12/my-wishlist-for-rust-2019/</link><description><![CDATA[For the first time, I’m writing for the Rust Roadmap blog posts call. Why this year? Maybe because after being part of the community for 3-ish years, I feel I’ve reached a level of knowledge of the language that allows me to talk about it. I’m far from being an expert, but I wrote an application of my own and I am contributing to Cobalt. Enough experience to give me some material to think about.]]></description><guid isPermaLink="false">4f647aa7-226f-4b30-b814-399284d59111</guid><pubDate>Fri, 28 Dec 2018 15:48:15 +0000</pubDate><dc:creator>Geobert Quach</dc:creator></item><item><title>Rust 2019: Address the &quot;Big&quot; Problem</title><link>https://internals.rust-lang.org/t/rust-2019-address-the-big-problem/9109</link><description><![CDATA[Tame Complexity through Community Involvement Tools]]></description><guid isPermaLink="false">fb92d7a2-b953-45d4-89b0-83cd1648cc47</guid><pubDate>Thu, 27 Dec 2018 19:10:18 +0000</pubDate><dc:creator>Sam Sieber</dc:creator></item><item><title>Announcing &apos;err-derive&apos; - yet another error handling library</title><link>https://users.rust-lang.org/t/announcing-err-derive-yet-another-error-handling-library/23594</link><description><![CDATA[err-derive A failure-like derive macro for the std Error. The source code is mostly copied from failure-derive.]]></description><guid isPermaLink="false">0461ffc8-05b3-413d-a015-c0859ed9665f</guid><pubDate>Thu, 27 Dec 2018 13:09:02 +0000</pubDate><dc:creator>Thomas Schaller</dc:creator></item><item><title>Easy Postgres extensions in Rust with pg-extend-rs</title><link>https://bluejekyll.github.io/blog/rust/2018/12/27/announcing-pg-extend.html</link><description><![CDATA[A project to make Postgres extensions in Rust easy, you might learn how to use macro_rules, attribute macros, allocators and some FFI in this post.]]></description><guid isPermaLink="false">043f0bae-caa0-4d77-8336-9ec0813a0ca0</guid><pubDate>Thu, 27 Dec 2018 07:00:00 +0000</pubDate><dc:creator>Benjamin Fry</dc:creator></item><item><title>This Year in Gfx-rs - 2018</title><link>https://gfx-rs.github.io/2018/12/27/this-year.html</link><description><![CDATA[In 2018 the project left the nursery and entered the adolescence period...]]></description><guid isPermaLink="false">9a6530f2-df83-41a2-b9fe-c2408eabbe0f</guid><pubDate>Thu, 27 Dec 2018 00:00:00 +0000</pubDate><dc:creator>gfx-rs</dc:creator></item><item><title>Thoughts on Rust in 2019</title><link>https://words.steveklabnik.com/thoughts-on-rust-in-2019</link><description><![CDATA[This year is also a bit special; in 2018, we introduced “editions” to Rust, on a roughly three-year schedule. So now is not just a good time to think about 2019, but about 2020 and 2021 as well. Rust 2015 was about “stability”. Rust 2018 was about “productivity.” I’d like Rust 2021 to be about “maturity.” In order to get there, here’s what we need in 2019.]]></description><guid isPermaLink="false">94213785-3a82-4f06-99ee-8477c184903c</guid><pubDate>Thu, 27 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Steve Klabnik</dc:creator></item><item><title>A Rusty Advent of Code</title><link>https://cprimozic.net/blog/a-rusty-aoc/</link><description><![CDATA[For the first time, I took part in the Advent of Code this year. If you haven't heard of it, it's a daily programming challenge that can be solved in any programming language. Rust was very present in the Advent of Code community with people contributing a ton of Rust-related content. In the daily solutions thread on the /r/aoc subreddit, there were always several Rust solutions posted. Advent of Code really helps show off the things that make Rust shine, demonstrating the power and utility of many community-created crates as well as the language itself.]]></description><guid isPermaLink="false">04d1c753-5242-4aa9-bff7-500a717a62bc</guid><pubDate>Thu, 27 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Casey Primozic</dc:creator></item><item><title>Rust 2019: The shift in Rust</title><link>https://vorner.github.io/2018/12/27/rust-2019.html</link><description><![CDATA[This is my answer to the call for blogposts about what I’d like the year 2019 to mean for Rust.]]></description><guid isPermaLink="false">3e7aead6-1e45-4897-8029-993214b6eb99</guid><pubDate>Thu, 27 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Michal &apos;vorner&apos; Vaner</dc:creator></item><item><title>Rust 2019 and beyond: limits to (some) growth</title><link>https://graydon2.dreamwidth.org/263429.html</link><description><![CDATA[This is a blog post (as solicited) about my suggestions for the Rust project in 2019 and beyond. I should note that I am speaking only for myself, not anyone else, and not even as a very active participant in Rust anymore. Moreover these suggestions, to a large extent, apply to many projects. Rust is just one case, but one that is currently doing some conscious year-end reflection. I should also note overall that I'm quite pleased by the trajectory of the Rust project and this suggestion is being made only in the spirit of keeping it healthy and on-track, avoiding some problems I observe developing in it, as a mostly-outsider these days.]]></description><guid isPermaLink="false">1155adc5-9d95-4185-97bb-742e3c0bd446</guid><pubDate>Wed, 26 Dec 2018 11:29:00 +0000</pubDate><dc:creator>Graydon Hoare</dc:creator></item><item><title>Barriers and Two-phase Borrows in Stacked Borrows</title><link>https://www.ralfj.de/blog/2018/12/26/stacked-borrows-barriers.html</link><description><![CDATA[My internship (“research assistantship”) with Mozilla has ended several weeks ago, and this post is a report of the most recent tweaks I made to Miri and Stacked Borrows. Neither project is by any means “done”, of course. However, both have reached a fairly reasonable state, so I felt some kind of closing report made sense. Also, if I ever want to finish my PhD, I’ll have to seriously scale down the amount of time I work on Rust – so at least from my side, things will move more slowly from now on.

In particular, installing Miri and running your test suite in it is now just a single command away! Scroll all the way down if you are not interested in the rest.]]></description><guid isPermaLink="false">152067d5-472f-4ba2-9429-6a5de749bf99</guid><pubDate>Wed, 26 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Ralf Jung</dc:creator></item><item><title>Handling failure in Rust</title><link>https://esimmler.com/handling-failure-in-rust/</link><description><![CDATA[I’ve begun to seriously dig into the Rust programming language. The learning curve is real, but I already appreciate the work they’ve put into ergonomics. I’m writing a simple photo thumbnail endpoint using the Rocket web framework (v0.4) and Image library (v0.20.1). My first pass used a lot of unwrapping to ignore potential errors. A lot can go wrong, even in this “simple” case. Rocket catches any panics thrown by route handlers, so this is about as robust as a naive equivalent in most other languages. However, Rust at least forces us to be explicit and purposeful about when we want to be sloppy. This is great for a first quick and dirty pass, but we can do much better.]]></description><guid isPermaLink="false">0a14c8b2-c25a-4733-9682-e1cc71567cc9</guid><pubDate>Wed, 26 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Erik Simmler</dc:creator></item><item><title>async-io-demo: Rust asynchronous io: from mio to stackless coroutine</title><link>https://github.com/Hexilee/async-io-demo</link><description><![CDATA[2019 is approaching. The rust team keeps their promise about asynchronous IO: async is introduced as keywords, Pin, Future, Poll and await! is introduced into standard library. I have never used rust for asynchronous IO programming earlier, so I almost know nothing about it. However, I would use it for a project recently but couldn't find many documents that are remarkably helpful for newbie of rust asynchronous programming. My purpose of writing this blog is to review and summarize, I will be happy if it can help someone who are interested in rust asynchronous programming.]]></description><guid isPermaLink="false">fe9a3482-44e2-48d3-8728-0a15b4d2fd48</guid><pubDate>Wed, 26 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Li Chenxi</dc:creator></item><item><title>Rust 2019 -- Finish Core Stuff!</title><link>https://gist.github.com/magnet/fab817fd64411f65d8d5f5109eadd5f9</link><description><![CDATA[I am a relatively new in Rust, but I believe I have gathered enough experience the last few months to enjoy its strengths and discover some of its current shortcomings. Being relatively new at Rust, I am also of this generation that started immediately with Edition 2018. I switched to nightly very early on, and recently have been porting some code back to stable (1.31.x). I am overall very satisfied with Rust, but sometimes I come across something that doesn't work as I hoped. Every time that happens, I discover there is work-in-progress solving these issues, including, most of the time, a merged RFC, a nightly implementation behind feature gates or at least some blogs from core developers. Many time, the work I come across is from many years back.

I have read several #Rust2019 and I want to use this opportunity to agree with those that suggest to finish current core stuff.]]></description><guid isPermaLink="false">055bf639-2649-43e8-8604-91388b069c98</guid><pubDate>Tue, 25 Dec 2018 19:03:55 +0000</pubDate><dc:creator>Simon Chemouil</dc:creator></item><item><title>Currying in rust Part 3 (The circle of life ... aka why borrowchecker ... why?!)</title><link>https://hashnode.com/post/currying-in-rust-part-3-the-circle-of-life-aka-why-borrowchecker-why-cjq3z1dd800dknds1sls4dqav</link><description><![CDATA[Today we're going to take a look at the 'pipe' function my friend has written and why all of the sudden lifetimes get important esp. when using references.]]></description><guid isPermaLink="false">bddc8eb0-f2db-4330-87fa-2eca9a68e9e5</guid><pubDate>Tue, 25 Dec 2018 16:35:00 +0000</pubDate><dc:creator>j</dc:creator></item><item><title>Jix&apos; Site: Introducing partial_ref</title><link>https://jix.one/introducing-partial_ref/</link><description><![CDATA[Recently there has been some discussion about interprocedural borrowing conflicts in rust. This is something I’ve been fighting with a lot, especially while working on my SAT solver varisat. Around the time Niko Matsakis published his blog post about this, I realized that the existing workarounds I’ve been using in varisat have become a maintenance nightmare. Making simple changes to the code required lots of changes in the boilerplate needed to thread various references to the places where they’re needed.

While I didn’t think that a new language feature to solve this would be something I’d be willing to wait for, I decided to sit down and figure out how such a language feature would have to look like. I knew that I wanted something that allows for partial borrows across function calls. I also prefer this to work with annotations instead of global inference. While trying to come up with a coherent design that fits neatly into the existing type and trait system, I realized that most of what I wanted can be realized in stable rust today.]]></description><guid isPermaLink="false">2508ab68-2b48-4066-a6b4-a15a4f061025</guid><pubDate>Mon, 24 Dec 2018 14:07:10 +0100</pubDate><dc:creator>Jannis Harder</dc:creator></item><item><title>Rust 2019: Ignorant Thoughts</title><link>http://www.russet.org.uk/blog/3207</link><description><![CDATA[I’ve written a single library in Rust, called Horned-OWL for manipulating OWL. The experience has been positive. There is already a good and complete library for manipulating OWL called the OWL API, so I needed a strong motivation for writing another. That motivation is simple: the OWL API is in Java and it is slow. Rust has fulfilled it’s promise for me; Horned-OWL is an order of magnitude faster thatn the OWL API. What have I learned from the experience though, and what could be improved?]]></description><guid isPermaLink="false">5a894193-9c56-4f80-8e38-546cadf5da44</guid><pubDate>Mon, 24 Dec 2018 09:05:36 +0000</pubDate><dc:creator>Phillip Lord</dc:creator></item><item><title>Rust in 2019</title><link>https://blog.strake.me.uk/archives/93</link><description><![CDATA[Rust made good progress in 2018: const fn in particular was a welcome and sorely needed feature. With #[panic_handler] now stable, we can finally write no_std binary crates on stable and not worry the next release will break it. We got some other useful features, including the following: u128, NonNull, fixed-length slice patterns, LTO, #[repr(transparent)], #[repr(align(_))] In 2019, I have one major wish for Rust: Const Generics.]]></description><guid isPermaLink="false">f90bfac4-bbae-4d28-baec-d46eadb5e2cb</guid><pubDate>Mon, 24 Dec 2018 02:52:50 +0000</pubDate><dc:creator>Strake</dc:creator></item><item><title>Rust for algorithms</title><link>https://ilyabiz.com/2018/12/rust-for-algorithms/</link><description><![CDATA[How I decided to challenge myself and solve coding tasks using Rust]]></description><guid isPermaLink="false">525bee43-14cb-422e-8b91-58322a8d2c63</guid><pubDate>Sun, 23 Dec 2018 20:54:31 +0000</pubDate><dc:creator>Ilya Bizyaev</dc:creator></item><item><title>Rust &amp; Python—A Gentle Comparison using Simple Neural Networks</title><link>https://blog.digital-horror.com/rust-python-comparison/</link><description><![CDATA[A gentle comparison between Rust & Python from multiple perspectives against a small, relatively simple problem.]]></description><guid isPermaLink="false">6aa36df9-001c-478b-830e-56e2b896303b</guid><pubDate>Sun, 23 Dec 2018 17:10:39 +0000</pubDate><dc:creator>Juxhin Dyrmishi Brigjaj</dc:creator></item><item><title>On Rust</title><link>https://dehora.net/journal/2018/12/23/on-rust</link><description><![CDATA[Back in 2013, I started a series of posts on programming languages I found interesting. One of the languages I wanted to write about at that time was Rust. As often happens, life got in the way, and it’s only now, in the twilight of 2018 I’m coming round to a long overdue post.]]></description><guid isPermaLink="false">0717e76b-2097-4ee0-87b1-5f6cffadbdf0</guid><pubDate>Sun, 23 Dec 2018 16:34:59 +0000</pubDate><dc:creator>Bill de hÓra</dc:creator></item><item><title>Visualizing Crates.io</title><link>https://8-p.info/visualizing-crates-io/</link><description><![CDATA[Visualizing Rust's growing ecosystem through crates.io, Rust's central package repository.]]></description><guid isPermaLink="false">7dd6ca97-374d-4c01-86fb-f3fed29bb6f6</guid><pubDate>Sun, 23 Dec 2018 12:06:00 +0000</pubDate><dc:creator>Kazuyoshi Kato</dc:creator></item><item><title>Serverless Rust: Revisited</title><link>https://medium.com/@softprops/serverless-rust-revisited-f2c79f4039bb</link><description><![CDATA[A refreshing new story for running Rust on AWS Lambda.]]></description><guid isPermaLink="false">164aa143-a832-491e-b1c0-304913959b8d</guid><pubDate>Sat, 22 Dec 2018 15:43:04 +0000</pubDate><dc:creator>Doug Tangren</dc:creator></item><item><title>Converting a Python library to Rust</title><link>https://alantrick.ca/writings/programming/python_to_rust/</link><description><![CDATA[I rewrote a Python project in Rust. The rewrite took a fair bit longer than expected, but the results were good (about 9 times faster and ½ the memory usage). In the process, I learned a fair bit about Rust.]]></description><guid isPermaLink="false">f6f38aae-10b9-4c71-b4fd-c0412a56e064</guid><pubDate>Sat, 22 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Alan Trick</dc:creator></item><item><title>Methods for Array Initialization in Rust</title><link>https://www.joshmcguigan.com/blog/array-initialization-rust/</link><description><![CDATA[Arrays in Rust are fixed size, and Rust requires that every element in an array is initialized to a valid value when the array is initialized. The result of these requirements is array initialization in Rust is a much deeper topic then it would seem.]]></description><guid isPermaLink="false">5e9ee3df-617a-4a7c-b8bd-ade701971b10</guid><pubDate>Sat, 22 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Josh Mcguigan</dc:creator></item><item><title>Azure Functions written in Rust</title><link>https://robertohuertas.com/2018/12/22/azure-function-rust/</link><description><![CDATA[A few days ago, we discussed how to write AWS Lambdas in Rust. Today, we’re going to learn how to create and deploy an Azure Function using Rust and the azure-functions-sdk library.]]></description><guid isPermaLink="false">f0df7d96-1aae-46ea-b454-d4d2ce7d3efd</guid><pubDate>Sat, 22 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Roberto Huertas</dc:creator></item><item><title>Rust2019</title><link>https://medium.com/@softprops/rust2019-83ebfe46602e</link><description><![CDATA[It’s the time year to reflect on the past and to make wishful prospects for the future.]]></description><guid isPermaLink="false">1c724779-9e18-4c1a-94db-7799f444f6b3</guid><pubDate>Fri, 21 Dec 2018 05:47:42 +0000</pubDate><dc:creator>Doug Tangren</dc:creator></item><item><title>Six years with Rust</title><link>https://words.steveklabnik.com/six-years-with-rust</link><description><![CDATA[This past year was… intense. Rust 1.31 was basically Rust 2.0, at least in the marketing sense. I burned myself out getting the first edition of the book together for Rust 1.0, and I burned myself out getting the edition shipped.

Let’s talk about the bad and the good. Bad first so we end on the high notes.]]></description><guid isPermaLink="false">deb0916b-c8e3-47b1-b957-bfa8015b73ff</guid><pubDate>Fri, 21 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Steve Klabnik</dc:creator></item><item><title>Procedural Macros in Rust 2018</title><link>https://blog.rust-lang.org/2018/12/21/Procedural-Macros-in-Rust-2018.html</link><description><![CDATA[Perhaps my favorite feature in the Rust 2018 edition is procedural macros. Procedural macros have had a long and storied history in Rust (and will continue to have a storied future!), and now is perhaps one of the best times to get involved with them because the 2018 edition has so dramatically improved the experience both defining and using them.

Here I'd like to explore what procedural macros are, what they're capable of, notable new features, and some fun use cases of procedural macros. I might even convince you that this is Rust 2018's best feature as well!]]></description><guid isPermaLink="false">e01f334f-a14e-4a54-b7d7-76c9cc6ccdc7</guid><pubDate>Fri, 21 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Alex Crichton</dc:creator></item><item><title>Rust in 2019: Working through the growing pains</title><link>https://isaacwoods.tk/rust_2019/</link><description><![CDATA[TLDR: this post is not as eloquent as I’d like it to be, but the main takeaway
is that Rust is still a fast growing language, and has experienced expected growing pains,
both social and technological. This is okay, and we as the community need to
work through these pains, with the teams, not despite them.]]></description><guid isPermaLink="false">df592561-9217-416a-bb32-5d610d948fad</guid><pubDate>Wed, 19 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Isaac Woods</dc:creator></item><item><title>Rust 2019: Stabilization</title><link>https://blog.ryanlevick.com/posts/rust-2019/</link><description><![CDATA[If you’re familiar with the history of Rust you might be confused with a call to stabilization. After all, Rust 2015 (a.k.a 1.0) was all about stabilization and the team has actually done a pretty good job with achieving this goal. So what gives?

While Rust 2015 defined stabilization around language backward compatibility, it’s time for the language, the tooling, the ecosystem and the governance to stabilize. Each of these characterize stability in a different way. Let me explain a bit more what I mean.]]></description><guid isPermaLink="false">1b761099-8ee4-4e1c-86b1-2aeac151507c</guid><pubDate>Wed, 19 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Ryan Levick</dc:creator></item><item><title>gbl: A typestate-powered zero-copy crate for GBL firmware update files</title><link>https://blog.1aim.com/post/gbl-release/</link><description><![CDATA[After a few weeks of reverse-engineering, internal dogfooding, and API design discussion, we're finally publishing our gbl crate for good.

The library implements a parser and writer for GBL firmware update containers, which are used to perform secure OTA updates for certain microcontrollers.]]></description><guid isPermaLink="false">aa59c999-cba6-4f20-80cc-888e8e257a73</guid><pubDate>Wed, 19 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Jonas Schievink</dc:creator></item><item><title>How to Become a Rust Super-developer</title><link>https://hashnode.com/post/how-to-become-a-rust-super-developer-cjpv1ee7e000buhs2aqrdw2ym</link><description><![CDATA[This is an article and a tutorial about stumbling and failing. It is about trying hard, and giving up - just to start all over again. All for the one goal - becoming the master of coding in Rust.]]></description><guid isPermaLink="false">5bfa329e-1d71-4b98-af03-90c1672ebb8b</guid><pubDate>Wed, 19 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Marco Alka</dc:creator></item><item><title>A great 2018, an even better 2019</title><link>https://tokio.rs/blog/2018-12-recap-2018/</link><description><![CDATA[A year ago, Tokio was a very different library. It includes the (now deprecated) tokio-core which provided a future executor, I/O selector, and basic TCP/UDP types in a single library. It also included tokio-proto, but we won't talk about that. Over the past year, Tokio has grown to become Rust's asynchronous I/O platform. It has been adopted by a number of large companies to build apps.]]></description><guid isPermaLink="false">8abe1072-74b2-4cc8-b349-ba38a3bfae1b</guid><pubDate>Wed, 19 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Carl Lerche</dc:creator></item><item><title>RTFM v0.4: +stable, software tasks, message passing and a timer queue</title><link>https://blog.japaric.io/rtfm-v4/</link><description><![CDATA[Today I’m pleased to announce v0.4.0 of the Real Time for The Masses framework (AKA RTFM), a concurrency framework for building real time applications. This release also packs quite a few new features which I’ll briefly cover in this post. For a more throughout explanation of RTFM’s task model and its capabilities check out the RTFM book, which includes examples you can run on your laptop (yay for emulation), and the API documentation.]]></description><guid isPermaLink="false">72e699cc-6b46-4f3b-9295-fef767681af8</guid><pubDate>Wed, 19 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Jorge Aparicio</dc:creator></item><item><title>My wishlist for Rust ‘19</title><link>https://apiraino.github.io/2018/12/19/call-for-2019-roadmap.html</link><description><![CDATA[This isn’t exactly a blog so this won’t be exactly a “post”, but I’d like to write down my thoughts on this notepad answering the call for a wishlist for Rust 2019. Opinions expressed are from the point of view of an enthusiast, Rust apprentice, that happened to be knee-deep involved in organizing the RustFest in Rome. It’s fun to pin today some thoughts and see in 12 months how things will have evolved!]]></description><guid isPermaLink="false">1a96907b-61a3-4b4f-aba9-640a5b6ac00e</guid><pubDate>Wed, 19 Dec 2018 00:00:00 +0100</pubDate><dc:creator>apiraino</dc:creator></item><item><title>Rust 2019: Bootstrapping Minorities</title><link>https://internals.rust-lang.org/t/rust-2019-bootstrapping-minorities/9053</link><description><![CDATA[As a response of https://blog.rust-lang.org/2018/12/06/call-for-rust-2019-roadmap-blogposts.html 3 for tooling improvement. Nice to see rust improved so much these few years on productivity but I think there is room for improvement. This would be my first post about Rust after hanging around for quite some time.]]></description><guid isPermaLink="false">3edd04cc-9a58-4b57-ab93-d948575875d9</guid><pubDate>Tue, 18 Dec 2018 14:08:45 +0000</pubDate><dc:creator>Ivan Tham</dc:creator></item><item><title>Intermission</title><link>https://azriel.im/will/2018/12/18/intermission/</link><description><![CDATA[Things I would like prioritized in the 2019 roadmap: Reduced Compilation Times, Refined Tools.]]></description><guid isPermaLink="false">f11f3bca-353a-4c96-b50d-7a28acb0d7ec</guid><pubDate>Tue, 18 Dec 2018 11:31:13 +1300</pubDate><dc:creator>Azriel Hoh</dc:creator></item><item><title>Rust 2019 wish-list</title><link>https://www.reddit.com/r/rust/comments/a6y6my/rust_2019_wishlist/</link><description><![CDATA[I'm writing in Rust a lot less than what I'd like, in part because of the lack of time, in part because the language and developer experience are already good. What I found missing is...]]></description><guid isPermaLink="false">536bfa8b-ba21-44b5-b570-3e5850de6320</guid><pubDate>Mon, 17 Dec 2018 20:06:00 +0000</pubDate><dc:creator>Matteo Bertini</dc:creator></item><item><title>Leveraging Rust types for modular specification and verification</title><link>https://www.research-collection.ethz.ch/handle/20.500.11850/311092</link><description><![CDATA[Rust’s type system ensures memory safety: well-typed Rust programs are guaranteed to not exhibit problems such as dangling pointers, data races, and unexpected side effects through aliased references. Going beyond memory safety, for instance, to guarantee the absence of assertion failures or functional correctness, requires static program verification. Formal verification of system software is notoriously difficult and requires complex specifications and logics to reason about pointers, aliasing, and side effects on mutable state. This complexity is a major obstacle to a more widespread verification of system software.

In this paper, we present a novel verification technique that leverages Rust’s type system to greatly simplify the specification and verification of Rust programs. We analyse information from the Rust compiler and synthesise a corresponding core proof for the program in a flavour of separation logic tailored to automation. Crucially, our proofs are constructed and checked automatically; users of our work never work with the underlying formal logic. Users can add specifications at the abstraction level of Rust expressions; we show how to interweave these to extend our core proof to prove modularly whether these specifications are correct. We have implemented our technique for a subset of Rust; our initial evaluation on two thousand functions from widely-used Rust crates demonstrates its effectiveness]]></description><guid isPermaLink="false">d282adbf-dce7-4fbb-86e5-2d33df229932</guid><pubDate>Mon, 17 Dec 2018 07:00:47 +0000</pubDate><dc:creator>Astrauskas, Vytautas; Müller, Peter; Poli, Federico; Summers, Alexander</dc:creator></item><item><title>Tools in the 2018 edition</title><link>https://blog.rust-lang.org/2018/12/17/Rust-2018-dev-tools.html</link><description><![CDATA[In this blog post I'll cover Clippy and Rustfmt – two tools that have been around for a few years and are now stable and ready for general use. I'll also cover IDE support – a key workflow for many users which is now much better supported. I'll start by talking about Rustfix, a new tool which was central to our edition migration plans.]]></description><guid isPermaLink="false">629810d5-0f02-4ef1-9826-32cd4bc2f048</guid><pubDate>Mon, 17 Dec 2018 00:00:00 +0000</pubDate><dc:creator>The Dev-tools team</dc:creator></item><item><title>Rust 2019: Go Slow</title><link>https://blog.hwc.io/posts/rust-2019/</link><description><![CDATA[I have many technical wishes for Rust, the language, in 2019. However, I’m not going to mention any in particular in this post. In fact, I can almost say that I’d prefer for there to not be a focus on achieving technical milestones in the next year.]]></description><guid isPermaLink="false">8d54d930-66a9-438f-8dad-de13e2fe8c3c</guid><pubDate>Sun, 16 Dec 2018 15:39:32 -0500</pubDate><dc:creator>hwc</dc:creator></item><item><title>Rust 2019</title><link>https://gist.github.com/xd009642/083a689c1fe460459d6bc792a626604e</link><description><![CDATA[This is a bit of a brain dump of my thoughts about Rust 2019. Mainly I work on my own code coverage tool tarpaulin, embedded rust and random little tools. So my perspective will be coloured by this.]]></description><guid isPermaLink="false">34b69da0-cd61-4a16-8bfe-21d8d98dd4bd</guid><pubDate>Sun, 16 Dec 2018 15:22:21 +0000</pubDate><dc:creator>xd009642</dc:creator></item><item><title>My thoughts on Rust 2019</title><link>https://raphlinus.github.io/rust/2018/12/16/rust-2019.html</link><description><![CDATA[Recently, the Rust Core Team solicited blog posts on where Rust should be headed in 2019. Here’s mine.]]></description><guid isPermaLink="false">94ad8d78-4b62-41ff-86c3-44690a1dbf66</guid><pubDate>Sun, 16 Dec 2018 14:55:42 +0000</pubDate><dc:creator>Raph Levien</dc:creator></item><item><title>Making Rust Float Parsing Fast and Correct</title><link>https://www.reddit.com/r/rust/comments/a6j5j1/making_rust_float_parsing_fast_and_correct/</link><description><![CDATA[Previously, I wrote about how Rust parsing is atypically slow comparing Rust's libcore implementation to a rudimentary parser I wrote. However, as others noted, the comparison was fairly limited. It didn't compare Rust's implementation to other implementations, such as glibc's strtod or Go's ParseFloat. The parser I implemented wasn't correct, it led to rounding error for most representations, by using floats for intermediate values. Furthermore, the comparisons used data unlikely to be encountered in real-world datasets, overstating the performance differences by forcing Rust to use slower algorithms. So, naturally, I aimed to address all these concerns. And finally, I forgot to disable CPU scaling, meaning CPU throttling could have led to inconsistent benchmarks.]]></description><guid isPermaLink="false">f848772a-4132-4e4f-b817-c4a6dec365b7</guid><pubDate>Sun, 16 Dec 2018 08:39:39 +1100</pubDate><dc:creator>u/ialex32_2</dc:creator></item><item><title>QADAPT - debug_assert! for your memory usage</title><link>https://speice.io/2018/12/allocation-safety.html</link><description><![CDATA[I think it’s part of the human condition to ignore perfectly good advice when it comes our way. A bit over a month ago, I was dispensing sage wisdom for the ages: I had a really great idea: build a custom allocator that allows you to track your own allocations. I gave it a shot, but learned very quickly: never write your own allocator. I proceeded to ignore it, because we never really learn from our mistakes. There’s another part of the human condition that derives joy from seeing things explode. And that’s the part I’m going to focus on.]]></description><guid isPermaLink="false">e72d0a8e-198f-4bd2-bf1e-7e0e94fac9d5</guid><pubDate>Sat, 15 Dec 2018 00:00:00 -0500</pubDate><dc:creator>Bradlee Speice</dc:creator></item><item><title>Creating an empty iterator of a certain type in Rust</title><link>https://www.freedomlayer.org/offst/option-iterator/</link><description><![CDATA[I am working these days on the development of offst's Index server. I needed to implement a basic directed graph structure, allowing to run the BFS algorithm to find routes with a certain amount of capacity. During the work on the Index server I had the problem of wanting to return an empty iterator in an early flow of a function.]]></description><guid isPermaLink="false">3f750cea-55f1-44cf-b965-b3a2803de32b</guid><pubDate>Sat, 15 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Freedomlayer</dc:creator></item><item><title>Rust Analyzer in 2018 and 2019</title><link>https://ferrous-systems.com/blog/rust-analyzer-2019/</link><description><![CDATA[Hi! I am Aleksey Kladov (aka @matklad). In the past, I've worked at Jet Brains where I've helped to create the IntelliJ Rust plug-in, and now I am a part of the Ferrous Systems team.

I've spent a significant amount of the last year experimenting with various approaches to make the Rust IDE story better. The culmination of my experiments is the rust-analyzer project – an experimental Rust compiler frontend, targeting the IDE/Language Server Protocol use case.]]></description><guid isPermaLink="false">bf6eb06b-346b-4f0c-a294-ee1dde663418</guid><pubDate>Sat, 15 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Aleksey Kladov</dc:creator></item><item><title>Kubernetes config management in Rust</title><link>https://clux.github.io/probes/post/2018-12-15-config-management-in-rust/</link><description><![CDATA[At babylon health we have a ton of microservices running on kubernetes that are, in turn, controlled by hundreds of thousands of lines of autogenerated yaml. So for our own sanity, we built shipcat - a standardisation tool (powered by rust-lang and serde) to control the declarative format and lifecycle of every microservice.]]></description><guid isPermaLink="false">0ee5d609-1891-4f10-9085-93696f564382</guid><pubDate>Sat, 15 Dec 2018 00:00:00 +0000</pubDate><dc:creator>clux</dc:creator></item><item><title>Rust and WebAssembly in 2019</title><link>http://fitzgeraldnick.com/2018/12/14/rust-and-webassembly-in-2019.html</link><description><![CDATA[Compiling Rust to WebAssembly should be the best choice for fast, reliable code for the Web. Additionally, the same way that Rust integrates with C calling conventions and libraries on native targets, Rust should also integrate with JavaScript and HTML5 on the Web. These are the Rust and WebAssembly domain working group’s core values. In 2018, we made it possible to surgically replace performance-sensitive JavaScript with Rust-generated WebAssembly. I propose that we make larger-scale adoption of Rust and WebAssembly practical in 2019.]]></description><guid isPermaLink="false">f12043be-3b2d-4ab3-8ce1-51463ffad905</guid><pubDate>Fri, 14 Dec 2018 00:00:00 -0800</pubDate><dc:creator>Nick Fitzgerald</dc:creator></item><item><title>Rust 2019</title><link>https://hsivonen.fi/rust2019/</link><description><![CDATA[The Rust team encouraged people to write blog posts reflecting on Rust in 2018 and proposing goals and directions for 2019. Here’s mine. This is knowingly blatantly focused on the niche that is immediately relevant to my work. I don’t even pretend this to represent any kind of overall big picture.]]></description><guid isPermaLink="false">2bc063a6-80f5-4f7b-aea3-329ceef00a8e</guid><pubDate>Fri, 14 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Henri Sivonen</dc:creator></item><item><title>My Wishes for Rust 2019</title><link>https://cetra3.github.io/blog/rust-2019/</link><description><![CDATA[2018 was a massive year for rust, and it's great to reflect back on how far we've all come. My main wish for the new year is to put on the breaks a little bit, and finish off what has been started without taking on anything majorly new.]]></description><guid isPermaLink="false">fde9a5b7-9e92-41aa-994a-15bdb87d2909</guid><pubDate>Fri, 14 Dec 2018 00:00:00 +0000</pubDate><dc:creator>cetra3</dc:creator></item><item><title>Rust 2019 - my 2¢</title><link>https://www.reddit.com/r/rust/comments/a5s024/rust_2019_my_2/</link><description><![CDATA[I will not be really original here, but I really hope to see the following features to land on stable in 2019: const generics, async/await, GATs, inherent traits, minimum supported Rust version:]]></description><guid isPermaLink="false">dd6ec508-904b-4cd2-96ca-3df2ed99b074</guid><pubDate>Thu, 13 Dec 2018 20:24:49 +1100</pubDate><dc:creator>u/newpavlov</dc:creator></item><item><title>Rust Raps - Ferris Crab (Rust Raps 2018 Edition)</title><link>http://fitzgeraldnick.com/2018/12/13/rust-raps.html</link><description><![CDATA[Just released: the hot new single “Ferris Crab (Rust Raps 2018 Edition)” by Rusta Rhymes off their upcoming debut album impl Drop for Mic {}.]]></description><guid isPermaLink="false">733eb57b-95f6-490b-b3aa-ba223cacb0f5</guid><pubDate>Thu, 13 Dec 2018 00:00:00 -0800</pubDate><dc:creator>Rusta Rhymes</dc:creator></item><item><title>Yet another Rust 2018 wishlist</title><link>https://www.reddit.com/r/rust/comments/a5q7eb/yet_another_rust_2018_wishlist/</link><description><![CDATA[The 2018 year brought a lot of incredible new features and I'm impressed with all the work that was put in to make the 2018 edition happen. I want to join the other users asking for 2019 to be a year we adjust to all the new changes and focus on cleaning and polishing, not entirely new projects*. For the upcoming year I'd like to see progress on compilation speed and maintenance attention in the library ecosystem.]]></description><guid isPermaLink="false">d4acf845-6f69-4f54-bd37-96d62f83a54c</guid><pubDate>Thu, 13 Dec 2018 15:38:32 +1100</pubDate><dc:creator>u/Saefroch</dc:creator></item><item><title>Async in Rust, circa 2018</title><link>https://rust-lang-nursery.github.io/wg-net/2018/12/13/async-update.html</link><description><![CDATA[Rust 2018 has shipped, and we’re closing in on the end of the year. While we didn’t manage to ship async/await as part of the edition itself, the community has made quite a lot of progress toward that goal. This post summarizes the state of play, and announces the publication of several crates intended to facilitate use of async/await on the nightly ecosystem.]]></description><guid isPermaLink="false">53c9e07b-f4d5-423f-8a84-05e119814fda</guid><pubDate>Thu, 13 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Aaron Turon</dc:creator></item><item><title>Edge programming with Rust and WebAssembly</title><link>https://www.fastly.com/blog/edge-programming-rust-web-assembly</link><description><![CDATA[Take a developer deep dive into Terrarium, our multi-language, browser-based editor and deployment platform at the edge. Learn how to compile Rust programs to WebAssembly right on your local machine, interact with the Terrarium system, and explore some applications we’ve built with it.]]></description><guid isPermaLink="false">78791a3b-395e-4d3b-b091-66aa2fa2c577</guid><pubDate>Wed, 12 Dec 2018 16:00:00 +0000</pubDate><dc:creator>Pat Hickey</dc:creator></item><item><title>Sinistersnare&apos;s Rust 2019 Wishlist</title><link>https://drs.is/post/rust-wishlist-2019/</link><description><![CDATA[Rust needs to focus on less glamorous features in 2019. We have added a lot of great features since 1.0, but we need to address the warts that we have had for a long time. I mostly echo sentiments from Jonathan Turner, Nathan Vegdahl, and many others in my ‘fallow-year’ sentiments. Overall, Compilation speed and generic constants are my two most wished-for features. On top of that, I would like to see more ecosystem work to make embedded applications more feasible and easy to use. Finally, Rust needs a moratorium on adding syntactic sugar for 2019.]]></description><guid isPermaLink="false">9e8f8e34-8fe9-4b4b-b40a-970e0a85a993</guid><pubDate>Wed, 12 Dec 2018 08:10:44 -0500</pubDate><dc:creator>Davis Ross Silverman</dc:creator></item><item><title>Rust 2019 - It&apos;s the Little Things</title><link>https://blog.cessen.com/post/2018_12_12_rust_2019_its_the_little_things</link><description><![CDATA[This might be an uncommon opinion—especially among those motivated enough to write a Rust 2019 post—but I actually think Rust is pretty much at a good place now. For the kinds of things that I want to do (e.g. my path tracer), there isn't much that Rust is lacking as a language. There are some fiddly things like "placement new" that could be useful, but nothing really major. And of course, well-designed new features are always welcome, they just don't seem particularly critical to me at this point. In other words, I'm pretty much satisfied. Mission accomplished, as far as I'm concerned. I think the rest is just polish. Just the little things.]]></description><guid isPermaLink="false">a884801e-f80b-4ea4-8441-a86c2c736086</guid><pubDate>Wed, 12 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Nathan Vegdahl</dc:creator></item><item><title>Rust 2019: Technical Debt, Continued Productivity, and Stability</title><link>https://gist.github.com/mark-i-m/2c3508ab7a9f2c48f634f0b5da3bb000</link><description><![CDATA[I hope this post doesn't come across as a laundry list of stuff to do. Mainly, I consider a lot of this to be technical debt, and I would like to see it paid down a bit. Most of them also happen to be pain points that I have come across in my own usage of Rust, so perhaps I'm biased! Feel free to let me know...]]></description><guid isPermaLink="false">7ebb05f4-2bc2-4637-b38d-fd29d4a1cc3c</guid><pubDate>Tue, 11 Dec 2018 23:47:53 +0000</pubDate><dc:creator>@mark-i-m</dc:creator></item><item><title>Rust 2019: Think Bigger</title><link>http://fitzgeraldnick.com/2018/12/11/rust-2019-think-bigger.html</link><description><![CDATA[Rust shines when we find ways to have our cake and eat it too: memory safety without runtime garbage collection, abstraction without overhead, threading without data races. We must find new ways to continue this tradition for Rust 2019 and beyond.]]></description><guid isPermaLink="false">c0d67320-edd6-4eef-b345-bbf3288acaae</guid><pubDate>Tue, 11 Dec 2018 00:00:00 -0800</pubDate><dc:creator>Nick Fitzgerald</dc:creator></item><item><title>Rust in 2022</title><link>https://www.ncameron.org/blog/rust-in-2022/</link><description><![CDATA[A response to the call for 2019 roadmap blog posts. In case you missed it, we released our second edition of Rust this year! An edition is an opportunity to make backwards incompatible changes, but more than that it's an opportunity to bring attention to how programming in Rust has changed. With the 2018 edition out of the door, now is the time to think about the next edition: how do we want programming in Rust in 2022 to be different to programming in Rust today? Once we've worked that out, lets work backwards to what should be done in 2019.]]></description><guid isPermaLink="false">4259e940-d508-4de3-8971-3c3df7b30f98</guid><pubDate>Tue, 11 Dec 2018 04:34:31 +0000</pubDate><dc:creator>Nick Cameron</dc:creator></item><item><title>Bootstrapping Rust</title><link>https://www.gnu.org/software/guix/blog/2018/bootstrapping-rust/</link><description><![CDATA[It has been a long-standing tradition to develop a language far enough to be able to write the language's compiler in the same language, and Rust does the same. Rust is nowadays written in Rust. We've tracked down the earlier Rust versions, which were written in OCaml, and were planning to use these to bootstrap Rust. But in parallel, John Hudge (Mutabah) developed a Rust compiler, called "mrustc", written in C++. mrustc is now good enough to compile Rust 1.19.0. Using mrustc, we were able to build Rust entirely from source with a bootstrap chain]]></description><guid isPermaLink="false">6bf8dccd-51b6-4dcb-a9eb-e38923d28a2c</guid><pubDate>Tue, 11 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Danny Milosavljevic</dc:creator></item><item><title>Positive-Sum Games</title><link>https://llogiq.github.io/2018/12/11/sum.html</link><description><![CDATA[One thing I learned from Aaron Turon is to search for positive-sum games. First what does that even mean? In most arguments you may run into, it will be easy to find a zero-sum game: Your win is my loss and vice versa. However, in many situations, it is actually possible to go above those petty games and find a variant that allows us both to win.]]></description><guid isPermaLink="false">2fdb4722-43ce-4bad-b37e-67dae34eecb2</guid><pubDate>Tue, 11 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Llogiq</dc:creator></item><item><title>Dynamically Generating Dockerfiles for K8s</title><link>https://medium.com/docql/dynamically-generating-dockerfiles-for-k8s-d2baf7bfef5a</link><description><![CDATA[Hello everyone! Today I am excited to announce that DocQL is open-sourcing a Rust crate (a library) which we built internally called…]]></description><guid isPermaLink="false">00b55ed6-da3d-4c6a-90ed-ebea6191afd8</guid><pubDate>Mon, 10 Dec 2018 19:43:10 +0000</pubDate><dc:creator>Anthony Dodd</dc:creator></item><item><title>Lokathor&apos;s Rust 2019 wishpost</title><link>https://www.reddit.com/r/rust/comments/a4ygji/lokathors_rust_2019_wishpost</link><description><![CDATA[Recently I've been using Rust for GBA development (repo link), and before that I spent most of my Rust time with Handmade Hero work (the actual repo is private to handmade hero backers, so that link is just the main website). As you might expect, this has given me a quite different view of what I want to see from Rust. Basically, I don't want more crates. I want language, and tools, and most importantly education.]]></description><guid isPermaLink="false">dcaa5235-2614-4f61-b0b4-8b1f2e0d136e</guid><pubDate>Tue, 11 Dec 2018 05:47:42 +1100</pubDate><dc:creator>u/Lokathor</dc:creator></item><item><title>Existential types in Rust</title><link>https://adelbertc.github.io/posts/2018-12-10-rust-existentials.html</link><description><![CDATA[The Rust project I am working on is a caching layer, currently backed by Redis, and it came to a point where I needed to leverage pipelining. On its own, pipelining is straightforward as the redis crate implements it already. However all notions of a cache in our code are abstracted out behind a trait so we can have alternative implementations, such as an in-memory HashMap-backed implementation.

The problem arises with representing the pipeline in code. It would force any implementation of our cache to Redis’s notion of a pipeline. Not only would this make it difficult to introspect during testing, but it would also be nonsensical for our HashMap-backed cache. My usual answer to this in languages that support higher-kinded types is to use tagless-final algebras, but Rust’s type system currently doesn’t support higher-kinded types1. Fortunately, there is a pretty good alternative that Rust does support: existential types.]]></description><guid isPermaLink="false">4fe3c55c-a091-40c2-ada0-8c5d371afc31</guid><pubDate>Mon, 10 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Adelbert Chang</dc:creator></item><item><title>Using Web Assembly in the Browser</title><link>https://ljcode.org/blog/wasm-part1/</link><description><![CDATA[WebAssembly (abbreviated Wasm) is a binary instruction format for a stack-based virtual machine. This essentially means that is is fast, because the program is compiled to a much more compact format, making it faster to parse. Wasm can be written by hand if you're looking for a challenge, but is primarily meant to be written in another language, and then compiled to Wasm. You may know a little about Assembly language and how it works - here's a quick refresher in-case you're rusty.]]></description><guid isPermaLink="false">27a7e602-da8a-4c0b-9ec1-81cc22c00df9</guid><pubDate>Mon, 10 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Luke Jones</dc:creator></item><item><title>Building Alexa Skills in Rust</title><link>https://medium.com/@amalec/building-alexa-skills-in-rust-4cf54a497ea4</link><description><![CDATA[My favorite way to explore Lambdas is to build Alexa skills because of the immediate feedback: you write a little code, and a home device talks to you. It’s a peek into the long promised of world of easy service composition.

Unfortunately, Rust didn’t have complete Alexa skill request/response handling (there is a crate from 2 years ago that handled only the basics), so I wrote one called alexa_sdk. (It’s basically a struct plus serde wrapper around the Alexa JSON spec, with some helpers.]]></description><guid isPermaLink="false">36dce8e1-2508-4e34-8aaf-1eb43a8b17e1</guid><pubDate>Sun,  9 Dec 2018 21:30:38 +0000</pubDate><dc:creator>Arien Malec</dc:creator></item><item><title>Rust 2019 -- Correctness and stabilizations</title><link>https://internals.rust-lang.org/t/rust-2019-correctness-and-stabilizations/8991</link><description><![CDATA[Last year for Rust 2018 I didn’t write a post like this, hoping to see other people write it. But even with a hundred plus posts that didn’t happen, so this year it’s the moment to speak up. I have used many different languages in past and when I started studying Rust at version 1.0 I was quickly impressed by its very good design, I was mostly in agreement with most of its design decisions, despite every useful language has a messy implementation. Even small things were designed with care. And I loved how much Rust cares for code correctness. I prefer to avoid long debug sessions and to use more time in the design and coding phases. So I’ve kept learning and using it ever since. For 2019 and beyond I’d like Rust to keep working on finishing its many unfinished parts.]]></description><guid isPermaLink="false">db72fed1-63a5-41eb-868f-716f694cd52e</guid><pubDate>Sun,  9 Dec 2018 11:38:40 +0000</pubDate><dc:creator>leonardo</dc:creator></item><item><title>Rust 2019 — let us pursue composability</title><link>https://medium.com/@GolDDranks/rust-2019-let-us-pursue-composability-70f1eb2238c3</link><description><![CDATA[We should drive home the goals set in spirit of productivity in 2019. We should also consider composibility as the next overarching theme.]]></description><guid isPermaLink="false">0e733a02-5972-4106-98a7-d0613485cac1</guid><pubDate>Sun,  9 Dec 2018 02:50:51 +0000</pubDate><dc:creator>Pyry Kontio</dc:creator></item><item><title>Rust 2019</title><link>https://vfoley.xyz/rust-2019/</link><description><![CDATA[In 2019, there are three areas where I would like to see the Rust community focus its efforts: Improved compile times, A community effort to review crates, More “80% solutions”.]]></description><guid isPermaLink="false">a02deaa2-0f75-48c6-86ef-f6a314be6355</guid><pubDate>Sun,  9 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Vincent Foley</dc:creator></item><item><title>Inside Rust’s Async Transform</title><link>https://blag.nemo157.com/2018/12/09/inside-rusts-async-transform.html</link><description><![CDATA[As you likely know if you’re reading this post Rust has an upcoming async/await feature being tested in nightly. Because of Rust’s unique features and positioning fully understanding the implementation powering this syntax is very different to understanding other well-known implementations (C# and JavaScript’s being the ones I am familiar with). Instead of thinking of a CPS-like transform where an async function is split into a series of continuations that are chained together via a Future::then method, Rust instead uses a generator/coroutine transform to turn the function into a state machine (C# and probably most JavaScript implementations use a similar transform under the hood, but as far as I’m aware because of the garbage collector these are indistinguishable from the naive CPS transform they are normally described as). For more detail on why Rust is taking this approach you should read eRFC 2033: Experimental Coroutines, that lays out the why’s much better than I could here.

What I’m going to try and provide instead, is a look into how this actually works today. What steps the compiler takes to turn an async fn into a normal function returning a state machine that you could write if you wanted to (but you definitely don’t).]]></description><guid isPermaLink="false">9303577c-bd85-4bfa-9b0c-30685300155c</guid><pubDate>Sun,  9 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Wim Looman</dc:creator></item></channel></rss>