<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/"><channel><title>Read Rust - All Posts</title><link>https://readrust.net/</link><description>All Posts posts on Read Rust</description><item><title>Rust 2020: Private enum variants</title><link>https://www.reddit.com/r/rust/comments/dov6ox/rust_2020_private_enum_variants/</link><description><![CDATA[For the 2021 edition of Rust, I'd like to see private enum variants.]]></description><guid isPermaLink="false">1b2c0d1d-3b43-444e-8755-e8e4a60cb2b7</guid><pubDate>Wed, 30 Oct 2019 00:00:00 +0000</pubDate><dc:creator>u/joshlf_</dc:creator></item><item><title>My Rust 2020 blog post</title><link>https://www.reddit.com/r/rust/comments/dot5pk/my_rust_2020_blog_post/</link><description><![CDATA[The 2019 goals for the Rust project were to finish some old language and library features that have had a lot of design but have not been pushed through the finish line.]]></description><guid isPermaLink="false">86590c31-b27d-4d59-b6d8-23eaae5c3dac</guid><pubDate>Wed, 30 Oct 2019 00:00:00 +0000</pubDate><dc:creator>u/0b_0101_001_1010</dc:creator></item><item><title>A call for blogs 2020</title><link>https://www.reddit.com/r/rust/comments/dorinl/a_call_for_blogs_2020/</link><description><![CDATA[Comments on the call for blog posts in 2020 on Reddit, some of which include 2020 wishes.]]></description><guid isPermaLink="false">a32d1a1c-6453-4222-b0a6-9a7f996f6864</guid><pubDate>Wed, 30 Oct 2019 00:00:00 +0000</pubDate><dc:creator>Commenters on Reddit</dc:creator></item><item><title>A call for blogs 2020</title><link>https://blog.rust-lang.org/2019/10/29/A-call-for-blogs-2020.html</link><description><![CDATA[We are accepting ideas about almost anything having to do with Rust: language features, tooling needs, community programs, ecosystem needs... if it's related to Rust, we want to hear about it.

One big question for this year: will there be a Rust 2021 edition? If so, 2020 would be the year to do a lot of associated work and plan the details. What would the edition's theme be?]]></description><guid isPermaLink="false">9dd9b6b4-1ab5-4421-b806-61594b0f5f98</guid><pubDate>Tue, 29 Oct 2019 00:00:00 +0000</pubDate><dc:creator>The Rust Core Team</dc:creator></item><item><title>Dreadbot: A Discord Bot for Magic The Gathering in Rust</title><link>https://bcarrigan.com/2019/10/28/dreadbot/</link><description><![CDATA[There is a wonderful Magic: The Gathering scene here in Durham, NC. Unfortunately, Magic often deserves the trope that it gets of being an expensive hobby. In order to enjoy the game on a budget, myself and a group of locals created a new format: Paper Dreadful. The format is simple: create a 60 card deck with a maximum of 4 of any card (other than basic lands) and the total cost must be $20 or less on that day. The same rule applies with the sideboard, except it must by $5 or less.

The problem here is that Magic cards change in price all the time. What happens if I build a deck and then a card skyrockets in price?]]></description><guid isPermaLink="false">1ca114e3-a283-4b4c-ae16-4d5966e0ffcf</guid><pubDate>Mon, 28 Oct 2019 12:00:00 +0000</pubDate><dc:creator>Brian Carrigan</dc:creator></item><item><title>A closer look at Ownership in Rust</title><link>https://blog.thoughtram.io/ownership-in-rust/</link><description><![CDATA[In this article we'll take a closer look at Rust's Ownership model and how it manages memory.]]></description><guid isPermaLink="false">f625696c-a751-4e36-8ede-0cd24cf05534</guid><pubDate>Mon, 28 Oct 2019 00:00:00 +0000</pubDate><dc:creator>Pascal Precht</dc:creator></item><item><title>Programming Servo: the incredibly shrinking timer</title><link>https://medium.com/programming-servo/programming-servo-the-incredibly-shrinking-timer-7283ae2a2669</link><description><![CDATA[How to build a timer in Rust in five easy evolutionary steps.]]></description><guid isPermaLink="false">49a2176c-55b0-4603-8f20-d0d15ab56ca4</guid><pubDate>Sun, 27 Oct 2019 15:40:54 +0000</pubDate><dc:creator>Gregory Terzian</dc:creator></item><item><title>Audio Processing for Dummies</title><link>http://adventures.michaelfbryan.com/posts/audio-processing-for-dummies/</link><description><![CDATA[In my spare time I’m an emergency services volunteer, and one of the tasks our unit has is to run the radio network and keep track of what’s happening. This can be a pretty stressful job, especially when there’s lots of radio traffic, and it’s not unusual to miss words or entire transmissions.

To help with a personal project that could make the job easier I’d like to implement a basic component of audio processing, the Noise Gate.]]></description><guid isPermaLink="false">6d1c1c33-6e97-4911-af35-4b6e621da968</guid><pubDate>Sun, 27 Oct 2019 23:34:00 +0800</pubDate><dc:creator>Michael-F-Bryan</dc:creator></item><item><title>Why async fn in traits are hard</title><link>http://smallcultfollowing.com/babysteps/blog/2019/10/26/async-fn-in-traits-are-hard/</link><description><![CDATA[After reading boat’s excellent post on asynchronous destructors, I thought it might be a good idea to write some about async fn in traits. Support for async fn in traits is probably the single most common feature request that I hear about. It’s also one of the more complex topics. So I thought it’d be nice to do a blog post kind of giving the “lay of the land” on that feature – what makes it complicated? What questions remain open?]]></description><guid isPermaLink="false">da517b10-2b8a-4b94-97c3-34b0c049de42</guid><pubDate>Sat, 26 Oct 2019 00:00:00 -0400</pubDate><dc:creator>Niko Matsakis</dc:creator></item><item><title>GNOME+Rust Hackfest #6 in Roma</title><link>https://blog.guillaume-gomez.fr/articles/2019-10-24+GNOME%2BRust+Hackfest+%236+in+Roma</link><description><![CDATA[End of the year, meaning it's time for a new GNOME+Rust hackfest and its feedback!]]></description><guid isPermaLink="false">e9565ca9-50f7-4ed7-9acd-485040d90014</guid><pubDate>Thu, 24 Oct 2019 21:15:00 +0000</pubDate><dc:creator>Guillaume Gomez</dc:creator></item><item><title>Rust+GNOME Hackfest #6</title><link>https://antoyo.ml/rust-gnome-hackfest-rome</link><description><![CDATA[Last week, I went to the sixth Rust+GNOME hackfest which was in Rome. During these hackfests, we work on improving the integration between Rust and the GNOME libraries.]]></description><guid isPermaLink="false">1206f8f5-e2a7-4679-91c3-d79143268a42</guid><pubDate>Thu, 24 Oct 2019 00:00:00 +0000</pubDate><dc:creator>Antoni Boucher</dc:creator></item><item><title>Where rustc spends its time</title><link>https://wiki.alopex.li/WhereRustcSpendsItsTime</link><description><![CDATA[So a couple weeks ago I was a little stung by the quote from This Week In Rust: “Rust compilation is so slow that I can fix the bugs while it still compiles the crates”. On the one hand, I have unfond memories of waiting for a Typescript project to compile, pack (aka link), minify (aka optimize), and so on, over and over, on every change. At least if it had been Rust I’d have been able to fix the bugs while it was doing this. On the other hand, it’s also mostly true: compiling Rust is heckin’ slow. So I’ve decided to dust off a backburner project for a while, and figure out just where rustc spends most of its time.]]></description><guid isPermaLink="false">5babdb55-5061-4e26-b05e-a7c407d03c80</guid><pubDate>Wed, 23 Oct 2019 00:00:00 +1100</pubDate><dc:creator>Simon Heath</dc:creator></item><item><title>Announcing the LLVM ICE-breaker group</title><link>https://blog.rust-lang.org/inside-rust/2019/10/22/LLVM-ICE-breakers.html</link><description><![CDATA[Today I'm announcing a new experiment in the compiler team, the LLVM ICE-breaker group. If you're familiar with LLVM and would like to contribute to rustc -- but without taking on a large commitment -- then the LLVM ICE-breaker group might well be for you!]]></description><guid isPermaLink="false">5a7311d2-3cf3-47fa-bce5-10b0747b30e8</guid><pubDate>Tue, 22 Oct 2019 00:00:00 +0000</pubDate><dc:creator>Niko Matsakis</dc:creator></item><item><title>Getting Started with Rust by Building a Tiny Markdown Compiler</title><link>https://jesselawson.org/rust/getting-started-with-rust-by-building-a-tiny-markdown-compiler/</link><description><![CDATA[My name is Jesse, and this is an introductory Rust tutorial for developers who like learning by doing. The purpose of this tutorial is to develop intuition about toolbuilding in Rust–specifically, to learn how to think and build in Rust. Our goal is to produce a very basic command line compiler that will turn a basic Markdown document containing headings and paragraphs into an html file. To do this, we will start from scratch by building a simple “Hello, World!” executable. Then, over the course of six chapters, iterate and expand until finally we can compile a very simple Markdown file into valid HTML.]]></description><guid isPermaLink="false">8df278c2-e4c1-434b-9dd4-ca1ad1207200</guid><pubDate>Mon, 21 Oct 2019 00:00:00 +0000</pubDate><dc:creator>Jesse Lawson</dc:creator></item><item><title>How to not rewrite it in Rust</title><link>http://adventures.michaelfbryan.com/posts/how-not-to-riir/</link><description><![CDATA[Once you get past the growing pains of the Borrow Checker and realise Rust gives you the power to do things which would be unheard of (or just plain dangerous) in other languages, the temptation to Rewrite it in Rust can be quite strong. However at best, the temptation to RiiR is unproductive (unnecessary duplication of effort), and at worst it can promote the creation of buggy software (why would you be better equipped to write a library for some domain-specific purpose than the original author?]]></description><guid isPermaLink="false">e8d05615-a728-4bea-8f43-400827903e1a</guid><pubDate>Sun, 20 Oct 2019 19:45:00 +0800</pubDate><dc:creator>Michael-F-Bryan</dc:creator></item><item><title>Rust Big Data Benchmarks</title><link>https://andygrove.io/rust_bigdata_benchmarks/</link><description><![CDATA[I have been running benchmarks of aggregate queries against the NYC taxi data set, using Apache Spark (JVM-based) as the baseline, since it is currently a popular tool for distributed compute, and a tool I am familiar with.]]></description><guid isPermaLink="false">59f60adc-9c66-4f8b-9a3a-6ffdcedb14c6</guid><pubDate>Sun, 20 Oct 2019 00:00:00 +0000</pubDate><dc:creator>Andy Grove</dc:creator></item><item><title>I made a NES emulator in Rust using generators</title><link>https://kyle.space/posts/i-made-a-nes-emulator/</link><description><![CDATA[Emulators are cool! They help preserve games, improve games, and help make games more accessible. On top of that, making an emulator is a cathartic and satisfying technical challenge!

So, I took this challenge myself and came out the other end with a pretty limited NES emulator, which I call Lochnes. It’s not very good at actually emulating most games, but I’m pretty happy with the guts of the thing and I learned a lot a long the way. I figured it might be worthwhile to share my approach, which might help or inspire others on their own emulation venture!]]></description><guid isPermaLink="false">394c26b3-924a-43e8-b262-4d8e895ddbcd</guid><pubDate>Sat, 19 Oct 2019 00:00:00 +0000</pubDate><dc:creator>Kyle Lacy</dc:creator></item><item><title>Migrate spirit to version 0.4</title><link>https://vorner.github.io/2019/10/19/migrate-spirit-to-0-4.html</link><description><![CDATA[This post can serve as a step by step migration guide from spirit 0.3 to spirit 0.4. If you already have an application using the crate, read on.

If you haven’t heard about the spirit library yet, it is a library to help you manage your configuration in an application and have it reloaded at runtime. It allows you to have the changes applied automatically and also to manage lifetime of the application. You can read more about it here. In that case, a migration guide won’t help you much, but I’m planning on having a tutorial how to start with the library soon.]]></description><guid isPermaLink="false">8de2bce6-9245-4f95-b12c-ca3e38efb3bb</guid><pubDate>Sat, 19 Oct 2019 00:00:00 +0000</pubDate><dc:creator>Michal &apos;vorner&apos; Vaner</dc:creator></item><item><title>Rust for JavaScript peeps</title><link>https://github.com/yoshuawuyts/rust-for-js-people</link><description><![CDATA[People seem to like Rust a lot! But if you're coming from JavaScript, not everything may make a lot of sense at first. But no problem; this guide is for you! Because I think Rust and JavaScript are really similar in many ways; to the point that if you know JS it's mostly a matter of getting the hang of some of the nuances before you can more or less get the hang of Rust.]]></description><guid isPermaLink="false">44a70495-156b-4de1-8eff-0ef9e334368c</guid><pubDate>Thu, 17 Oct 2019 07:58:16 +0000</pubDate><dc:creator>Yoshua Wuyts</dc:creator></item><item><title>Rotary Encoders in Embedded Rust</title><link>https://leshow.github.io/post/rotary_encoder_hal/</link><description><![CDATA[Recently, I’ve been trying to learn more about electronics and embedded development. Maybe I’m just tired of operating purely in the virtual, but there’s something cool about being able to physically put together a circuit and push a button to make something happen. I went through the usual Arduino resources before seeing what Rust had to offer. I’m happy to report there’s some really good material out there.]]></description><guid isPermaLink="false">307357e3-11d1-4494-9193-4f96e9946978</guid><pubDate>Wed, 16 Oct 2019 20:31:51 -0400</pubDate><dc:creator>Evan Cameron</dc:creator></item><item><title>A Tiny, Static, Full-Text Search Engine using Rust and WebAssembly</title><link>https://endler.dev/2019/tinysearch/</link><description><![CDATA[I wrote a basic search module that you can add to your static website. It's very lightweight (around 50kB-100kB gzipped), should work with Hugo, Zola, and Jekyll. Only searching entire words is supported. Try the search box on the left side for a demo. The code is on Github.]]></description><guid isPermaLink="false">bb944334-6ce6-4bbd-9014-d5b4909db91b</guid><pubDate>Thu, 17 Oct 2019 00:00:00 +0000</pubDate><dc:creator>Matthias Endler</dc:creator></item><item><title>This Month in Raygon 1</title><link>https://github.com/raygon-renderer/readme/blob/master/blogs/month-1.md</link><description><![CDATA[It's been about 51 days since I first announced Raygon, a WIP high-performance CPU path tracer written in the Rust programming language, which will feature state of the art light transport integrators, including path tracing, bidirectional path tracing and VCM.

In this post I'll go over some of the features implemented or improved, and show some recent renders, then talk about the future of Raygon and how you can help.]]></description><guid isPermaLink="false">5d2b3926-5f8e-496f-a438-a26c8ed7dfb7</guid><pubDate>Thu, 17 Oct 2019 00:00:00 +0000</pubDate><dc:creator>Aaron Trent</dc:creator></item><item><title>An intern&apos;s experience with Rust</title><link>https://msrc-blog.microsoft.com/2019/10/16/an-interns-experience-with-rust/</link><description><![CDATA[Over the course of my internship at the Microsoft Security Response Center (MSRC), I worked on the safe systems programming languages (SSPL) team to promote safer languages for systems programming where runtime overhead is important, as outlined in this blog. My job was to port a security critical network processing agent into Rust to eliminate …  An intern’s experience with Rust Read More »]]></description><guid isPermaLink="false">1154694c-7ad8-4ea5-bf37-1c1e4238dc46</guid><pubDate>Wed, 16 Oct 2019 21:26:29 +0000</pubDate><dc:creator>Alexander Clarke</dc:creator></item><item><title>Cost of rust-analyzer</title><link>https://rust-analyzer.github.io/2019/10/16/finance.html</link><description><![CDATA[In this post, we’ll talk about financial side of the rust-analyzer project. The goal is to find out how much rust-analyzer costs now, formulate financial goals for speeding up the development and document the Open Collective expenses policy.]]></description><guid isPermaLink="false">6e9b1816-3105-4847-b96e-d3af713b9ebc</guid><pubDate>Wed, 16 Oct 2019 09:00:00 +0000</pubDate><dc:creator>Aleksey Kladov</dc:creator></item><item><title>Asynchronous Destructors</title><link>https://boats.gitlab.io/blog/post/poll-drop/</link><description><![CDATA[The first version of async/await syntax is in the beta release, set to be shipped to stable in 1.39 on November 7, next month. There are a wide variety of additional features we could add to async/await in Rust beyond what we’re shipping in that release, but speaking for myself I know that I’d like to pump the breaks on pushing forward big ticket items in this space. Let’s let the ecosystem develop around what we have now before we start sprinting toward more big additions to the language.]]></description><guid isPermaLink="false">9b853968-186e-414b-af4a-f4a6cf9e7392</guid><pubDate>Wed, 16 Oct 2019 00:00:00 +0000</pubDate><dc:creator>boats</dc:creator></item><item><title>Learning Rust at Hacktoberfest in 8 hours</title><link>https://medium.com/@knidarkness/learning-rust-at-hacktoberfest-in-8-hours-7b788883c665</link><description><![CDATA[This year’s #hacktoberfest became a great opportunity for me to start learning Rust. In this article, I will share a couple of tricks about how to start mastering this relatively new technology.]]></description><guid isPermaLink="false">b741f301-dd98-4d7c-a82c-486b43242507</guid><pubDate>Tue, 15 Oct 2019 07:42:17 +0000</pubDate><dc:creator>Sergey Dubovyk</dc:creator></item><item><title>Nushell 0.4.0</title><link>http://www.jonathanturner.org/2019/10/nushell-0_4_0.html</link><description><![CDATA[Nushell, or Nu for short, is a new shell that takes a modern, structured approach to your commandline. It works seamlessly with the data from your filesystem, operating system, and a growing number of file formats to make it easy to build powerful commandline pipelines.

Today we’re happy to announce the 0.4.0 release of Nushell. The 0.4.0 release marks a continually maturing shell that is now starting to show signs of stability. And, of course, a few fun features along the way.]]></description><guid isPermaLink="false">1f048104-e5be-49df-9def-c7b4de0d5478</guid><pubDate>Tue, 15 Oct 2019 00:00:00 +0000</pubDate><dc:creator>Jonathan Turner</dc:creator></item><item><title>Announcing Rustup 1.20.0</title><link>https://blog.rust-lang.org/2019/10/15/Rustup-1.20.0.html</link><description><![CDATA[The highlights of this release are profiles support, the ability to get the latest available nightly with all the components you need, and improvements to the rustup doc command. You can also check out the changelog for a list of all the changes included in this release.]]></description><guid isPermaLink="false">8629a67f-d7a6-41e9-80b1-e568f491c325</guid><pubDate>Tue, 15 Oct 2019 00:00:00 +0000</pubDate><dc:creator>The Rustup Working Group</dc:creator></item><item><title>Ruffle: an Adobe Flash Player emulator written in the Rust</title><link>https://github.com/ruffle-rs/ruffle/blob/master/README.md</link><description><![CDATA[Ruffle is an Adobe Flash Player emulator written in the Rust programming language. Ruffle targets both the desktop and the web using WebAssembly.]]></description><guid isPermaLink="false">15a21264-f2eb-4d31-8f58-700f2382b9e8</guid><pubDate>Tue, 15 Oct 2019 00:00:00 +0000</pubDate><dc:creator>Mike Welsh</dc:creator></item><item><title>Watt: A runtime for executing Rust procedural macros compiled as WebAssembly</title><link>https://github.com/dtolnay/watt</link><description><![CDATA[ By compiling macros ahead-of-time to Wasm, we save all downstream users of the macro from having to compile the macro logic or its dependencies themselves. Instead, what they compile is a small self-contained Wasm runtime (~3 seconds, shared by all macros) and a tiny proc macro shim for each macro crate to hand off Wasm bytecode into the Watt runtime (~0.3 seconds per proc-macro crate you depend on). This is much less than the 20+ seconds it can take to compile complex procedural macros and their dependencies.]]></description><guid isPermaLink="false">f33cd82d-46fa-4e3e-97e9-0bef43ba9b00</guid><pubDate>Tue, 15 Oct 2019 00:00:00 +0000</pubDate><dc:creator>David Tolnay</dc:creator></item><item><title>Detecting Application Uniqueness and interprocess communication in Rust</title><link>https://gitlab.com/snippets/1903637</link><description><![CDATA[The aim of this article is to demonstrate one of many ways to detect application uniqueness and establish unilateral interprocess communication in Rust in the Linux platform. Note that the APIs used in this article is not portable to Windows and other *nix systems. Also note that methods used in this article may not be best suitable for all use cases.]]></description><guid isPermaLink="false">8b2ade3b-1476-4770-a7e2-838c3623a381</guid><pubDate>Mon, 14 Oct 2019 00:00:00 +0000</pubDate><dc:creator>9898287</dc:creator></item><item><title>Making the Tokio scheduler 10x faster</title><link>https://tokio.rs/blog/2019-10-scheduler/</link><description><![CDATA[We’ve been hard at work on the next major revision of Tokio, Rust’s asynchronous runtime. Today, a complete rewrite of the scheduler has been submitted as a pull request. The result is huge performance and latency improvements. Some benchmarks saw a 10x speed up! It is always unclear how much these kinds of improvements impact “full stack” use cases, so we’ve also tested how these scheduler improvements impacted use cases like Hyper and Tonic (spoiler: it’s really good).]]></description><guid isPermaLink="false">97ca4165-4f8c-4c57-872d-e5986df0c7ee</guid><pubDate>Sun, 13 Oct 2019 00:00:00 +0000</pubDate><dc:creator>Carl Lerche</dc:creator></item><item><title>Persy transactional storage engine version 0.7</title><link>https://persy.rs/posts/persy-0.7.html</link><description><![CDATA[In the last couple of months just right after the release of Persy 0.6 the development speeded up a bit, a few people started to play with persy and some downstream projects as well, first reporting few critical issue that produced the 3 hotfix 0.6.1,0.6.2,0.6.3 and then starting contributing back.]]></description><guid isPermaLink="false">22724643-a42b-447d-98e2-6d7d3ad56aed</guid><pubDate>Fri, 11 Oct 2019 07:23:00 +0000</pubDate><dc:creator>tglman</dc:creator></item><item><title>How to speed up the Rust compiler some more in 2019</title><link>https://blog.mozilla.org/nnethercote/2019/10/11/how-to-speed-up-the-rust-compiler-some-more-in-2019/</link><description><![CDATA[In July I wrote about my efforts to speed up the Rust compiler in 2019. I also described how the Rust compiler has gotten faster in 2019, with compile time reductions of 20-50% on most benchmarks. Now that Q3 is finished it’s a good time to see how things have changed since then.]]></description><guid isPermaLink="false">67d3364b-64e1-4c9e-bf5c-93ed324c8f4a</guid><pubDate>Thu, 10 Oct 2019 23:01:52 +0000</pubDate><dc:creator>Nicholas Nethercote</dc:creator></item><item><title>Mun Programming Language</title><link>https://mun-lang.org/</link><description><![CDATA[The idea to create Mun originated out of frustration with the Lua dynamic scripting language that is extensively used for game development at Abbey Games.

Lua's hot reloading capabilities and LuaJIT's performance make it a great language for rapid prototyping of real-time applications - such as games - on PC. However, the language has performance issues on some mobile and console platforms - to which LuaJIT cannot deploy, the language lacks refactoring functionality, and does not scale well with modern technology.

Mun tries to take the best of both worlds to create a more robust, highly iterative, productive, and performant programming language.]]></description><guid isPermaLink="false">0932500c-62e0-4379-9e09-eb5ed61d826a</guid><pubDate>Thu, 10 Oct 2019 06:38:30 +0000</pubDate><dc:creator>Mun Developers</dc:creator></item><item><title>We couldn&apos;t get Bitcode and Rust to play nice, until we did</title><link>https://www.ditto.live/blog/rust-bitcode-with-xcode</link><description><![CDATA[The Rust compiler has problems creating Bitcode that's compatible with recent versions of Xcode. Ditto uses a custom toolchain that stays in sync with Apple—and you can too.]]></description><guid isPermaLink="false">dabffd4d-73ef-4700-8711-b648230659b9</guid><pubDate>Thu, 10 Oct 2019 00:00:00 +0000</pubDate><dc:creator>Tom Karpiniec</dc:creator></item><item><title>OxidizeBot - The high octane Twitch bot</title><link>https://setbac.tv/</link><description><![CDATA[OxidizeBot as an open source Twitch Bot empowering you to focus on what's important. It allows for a richer interaction between you and your chat. From a song request system, to groundbreaking game modes where your viewers can interact directly with you and your game.]]></description><guid isPermaLink="false">ab31d896-cb5c-40a9-bb9f-a496a672239b</guid><pubDate>Thu, 10 Oct 2019 00:00:00 +0000</pubDate><dc:creator>John-John Tedro</dc:creator></item><item><title>The Node Experiment - Exploring Async Basics with Rust</title><link>https://cfsamson.github.io/book-exploring-async-basics/</link><description><![CDATA[After originally researching the history and discussions about Rusts Async story, I realized I needed a better understanding of async basics and the result is this book. It's published it as a gitbook to make this journey easier for the next person (hopefully).]]></description><guid isPermaLink="false">e131911e-9ccb-4b6f-9c05-f95611cb66d2</guid><pubDate>Thu, 10 Oct 2019 00:00:00 +0000</pubDate><dc:creator>Carl Fredrik Samson</dc:creator></item><item><title>How I handle errors in Rust</title><link>https://blog.kiani.io/blog/how-i-handle-errors-in-rust/</link><description><![CDATA[derive_more is a crate which has many proc macros, amongst which is a macro for deriving From for structs, enums, and newtypes. From is the basic mechanism for using ? ergonomically in a function which returns Result<T, Error>. Almost everything I write has the derive_more crate as a dependency, and the following pattern for handling errors.]]></description><guid isPermaLink="false">79f41426-ad58-4eac-9adb-88b27c2a63ba</guid><pubDate>Wed,  9 Oct 2019 00:00:00 +0000</pubDate><dc:creator>Ashkan Kiani</dc:creator></item><item><title>Designing a COM library for Rust</title><link>https://msrc-blog.microsoft.com/2019/10/08/designing-a-com-library-for-rust/</link><description><![CDATA[I interned with Microsoft as a Software Engineering Intern in the MSRC UK team in Cheltenham this past summer. I worked in the Safe Systems Programming Language (SSPL) group, which explores safe programming languages as a proactive measure against memory-safety related vulnerabilities.

This blog post describes the project that I have been working on under the mentorship of the SSPL team. Hopefully, this provides additional insight into the work Microsoft interns do! My goal was to build an open-sourced Rust library that will allow developers to both consume and produce in-process Component Object Model (COM) components in an idiomatic manner.]]></description><guid isPermaLink="false">409c73c3-8c32-4c3a-97a9-30f700237fe8</guid><pubDate>Tue,  8 Oct 2019 17:00:03 +0000</pubDate><dc:creator>Hadrian Wei Heng Lim</dc:creator></item><item><title>Dev Time Optimization -- Part 1 (1.9x speedup, 65% less disk usage)</title><link>https://azriel.im/will/2019/10/08/dev-time-optimization-part-1-1.9x-speedup-65-less-disk-usage/</link><description><![CDATA[Summary In a 45k LOC / 102-crate workspace, moving tests from member crates into a single workspace_tests crate achieved the following improvements:

Build and test duration in release mode reduced from 23 minutes to 13 minutes . Debug artifact disk usage reduced from 20 G to 7 G (65% reduction, fresh build), or 230 G to 50 G (78% reduction, ongoing development)  Background The rate of software development is affected by many limits.]]></description><guid isPermaLink="false">9058ab44-792b-4652-a06a-db4ada3e0ff5</guid><pubDate>Tue,  8 Oct 2019 13:10:38 +1300</pubDate><dc:creator>Azriel Hoh</dc:creator></item><item><title>reqwest alpha.await</title><link>https://seanmonstar.com/post/188220739932/reqwest-alphaawait</link><description><![CDATA[reqwest alpha.await reqwest is a higher-level HTTP client for Rust. I’m delighted to announce the first alpha release that brings async/await support!]]></description><guid isPermaLink="false">33fc22f5-6021-4395-b8ab-7f5f25ec2384</guid><pubDate>Tue,  8 Oct 2019 00:00:00 +0000</pubDate><dc:creator>Sean McArthur</dc:creator></item><item><title>Riker - a framework for building modern, concurrent and resilient systems using the Rust language using the actor model</title><link>https://riker.rs/</link><description><![CDATA[Riker is a framework for building modern, concurrent and resilient systems using the Rust language. Riker aims to make working with state and behavior in concurrent systems as easy and scalable as possible. The Actor Model has been chosen to realize this because of the familiar and inherent simplicity it provides while also providing strong guarantees that are easy to reason about. The Actor Model also provides a firm foundation for resilient systems through the use of the actor hierarchy and actor supervision.]]></description><guid isPermaLink="false">3fc0a35d-5eab-4143-98d5-7325738364e4</guid><pubDate>Tue,  8 Oct 2019 00:00:00 +0000</pubDate><dc:creator>Riker</dc:creator></item><item><title>Why we’re bringing Astropad cross-platform with Rust</title><link>https://blog.astropad.com/why-rust/</link><description><![CDATA[Over the past few years, we’ve heard over and over again about an exodus from Mac to Windows in the creative community. Here at Astropad, we’ve kept a close eye on this shift, knowing that Windows would be a big part of our company’s future. Our flagship products — Astropad Studio and Luna Display — primarily serve the creative pro market. Both products run on our low-latency, high-fidelity video streaming technology called Liquid that was designed to meet the demands of professional illustrators, animators, and photographers.

When we were first building our products, we used the tools we were most comfortable with, like Objective-C and the Cocoa APIs. This allowed us to move quickly, launch Astropad 1.0, and establish product-market fit in a relatively short period of time. But as we grew, we made the mistake of doubling down on Objective-C, and we pushed off the Windows effort because it created a catch-22 situation of engineering hurdles. Our Liquid engine was tightly wrapped around the Apple ecosystem, and the thought of unraveling ourselves was hard to imagine. ]]></description><guid isPermaLink="false">6907953b-62d5-475e-8695-0e89fec37b5e</guid><pubDate>Mon,  7 Oct 2019 19:23:43 +0000</pubDate><dc:creator>Matt Ronge</dc:creator></item><item><title>Coding nRF52 with Rust and Apache Mynewt on Visual Studio Code</title><link>https://medium.com/@ly.lee/coding-nrf52-with-rust-and-apache-mynewt-on-visual-studio-code-9521bcba6004</link><description><![CDATA[The nRF52 Microcontroller by Nordic Semiconductor is an awesome gadget with powerful Bluetooth Low Energy networking capability. It’s affordable too… For under $8, I can buy an EBYTE E73-TBB Development Board with onboard nRF52. Powered by an Arm Cortex-M4 CPU (hardware floating-point) with 64 KB of RAM and 512 KB of Flash ROM, the nRF52 has plenty of capacity to run modern embedded platforms… Like Apache Mynewt realtime OS and Embedded Rust!]]></description><guid isPermaLink="false">e808921f-a270-4d4b-a897-d856dbd4a5ab</guid><pubDate>Mon,  7 Oct 2019 12:15:40 +0000</pubDate><dc:creator>Lup Yuen Lee</dc:creator></item><item><title>mda-rs: Custom Mail Delivery Agents in Rust</title><link>https://afrantzis.com/posts/mda-rs/</link><description><![CDATA[With mda-rs I wanted to create an experience as close as possible to using an interpreted domain specific language, the approach follow by typical MDAs, while still having the performance and power of a full, compiled language at the fingertips. One aspect of this experience was providing an API that feels like natural fit for the intended purpose. The other aspect was providing a straightforward way to build a custom MDA. For this second aspect, the simplicity of Rust's cargo was one of the reasons I decided to use Rust for this project.]]></description><guid isPermaLink="false">10dac43f-1aba-416e-bfbb-190a33ad2c5d</guid><pubDate>Mon,  7 Oct 2019 00:00:00 +0000</pubDate><dc:creator>Alexandros Frantzis</dc:creator></item><item><title>Async Foundations Update: Time for polish!</title><link>https://blog.rust-lang.org/inside-rust/2019/10/07/AsyncAwait-WG-Focus-Issues.html</link><description><![CDATA[As you've perhaps heard, recently the async-await feature landed on the Rust beta branch. This marks a big turning point in the usability story for Async Rust. But there's still a lot of work to do. As we mentioned in the main post, the focus for the Async Foundations WG in the immediate term is going to be polish, polish and (ahem) more polish.

In particular, we want to take aim at a backlog of strange diagnostics, suboptimal performance, and the occasional inexplicable type-check failure. This is a shift: whereas before, we could have laser focus on things that truly blocked stabilization, we've now got a large set of bugs, often without a clear prioritization between them. This requires us to mix up how the Async Foundations WG is operating.]]></description><guid isPermaLink="false">15c5520b-d7f9-4acc-939f-371cb8fbab95</guid><pubDate>Mon,  7 Oct 2019 00:00:00 +0000</pubDate><dc:creator>Niko Matsakis</dc:creator></item><item><title>Spotify TUI: Spotify for the terminal written in Rust</title><link>https://github.com/Rigellute/spotify-tui</link><description><![CDATA[Spotify TUI: Spotify for the terminal written in Rust.]]></description><guid isPermaLink="false">6597a1f3-2858-46de-ab2b-fb2c639759b5</guid><pubDate>Mon,  7 Oct 2019 00:00:00 +0000</pubDate><dc:creator>Alexander Keliris</dc:creator></item><item><title>Rust on the Sipeed Longan Nano, an inexpensive RISC-V dev board</title><link>https://pramode.in/2019/10/07/rust-on-riscv-board-sipeed-longan-nano/</link><description><![CDATA[The Sipeed Longan Nano is a $5 development board based on a new RISC-V processor from Gigadevices. The processor and the dev board are properly documented in English. If you are a RISC-V enthusiast, I believe this is the best option you have at the moment for learning and experimentation. I was able to run Rust code on this board by making small changes to the riscv/rust PicoSoc example.]]></description><guid isPermaLink="false">66b4c1e7-68e4-4006-bdb8-f53129822773</guid><pubDate>Mon,  7 Oct 2019 00:00:00 +0000</pubDate><dc:creator>Pramode C.E</dc:creator></item><item><title>Announcing Bastion 0.2.0!</title><link>https://www.reddit.com/r/rust/comments/day85g/announcing_bastion_020/</link><description><![CDATA[Bastion is a fault-tolerant runtime for Rust applications. After receiving plenty of good feedback from the community and a long-running development stage, now Bastion is 0.2.0!]]></description><guid isPermaLink="false">b2b15138-1280-44d7-95a0-9e5954a14b9a</guid><pubDate>Sun,  6 Oct 2019 04:16:30 +0000</pubDate><dc:creator>Mahmut Bulut</dc:creator></item><item><title>LDraw.rs: A library for reading and writing Lego model files for native and web</title><link>https://github.com/segfault87/ldraw.rs</link><description><![CDATA[A library for reading and writing LDraw model files and rendering the model using OpenGL for both native and web!]]></description><guid isPermaLink="false">5f7c6828-7321-4f85-8d17-e80a4c0a44ad</guid><pubDate>Sun,  6 Oct 2019 00:00:00 +0000</pubDate><dc:creator>Park Joon-Kyu</dc:creator></item><item><title>The &quot;Inside Rust&quot; Blog</title><link>https://blog.rust-lang.org/inside-rust/</link><description><![CDATA[This is the "Inside Rust" blog. This blog is aimed at those who wish to follow along with Rust development. The various Rust teams and working groups use this blog to post status updates, calls for help, and other similar announcements.]]></description><guid isPermaLink="false">55e7a635-29bd-4a2d-aaac-b0d599006ff7</guid><pubDate>Fri,  4 Oct 2019 01:18:00 +0000</pubDate><dc:creator>Niko Matsakis</dc:creator></item><item><title>The Embedded Working Group Newsletter - 19</title><link>https://rust-embedded.github.io/blog/newsletter-19/</link><description><![CDATA[This is the 19th newsletter of the Embedded WG where we highlight new progress, celebrate cool projects, thank the community, and advertise projects that need help!]]></description><guid isPermaLink="false">230003fc-89e8-4108-97d1-45f2d8b30dd8</guid><pubDate>Thu,  3 Oct 2019 00:00:00 +0000</pubDate><dc:creator>The Embedded Working Group</dc:creator></item><item><title>Roguelike Tutorial: Up-to-date and Literate</title><link>https://aimlesslygoingforward.com/blog/2019/10/02/roguelike-tutorial-up-to-date-and-literate/</link><description><![CDATA[This tutorial will show you how to write a roguelike in the Rust programming language and the libtcod library. In this update the Asciidoctor documents were changed to allow generating the final source files at the end of each chapter directly from the tutorial text.]]></description><guid isPermaLink="false">e3c786d5-955b-422a-b426-fcc3639d92c3</guid><pubDate>Wed,  2 Oct 2019 00:00:00 +0000</pubDate><dc:creator>Tomas Sedovic</dc:creator></item><item><title>Static Assertions 1.0</title><link>https://nikolaivazquez.com/posts/programming/rust-static-assertions-1_0/</link><description><![CDATA[static_assertions is a library designed to enable users to perform various checks at compile-time. It allows for finding errors quickly and early when it comes to ensuring certain features or aspects of a codebase. The macros it provides are especially important when exposing a public API that requires types to be the same size or implement certain traits.]]></description><guid isPermaLink="false">e2d3a9d7-cc8b-4cd5-8d5b-3bb986487601</guid><pubDate>Wed,  2 Oct 2019 00:00:00 +0000</pubDate><dc:creator>Nikolai Vazquez</dc:creator></item><item><title>Happy First Birthday, Ferrous!</title><link>https://ferrous-systems.com/blog/happy-birthday-ferrous/</link><description><![CDATA[Ferrous Systems GmbH was fully incorporated in Berlin, on October 1st, 2018; which makes today Ferrous' first birthday! It's been a busy year (or really more than a year) for us, full of ups, downs, growth, challenges, stress, and opportunities, and it finally feels like the right time to write a bit more about it from a personal perspective.]]></description><guid isPermaLink="false">b909cef2-cf3b-4db8-b567-c230036a7adf</guid><pubDate>Tue,  1 Oct 2019 00:00:00 +0000</pubDate><dc:creator>James Munns</dc:creator></item><item><title>Project update</title><link>https://gfx-rs.github.io/2019/10/01/update.html</link><description><![CDATA[gfx-rs is a Rust project aiming to make low-level GPU programming portable with low overhead. It’s a single Vulkan-like Rust API with multiple backends that implement it: Direct3D 12/11, Metal, Vulkan, and even OpenGL. wgpu-rs is a Rust project on top of gfx-rs that provides safety, accessibility, and even stronger portability. This is an update that is not aligned to any dates or releases. We just want to share about some of the exciting work that landed recently, which will make it to the next release cycle.]]></description><guid isPermaLink="false">17460b05-a9d9-4c79-801c-2a2e54c5132f</guid><pubDate>Tue,  1 Oct 2019 00:00:00 +0000</pubDate><dc:creator>gfx-rs</dc:creator></item><item><title>Building the Azure IoT Edge Security Daemon in Rust</title><link>https://msrc-blog.microsoft.com/2019/09/30/building-the-azure-iot-edge-security-daemon-in-rust/</link><description><![CDATA[Azure IoT Edge is an open source, cross platform software project from the Azure IoT team at Microsoft that seeks to solve the problem of managing distribution of compute to the edge of your on-premise network from the cloud. This post explains some of the rationale behind our choice of Rust as the implementation programming language for the Security Daemon component in the product.]]></description><guid isPermaLink="false">f7d6bffe-ea86-4fbc-9aa6-4ba15b3929a5</guid><pubDate>Mon, 30 Sep 2019 16:45:48 +0000</pubDate><dc:creator>Raj Vengalil</dc:creator></item><item><title>Plugins in Rust</title><link>http://adventures.michaelfbryan.com/posts/plugins-in-rust/</link><description><![CDATA[Imagine you are implementing a calculator application and want users to be able to extend the application with their own functionality. For example, imagine a user wants to provide a random() function that generates true random numbers using random.org instead of the pseudo-random numbers that a crate like rand would provide.

The Rust language gives you a lot of really powerful tools for adding flexibility and extensibility to your applications (e.g. traits, enums, macros), but all of these happen at compile time. Unfortunately, to get the flexibility that we’re looking we’ll need to be able to add new functionalty at runtime. This can be achieved using a technique called Dynamic Loading.]]></description><guid isPermaLink="false">7a86a452-ec34-4489-b209-f91aecdd6d98</guid><pubDate>Mon, 30 Sep 2019 22:04:58 +0800</pubDate><dc:creator>Michael-F-Bryan</dc:creator></item><item><title>Async-await hits beta!</title><link>https://blog.rust-lang.org/2019/09/30/Async-await-hits-beta.html</link><description><![CDATA[Big news! As of this writing, syntactic support for async-await is available in the Rust beta channel! It will be available in the 1.39 release, which is expected to be released on November 7th, 2019. Once async-await hits stable, that will mark the culmination of a multi-year effort to enable efficient and ergonomic asynchronous I/O in Rust. It will not, however, mark the end of the road: there is still more work to do, both in terms of polish (some of the error messages we get today are, um, not great) and in terms of feature set (async fn in traits, anyone?).]]></description><guid isPermaLink="false">fbf09d15-52c8-4ab6-a6bf-22c0b238aedb</guid><pubDate>Mon, 30 Sep 2019 00:00:00 +0000</pubDate><dc:creator>Niko Matsakis</dc:creator></item><item><title>Figthting The Async Fragmentation</title><link>https://vorner.github.io/2019/09/29/figthting-the-async-fragmentation.html</link><description><![CDATA[Sometimes, I get this nudging feeling that something is not exactly right and that I have to go out and save the world and fix it (even though it’s usually something minor or doesn’t need fixing at all). I guess everyone has days like these. It’s part what drives me to invest my free time to writing software.

This is about some dead ends when trying to fix the problem of Rust’s async networking fragmentation. I haven’t been successful, but I can at least share what I tried and discovered, maybe someone else is having the same bugging feeling so they don’t have to repeat them. Or just maybe some of the approaches would work for some other problems. And because we have a bunch of success stories out there, having some failure stories to balance it doesn’t hurt.]]></description><guid isPermaLink="false">51a1a155-fccb-426f-b0e5-f4670be28e9d</guid><pubDate>Sun, 29 Sep 2019 00:00:00 +0000</pubDate><dc:creator>Michal &apos;vorner&apos; Vaner</dc:creator></item><item><title>Binary Format Shootout</title><link>https://speice.io/2019/09/binary-format-shootout.html</link><description><![CDATA[Cap'n Proto vs. Flatbuffers vs. Simple Binary Encoding]]></description><guid isPermaLink="false">87600fb3-40d3-403e-87b7-25a3a2eacdcf</guid><pubDate>Sat, 28 Sep 2019 00:00:00 +0000</pubDate><dc:creator>Bradlee Speice</dc:creator></item><item><title>Sample REST API in Rust and Go</title><link>https://jmmv.dev/2019/09/rest-api-rust-go.html</link><description><![CDATA[Over the summer, I prototyped a bunch of web apps whose ideas had been floating in my mind for a long time. I spent quite a bit of time learning about REST APIs and, as part of these exercises, implemented skeletons of REST servers in both Go and Rust. The app prototypes have gone nowhere but I thought of sharing the skeletons I built if only to serve as templates for myself in future work. Thus, in this post, I will cover these skeleton demos and I will compare them.]]></description><guid isPermaLink="false">dcbe1901-b9b1-4eec-a44e-d6be0dcdd958</guid><pubDate>Fri, 27 Sep 2019 06:45:40 +0500</pubDate><dc:creator>Julio Merino</dc:creator></item><item><title>Making a RISC-V Operating System using Rust</title><link>http://osblog.stephenmarz.com/index.html</link><description><![CDATA[ RISC-V ("risk five") and the Rust programming language both start with an R, so naturally they fit together. In this blog, we will write an operating system targeting the RISC-V architecture in Rust (mostly). If you have a sane development environment for RISC-V, you can skip the setup parts right to bootloading. Otherwise, it'll be fairly difficult to get started.

This tutorial will progressively build an operating system from start to something that you can show your friends or parents -- if they're significantly young enough. Since I'm rather new at this I decided to make it a "feature" that each blog post will mature as time goes on. More details will be added and some will be clarified.]]></description><guid isPermaLink="false">6712ac58-9b5c-43de-bcf5-79548cb8c59d</guid><pubDate>Thu, 26 Sep 2019 00:00:00 +0000</pubDate><dc:creator>Stephen Marz</dc:creator></item><item><title>Announcing Rust 1.38.0</title><link>https://blog.rust-lang.org/2019/09/26/Rust-1.38.0.html</link><description><![CDATA[The highlight of this release is pipelined compilation. The release also includes linting of some incorrect uses of mem::{uninitialized, zeroed}, #[deprecated] macros, std::any::type_name, and more.]]></description><guid isPermaLink="false">d9b796b1-aacb-4a2f-ad7b-05ce22cc3ec1</guid><pubDate>Thu, 26 Sep 2019 00:00:00 +0000</pubDate><dc:creator>The Rust Release Team</dc:creator></item><item><title>Nushell 0.3.0</title><link>http://www.jonathanturner.org/2019/09/nushell_0_3_0.html</link><description><![CDATA[Nushell, or Nu for short, is a new shell that takes a modern, structured approach to your commandline. It works seamlessly with the data from your filesystem, operating system, and a growing number of file formats to make it easy to build powerful commandline pipelines. We’re happy to announce that today we’re releasing Nushell 0.3.0. Nu has seen numerous bugfixes, performance improvements, and features added since its initial public release (which was only a few weeks ago!)]]></description><guid isPermaLink="false">f449d35d-98c7-4460-9d42-d6641415e542</guid><pubDate>Tue, 24 Sep 2019 00:00:00 +0000</pubDate><dc:creator>Jonathan Turner</dc:creator></item><item><title>Build an NB-IoT GPS Tracker on STM32 L476 with Apache Mynewt and Embedded Rust</title><link>https://medium.com/@ly.lee/build-an-nb-iot-gps-tracker-on-stm32-l476-with-apache-mynewt-and-embedded-rust-8c095a925546</link><description><![CDATA[Let’s build an NB-IoT GPS Tracker! A simple gadget that determines its current location based on received GPS signals… And transmits the location to a server via NB-IoT. We shall take an existing Apache Mynewt Embedded OS + Embedded Rust project from the article “Rust Rocks NB-IoT! STM32 Blue Pill with Quectel BC95-G on Apache Mynewt”… And extend it with a GPS module: Quectel L70-R.]]></description><guid isPermaLink="false">c793ec07-09a1-4b5d-b3e6-f8b146178fbc</guid><pubDate>Sun, 22 Sep 2019 12:24:41 +0000</pubDate><dc:creator>Lup Yuen Lee</dc:creator></item><item><title>Async Builders</title><link>https://blog.yoshuawuyts.com/async-finalizers/</link><description><![CDATA[Last month we introduced Surf, an async cross-platform streaming HTTP client for Rust. It was met with a great reception, and people generally seem to be really enjoying it. A common piece of feedback we've gotten is how much people enjoy the interface, in particular how little code it requires to create HTTP requests. In this post we'll cover a pattern at the heart of Surf's ergonomics stjepang came up with: the "async finalizer".]]></description><guid isPermaLink="false">258e95ec-03a2-47b2-b577-cf45ad96924e</guid><pubDate>Sat, 21 Sep 2019 00:00:00 +0000</pubDate><dc:creator>Yoshua Wuyts</dc:creator></item><item><title>Of bitpacking, with or without SSE3</title><link>https://fulmicoton.com/posts/bitpacking/</link><description><![CDATA[This blog post might interest three type of readers: people interested in tantivy: You’ll learn how tantivy uses SIMD instructions to decode posting lists, and what happens on platform where the relevant instruction set is not available.  rustaceans who would like to hear a good SIMD in rust story. lucene core devs (yeah it is a very select club) who might be interested in a possible (unconfirmed) optimization opportunity.]]></description><guid isPermaLink="false">d7a12b5f-ab52-4e4b-b752-7d857e9f86bf</guid><pubDate>Fri, 20 Sep 2019 00:00:00 +0000</pubDate><dc:creator>Paul Masurel</dc:creator></item><item><title>Rust on the ESP32</title><link>https://mabez.dev/blog/posts/esp32-rust/</link><description><![CDATA[In March of 2019, Espressif released their first run at an llvm fork to support the xtensa architecure. Shortly after I got to work bootstrapping Rust to use this newly created fork. Prior to this project, I'd had no experience with the compiler, fortunately I came across the RISCV PR which gave me a rough idea of what was required. After many build attempts I finally got it working; I was now able to generate xtensa assembly from Rust source code!]]></description><guid isPermaLink="false">abac05ba-47c5-4454-8363-2f823ff9c573</guid><pubDate>Tue, 10 Sep 2019 00:00:00 +0000</pubDate><dc:creator>Scott Mabin</dc:creator></item><item><title>Writing Linux Kernel Module in Rust</title><link>https://github.com/lizhuohua/linux-kernel-module-rust</link><description><![CDATA[We designed a framework to help developers to quickly build device drivers in Rust. We also utilized Rust’s security features to provide several useful infrastructures for developers so that they can easily handle kernel memory allocation and concurrency management, at the same time, some common bugs (e.g. use-after-free) can be alleviated.

We demonstrate the generality of our framework by implementing a real-world device driver on Raspberry Pi 3, and our evaluation shows that device drivers generated by our framework have acceptable binary size for canonical embedded systems and the runtime overhead is negligible.]]></description><guid isPermaLink="false">8ae2d3d4-bbd0-4e9b-8bb8-f1ff4703b0cf</guid><pubDate>Mon,  9 Sep 2019 06:31:16 +0000</pubDate><dc:creator>Li Zhuohua</dc:creator></item><item><title>Improvement to the compile time of a crate</title><link>http://antoyo.ml/compilation-time-dependencies</link><description><![CDATA[For one of my projects, I need to use LLVM so I tried this cool inkwell crate that provides a mostly safe wrapper over LLVM. To my dismay, though, compiling this crate takes… a lot of time: Debug build: 1m 05s Release build: 3m 34s. By the way, I write this article for the sole purpose of trying to fix some problems there is in the crate ecosystem and by no mean I want to incriminate the author of this crate (or any other). I’ve been guilty of doing the same mistakes, but I learned from them and want other people to learn from them as well.]]></description><guid isPermaLink="false">a8b46d95-5e16-4348-abfe-b54bc46da590</guid><pubDate>Sat,  7 Sep 2019 00:00:00 +0000</pubDate><dc:creator>Antoni Boucher</dc:creator></item><item><title>Linux.Fe2O3: a Rust virus</title><link>https://www.guitmz.com/linux-fe2o3-rust-virus/</link><description><![CDATA[Everytime I try to learn a new programming language, I try by port my prependers (Linux.Zariche, Linux.Liora, Linux.Cephei). Despite the code simplicity , it gives me the chance to understand very useful things in a language, like error handling, file i/o, encryption, memory and a few of its core libraries.

This time, Rust is the language and I must say that I was impressed by its compiler and error handling, but the syntax is still not 100% clear to me (as you can see from my rudimentar code in Linux.Fe2O3) and I wish it had a built-in random library too. This code was written in less than 2 days, of course its not pretty, has lots of .unwrap() (already got great input from some people on Reddit to help me with that, will be addressed) so I apologise in advance.]]></description><guid isPermaLink="false">5e44948a-fa5d-4dbb-a7e7-7e4838fbaa80</guid><pubDate>Fri,  6 Sep 2019 13:35:51 +0000</pubDate><dc:creator>Guilherme Thomazi</dc:creator></item><item><title>We want smaller, faster, more secure native apps</title><link>https://medium.com/tauri-apps/we-want-smaller-faster-more-secure-native-apps-77222f590c64</link><description><![CDATA[Introducing Tauri-Apps, an open-source project to help you make native apps with any framework with the power of Rust.]]></description><guid isPermaLink="false">e2f780ad-41db-499a-999c-321f0e8f556e</guid><pubDate>Thu,  5 Sep 2019 20:57:20 +0000</pubDate><dc:creator>nothingismagick</dc:creator></item><item><title>Low Power NB-IoT on STM32 Blue Pill with Apache Mynewt and Embedded Rust</title><link>https://medium.com/@ly.lee/low-power-nb-iot-on-stm32-blue-pill-with-apache-mynewt-and-embedded-rust-cef5a3ecdd90</link><description><![CDATA[In this article we’ll learn to optimise the power consumption of the NB-IoT Sensor Application in the previous tutorial from this jagged power-hungry mess… To these well-disciplined bars… It’s a simple application (coded in Embedded Rust) that polls Blue Pill’s internal temperature sensor and transmits the sensor data to a server over NB-IoT.]]></description><guid isPermaLink="false">695ee455-42ad-432f-88a0-00deb73361d3</guid><pubDate>Wed,  4 Sep 2019 01:25:15 +0000</pubDate><dc:creator>Lup Yuen Lee</dc:creator></item><item><title>Adventures in Motion Control: Top-Level Infrastructure</title><link>http://adventures.michaelfbryan.com/posts/top-level-infrastructure/</link><description><![CDATA[Most embedded systems will implement multi-tasking by rapidly polling each system within an infinite loop. A motion controller will normally spend most of its time polling, but there are places where polling isn’t appropriate. For example, accurate movement of a stepper motor relies on sending pulses at very precise times. Another scenario is in the handling of communication, where waiting for the next poll to read a byte may result in missing part of a message.]]></description><guid isPermaLink="false">f89a8738-2275-4023-8223-28dae4184cd9</guid><pubDate>Mon,  2 Sep 2019 21:22:30 +0800</pubDate><dc:creator>Michael-F-Bryan</dc:creator></item><item><title>Futures Concurrency</title><link>https://blog.yoshuawuyts.com/futures-concurrency/</link><description><![CDATA[In a previous post we've looked at Rust streams. In this post we're going to discuss another problem in the async space: futures concurrency combinators. We're going to cover the different forms of concurrency that can be expressed with Futures, and cover both fallible and infallible variants.]]></description><guid isPermaLink="false">d821223f-0e0c-4bbf-a248-7191d0c0c1da</guid><pubDate>Mon,  2 Sep 2019 00:00:00 +0000</pubDate><dc:creator>Yoshua Wuyts</dc:creator></item><item><title>How Rust optimizes async/await II: Program analysis</title><link>https://tmandry.gitlab.io/blog/posts/optimizing-await-2/</link><description><![CDATA[In Part 1, we covered how async fns in Rust are compiled to state machines. We saw that the internal compiler implementation uses generators and the yield statement to facilitate this transformation. In this post, we'll go over some subtleties that the compiler implementation must consider when optimizing generators. We'll look at two different kinds of analysis, liveness analysis and storage conflict detection.]]></description><guid isPermaLink="false">7304ebe7-ee28-48a9-b88c-dd03e2605a10</guid><pubDate>Mon,  2 Sep 2019 00:00:00 +0000</pubDate><dc:creator>Tyler Mandry</dc:creator></item><item><title>Announcing actix-raft: Raft distributed consensus implemented using Actix</title><link>https://railgun-rs.github.io/actix-raft/overview.html</link><description><![CDATA[An implementation of the Raft distributed consensus protocol using the Actix actor framework. Blazing fast Rust, a modern consensus protocol, an outstanding actor framework. This project intends to provide a backbone for the next generation of distributed data storage systems (SQL, NoSQL, KV, Streaming &c) built with Rust.]]></description><guid isPermaLink="false">8e664490-3dfb-419b-8281-61ea737dd762</guid><pubDate>Wed, 28 Aug 2019 00:00:00 +0000</pubDate><dc:creator>Anthony Dodd</dc:creator></item><item><title>How to use routers in Rust Frontend</title><link>https://www.steadylearner.com/blog/read/How-to-use-routers-in-Rust-Frontend</link><description><![CDATA[In the previous post How to use a modal in Rust, we learnt how to write a simple image modal with Rust frontend. We could find that we can build components visible only in specific conditions. In this post, we will learn how to use routers in Rust frontend with Yew. You will find that it is easy with an example.]]></description><guid isPermaLink="false">4da678ba-45e7-444f-b5da-20e2893bb4d6</guid><pubDate>Tue, 27 Aug 2019 23:46:31 +0000</pubDate><dc:creator>Steadylearner</dc:creator></item><item><title>Async Stack Traces in Rust</title><link>http://fitzgeraldnick.com/2019/08/27/async-stacks-in-rust.html</link><description><![CDATA[One neat result of Rust’s futures and async/await design is that all of the async callers are on the stack below the async callees. In most other languages, only the youngest async callee is on the stack, and none of the async callers. Because the youngest frame is most often not where a bug’s root cause lies, this extra context makes debugging async code easier in Rust.]]></description><guid isPermaLink="false">518da2d7-644e-4028-95a2-388b2cb5fc0f</guid><pubDate>Tue, 27 Aug 2019 00:00:00 -0700</pubDate><dc:creator>Nick Fitzgerald</dc:creator></item><item><title>rx — a minimalist and extensible pixel editor</title><link>http://cloudhead.io/rx/</link><description><![CDATA[rx is an extensible, modern and minimalist pixel editor implemented in Rust. It's designed to have as little UI as possible, and instead takes inspiration from vi's modal nature and command mode. Compared to other pixel editors, rx aims to be smaller, yet more configurable and extendable. `rx` takes a different approach when it comes to animation as well, which is done with *strips*.]]></description><guid isPermaLink="false">ce52dbf1-c1be-4db1-bdb9-c2ac79ed9b1d</guid><pubDate>Mon, 26 Aug 2019 20:08:25 +0000</pubDate><dc:creator>Alexis Sellier</dc:creator></item><item><title>Picking Rust for web</title><link>https://abe-winter.github.io/wisdom/2019/08/26/rust-for-web.html</link><description><![CDATA[I’ve been staring at this energy efficiency across programming languages table for days. It can’t be right (why is typescript so much worse than javascript?) but a lot of it tracks with things I’ve observed from using these languages IRL. Also this web framework benchmarks project. Bottom line: I’m thinking about using rust as the backend for a small one-person web project. Here’s everything I said to myself while researching reasons not to.]]></description><guid isPermaLink="false">5d8d151f-18fd-4aa2-8a3d-eb5620394f36</guid><pubDate>Mon, 26 Aug 2019 00:00:00 +0000</pubDate><dc:creator>Abe Winter</dc:creator></item><item><title>pastel - A command-line tool to generate, analyze, convert and manipulate colors</title><link>https://github.com/sharkdp/pastel</link><description><![CDATA[pastel is a command-line tool to generate, analyze, convert and manipulate colors. It supports many different color formats and color spaces like RGB, HSL, CIELAB, CIELCh as well as ANSI 8-bit and 24-bit representations.]]></description><guid isPermaLink="false">315ad655-56d7-48d4-b68a-434cbabf710a</guid><pubDate>Mon, 26 Aug 2019 00:00:00 +0000</pubDate><dc:creator>David Peter</dc:creator></item><item><title>Actually Using Crev, Or, The Problem Of Trusting Software Dependencies</title><link>https://wiki.alopex.li/ActuallyUsingCrev</link><description><![CDATA[Currently the only implementation of crev is cargo-crev, which ties into the Rust language package manager, cargo. However, none of this is Rust-specific apart from the implementation, the basic concept and code review format should work for any language or package system. Code reviews (“proofs”) are just YAML files, and they can be shared around however you feel like – the method currently seems to be by putting proofs in git repositories, and cargo-crev has support for this. crev already has a pretty good getting started guide that covers much of the same ground as this, but I wanted to write something similar that comes from a random user, not the system’s creator.]]></description><guid isPermaLink="false">5ab7b4e5-a7ab-470c-be66-ec1a8354a782</guid><pubDate>Sun, 25 Aug 2019 00:00:00 +0000</pubDate><dc:creator>Simon Heath</dc:creator></item><item><title>Wrapping Unsafe C Libraries in Rust</title><link>https://medium.com/dwelo-r-d/wrapping-unsafe-c-libraries-in-rust-d75aeb283c65</link><description><![CDATA[In this article, we will explore how to wrap those functions and make them safe for normal use. We’ll go over how to define a wrapper struct that handles initialization and cleanup, and describe some traits that describe how application developers can safely use your library with threads. We’ll also talk a bit about how to turn a function’s random integer return into an ergonomic, type-checked Result, how to translate strings and arrays to and from the world of C, and how to turn raw pointers returned from C into scoped objects with inherited lifetimes.

The overall goal of this step is to dig into the C library’s documentation and make each function’s internal assumptions explicit.]]></description><guid isPermaLink="false">eb9194f2-85b1-412c-aa0b-0218529bf163</guid><pubDate>Sat, 24 Aug 2019 07:09:28 +0000</pubDate><dc:creator>Jeff Hiner</dc:creator></item><item><title>Is This Magic!? Ferris Explores Rustc!</title><link>https://quietmisdreavus.net/code/2019/08/23/is-this-magic-ferris-explores-rustc/</link><description><![CDATA[A companion to the RustConf 2019 talk with the same name; an introduction to making your first contribution to the Rust compiler.]]></description><guid isPermaLink="false">63fb93a7-e179-491f-83b9-84a7e284fe48</guid><pubDate>Fri, 23 Aug 2019 11:00:00 -0500</pubDate><dc:creator>QuietMisdreavus</dc:creator></item><item><title>Join Your Threads</title><link>https://matklad.github.io/2019/08/23/join-your-threads.html</link><description><![CDATA[This is a note on how to make multithreaded programs more robust. It’s not really specific to Rust, but I get to advertise my new jod-thread micro-crate :)]]></description><guid isPermaLink="false">c50ebb87-7e8f-4d08-bc8c-ebe51377faf4</guid><pubDate>Fri, 23 Aug 2019 00:00:00 +0000</pubDate><dc:creator>Aleksey Kladov</dc:creator></item><item><title>Introduction to C2Rust</title><link>https://immunant.com/blog/2019/08/introduction-to-c2rust/</link><description><![CDATA[Our goal is to build useful tools that make it easier to take existing Rust code and get up and running with Rust. We aim to automate much of the translation and rewriting process so that migrating legacy systems is practical and scalable with minimal manual effort.

We’re excited to announce that a milestone long in the making is finally here! You can now install C2Rust from crates.io with a simple cargo install on Linux and OS X. We’ve been hard at work improving C2Rust, so go install and give it a spin! You can find the necessary prerequisites in the C2Rust README.]]></description><guid isPermaLink="false">0df32177-8f6b-48ec-a896-5555337110fa</guid><pubDate>Fri, 23 Aug 2019 00:00:00 +0000</pubDate><dc:creator>Immunant, Inc</dc:creator></item><item><title>Introducing nushell</title><link>http://www.jonathanturner.org/2019/08/introducing-nushell.html</link><description><![CDATA[Today, we’re introducing a new shell, written in Rust. It draws inspiration from the classic Unix philosophy of pipelines, the structured data approach of PowerShell, functional programming, systems programming, and more.]]></description><guid isPermaLink="false">adf5ec47-1ec7-4b47-9d89-122b4efdd8f9</guid><pubDate>Fri, 23 Aug 2019 00:00:00 +0000</pubDate><dc:creator>Jonathan Turner, Yehuda Katz, and Andrés Robalino, with contributions from Odin Dutton</dc:creator></item><item><title>Artichoke is a Ruby made with Rust</title><link>https://github.com/artichoke/artichoke</link><description><![CDATA[Artichoke is a platform for building MRI-compatible Ruby implementations. Artichoke provides a Ruby runtime implemented in Rust that can be loaded into many VM backends.]]></description><guid isPermaLink="false">1e20c763-7a28-429e-9d68-e3628dcc2edd</guid><pubDate>Fri, 23 Aug 2019 00:00:00 +0000</pubDate><dc:creator>Ryan Lopopolo</dc:creator></item><item><title>Thoughts on Rust bloat</title><link>https://raphlinus.github.io/rust/2019/08/21/rust-bloat.html</link><description><![CDATA[I’m about to accept a PR that will increase druid’s compile time about 3x and its executable size almost 2x. In this case, I think the tradeoff is worth it (without localization, a GUI toolkit is strictly a toy), but the bloat makes me unhappy and I think there is room for improvement in the Rust ecosystem.]]></description><guid isPermaLink="false">5b9044be-428f-48ff-b1f3-b9f0e6b63732</guid><pubDate>Wed, 21 Aug 2019 17:17:42 +0000</pubDate><dc:creator>Raph Levien</dc:creator></item><item><title>Building with async/await in Rust</title><link>https://ragona.com/posts/clobber_async_await</link><description><![CDATA[As you might have heard, async/await is coming to Rust soon. This is a big deal. Rust has already has popular crates (tokio, actix) that provide asynchronous concurrency, but the async syntax coming to stable in 1.39 is much, much more approachable. My experience has been that you can produce and reason about application flow much more easily, which has made me significantly more productive when dealing with highly concurrent systems. To kick the tires of this new syntax I dug into the nightly branch, and built a high-performance TCP client called clobber. In this post I'll talk about why I think async/await in Rust is a big deal, and walk you some of the code in clobber.]]></description><guid isPermaLink="false">b577a6bb-429a-454b-8d2b-77175dba68c8</guid><pubDate>Wed, 21 Aug 2019 00:00:00 +0000</pubDate><dc:creator>Ryan Ragona</dc:creator></item><item><title>6 months of game development in Rust</title><link>https://iolivia.me/posts/6-months-of-rust-game-dev/</link><description><![CDATA[If you made it here you might have already read my previous post 24 hours of game development in Rust, but if you haven't, it was basically a short summary of how I started learning rust and decided to make a game with it. I started with a classical OOP/trait architecture that was taking me nowhere really fast, so I switched to ECS and got a minimal prototype working. Fast forward 6 months, I wanted to catch you folks up on where I am and what I've learnt so far.]]></description><guid isPermaLink="false">c5ced679-f825-47f6-b97e-11199ed40973</guid><pubDate>Wed, 21 Aug 2019 00:00:00 +0000</pubDate><dc:creator>Olivia Ifrim</dc:creator></item><item><title>Visual Embedded Rust Programming with Visual Studio Code</title><link>https://medium.com/@ly.lee/visual-embedded-rust-programming-with-visual-studio-code-1bc1262e398c</link><description><![CDATA[Create and edit Embedded Rust programs for STM32 Blue Pill and Apache Mynewt… By dragging and dropping blocks!]]></description><guid isPermaLink="false">05f496a4-b42b-43f3-b0f8-90edcdb52bee</guid><pubDate>Mon, 19 Aug 2019 00:08:33 +0000</pubDate><dc:creator>Lup Yuen Lee</dc:creator></item><item><title>Introduction</title><link>https://rust-lang.github.io/compiler-team/</link><description><![CDATA[A home for compiler team planning documents, meeting minutes, and other such things. If you’re interested in learning about how rustc works – as well as advice on building the compiler, preparing a PR, and other similar topics – check out the rustc-guide.]]></description><guid isPermaLink="false">6f824da5-4033-40da-994f-581a7909e50e</guid><pubDate>Sun, 18 Aug 2019 04:30:25 +0000</pubDate><dc:creator>Rust Lang Compiler Team</dc:creator></item><item><title>Rsoc: Improving Ion&apos;s UX, week 5 and 6</title><link>https://www.redox-os.org/news/rsoc-ion-ux-4-5/</link><description><![CDATA[The Redox official website]]></description><guid isPermaLink="false">a14dd34c-7e7d-4040-9b8f-e8708df5447d</guid><pubDate>Sun, 18 Aug 2019 00:00:00 +0000</pubDate><dc:creator>AdminXVII</dc:creator></item><item><title>Introducing the Rust Game Development Working Group</title><link>https://rust-gamedev.github.io/2019/08/18/introducing-the-rust-game-development-working-group</link><description><![CDATA[Rust’s combination of low-level control, excellent performance and modern build tools makes it an exciting choice for game developers. The idea of a working group to support this burgeoning community has been proposed many times over the years, and we’re excited to announce that a group has finally been formed!]]></description><guid isPermaLink="false">01b4afb8-222b-4d4f-ad09-443d48231e3f</guid><pubDate>Sun, 18 Aug 2019 00:00:00 +0000</pubDate><dc:creator>Rust GameDev</dc:creator></item><item><title>How Rust optimizes async/await: Part 1</title><link>https://tmandry.gitlab.io/blog/posts/optimizing-await-1/</link><description><![CDATA[The issue to stabilize an initial version of async/await in Rust has left final comment period. The feature looks slated to stabilize in an upcoming release, most likely 1.39. One of the blockers mentioned in the RFC is the size of the state machines emitted by async fn. I’ve spent the last few months tackling this problem, and wanted to give people a window into the process of writing these optimizations, with all the intricacies involved.]]></description><guid isPermaLink="false">c0401410-c335-43a2-a9f3-342909efdb3f</guid><pubDate>Sun, 18 Aug 2019 00:00:00 +0000</pubDate><dc:creator>Tyler Mandry</dc:creator></item><item><title>Using C Libraries in Rust</title><link>https://medium.com/dwelo-r-d/using-c-libraries-in-rust-13961948c72a</link><description><![CDATA[Today I want to dig into one of the difficulties we ran into while trying to rewrite our IoT Python code in Rust: specifically FFI, or the “Foreign Function Interface” — the bit that allows Rust to interact with other languages. When I tried to write Rust code to integrate with C libraries a year ago, the existing documents and guides often gave conflicting advice, and I had to stumble through the process on my own. This guide is intended to help future Rustaceans work through the process of porting C libraries to Rust, and familiarize the reader with the most common problems we encountered while doing the same.]]></description><guid isPermaLink="false">86fe455b-cfd7-472b-860b-2d969a8cd5ba</guid><pubDate>Sat, 17 Aug 2019 00:22:36 +0000</pubDate><dc:creator>Jeff Hiner</dc:creator></item></channel></rss>