<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/"><channel><title>Read Rust - All Posts</title><link>https://readrust.net/</link><description>All Posts posts on Read Rust</description><item><title>Organizational Debt</title><link>https://boats.gitlab.io/blog/post/rust-2019/</link><description><![CDATA[We all know that classic aphorism: Year comes to an end, Rust blog post press send. This is mine.

There are lots of cool technical improvements to Rust that I want the project to achieve this year, and a few in particular that I’m definitely going to be putting a lot of time into. But this blog post is going to talk about none of them. Instead, I want to talk about organizational debt, and how badly the Rust project needs to deal with it in 2019.]]></description><guid isPermaLink="false">f0adf24b-6589-4306-a580-6cef894ad3b7</guid><pubDate>Mon, 16 Dec 2019 00:00:00 +0000</pubDate><dc:creator>withoutboats</dc:creator></item><item><title>The smooth resize test</title><link>https://raphlinus.github.io/rust/gui/2019/06/21/smooth-resize-test.html</link><description><![CDATA[Today is an exciting point in the evolution of native GUI in Rust. There is much exploration, and a number of promising projects, but I also think we don’t yet know the recipe to make GUI truly great. As I develop my own vision in this space, druid, I hope more that the efforts will learn from each other and that an excellent synthesis will emerge, more so than simply hoping that druid will win.

In my work, I have come across a problem that is as seemingly simple, yet as difficult to get right, as making decent tea: handling smooth window resizing. Very few GUI toolkits get it perfect, with some failing spectacularly. This is true across platforms, though Windows poses special challenges. It’s also pretty easy to test (as opposed to requiring sophisticated latency measurements, which I also plan to develop). I suggest it become one of the basic tests to evaluate a GUI toolkit.]]></description><guid isPermaLink="false">1898399d-d60a-46fc-a3e0-cb8a73fb546e</guid><pubDate>Fri, 21 Jun 2019 19:50:42 +0000</pubDate><dc:creator>Raph Levien</dc:creator></item><item><title>Collaborative Editor in Rust</title><link>https://caolan.org/posts/collaborative_editor_in_rust.html</link><description><![CDATA[I've been experimenting with techniques for collaborative editing in Rust recently and I'd like to share my first functional prototype with you. The demo uses Rust and WebAssembly, and I implemented it using a conflict-free replicated data type (CRDT) based on LOGOOT, which I modified to work with variable-sized strings rather than individual characters or lines.]]></description><guid isPermaLink="false">54d40e7f-c5c5-4c69-86e2-9913c6a88200</guid><pubDate>Fri, 21 Jun 2019 00:00:00 +0000</pubDate><dc:creator>Caolan McMahon</dc:creator></item><item><title>Asyncifying an Actix Web App and Upgrading it to 1.0 - zupzup</title><link>https://zupzup.org/asyncify-rust-webapp/</link><description><![CDATA[In a previous post, we created an Actix 0.7 Web App, which was not fully non-blocking. In this post, we'll become fully non-blocking and upgrade the app to Actix 1.0]]></description><guid isPermaLink="false">a5730863-ff70-4122-8595-81c11ee59697</guid><pubDate>Thu, 20 Jun 2019 00:00:00 +0000</pubDate><dc:creator>Mario Zupan</dc:creator></item><item><title>A Detailed Look at Rust Streams</title><link>https://blog.yoshuawuyts.com/rust-streams/</link><description><![CDATA[As Rust's async story is evolving, so is Rust's streaming story. In this post we'll take a look at how Rust's streaming model works, how to use it effectively, and where things are heading in the future.]]></description><guid isPermaLink="false">7602cf1d-bae1-41bb-bfb8-4d7967af1704</guid><pubDate>Thu, 20 Jun 2019 00:00:00 +0000</pubDate><dc:creator>Yoshua Wuyts</dc:creator></item><item><title>Distributed Systems Training in Rust and Go</title><link>https://tikv.org/blog/talent-training/</link><description><![CDATA[PingCAP is creating a series of training courses on writing distributed systems in Rust and Go. These courses consist of:

Practical Networked Applications in Rust. A series of projects that incrementally develop a single Rust project from the ground up into a high-performance, networked, parallel and asynchronous key/value store. Along the way various real-world and practical Rust development subject matter are explored and discussed.

Distributed Systems in Rust. Adapted from the MIT 6.824 distributed systems coursework, this course focuses on implementing important distributed algorithms, including the Raft consensus algorithm, and the Percolator distributed transaction protocol.]]></description><guid isPermaLink="false">f756eb13-90c3-407a-a304-66e198248d3b</guid><pubDate>Thu, 20 Jun 2019 00:00:00 +0000</pubDate><dc:creator>Brian Anderson</dc:creator></item><item><title>Rust crates – frehberg’s annotated catalogue</title><link>https://frehberg.com/2019/06/rust-crates-frehbergs-annotated-catalogue/</link><description><![CDATA[The base of Rust users and contributors is growing steadily. The amount of libraries (aka crates) at http://crates.io is growing quickly; the overall “noise” is increasing. Some libraries might not be maintained any longer 🙁

This annotated catalogue shall help the Rust-users to find specific, popular, mature Rust crates. This list is WIP (Work In Progress), reflecting my personal shortlist. The ordering in the table top-down doesn’t express any preference.]]></description><guid isPermaLink="false">f1697ece-4d5e-46b8-88b5-d5a2e729ae96</guid><pubDate>Wed, 19 Jun 2019 19:13:23 +0000</pubDate><dc:creator>Frank Rehberger</dc:creator></item><item><title>On Memoization in Rust</title><link>https://medium.com/swlh/on-memoization-291fd1dd924</link><description><![CDATA[A detailed walk through how to memoize function calls in Rust.]]></description><guid isPermaLink="false">b26fcca3-2a79-4340-88fd-80c6f70c95d1</guid><pubDate>Mon, 17 Jun 2019 12:30:14 +0000</pubDate><dc:creator>Andrew Pritchard</dc:creator></item><item><title>Rust for OOP - Enums &amp; Pattern Matching - Part 1</title><link>https://oribenshir.github.io/afternoon_rusting/blog/enum-and-pattern-matching-part-1</link><description><![CDATA[We continue our series “Rust for OOP” with Enums & Pattern Matching, one of my preferred features of Rust. I didn’t hear about it before getting into the language, yet immediately fell in love with it. Enums are simple, expressive, reducing code bloat, enable encapsulation, easy to understand, and reason with. It also enables many useful design pattern. ]]></description><guid isPermaLink="false">e7bf2504-b854-4a1d-b946-38075e83e97a</guid><pubDate>Mon, 17 Jun 2019 00:00:00 +0000</pubDate><dc:creator>Ori Ben-Shir</dc:creator></item><item><title>Makepad, a live Rust authoring tool for 2D vector design, shaders and animation</title><link>https://github.com/makepad/makepad</link><description><![CDATA[The vision is to build a livecoding / design hybrid program, where procedural design and code are fused in one environment. If you have missed 'learnable programming' please check this out: http://worrydream.com/LearnableProgramming/ Makepad aims to fulfill (some) of these ideas using a completely from-scratch renderstack built on the GPU and Rust. It will be like an IDE meets a vector designtool, and had offspring. Direct manipulation of the vectors modifies the code, the code modifies the vectors.

However before we can make this awesome application, we need to build a UI stack. The aim of this toolkit is to be our stepping stone into building a livecoding IDE and designtools that don't suck or fall to pieces along the way.]]></description><guid isPermaLink="false">87146592-5c10-431e-8655-5272eec53ed9</guid><pubDate>Mon, 17 Jun 2019 00:00:00 +0000</pubDate><dc:creator>makepad</dc:creator></item><item><title>Rust on the ESP and how to get started</title><link>https://dentrassi.de/2019/06/16/rust-on-the-esp-and-how-to-get-started/?pk_campaign=twitter</link><description><![CDATA[Read about a simple quickstart with Rust on the ESP, using a ready-to-run container setup that should make this as easy as possible.]]></description><guid isPermaLink="false">38752604-badd-4d11-a3e3-92b6091d2153</guid><pubDate>Sun, 16 Jun 2019 14:18:55 +0000</pubDate><dc:creator>Jens Reimann</dc:creator></item><item><title>A simple plugin interface for the Rust FFI</title><link>http://kmdouglass.github.io/posts/a-simple-plugin-interface-for-the-rust-ffi/</link><description><![CDATA[I present a straight-forward design of a plugin interface using the Rust FFI.]]></description><guid isPermaLink="false">d0496592-58c8-4e56-8cfb-890df49f7b6c</guid><pubDate>Sun, 16 Jun 2019 07:33:33 +0000</pubDate><dc:creator>Kyle M. Douglass</dc:creator></item><item><title>Hagrid: A New Verifying Key Server Built on Sequoia</title><link>https://sequoia-pgp.org/blog/2019/06/14/20190614-hagrid/</link><description><![CDATA[On Wednesday, Vincent launched a new key server at keys.openpgp.org! What makes this launch special is that keys.openpgp.org is running Hagrid —“The Keeper of Keys”—a new verifying key server, which is written in Rust and based on Sequoia. Even though the launch didn’t receive much media attention, 700 people have already verified their keys in the 48 hours since the announcement.]]></description><guid isPermaLink="false">81657ee0-b628-449d-b5c3-3258a0219756</guid><pubDate>Fri, 14 Jun 2019 14:21:35 +0200</pubDate><dc:creator>Neal</dc:creator></item><item><title>Emu - GPU programming language for Rust</title><link>https://calebwin.github.io/emu/</link><description><![CDATA[Emu is a language for programming GPUs from Rust. Emu provides the emu! macro for compiling functions written in the Emu language to an intermediate code which gets stored in the EMU global constant. You can then run your code using a binding to OpenCL such as ocl or rust-opencl or use the build! macro which generates Rust functions that can be called to run your Emu functions.]]></description><guid isPermaLink="false">3fab26a6-a1c1-4107-a0c0-c69f2c297342</guid><pubDate>Thu, 13 Jun 2019 00:00:00 +0000</pubDate><dc:creator>Caleb Winston</dc:creator></item><item><title>Green Threads Explained in 200 Lines of Rust</title><link>https://cfsamson.gitbook.io/green-threads-explained-in-200-lines-of-rust/</link><description><![CDATA[This book aims to explain green threads by using a small example where we implement a simple but working program where we use our own green threads to execute code.]]></description><guid isPermaLink="false">87fc989d-1a0d-47ce-9663-105f4e93a217</guid><pubDate>Wed, 12 Jun 2019 00:00:00 +0000</pubDate><dc:creator>cfsamson</dc:creator></item><item><title>5 Year Anniversary</title><link>https://gfx-rs.github.io/2019/06/12/anniversary-5.html</link><description><![CDATA[gfx-rs project started with a simple idea: separate the API-specific logic of interaction with the graphic driver from a Rust application. That idea was brewing in the heads of @kvark and @bjz precisely 5 years ago, when they realized the common goal and kicked off the project. The Rust game dev community at the time consisted of a few prominent projects (like kiss3d, claymore, and q3) driven by individuals. They used gl-rs for rendering with no strong separation between higher levels, built as mostly monolithic systems. Because GL was known to keep the CPU occupied on the owning thread, we wanted to provide a separate thread dedicated to talking to the GPU. We had a lot to learn, some great contributors to meet, and hoped to eventually make Rust ecosystem a better place.]]></description><guid isPermaLink="false">5d2b3bb3-b939-4e5a-851f-31963f805af4</guid><pubDate>Wed, 12 Jun 2019 00:00:00 +0000</pubDate><dc:creator>gfx-rs</dc:creator></item><item><title>Bzip2 in Rust: porting the randomization table</title><link>https://people.gnome.org/~federico/blog/bzip2-in-rust-randomization-table.html</link><description><![CDATA[Here is a straightforward port of some easy code. randtable.c has a lookup table with seemingly-random numbers. This table is used by the following macros in bzlib_private.h]]></description><guid isPermaLink="false">05531a2c-35fc-4e51-ad25-77b362b99e03</guid><pubDate>Tue, 11 Jun 2019 14:30:17 -0500</pubDate><dc:creator>Federico Mena Quintero</dc:creator></item><item><title>Hosting Embedded Rust apps on Apache Mynewt with STM32 Blue Pill</title><link>https://medium.com/@ly.lee/hosting-embedded-rust-apps-on-apache-mynewt-with-stm32-blue-pill-c86b119fe5f?sk=f58f4cf6c608fded4b354063e474a93b</link><description><![CDATA[Today’s microcontrollers (like the STM32 Blue Pill) pack so many features in a tiny package… yet few embedded programmers are capable of exploiting the full potential of modern microcontrollers. Many of us (my IoT students included) seem to be stuck in the 1980s — painstakingly writing C programs for small computers.

It’s time to drop our legacy programming practices and adopt smarter, safer ways to exploit these microcontrollers… starting with Apache Mynewt and Rust.]]></description><guid isPermaLink="false">4676f66e-29a0-4d5d-9da8-34c09f104ca2</guid><pubDate>Sun,  9 Jun 2019 14:47:44 +0000</pubDate><dc:creator>Lup Yuen Lee 李立源</dc:creator></item><item><title>Nannou Update - Vulkan, LASERs and more!</title><link>https://nannou.cc/posts/nannou_v0.9</link><description><![CDATA[Nannou is an open source, creative coding framework for Rust. Today marks one of the biggest milestones for the project since its launch - the release of version 0.9. This version is particularly special for our community as it lands the last eight months of progress into master and onto crates.io. While some of us have already been using the work-in-progress 0.9 branch in our personal and commercial work over the past few months, it is a relief to finally be able to land and share the progress with the wider world!]]></description><guid isPermaLink="false">0f7e8d0a-81fa-4f1a-aa4d-418554873fe6</guid><pubDate>Sun,  9 Jun 2019 00:00:00 +0000</pubDate><dc:creator>Nannou team</dc:creator></item><item><title>Announcing Contrie: concurrent maps and sets</title><link>https://vorner.github.io/2019/06/09/announcing-contrie.html</link><description><![CDATA[This is partly an announcement of a new crate folks might find useful, partly a call for participation and help and partly a journal like story how the crate came to being. Read on (or not) or skip to the parts that seem interesting to you.]]></description><guid isPermaLink="false">aaa397b7-d0b2-43d0-af75-0934ac4bfe73</guid><pubDate>Sun,  9 Jun 2019 00:00:00 +0000</pubDate><dc:creator>Michal &apos;vorner&apos; Vaner</dc:creator></item><item><title>Release Notes for v0.6.0</title><link>https://www.rs-pbrt.org/blog/v0-6-0-release-notes/</link><description><![CDATA[The biggest change for this release is that I started writing a parser for binary Blender files. There is a blog post, where I talk a bit about that, how to explore binary Blender files, and basically how to reconstruct useful information from their DNA.]]></description><guid isPermaLink="false">42c2c580-96cc-4fc8-9485-b29364da6144</guid><pubDate>Fri,  7 Jun 2019 00:00:00 +0000</pubDate><dc:creator>Jan Douglas Bert Walter</dc:creator></item><item><title>Threads in rust</title><link>https://chilimatic.hashnode.dev/threads-in-rust-cjwmbxw9e003pzjs19n7pa0bt</link><description><![CDATA[In our regular hacksession, the current season ;), we are focusing on threading. Concurrency/Multithreading is a really hard topic it has a lot of very specific nomenclature and there are different 'levels' of concurrency one might say. I will start with the nomenclature starting from the programmers / OS perspective.]]></description><guid isPermaLink="false">922ec00d-8aa7-48eb-9344-c1d1eacc44ec</guid><pubDate>Fri,  7 Jun 2019 00:00:00 +0000</pubDate><dc:creator>j</dc:creator></item><item><title>Determining if a Rust Vector has all equal elements</title><link>https://sts10.github.io/2019/06/06/is-all-equal-function.html</link><description><![CDATA[Earlier today, I tooted out a Rust question: How would you write a function to determine if a Vector of integers are all the same, or not. Anyway, the Fediverse is wonderful and full of helpful Rust friends – I ended up getting about a dozen solutions (none exactly the same I don’t think?)]]></description><guid isPermaLink="false">c4166c18-6984-4c64-bda0-68d98d5b3ae7</guid><pubDate>Thu,  6 Jun 2019 22:11:00 +0000</pubDate><dc:creator>Sam Schlinkert</dc:creator></item><item><title>Solutions to the first 20 project euler problems</title><link>https://ngoldbaum.github.io/posts/project-euler/</link><description><![CDATA[I’m getting more and more used to thinking about Rust code in an idiomatic way, but I don’t think I’m comfortable enough to call myself a rustacean yet. To further my goal of oxidizing my brain with rust knowledge, I decided to start working through project euler problems sequentially. I’ve recently finished the first 20 problems and I though I’d share the highlights of what I learned about rust along the way.]]></description><guid isPermaLink="false">30deb171-6751-4af4-9f56-202fe6a78110</guid><pubDate>Thu,  6 Jun 2019 10:23:45 -0400</pubDate><dc:creator>Nathan Goldbaum</dc:creator></item><item><title>Sealed Rust</title><link>https://ferrous-systems.com/blog/sealed-rust-the-pitch/</link><description><![CDATA[This is the first post in a series detailing Ferrous System's plan to qualify the Rust Language and Compiler for use in the Safety Critical domain. We call this effort Sealed Rust.]]></description><guid isPermaLink="false">b3f6b505-fb93-4330-a039-d97e148e80d5</guid><pubDate>Thu,  6 Jun 2019 02:21:00 +0000</pubDate><dc:creator>James Munns</dc:creator></item><item><title>Speed Up Your JavaScript With Rust</title><link>https://medium.com/paloit/speed-up-your-javascript-with-rust-7661922562fa</link><description><![CDATA[For a recent personal project, I had only needed a fairly simple node.js server to do exponential and costly computing tasks. To be honest, I could have switched the entire tech stack, but I estimated that the development time of such a choice wasn’t worth it… Still, I had some functions taking ages to compute. So I had a look around, and decided to let that task be handled by a more appropriate language, in this case Rust.]]></description><guid isPermaLink="false">e3be782c-4057-4e64-9c1a-0ff81761d5d7</guid><pubDate>Thu,  6 Jun 2019 01:54:49 +0000</pubDate><dc:creator>Johan Paasche</dc:creator></item><item><title>Actix - Actor System and Web Framework for Rust</title><link>https://actix.rs/</link><description><![CDATA[Actix web 1.0.0 is released - a small, pragmatic, and extremely fast web framework.]]></description><guid isPermaLink="false">ae6027ab-b71f-4bce-9ab8-e1853aa24030</guid><pubDate>Wed,  5 Jun 2019 15:38:00 +0000</pubDate><dc:creator>Nikolay Kim</dc:creator></item><item><title>Overlapping blanket impls</title><link>https://codesandwich.github.io/overlapping_blanket_impls/</link><description><![CDATA[Rust doesn’t allow multiple impls of a trait on the same type. This rule keeps resolution transparent and reliable. It also has an ugly side effect, that for every trait there can be only 1 blanket impl. Compiler is completely distrustful here. What if somebody somewhere created a structure that implemented both ToString and Clone? Should such combination suddenly be forbidden? What about String and u32? This rule prevents type hierarchy from sliding into minefield of odd rules and breakages on every other dependency update.]]></description><guid isPermaLink="false">37400230-0f89-41d9-a9e4-a0d7460217ab</guid><pubDate>Wed,  5 Jun 2019 12:00:00 +0000</pubDate><dc:creator>CodeSandwich</dc:creator></item><item><title>The design and implementation of a lock-free ring-buffer with contiguous reservations</title><link>https://ferrous-systems.com/blog/lock-free-ring-buffer/</link><description><![CDATA[Berlin based technology consultancy specialising in the rust programming language and related services.]]></description><guid isPermaLink="false">c12ced69-039d-4d8a-99f3-ed518947537a</guid><pubDate>Wed,  5 Jun 2019 03:02:00 +0000</pubDate><dc:creator>Andrea Lattuada and James Munns</dc:creator></item><item><title>The Typestate Pattern in Rust</title><link>http://cliffle.com/blog/rust-typestate/</link><description><![CDATA[The typestate pattern is an API design pattern that encodes information about an object's run-time state in its compile-time type. This pattern is so easy in Rust that it's almost obvious, to the point that you may have already written code that uses it, perhaps without realizing it. I haven't seen a detailed examination of the nuances of this pattern, so here's my contribution.]]></description><guid isPermaLink="false">7d1887a3-55d1-448d-8643-2a520bfddc41</guid><pubDate>Wed,  5 Jun 2019 00:00:00 +0000</pubDate><dc:creator>Cliff L. Biffle</dc:creator></item><item><title>A generic kubernetes client</title><link>https://clux.github.io/probes/post/2019-06-04-towards-a-generic-kube-client/</link><description><![CDATA[It’s been about a month since we released kube, a new rust client library for kubernetes. We covered the initial release, but it was full of naive optimism and uncertainty. Would the generic setup work with native objects? How far would it extend? Non-standard objects? Patch handling? Event handling? Surely, it’d be a fools errand to write an entire client library?]]></description><guid isPermaLink="false">c26ac9a2-3fbe-4cb3-b845-58e08b05502c</guid><pubDate>Tue,  4 Jun 2019 00:00:00 +0000</pubDate><dc:creator>clux</dc:creator></item><item><title>Announcing The Triage WG</title><link>https://users.rust-lang.org/t/announcing-the-triage-wg/28909</link><description><![CDATA[The Release team is pleased to announce the triage working group , which will assume responsibility from the release team for triaging issues and pull requests in the rust-lang repositories as well as for diagnosing failures in Crater runs.]]></description><guid isPermaLink="false">254cd239-bad6-4331-ad8e-fe00edfb834d</guid><pubDate>Mon,  3 Jun 2019 16:15:03 +0000</pubDate><dc:creator>Dylan DPC</dc:creator></item><item><title>Announcing our Verifiable Random Function (VRF) Rust library</title><link>https://medium.com/witnet/announcing-our-verifiable-random-function-vrf-rust-library-2e042c29a4f7</link><description><![CDATA[Recently Gorka Irazoqui Apecechea and me proudly published a VRF crate as an open source project under the MIT license. The library is a fast, flexible and general-purpose Verifiable Random Function (VRF) library written in Rust, which follows the IETF standard draft written by Sharon Goldberg, Moni Naor, Dimitris Papadopoulos, Leonid Reyzin, and Jan Včelák.]]></description><guid isPermaLink="false">aea12212-4a3a-4c00-baa5-313f5c998977</guid><pubDate>Mon,  3 Jun 2019 15:03:50 +0000</pubDate><dc:creator>Mario Cao</dc:creator></item><item><title>essential rust tools</title><link>https://www.ultrasaurus.com/2019/06/essential-rust-tools/</link><description><![CDATA[Rust has a “community of developers empowered by their tools and each other” (via Katharina Fey in “An async story“). The Rust community helps each other through effective narrative documentation and attention to error messages, and the robust tooling around Rust drives momentum, overcoming some of the natural hurdles when diving into a new language.

Here’s my list of essential rust tools (so far).]]></description><guid isPermaLink="false">f9c3c42b-87f8-4edf-820b-aad48a409482</guid><pubDate>Mon,  3 Jun 2019 14:19:23 +0000</pubDate><dc:creator>Sarah Allen</dc:creator></item><item><title>The Governance WG is going public</title><link>https://blog.rust-lang.org/2019/06/03/governance-wg-announcement.html</link><description><![CDATA[Hey all! Today we're happy to announce the Governance Working Group is going public. We've been spending the last couple weeks finding our bearings and structuring the working group.]]></description><guid isPermaLink="false">d325b708-16d9-45b7-a1d8-6f9e5a331da5</guid><pubDate>Mon,  3 Jun 2019 00:00:00 +0000</pubDate><dc:creator>The Rust Governance WG</dc:creator></item><item><title>Evoli - an official Amethyst showcase game</title><link>https://amethyst.rs/posts/evoli-an-official-amethyst-showcase-game</link><description><![CDATA[Today marks the first stable release of Evoli, an evolution-inspired simulation game made in Amethyst. We’ve successfully completed the MVP spec (and then some) as it was laid out back in February.]]></description><guid isPermaLink="false">b1731301-ca91-4f8c-a66a-48320013705b</guid><pubDate>Sun,  2 Jun 2019 00:00:00 +0000</pubDate><dc:creator>Erlend Sogge Heggen</dc:creator></item><item><title>Gopher Server in Rust</title><link>https://gkbrk.com/2019/06/gopher-server/</link><description><![CDATA[I find Gopher really cool. I think it’s a really nice way to organize information into trees and hierarchies, and as we all know programmers can’t resist trees. So recently I took an interest in Gopher and started writing my own server.

But recently it’s been gaining traction; so we should provide a decent landscape for new gophers, full of oxidised servers. Since I started using Gopher more often, it’s beneficial for me if there’s more content out there. So I’m writing this blog post to walk you through how to write your own server. We’ll be doing this in Rust.]]></description><guid isPermaLink="false">91ae37e0-3d4f-4c78-879d-47e635f8fbda</guid><pubDate>Sun,  2 Jun 2019 01:00:00 +0100</pubDate><dc:creator>Gokberk Yaltirakli</dc:creator></item><item><title>How to Package Rust Applications Into Minimal Docker Containers</title><link>https://alexbrand.dev/post/how-to-package-rust-applications-into-minimal-docker-containers/</link><description><![CDATA[In the Go world, it is common to use docker’s multi-stage build feature to produce the app’s docker image in two stages. The first stage uses the golang image and is where we build the application into a statically-linked binary. Once built, we copy the binary into a scratch container in the second stage. The result is a rather small image that has nothing other than the application.

I was looking to do the same thing for my Rust application. While I was at it, I also wanted to leverage the docker build cache to avoid having to download crates on every docker build.]]></description><guid isPermaLink="false">2c6b8329-385a-4e19-ba91-4c84b1ebf4bc</guid><pubDate>Sat,  1 Jun 2019 09:00:00 -0400</pubDate><dc:creator>Alexander Brand</dc:creator></item><item><title>Toward Piston 1.0</title><link>http://blog.piston.rs/2019/06/01/toward-piston-1.0/</link><description><![CDATA[The Piston core is a set of libraries that defines a core abstraction for user inputs, window and event loop. If you take a look at the dependency graph in the README, it might look a bit scary: In this post I will go through each library, explain what it does and describe the status of stability.]]></description><guid isPermaLink="false">f6a4f101-2fc4-4bb8-827c-c1e54d5dc877</guid><pubDate>Sat,  1 Jun 2019 00:00:00 +0000</pubDate><dc:creator>Sven Nilsen</dc:creator></item><item><title>dua: Disk Usage Analyzer</title><link>https://github.com/Byron/dua-cli</link><description><![CDATA[dua (-> Disk Usage Analyzer) is a tool to conveniently learn about the usage of disk space of a given directory. It's parallel by default and will max out your SSD, providing relevant information as fast as possible.]]></description><guid isPermaLink="false">2ebb2e7a-9b56-4fe3-8605-91c8deb394a9</guid><pubDate>Sat,  1 Jun 2019 00:00:00 +0000</pubDate><dc:creator>Sebastian Thiel</dc:creator></item><item><title>LambdaCore Programming Language</title><link>https://sites.google.com/view/lcore</link><description><![CDATA[An interpreted language written in Rust inspired by the Lisp family of languages.]]></description><guid isPermaLink="false">d4eee998-344f-4863-9402-c8636ff8afc0</guid><pubDate>Sat,  1 Jun 2019 00:00:00 +0000</pubDate><dc:creator>Pebaz</dc:creator></item><item><title>Poking the macOS IO Kit with Rust</title><link>https://svartalf.info/posts/2019-05-31-poking-the-macos-io-kit-with-rust/</link><description><![CDATA[How to fetch batteries information from the macOS APIs with Rust]]></description><guid isPermaLink="false">da8a8064-82b9-4b6f-a37e-d8560a353283</guid><pubDate>Fri, 31 May 2019 00:00:00 +0000</pubDate><dc:creator>Nikita Kuznetsov</dc:creator></item><item><title>Bzip2 in Rust - Basic infrastructure and CRC32 computation</title><link>https://people.gnome.org/~federico/blog/bzip2-in-rust-basic-infra.html</link><description><![CDATA[I have started a little experiment in porting bits of the widely-used bzip2/bzlib to Rust. I hope this can serve to refresh bzip2, which had its last release in 2010 and has been nominally unmaintained for years.

I hope to make several posts detailing how this port is done. In this post, I'll talk about setting up a Rust infrastructure for bzip2 and my experiments in replacing the C code that does CRC32 computations.]]></description><guid isPermaLink="false">332be129-192f-46d1-aefc-c3765e5b1b56</guid><pubDate>Thu, 30 May 2019 10:36:19 -0500</pubDate><dc:creator>Federico Mena Quintero</dc:creator></item><item><title>Debugging with and without parameter in Rust</title><link>https://blog.knoldus.com/debugging-with-and-without-parameter-in-rust/</link><description><![CDATA[Rust 1.32.0 introduced a macro dbg! for quick and dirty debugging with which you can inspect the value of a given expression. Rust 1.35.0 announced an improvement in this macro to make it more usable for Rustaceans. Now you can trace any fine and line number using this macro without passing any parameter.]]></description><guid isPermaLink="false">56e998a6-89d0-4a99-b11c-a541d35dc9a1</guid><pubDate>Thu, 30 May 2019 04:33:10 +0000</pubDate><dc:creator>Ayush Mishra</dc:creator></item><item><title>Rust&apos;s custom derives in a hexagonal architecture: Incompatible ideas?</title><link>https://blog.eizinger.io/5835/rust-s-custom-derives-in-a-hexagonal-architecture-incompatible-ideas</link><description><![CDATA[This blog post is a manifestation of a problem that has been floating around in my head for quite a while now. It is about the seemingly incompatible idea of fully embracing Rust's custom derive system in an application that puts a strong focus on a hexagonal architecture.

To discuss this problem, I am going to first write about both concepts individually. Feel free to skip over those sections if you are already familiar with the topics. The blog post finishes off with some ideas on how Rust could be extended to better support these kind of usecases.]]></description><guid isPermaLink="false">d6200716-96c2-4c9c-890d-0047906b7c72</guid><pubDate>Thu, 30 May 2019 00:00:00 +0000</pubDate><dc:creator>Thomas Eizinger</dc:creator></item><item><title>battop: top for your laptop battery</title><link>https://github.com/svartalf/rust-battop</link><description><![CDATA[battop is an interactive viewer, similar to top, htop and other *top utilities, but about batteries installed in your notebook.]]></description><guid isPermaLink="false">834cc4e5-1dd6-446d-966e-8a869ff45f79</guid><pubDate>Thu, 30 May 2019 00:00:00 +0000</pubDate><dc:creator>Nikita Kuznetsov</dc:creator></item><item><title>[blend_info] Rust and Blender</title><link>https://www.janwalter.org/jekyll/blender/rust/blendinfo/2019/05/28/blend_info.html</link><description><![CDATA[To explore a bit the Blender binary file format and provide tools to read and use them I started a new repository on Codeberg. Finally I want to read Blender files directly, and render them with my own renderer. But on my way to develop such a thing, there are many other possibilities, e.g. one could convert Blender files to a new file format, which does not only work for Blender and one single renderer, but would allow any Digital Content Creation (DCC) tool to save to, and any renderer to read from. Anyway, that's a complicated topic and let's start far simpler, by exploring Blender's file format. You get the source code of Blender for reverse engineering (create a debug version and single step through file related code with a debugger) and some Rust code (provided by me) to see what I have figured out so far...]]></description><guid isPermaLink="false">c8b3f39e-8427-42db-93fa-ea196b956607</guid><pubDate>Tue, 28 May 2019 00:00:00 +0000</pubDate><dc:creator>Jan Walter</dc:creator></item><item><title>Update on await syntax</title><link>https://boats.gitlab.io/blog/post/await-decision-ii/</link><description><![CDATA[In my previous post I said that the lang team would be making our final decision about the syntax of the await operator in the May 23 meeting. That was last Thursday, and we did reach a decision. In brief, we decided to go forward with the preliminary proposal I outlined earlier: a postfix dot syntax, future.await. For more background, in addition the previous post on my blog, you can read this write up about some of the trade offs from April.]]></description><guid isPermaLink="false">b3ca84bd-3574-43f7-aef3-988cbc6389a4</guid><pubDate>Tue, 28 May 2019 00:00:00 +0000</pubDate><dc:creator>boats</dc:creator></item><item><title>Eight million pixels and counting – A look at pathfinder</title><link>https://nical.github.io/posts/a-look-at-pathfinder.html</link><description><![CDATA[This post is about pathfinder, a GPU vector graphics renderer written in Rust by Patrick Walton as part of his work in the emerging technologies team at Mozilla. Pathfinder can be used to render glyph atlases and larger scenes such as SVG paths. The two use cases are handled a bit differently and in this post I will be focusing on the latter.]]></description><guid isPermaLink="false">cbb3c7f8-1ff0-4a30-b924-08c79542c259</guid><pubDate>Tue, 28 May 2019 00:00:00 +0000</pubDate><dc:creator>Nical</dc:creator></item><item><title>Creating a Static HTTP Server with Rust – Part 2</title><link>http://concisecoder.io/2019/05/27/creating-a-static-http-server-with-rust-part-2/</link><description><![CDATA[In this series, we are creating a basic static HTTP 1.0 server with Rust. If you haven’t seen Part 1 yet, go do that first. At the end of Part 2, our server will do the following: Read and serve files from a predefined directory on the host server, Generate appropriate HTTP responses to incoming requests, Log information about the response to standard output.]]></description><guid isPermaLink="false">4e723122-0527-43dc-b95b-ff4fd5cd5d28</guid><pubDate>Mon, 27 May 2019 13:25:29 +0000</pubDate><dc:creator>Levi Payne</dc:creator></item><item><title>Writing a Raytracer in Rust: part 2</title><link>https://canmom.github.io/programming/graphics/raytracer/rust-raytracer-part-2</link><description><![CDATA[After I posted the previous post, one of my friends remarked, "i like the way there is no raytracing in the first post its just faffing to get a window". This is an entirely accurate diagnosis. But, right now, have a representation of a frame buffer as a container (probably a vector) of pixels, which we can pass to the window to render a frame. Now we need to figure out what we’re drawing to it!

There are a couple of tweaks I need to make to this - a representation of the framebuffer in linear float space, for example. But let’s come back to that. I want to trace rays.]]></description><guid isPermaLink="false">5503b5d1-aef0-4bb5-8d51-c050b3d4fb1e</guid><pubDate>Mon, 27 May 2019 00:00:00 +0000</pubDate><dc:creator>bryn dickinson</dc:creator></item><item><title>Calling a Go Library from Rust: A Case Study with SQIP</title><link>https://blog.arranfrance.com/post/cgo-sqip-rust/</link><description><![CDATA[A brief run-down of how to wrap a Go library in a CGO FFI to enable its functions to be called by Rust.]]></description><guid isPermaLink="false">ec3d6230-6b29-4459-8a62-c40a8ef08430</guid><pubDate>Mon, 27 May 2019 00:00:00 +0000</pubDate><dc:creator>Arran France</dc:creator></item><item><title>Programming Servo: Zen and the art of removing blocks from your system</title><link>https://medium.com/@polyglot_factotum/programming-servo-zen-and-the-art-of-removing-blocks-from-your-system-51c1b7d404e3</link><description><![CDATA[It all started with a simple issue, a “quick fix”, or so I thought.]]></description><guid isPermaLink="false">0cc7297b-a14f-443d-a02a-073685c663a3</guid><pubDate>Sun, 26 May 2019 09:41:02 +0000</pubDate><dc:creator>Gregory Terzian</dc:creator></item><item><title>Creating a &apos;paged&apos; Vec in Rust</title><link>https://dev.to/kdrakon/creating-a-paged-vec-in-rust-193l</link><description><![CDATA[In this post I'll show you some code I wrote for paginating over a Vec collection in Rust. I needed this for a CLI tool I wrote which was meant to display all the vector entries retrieved from a remote server. In most cases, I expected to receive a lot of results, so to display them in a terminal efficiently, I couldn't reasonably render them all. I decided I would page the results.]]></description><guid isPermaLink="false">51cdd7b5-fed9-439c-b6f8-c50ee7f93ea2</guid><pubDate>Fri, 24 May 2019 06:36:49 +0000</pubDate><dc:creator>Sean Policarpio</dc:creator></item><item><title>Announcing j4rs</title><link>https://astonbitecode.github.io/blog/post/j4rs_0.6.0/</link><description><![CDATA[j4rs stands for “Java for Rust” and allows effortless calls to Java code, from Rust. Some time ago, on a need to call Java code from Rust, I started the j4rs project. The main idea was to implement a crate that would give the ability to its users to make calls to Java easily, so that they can benefit from the huge Java ecosystem.]]></description><guid isPermaLink="false">f94980b0-dfbb-421b-b861-16e158c7c0c2</guid><pubDate>Fri, 24 May 2019 00:10:10 +0000</pubDate><dc:creator>Aston</dc:creator></item><item><title>Announcing Mockiato - A strict, yet friendly mocking library for Rust 2018</title><link>https://blog.myelin.ch/2019/05/24/mockiato-announcement.html</link><description><![CDATA[We’re proud to announce mockiato! For the last few months, we tackled the issue of creating a usable mocking library. Our primary goals were: Ease of use: The mocks are written in idiomatic Rust and don’t rely on custom macro syntax. Maintainability: The entire code base strives to follow the rules of Clean Code and Clean Architecture as specified by Robert C. Martin.  Strict expectation enforcement: Mockiato catches unexpected behavior as soon as it happens instead of returning default values.]]></description><guid isPermaLink="false">635d3c1f-b71e-4883-b72e-52efe1ab01d0</guid><pubDate>Fri, 24 May 2019 00:00:00 +0000</pubDate><dc:creator>Jeremy, Ruben, Jan, Mathias</dc:creator></item><item><title>Hawk-Rust Series: Actuation of Raspberry Pi Camera</title><link>https://blog.knoldus.com/hawk-rust-series-actuation-of-raspberry-pi-camera/</link><description><![CDATA[In this project, we have used Raspberry Pi and its camera to authenticate whether the RFID card is punched by the card’s owner or not. HAWK is a Rust based Image Recognition project, which implements a two-factor authentication by using the RFID card for user identification and Image for user validation. In this blog, I’ll show you how to trigger RPi’s camera using Rust Programming Language. To know more about HAWK click here]]></description><guid isPermaLink="false">4d542211-c76e-41b8-b9fd-d008c06ed937</guid><pubDate>Thu, 23 May 2019 08:51:49 +0000</pubDate><dc:creator>Pawan Bisht</dc:creator></item><item><title>Blockchain-Flavored WASI</title><link>https://medium.com/oasislabs/blockchain-flavored-wasi-50e3612b8eba</link><description><![CDATA[General purpose computation on the blockchain using Web Assembly System Interface (WASI).]]></description><guid isPermaLink="false">fe48ce77-ad77-4983-a08d-1fb9cf951bb1</guid><pubDate>Thu, 23 May 2019 04:07:55 +0000</pubDate><dc:creator>Nick Hynes</dc:creator></item><item><title>Rust&apos;s Bindgen + Fuse in 2019</title><link>https://dev.to/kdrakon/rust-s-bindgen-fuse-in-2019-2e8l</link><description><![CDATA[I will quickly show how I got bindgen (https://rust-lang.github.io/rust-bindgen) to generate the bindings to Fuse (libfuse) with the current stable1 release of Rust. By doing so, this should demonstrate how to bootstrap writing your own Fuse file system in Rust.

I do realise that there are some crates that already exist that aid in making Fuse drivers in Rust, but this was more or less an excuse to also try out bindgen, which I don't believe those existing libraries utilise.]]></description><guid isPermaLink="false">6abeffb3-1d06-4642-9a7d-9c089fd1a030</guid><pubDate>Thu, 23 May 2019 03:56:28 +0000</pubDate><dc:creator>Sean Policarpio</dc:creator></item><item><title>Announcing Rust 1.35.0</title><link>https://blog.rust-lang.org/2019/05/23/Rust-1.35.0.html</link><description><![CDATA[The highlight of this release is the implementation of the FnOnce, FnMut, and Fn closure traits for Box<dyn FnOnce>, Box<dyn FnMut>, and Box<dyn Fn> respectively. Additionally, closures may now be coerced to unsafe function pointers. The dbg! macro introduced in Rust 1.32.0 can now also be called without arguments. Moreover, there were a number of standard library stabilizations. Read on for a few highlights, or see the detailed release notes for additional information.]]></description><guid isPermaLink="false">53c0e6e9-a95e-4509-b70a-74e945e74e92</guid><pubDate>Thu, 23 May 2019 00:00:00 +0000</pubDate><dc:creator>The Rust Release Team</dc:creator></item><item><title>Speeding up Ruby MRI with Rust</title><link>https://medium.com/@flixdescteaux/speeding-up-ruby-mri-with-rust-a7c914d2f9d0</link><description><![CDATA[Let me start by saying I really like Ruby. I tend to agree with the statement saying Ruby is optimized for developer happiness. However, nothing comes for free. Programming ecstasy is a double-edged sword and writing slow Ruby is as easy as it is pleasant.]]></description><guid isPermaLink="false">63fcd49a-f8d8-46f4-92dd-58cb8d77082c</guid><pubDate>Tue, 21 May 2019 13:58:31 +0000</pubDate><dc:creator>Félix Descôteaux</dc:creator></item><item><title>Rebuffing the Attack of the Clones</title><link>https://thenewwazoo.github.io/clone.html</link><description><![CDATA[I left a comment on HN about how I teach new users not to clone, and someone asked me if I’d written more, so here we go!

When new users are writing Rust code, it’s reasonably common to “fight with the borrow checker”. I personally find this to be quite a misnomer, as it is not a fight so much as a misunderstanding of the nature of Rust’s semantics. In an attempt to make the errors go away, users will understandably take the path of least resistance, according to the docs they’ve got. They dutifully read up, and eventually land on the clone method. This makes the errors go away! Great! Except if you were my newbie, in the code review I’d tell you clone is banned unless you can tell me why you need it.]]></description><guid isPermaLink="false">ecccd5a6-53e0-4e7a-9ece-f02450f3eb2f</guid><pubDate>Tue, 21 May 2019 00:00:00 +0000</pubDate><dc:creator>Brandon Matthews</dc:creator></item><item><title>Putting the stack back into Stacked Borrows</title><link>https://www.ralfj.de/blog/2019/05/21/stacked-borrows-2.1.html</link><description><![CDATA[Less than a month ago, I announced Stacked Borrows 2. In particular, I hoped that that version would bring us closer to proper support for two-phase borrows. Turns out I was a bit too optimistic! Last week, @Manishearth asked on Zulip why Miri rejected a certain program, and it turned out that the issue was related to two-phase borrows: in combination with interior mutability, behavior wasn’t always what we wanted it to be. So, I went back to the drawing board and tried to adjust Stacked Borrows.

In the end, I decided to give up on “proper” support for two-phase borrows for now, which I explained here. But I also made some tweaks to Stacked Borrows that affect all accesses (not just two-phase borrows), and that’s what this post is about. I am referring to this as “Stacked Borrows 2.1”.]]></description><guid isPermaLink="false">c12cd1dc-8523-4caf-add8-4ba0322a3cb6</guid><pubDate>Tue, 21 May 2019 00:00:00 +0000</pubDate><dc:creator>Ralf Jung</dc:creator></item><item><title>Here&apos;s My Type, So Initialize Me Maybe (mem::uninitialized is deprecated)</title><link>https://gankro.github.io/blah/initialize-me-maybe/</link><description><![CDATA[Rust's infamous mem::uninitialized method has been deprecated in today's nightly build. Its replacement, MaybeUninit, has been stabilized. If you are using the former, you should migrate to using the latter as soon as possible (probably when it hits stable in 6 weeks). This was done because it was determined that mem::uninitialized was fundamentally broken, and could not be made to work.]]></description><guid isPermaLink="false">bab17ec7-d45f-40fa-963b-10c3085fa7bf</guid><pubDate>Tue, 21 May 2019 00:00:00 +0000</pubDate><dc:creator>Alexis Beingessner</dc:creator></item><item><title>dtolnay/case-studies: Analysis of various tricky Rust code</title><link>https://github.com/dtolnay/case-studies</link><description><![CDATA[This repository showcases some examples of tricky Rust code that I have encountered during my years working with a variety of advanced macro libraries in Rust (my own and others').]]></description><guid isPermaLink="false">4dfd194e-9cc6-4b75-b2f4-8900d8fdebcd</guid><pubDate>Tue, 21 May 2019 00:00:00 +0000</pubDate><dc:creator>David Tolnay</dc:creator></item><item><title>mini-aio: the new async IO library for Rust</title><link>http://antoyo.ml/mini-aio-new-async-io-library</link><description><![CDATA[During my work at Adgear, I’ve been working for a while on an async IO library for Rust. This post will present this new library. This library takes a very different approach than most other async IO libraries in Rust: it is actually inspired by the Pony programming language. So, it does not use futures, it does not use async/await: it just provides simple trait]]></description><guid isPermaLink="false">db12537e-42d3-4bba-9c68-7adc1afec917</guid><pubDate>Mon, 20 May 2019 00:00:00 +0000</pubDate><dc:creator>Antoni Boucher</dc:creator></item><item><title>Polyglot Projects</title><link>https://myrrlyn.net/blog/misc/polyglot-projects</link><description><![CDATA[An exploration of how I wrote a C++ binding API for my Rust library.]]></description><guid isPermaLink="false">812b46b0-ec10-45f3-9fc6-4aaa2ae2534e</guid><pubDate>Mon, 20 May 2019 00:00:00 +0000</pubDate><dc:creator>Alexander Payne</dc:creator></item><item><title>The 2019 Rust Event Lineup</title><link>https://blog.rust-lang.org/2019/05/20/The-2019-Rust-Event-Lineup.html</link><description><![CDATA[We're excited for the 2019 conference season, which we're actually late in writing up. Some incredible events have already happened! Read on to learn more about all the events occurring around the world, past and future.]]></description><guid isPermaLink="false">5c93aa16-acee-46d1-8a08-462d9ce7c09f</guid><pubDate>Mon, 20 May 2019 00:00:00 +0000</pubDate><dc:creator>Rust Community Team</dc:creator></item><item><title>powerset-enum - anonymous enum and a PoC for how that feature can be used to improve Rust&apos;s error handling</title><link>https://www.reddit.com/r/rust/comments/bqn9e6/announcing_the_powersetenum_crate_a_poor_mans/</link><description><![CDATA[My crate offers a powerset enum - an enum that can be parametrized to any subset of it's variants. I also included a macro for doing this parametrization by providing the types of the variants - so for example Error![std::io::Error, serde_json::Error] would generate a subset of the enum that can only have IO and JSON parsing errors.]]></description><guid isPermaLink="false">feed408e-361c-4a9c-9432-5729aed1e789</guid><pubDate>Mon, 20 May 2019 08:50:00 +1000</pubDate><dc:creator>someboddy</dc:creator></item><item><title>Scala Developer Journey into Rust - Part 5: Domain Models</title><link>http://blog.madhukaraphatak.com/rust-scala-part-5/</link><description><![CDATA[Rust is one of the major programming languages that’s been getting popular in recent years. It has many advanced high level language features like Scala. This made me interested to learn Rust. So in this next series of blogs I will share my experience with Rust from a Scala developer point of view. I would like to explore how these two language approach things. I would like to explore the similarities and their differences.

This is fifth post in the series. In this post, I will be talking about domain models.]]></description><guid isPermaLink="false">d6fe8e42-6394-4db9-858e-e572740e0915</guid><pubDate>Sun, 19 May 2019 00:00:00 +0000</pubDate><dc:creator>Madhukara Phatak</dc:creator></item><item><title>Rust In Avast</title><link>https://vorner.github.io/2019/05/19/rust-in-avast.html</link><description><![CDATA[When I joined Avast about a year and a half ago, I did it because of two things:  I wanted to work on interesting problems and I wanted to share the Wisdom of Rust with few more people.

Originally, I was hired because of my experience with writing software for „bigger embedded“ (think a home router or Raspberry PI ‒ it runs Linux kernel, has a shell, but the file system is a bad joke, your libc has bunch of weird bugs features, you really need to think twice not to waste RAM needlessly and you have to cross-compile), low-level networking knowledge and C++.

But I don’t enjoy writing C++ (not speaking about the libc features). And I have other skills I like to practice too. So I would drop an occasional comment about how this or that would be better done in Rust. I’ve done internal courses and workshops about Rust for whoever was interested, in the hope more people would start asking to be allowed to do stuff in Rust and I could participate in such projects.]]></description><guid isPermaLink="false">eedb81ef-265f-4dc2-a1d9-559d2d68594d</guid><pubDate>Sun, 19 May 2019 00:00:00 +0000</pubDate><dc:creator>Michal &apos;vorner&apos; Vaner</dc:creator></item><item><title>Rust for OOP - Project Management</title><link>https://oribenshir.github.io/afternoon_rusting/blog/project-management</link><description><![CDATA[The basics of Rust project layout are simple, and common to many other languages. You have the artifacts of your project. The basics artifacts are executables(binaries) and libraries. You use binaries whenever you want to produce a runnable application. For reusable code, use libraries. Nothing remarkable in Rust. In my projects, I prefer to write almost everything inside libraries, as one can never know when he will reuse a piece of code. Usually, I want my executable to be a thin wrapper around my libraries. Rust has a uniform name for a single library or binary: crate. Meaning crate is either an executable or a library. Creating either a library or a binary crate is straightforward.]]></description><guid isPermaLink="false">e8a7784f-8334-4e7a-b912-a6c3cfbb5522</guid><pubDate>Sat, 18 May 2019 00:00:00 +0000</pubDate><dc:creator>Ori Ben-Shir</dc:creator></item><item><title>Momo · Get Back Some Compile Time From Monomorphization</title><link>https://llogiq.github.io/2019/05/18/momo.html</link><description><![CDATA[Monomorphization has one problem (apart from being a ridiculous word that I’ll probably spell wrong every time): It generates rather a lot of code, bloating binary size and potentially pessimizing execution cache usage. Often, generics aren’t really needed for speed, but for ergonomics: Library code might want to present an easy-to-use generic interface that will automate some conversions. However, this often means that almost each user gets their own version of the code, leading to the aforementioned bloat (case in point: Earlier clap versions were notorious for adding hundreds of kilobytes to the binary size – for a simple command line parser).]]></description><guid isPermaLink="false">568fdc54-427f-47be-8849-dd040bafe8dd</guid><pubDate>Sat, 18 May 2019 00:00:00 +0000</pubDate><dc:creator>Llogiq</dc:creator></item><item><title>Image processing experiments (1)</title><link>https://toswak.net/blog/image-processing-experiments-1-rust/</link><description><![CDATA[I implemented an image processing experiment in Rust and was positively surprised.]]></description><guid isPermaLink="false">1c9745cb-ea4b-4d95-81b4-c51c4a217602</guid><pubDate>Sat, 18 May 2019 00:00:00 +0000</pubDate><dc:creator>Tobias Watzek</dc:creator></item><item><title>My Project to Write Embedded OS in Rust</title><link>https://medium.com/@garasubo/my-project-to-write-embedded-os-in-rust-eadf83f5ee37</link><description><![CDATA[My experience writing embedded OS in Rust. The target architecture is Arm Cortex-M series. My application is running on Nucleo-F4291ZI board and QEMU. Currently, I implemented those functionality: Round-robin scheduler to schedule processes running in Thread mode, SVC interfaces to call kernel function for user processes (e.g. print messages using USART, sleep to wait for interrupts), Move to sleep mode to wait for interrupt when there is no executable processes. There are only a few functionality yet, but the core structure is being completed, I think.]]></description><guid isPermaLink="false">a534602d-8f20-4c12-800d-adbab4f62ca0</guid><pubDate>Fri, 17 May 2019 23:01:00 +0000</pubDate><dc:creator>garasubo (ガラスボー)</dc:creator></item><item><title>Evaluating pipelined rustc compilation</title><link>https://internals.rust-lang.org/t/evaluating-pipelined-rustc-compilation/10199</link><description><![CDATA[Recently landed in nightly is the ability for Cargo to execute rustc in a “pipelined” fashion which has the promise of faster build times across the ecosystem. This support is turned off by default and the Cargo team is interested to gather more data and information about this feature, and that’s where you come in! If you’re interested in faster compiles, we’re interested in getting your feedback on this feature!]]></description><guid isPermaLink="false">64f26c72-e208-4900-90b5-cd1c61ec450b</guid><pubDate>Fri, 17 May 2019 16:09:30 +0000</pubDate><dc:creator>Alex Crichton</dc:creator></item><item><title>Using Rust to Scale Elixir for 11 Million Concurrent Discord Users</title><link>https://blog.discordapp.com/using-rust-to-scale-elixir-for-11-million-concurrent-users-c6f19fc029d3</link><description><![CDATA[Over the last year, the Backend Infrastructure team at Discord was hard at work improving the scalability and performance of our core real-time communications infrastructure. One big project we undertook was changing how we update the Member List.]]></description><guid isPermaLink="false">2d643e8c-a753-49c4-b18a-3323bb783259</guid><pubDate>Fri, 17 May 2019 15:42:16 +0000</pubDate><dc:creator>Matt Nowack</dc:creator></item><item><title>Tutorial: Use FlatBuffers in Rust</title><link>https://rwinslow.com/posts/use-flatbuffers-in-rust/</link><description><![CDATA[The FlatBuffers project is an extremely efficient schema-versioned serialization library. In this tutorial, you’ll learn how to use it in Rust.]]></description><guid isPermaLink="false">7d2d904d-78a6-42be-8c41-c1934b975516</guid><pubDate>Fri, 17 May 2019 00:00:00 +0000</pubDate><dc:creator>Robert Winslow</dc:creator></item><item><title>Running WebAssembly on the Kernel</title><link>https://medium.com/wasmer/running-webassembly-on-the-kernel-8e04761f1d8e</link><description><![CDATA[This is the story of our journey running Wasmer on the Linux kernel.]]></description><guid isPermaLink="false">ef3c5cdb-f130-4211-83a1-1550ea15d73f</guid><pubDate>Thu, 16 May 2019 22:37:36 +0000</pubDate><dc:creator>Heyang Zhou</dc:creator></item><item><title>Rust – Arrays? Make chains, not concat!</title><link>https://frehberg.com/2019/05/rust-arrays-make-chains-no-concat/</link><description><![CDATA[f your application needs to iterate over a bunch of items from different sources or arrays, someone with C/C++ background might copy all items into a single vector and iterate this vector. This strategy will cause high costs in terms of allocating heap memory for the consecutive vector buffer. Instead, keep the data where it is, and chain it together to form an iterator over a virtual array. The following Rust code demonstrates the chaining of multiple arrays, forming a single itertator, without any additional allocation of vector buffer in heap. ]]></description><guid isPermaLink="false">009c05c5-89b2-4519-9133-c46988d45a17</guid><pubDate>Thu, 16 May 2019 16:59:10 +0000</pubDate><dc:creator>Frank Rehberger</dc:creator></item><item><title>Cross compiling and statically linking against Rust libraries</title><link>https://medium.com/csis-techblog/cross-compiling-and-statically-linking-against-rust-libraries-2c02ee2c01af</link><description><![CDATA[A few years ago, mainly due to performance reasons, we started rewriting specific back-end services from Python to Rust, with great success. Now, for the sake of ease of development and testing, we are exploring the idea of moving parts of our C/C++ code base to Rust, too.

In order to do so, instead of re-writing everything in one swoop, we decided to try integrating Rust into our existing code base.

Following is a summary of our experiments, and a skeleton for writing a Rust library and calling it from a C/C++ application.]]></description><guid isPermaLink="false">3f754573-640a-4f2c-8c98-bcb1d2727bf9</guid><pubDate>Thu, 16 May 2019 10:29:25 +0000</pubDate><dc:creator>Tiago Seco</dc:creator></item><item><title>Papers on Rust</title><link>http://magnusmanske.de/wordpress/?p=617</link><description><![CDATA[With these crates in a basic but usable state, I went to write papers, Rust code to gather data from the above sources, and inject them into Wikidata. I wrote a Rust trait to represent a generic source, and then wrote adapter structs for each of the sources. Finally, I added some wrapper code to take a list of adapters, query them about a paper, and update Wikidata accordingly.]]></description><guid isPermaLink="false">93fbaebd-c627-46f3-89ea-1469e58ecd22</guid><pubDate>Thu, 16 May 2019 10:06:00 +0000</pubDate><dc:creator>Magnus Manske</dc:creator></item><item><title>Zero Cost Abstractions</title><link>https://boats.gitlab.io/blog/post/zero-cost-abstractions/</link><description><![CDATA[The idea of a zero cost abstraction is very important to certain programming languages, like Rust and C++, which intend to enable users to write programs with excellent performance profiles with relatively little effort. Since this idea is fundamental to the design of Rust and my work, I want to investigate, for a moment, what exactly a zero cost abstraction even is.]]></description><guid isPermaLink="false">0369c538-0c12-4b33-9211-fd410b2c38da</guid><pubDate>Thu, 16 May 2019 00:00:00 +0000</pubDate><dc:creator>boats</dc:creator></item><item><title>Terraform: generate 3-d models of geographic terrain</title><link>https://jaredforsyth.com/posts/intoducing-terraform/</link><description><![CDATA[I just spent the past two weeks building a GUI Rust app to help you generate a 3-d model of terrain from around the world, that can then be used for 3-d printing, rendering, or whatever you like.]]></description><guid isPermaLink="false">27b12f19-d9cb-4ac4-b150-14398ad2f7da</guid><pubDate>Thu, 16 May 2019 00:00:00 +0000</pubDate><dc:creator>Jared Forsyth</dc:creator></item><item><title>How to start a Rust Chat App</title><link>https://www.steadylearner.com/blog/read/How-to-start-Rust-Chat-App</link><description><![CDATA[In this post, we will learn how to build simple chat app in your local machine with Rust and simple JavaScript.]]></description><guid isPermaLink="false">e25cac18-f4ca-4872-babe-c4614327e076</guid><pubDate>Thu, 16 May 2019 00:00:00 +0000</pubDate><dc:creator>Steadylearner</dc:creator></item><item><title>Introducing Packem: a super fast experimental bundler written in Rust</title><link>https://medium.freecodecamp.org/introducing-packem-a-super-fast-experimental-bundler-written-in-rust-e981af875517</link><description><![CDATA[Packem is an experimental precompiled JavaScript module bundler primarily implemented in Rust. It can also handle a variety of other file types like YAML/TOML, fragment shader files and a lot more.]]></description><guid isPermaLink="false">3eb814d5-d467-4e34-ba31-e0a55da4da36</guid><pubDate>Wed, 15 May 2019 16:36:27 +0000</pubDate><dc:creator>Bukhari Muhammad</dc:creator></item><item><title>Rust - 4+ years later</title><link>https://fnordig.de/2019/05/15/rust-4-years-later/</link><description><![CDATA[A quick tour through my 4+ years with Rust.]]></description><guid isPermaLink="false">e710999e-81b7-433e-a2cd-d1968a619567</guid><pubDate>Wed, 15 May 2019 00:00:00 +0000</pubDate><dc:creator>Jan-Erik Rediger</dc:creator></item><item><title>4 years of Rust</title><link>https://blog.rust-lang.org/2019/05/15/4-Years-Of-Rust.html</link><description><![CDATA[On May 15th, 2015, Rust was released to the world! After 5 years of open development (and a couple of years of sketching before that), we finally hit the button on making the attempt to create a new systems programming language a serious effort!]]></description><guid isPermaLink="false">1bda7394-787a-42d1-9733-2b503a611ffb</guid><pubDate>Wed, 15 May 2019 00:00:00 +0000</pubDate><dc:creator>The Rust Core Team</dc:creator></item><item><title>Creating C/C++ APIs in Rust</title><link>https://karroffel.gitlab.io/post/2019-05-15-rust/</link><description><![CDATA[Rust is an amazing language with an even better ecosystem. Many design decisions of Rust make it a great fit to add new functionality to existing C/C++ systems or gradually replace parts of those systems!

When I tried to make a C++ API for a Rust library, I found that binding from C/C++ to Rust is better documented and has a smoother experience than binding from Rust to C/C++.]]></description><guid isPermaLink="false">6715c2d9-9049-40c2-bc29-cca235bde059</guid><pubDate>Wed, 15 May 2019 00:00:00 +0000</pubDate><dc:creator>Thomas Herzog</dc:creator></item><item><title>Rust for OOP - Series Introduction</title><link>https://oribenshir.github.io/afternoon_rusting/blog/rust-for-oop</link><description><![CDATA[While working on my simple chat program, I’ve identified some aspects of Rust, which mastering them will probably turn my code to be more idiomatic. These aspects will turn into a blog series. I’m far from mastering those aspects of Rust, but I’ll share what I’ve learned so far. And how I’ve used it in my chat project.]]></description><guid isPermaLink="false">88afb6a5-3414-407a-9ecc-4e0179e1295f</guid><pubDate>Wed, 15 May 2019 00:00:00 +0000</pubDate><dc:creator>Ori Ben-Shir</dc:creator></item><item><title>Rust – Handling Executables and their Debug-Symbols</title><link>https://frehberg.com/2019/05/rust-handling-executables-and-their-debug-symbols/</link><description><![CDATA[This post is about compiling Rust-code, the executables, the handling of the corresponding debug symbols and core-files. It highlights the importance of debug-symbols for debugging and how to split them of the binary before shipping to customer.]]></description><guid isPermaLink="false">0e504089-5eaf-4cb5-a22d-04bb587e54f9</guid><pubDate>Tue, 14 May 2019 22:24:55 +0000</pubDate><dc:creator>Frank Rehberger</dc:creator></item><item><title>State of Machine Learning in Rust</title><link>https://ehsanmkermani.com/2019/05/13/state-of-machine-learning-in-rust/</link><description><![CDATA[Every once in a while this topic comes up on a social media or Rust user channel. I’d like to describe briefly the way I see where things are going by a little bit of history as well as some information about existing flux of Machine Learning/Deep Learning frameworks and major recent trends.]]></description><guid isPermaLink="false">5d09aa3e-28c5-4535-9d07-cc3cafbb2ca2</guid><pubDate>Tue, 14 May 2019 00:48:37 +0000</pubDate><dc:creator>Ehsan M. Kermani</dc:creator></item><item><title>Rust+GNOME Hackfest #5</title><link>http://antoyo.ml/rust-gnome-hackfest-berlin</link><description><![CDATA[Last week, I went to the fifth Rust+GNOME hackfest which was in Berlin again. My goal for this hackfest was to fix this issue I opened nearly three years ago. The problem is that sometimes you want to create a widget or an object and set some properties at construction time. This might be needed when you want to set construct-only properties. For instance, you might want to create a webkit2gtk::WebView with a WebContext and a UserContentManager at the same time. That’s why a constructor was manually written for this use case.]]></description><guid isPermaLink="false">ad13d235-c5b0-454f-b35c-891006484207</guid><pubDate>Tue, 14 May 2019 00:00:00 +0000</pubDate><dc:creator>Antoni Boucher</dc:creator></item><item><title>Announcing Rust 1.34.2</title><link>https://blog.rust-lang.org/2019/05/14/Rust-1.34.2.html</link><description><![CDATA[The Error::type_id method was recently stabilized as part of Rust 1.34.0. This point release destabilizes it, preventing any code on the stable and beta channels to implement or use it, awaiting future plans that will be discussed in issue #60784.]]></description><guid isPermaLink="false">294ff4dd-a217-4d15-a378-a2ef10f6aae8</guid><pubDate>Tue, 14 May 2019 00:00:00 +0000</pubDate><dc:creator>The Rust Release Team</dc:creator></item><item><title>Build Rust environment for ESP32</title><link>http://quickhack.net/nom/blog/2019-05-14-build-rust-environment-for-esp32.html</link><description><![CDATA[What is it? Recently I heard that LLVM for xtensa is working, so I tried to build Rust for ESP32.]]></description><guid isPermaLink="false">e50d6f14-3323-48d5-b85b-e8302eddce92</guid><pubDate>Tue, 14 May 2019 00:00:00 +0900</pubDate><dc:creator>Yoshinari Nomura</dc:creator></item><item><title>What’s the best IDE for developing in Rust?</title><link>https://medium.com/cloud-native-the-gathering/whats-the-best-ide-for-developing-in-rust-5087d46006f5</link><description><![CDATA[A curation of opinions and facts on a variety of Rust IDEs.]]></description><guid isPermaLink="false">154c7165-f0e5-46e1-96e7-c8338485549f</guid><pubDate>Mon, 13 May 2019 06:43:35 +0000</pubDate><dc:creator>Tremaine Eto</dc:creator></item><item><title>Security advisory for the standard library</title><link>https://blog.rust-lang.org/2019/05/13/Security-advisory.html</link><description><![CDATA[The Rust team was recently notified of a security vulnerability affecting manual implementations of Error::type_id and their interaction with the Error::downcast family of functions in the standard library. If your code does not manually implement Error::type_id your code is not affected.]]></description><guid isPermaLink="false">593aaa73-c49a-4b38-99c7-ce2a1070723d</guid><pubDate>Mon, 13 May 2019 00:00:00 +0000</pubDate><dc:creator>The Rust Core Team</dc:creator></item><item><title>Zemeroth v0.5: ggez, WASM, itch.io, visuals, AI, campaign, tests</title><link>https://ozkriff.github.io/2019-05-13--devlog-zemeroth-v0-5/</link><description><![CDATA[Zemeroth is a turn-based hexagonal tactical game written in Rust. You can download precompiled v0.5 binaries for Windows, Linux, and macOS. Also, now you can play an online version (read more about it in the "WebAssembly version" section).]]></description><guid isPermaLink="false">8922aaed-cc0e-482a-8422-d7dceec6dac3</guid><pubDate>Mon, 13 May 2019 00:00:00 +0000</pubDate><dc:creator>Andrey Lesnikov</dc:creator></item><item><title>Manticore Operating System</title><link>https://github.com/manticoreos/manticore</link><description><![CDATA[Manticore is a research operating system, written in Rust, with the aim of exploring the parakernel OS architecture.

The OS is increasingly a bottleneck for server applications that want to take maximum advantage of the hardware. Many traditional kernel interfaces (such as in POSIX) were designed when I/O was significantly slower than the CPU. However, today I/O is getting faster, but single-threaded CPU performance has stagnated. For example, a 40 GbE NIC can receive a cache-line sized packet faster than the CPU can access its last-level cache (LLC), which makes it tricky for an OS to keep up with packets arriving from the network. Similarly, non-volatile memory (NVM) access speed is getting closer to DRAM speeds, which challenges OS abstractions for storage.

To address this OS bottleneck, server applications are increasingly adopting kernel-bypass techniques. For example, the Seastar framework is an OS implemented in userspace, which implements its own CPU and I/O scheduler, and bypasses the Linux kernel as much as it can. Parakernel is an OS architecture that eliminates many OS abstractions (similar to exokernels) and partitions hardware resources (similar to multikernels) to facilitate high-performance server application with increased application-level parallelism and predictable tail latency.]]></description><guid isPermaLink="false">0650fe18-12a0-40f4-916f-1a5c2464b9d5</guid><pubDate>Mon, 13 May 2019 00:00:00 +0000</pubDate><dc:creator>Pekka Enberg</dc:creator></item><item><title>Shell Completions in Pure Rust</title><link>https://www.joshmcguigan.com/blog/shell-completions-pure-rust/</link><description><![CDATA[Custom completion behavior is configured using a special bash built-in called complete. complete can be used to designate either a bash function or any other command as the completion script for a particular command. When the user requests completions for a command, complete will run specified code, passing in as args information about what the user has already typed, and expecting as output the completion suggestions. Typically these completion scripts are written in bash, but we’ll look at how it is possible to write them in Rust.]]></description><guid isPermaLink="false">fdf7f732-0af5-4031-9135-4b1db1ebfc28</guid><pubDate>Sun, 12 May 2019 00:00:00 +0000</pubDate><dc:creator>Josh Mcguigan</dc:creator></item></channel></rss>