<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/"><channel><title>Read Rust - All Posts</title><link>https://readrust.net/</link><description>All Posts posts on Read Rust</description><item><title>Organizational Debt</title><link>https://boats.gitlab.io/blog/post/rust-2019/</link><description><![CDATA[We all know that classic aphorism: Year comes to an end, Rust blog post press send. This is mine.

There are lots of cool technical improvements to Rust that I want the project to achieve this year, and a few in particular that I’m definitely going to be putting a lot of time into. But this blog post is going to talk about none of them. Instead, I want to talk about organizational debt, and how badly the Rust project needs to deal with it in 2019.]]></description><guid isPermaLink="false">f0adf24b-6589-4306-a580-6cef894ad3b7</guid><pubDate>Mon, 16 Dec 2019 00:00:00 +0000</pubDate><dc:creator>withoutboats</dc:creator></item><item><title>Rust in 2019: The next year and edition</title><link>https://mgattozzi.com/rust-in-2019-the-next-year-and-edition/</link><description><![CDATA[This post is gonna be as much personal as it is both technical and people oriented. Buckle up, we’re gonna cover a lot of things, and a lot of it is not fun. This is definitely one of those, “We really need to look at ourselves in the mirror” hard truths posts. As I type this though, I’ve reflecting on the past few years with the Rust community I’m just in awe of the amount of work, dedication, and passion that’s gone into it. I started Rust when I was still starting my career and finishing up my CS degree and now we have a brand spanking new edition! So much has changed that it’s honestly mind boggling thinking about it. Even at work I gave a history of Rust presentation and it was wild being able to go “back in the day” for something that was just a regular day a few years ago.

Now I find myself thinking about the problems we face as we become an even bigger community. We have a lot of problems. They’re good problems to have, but problems that must be solved eventually. I’m gonna go through all of them, what I see as major pain points/issues we’ve solved up to now, the present problems, and ones on the horizon. I’ll cover what I think we should focus on in the upcoming year and where we can go towards for Rust’s 2nd Edition. Let’s get started!]]></description><guid isPermaLink="false">eb6cda74-6556-4a37-bd1e-0a6471b700e4</guid><pubDate>Mon, 31 Dec 2018 19:20:32 +0000</pubDate><dc:creator>Michael Gattozzi</dc:creator></item><item><title>Comparing Pythagorean triples in C++, D, and Rust</title><link>https://atilanevesoncode.wordpress.com/2018/12/31/comparing-pythagorean-triples-in-c-d-and-rust/</link><description><![CDATA[You may have recently encountered and/or read this blog post criticising a possible C++20 implementation of Pythagorean triples using ranges. In it the author benchmarks different implemetations of the problem, comparing readability, compile times, run times and binary sizes. My main language these days is D, and given that D also has ranges (and right now, as opposed to a future version of the language), I almost immediately reached for my keyboard. By that time there were already some D and Rust versions floating about as a result of the reddit thread, so fortunately for lazy me “all” I had to next was to benchmark the lot of them.]]></description><guid isPermaLink="false">6022c644-5499-422b-baab-9124f58a0c69</guid><pubDate>Mon, 31 Dec 2018 13:16:03 +0000</pubDate><dc:creator>Átila Alves Neves</dc:creator></item><item><title>What is &apos;Placement New&apos; in Rust?</title><link>http://blakesmith.me/2018/12/31/what-is-placement-new-in-rust.html</link><description><![CDATA[Placement new is a feature currently being discussed for the Rust programming language. It gives programmer control of memory allocation and memory placement, where current memory allocation implementations are hidden behind compiler internals via the Box::new interface. This is Rust’s answer to C++ placement new, allowing one to control not only when and how memory is freed, but also where it is allocated and freed from.]]></description><guid isPermaLink="false">793ef59c-ee13-4673-a06b-e65d461e7b1c</guid><pubDate>Mon, 31 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Blake Smith</dc:creator></item><item><title>All I Want for Rust 2019 is You (To Give a Talk)</title><link>https://optimistictypes.com/rust-2019/</link><description><![CDATA[A call to action for local Rust meetups.]]></description><guid isPermaLink="false">ee55b2d9-0365-406f-aaef-b4247d8fdf78</guid><pubDate>Sun, 30 Dec 2018 00:00:00 +0000</pubDate><dc:creator>J Haigh</dc:creator></item><item><title>cargo-crev and Rust 2019 fearless code reuse</title><link>https://dpc.pw/cargo-crev-and-rust-2019-fearless-code-reuse</link><description><![CDATA[In my opinion, one of the biggest reasons why Rust is so productive is that it's a superb language for code reuse. Despite all these strengths, there's one problem that sticks out like a sore thumb: trust. Every additional dependency is another piece of code that could be buggy, or even malicious. And in my opinion, it's problem so serious, that is entirely blocking the untapped potential of code reuse in Rust.]]></description><guid isPermaLink="false">ae506c52-88d5-4803-ade0-610f083298ae</guid><pubDate>Sat, 29 Dec 2018 04:43:26 +0000</pubDate><dc:creator>Dawid Ciężarkiewicz aka `dpc`</dc:creator></item><item><title>My Rust 2019 Dream: Dominate the Web</title><link>https://www.reddit.com/r/rust/comments/aac8zk/my_rust_2019_dream_dominate_the_web/?st=JQ8PQ5Z8&amp;sh=3ad6032f</link><description><![CDATA[A lot of people already know Rust is a great systems language. It can be put on embedded, feels better than C/C++ in many ways, and concurrency is way better than it was before. It's almost no doubt that Rust will continue to grow in these realms. The opportunity I see Rust has to lose though, is being the defacto language of the future of serious web programming. The dream I see is Rust as the language every one uses to create backend, front end, and perhaps even the distributed web ( wasm distributed apps on blockchain implementations).]]></description><guid isPermaLink="false">89df3ecf-8eeb-4da6-9945-3d69b6095f5e</guid><pubDate>Sat, 29 Dec 2018 00:04:23 +0000</pubDate><dc:creator>u/richardanaya</dc:creator></item><item><title>Debugging Rust with VSCode on FreeBSD</title><link>https://venshare.com/debugging-rust-with-vscode-on-freebsd/</link><description><![CDATA[The following is a set of notes for installing VSCode on FreeBSD and getting a debugger up and running in a step by step guide. I thought I would share them in a full post as having a full IDE with syntax and error highlighting along with detailed in-context explanations has been really useful as I get to grips with Rust.]]></description><guid isPermaLink="false">c4069a09-be22-45a1-a39b-3067584379a8</guid><pubDate>Fri, 28 Dec 2018 23:56:37 +0000</pubDate><dc:creator>Anton Whalley</dc:creator></item><item><title>Rust 2019 - Usability and Tools</title><link>https://crepererum.net/rust-2019-stabilization-and-ecosystem/</link><description><![CDATA[This is my personal answer to the call for Rust 2019 Roadmap blog posts. To make it easier to read I've separated the post into sections by topic: Cargo & Crates.io, Rustdoc, Language & Stdlib, Compiler & Analyzer.]]></description><guid isPermaLink="false">b6c3cfcb-a670-4295-8a94-a76931e60985</guid><pubDate>Fri, 28 Dec 2018 19:07:59 +0000</pubDate><dc:creator>Marco Neumann</dc:creator></item><item><title>Thoughts on Rust in 2019</title><link>https://medium.com/@bowlescompling/thoughts-on-rust-in-2019-6c0af39a6b76</link><description><![CDATA[2018 was a success with the stated goals of releasing “editions” and working on usability/ergonomics. My first encounter with Rust was pre-1.0 (early 2015) and I immediately saw that Rust would be my future, wherein I joked to colleagues that I’d use it to “make toasters talk”. Followed by a sizeable hiatus (lack of personal time), I came back mid-year 2018. I can say for certain that the focus on usability and ergonomics was successful. Rust is much easier to use now than it was then. Rust format (rustfmt), Rust language server (RLS), text editor support, cargo tooling, compiler messages, and ecosystem crates’ quality and diversity are all amazing. The community is crazy diverse (first language learners, experienced systems people, web-dev people, programming language theory people, etc…). The chaos is well-managed with self-organizing working groups.]]></description><guid isPermaLink="false">53e4c3d4-a70a-4caa-a4c8-17be048c93df</guid><pubDate>Fri, 28 Dec 2018 16:49:44 +0000</pubDate><dc:creator>Josh Bowles</dc:creator></item><item><title>My Wish List For Rust 2019</title><link>https://haurchefant.fr/posts/2018/12/my-wishlist-for-rust-2019/</link><description><![CDATA[For the first time, I’m writing for the Rust Roadmap blog posts call. Why this year? Maybe because after being part of the community for 3-ish years, I feel I’ve reached a level of knowledge of the language that allows me to talk about it. I’m far from being an expert, but I wrote an application of my own and I am contributing to Cobalt. Enough experience to give me some material to think about.]]></description><guid isPermaLink="false">4f647aa7-226f-4b30-b814-399284d59111</guid><pubDate>Fri, 28 Dec 2018 15:48:15 +0000</pubDate><dc:creator>Geobert Quach</dc:creator></item><item><title>Rust 2019: Address the &quot;Big&quot; Problem</title><link>https://internals.rust-lang.org/t/rust-2019-address-the-big-problem/9109</link><description><![CDATA[Tame Complexity through Community Involvement Tools]]></description><guid isPermaLink="false">fb92d7a2-b953-45d4-89b0-83cd1648cc47</guid><pubDate>Thu, 27 Dec 2018 19:10:18 +0000</pubDate><dc:creator>Sam Sieber</dc:creator></item><item><title>Announcing &apos;err-derive&apos; - yet another error handling library</title><link>https://users.rust-lang.org/t/announcing-err-derive-yet-another-error-handling-library/23594</link><description><![CDATA[err-derive A failure-like derive macro for the std Error. The source code is mostly copied from failure-derive.]]></description><guid isPermaLink="false">0461ffc8-05b3-413d-a015-c0859ed9665f</guid><pubDate>Thu, 27 Dec 2018 13:09:02 +0000</pubDate><dc:creator>Thomas Schaller</dc:creator></item><item><title>Easy Postgres extensions in Rust with pg-extend-rs</title><link>https://bluejekyll.github.io/blog/rust/2018/12/27/announcing-pg-extend.html</link><description><![CDATA[A project to make Postgres extensions in Rust easy, you might learn how to use macro_rules, attribute macros, allocators and some FFI in this post.]]></description><guid isPermaLink="false">043f0bae-caa0-4d77-8336-9ec0813a0ca0</guid><pubDate>Thu, 27 Dec 2018 07:00:00 +0000</pubDate><dc:creator>Benjamin Fry</dc:creator></item><item><title>This Year in Gfx-rs - 2018</title><link>https://gfx-rs.github.io/2018/12/27/this-year.html</link><description><![CDATA[In 2018 the project left the nursery and entered the adolescence period...]]></description><guid isPermaLink="false">9a6530f2-df83-41a2-b9fe-c2408eabbe0f</guid><pubDate>Thu, 27 Dec 2018 00:00:00 +0000</pubDate><dc:creator>gfx-rs</dc:creator></item><item><title>Thoughts on Rust in 2019</title><link>https://words.steveklabnik.com/thoughts-on-rust-in-2019</link><description><![CDATA[This year is also a bit special; in 2018, we introduced “editions” to Rust, on a roughly three-year schedule. So now is not just a good time to think about 2019, but about 2020 and 2021 as well. Rust 2015 was about “stability”. Rust 2018 was about “productivity.” I’d like Rust 2021 to be about “maturity.” In order to get there, here’s what we need in 2019.]]></description><guid isPermaLink="false">94213785-3a82-4f06-99ee-8477c184903c</guid><pubDate>Thu, 27 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Steve Klabnik</dc:creator></item><item><title>A Rusty Advent of Code</title><link>https://cprimozic.net/blog/a-rusty-aoc/</link><description><![CDATA[For the first time, I took part in the Advent of Code this year. If you haven't heard of it, it's a daily programming challenge that can be solved in any programming language. Rust was very present in the Advent of Code community with people contributing a ton of Rust-related content. In the daily solutions thread on the /r/aoc subreddit, there were always several Rust solutions posted. Advent of Code really helps show off the things that make Rust shine, demonstrating the power and utility of many community-created crates as well as the language itself.]]></description><guid isPermaLink="false">04d1c753-5242-4aa9-bff7-500a717a62bc</guid><pubDate>Thu, 27 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Casey Primozic</dc:creator></item><item><title>Rust 2019: The shift in Rust</title><link>https://vorner.github.io/2018/12/27/rust-2019.html</link><description><![CDATA[This is my answer to the call for blogposts about what I’d like the year 2019 to mean for Rust.]]></description><guid isPermaLink="false">3e7aead6-1e45-4897-8029-993214b6eb99</guid><pubDate>Thu, 27 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Michal &apos;vorner&apos; Vaner</dc:creator></item><item><title>Rust 2019 and beyond: limits to (some) growth</title><link>https://graydon2.dreamwidth.org/263429.html</link><description><![CDATA[This is a blog post (as solicited) about my suggestions for the Rust project in 2019 and beyond. I should note that I am speaking only for myself, not anyone else, and not even as a very active participant in Rust anymore. Moreover these suggestions, to a large extent, apply to many projects. Rust is just one case, but one that is currently doing some conscious year-end reflection. I should also note overall that I'm quite pleased by the trajectory of the Rust project and this suggestion is being made only in the spirit of keeping it healthy and on-track, avoiding some problems I observe developing in it, as a mostly-outsider these days.]]></description><guid isPermaLink="false">1155adc5-9d95-4185-97bb-742e3c0bd446</guid><pubDate>Wed, 26 Dec 2018 11:29:00 +0000</pubDate><dc:creator>Graydon Hoare</dc:creator></item><item><title>Barriers and Two-phase Borrows in Stacked Borrows</title><link>https://www.ralfj.de/blog/2018/12/26/stacked-borrows-barriers.html</link><description><![CDATA[My internship (“research assistantship”) with Mozilla has ended several weeks ago, and this post is a report of the most recent tweaks I made to Miri and Stacked Borrows. Neither project is by any means “done”, of course. However, both have reached a fairly reasonable state, so I felt some kind of closing report made sense. Also, if I ever want to finish my PhD, I’ll have to seriously scale down the amount of time I work on Rust – so at least from my side, things will move more slowly from now on.

In particular, installing Miri and running your test suite in it is now just a single command away! Scroll all the way down if you are not interested in the rest.]]></description><guid isPermaLink="false">152067d5-472f-4ba2-9429-6a5de749bf99</guid><pubDate>Wed, 26 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Ralf Jung</dc:creator></item><item><title>Handling failure in Rust</title><link>https://esimmler.com/handling-failure-in-rust/</link><description><![CDATA[I’ve begun to seriously dig into the Rust programming language. The learning curve is real, but I already appreciate the work they’ve put into ergonomics. I’m writing a simple photo thumbnail endpoint using the Rocket web framework (v0.4) and Image library (v0.20.1). My first pass used a lot of unwrapping to ignore potential errors. A lot can go wrong, even in this “simple” case. Rocket catches any panics thrown by route handlers, so this is about as robust as a naive equivalent in most other languages. However, Rust at least forces us to be explicit and purposeful about when we want to be sloppy. This is great for a first quick and dirty pass, but we can do much better.]]></description><guid isPermaLink="false">0a14c8b2-c25a-4733-9682-e1cc71567cc9</guid><pubDate>Wed, 26 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Erik Simmler</dc:creator></item><item><title>async-io-demo: Rust asynchronous io: from mio to stackless coroutine</title><link>https://github.com/Hexilee/async-io-demo</link><description><![CDATA[2019 is approaching. The rust team keeps their promise about asynchronous IO: async is introduced as keywords, Pin, Future, Poll and await! is introduced into standard library. I have never used rust for asynchronous IO programming earlier, so I almost know nothing about it. However, I would use it for a project recently but couldn't find many documents that are remarkably helpful for newbie of rust asynchronous programming. My purpose of writing this blog is to review and summarize, I will be happy if it can help someone who are interested in rust asynchronous programming.]]></description><guid isPermaLink="false">fe9a3482-44e2-48d3-8728-0a15b4d2fd48</guid><pubDate>Wed, 26 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Li Chenxi</dc:creator></item><item><title>Rust 2019 -- Finish Core Stuff!</title><link>https://gist.github.com/magnet/fab817fd64411f65d8d5f5109eadd5f9</link><description><![CDATA[I am a relatively new in Rust, but I believe I have gathered enough experience the last few months to enjoy its strengths and discover some of its current shortcomings. Being relatively new at Rust, I am also of this generation that started immediately with Edition 2018. I switched to nightly very early on, and recently have been porting some code back to stable (1.31.x). I am overall very satisfied with Rust, but sometimes I come across something that doesn't work as I hoped. Every time that happens, I discover there is work-in-progress solving these issues, including, most of the time, a merged RFC, a nightly implementation behind feature gates or at least some blogs from core developers. Many time, the work I come across is from many years back.

I have read several #Rust2019 and I want to use this opportunity to agree with those that suggest to finish current core stuff.]]></description><guid isPermaLink="false">055bf639-2649-43e8-8604-91388b069c98</guid><pubDate>Tue, 25 Dec 2018 19:03:55 +0000</pubDate><dc:creator>Simon Chemouil</dc:creator></item><item><title>Currying in rust Part 3 (The circle of life ... aka why borrowchecker ... why?!)</title><link>https://hashnode.com/post/currying-in-rust-part-3-the-circle-of-life-aka-why-borrowchecker-why-cjq3z1dd800dknds1sls4dqav</link><description><![CDATA[Today we're going to take a look at the 'pipe' function my friend has written and why all of the sudden lifetimes get important esp. when using references.]]></description><guid isPermaLink="false">bddc8eb0-f2db-4330-87fa-2eca9a68e9e5</guid><pubDate>Tue, 25 Dec 2018 16:35:00 +0000</pubDate><dc:creator>j</dc:creator></item><item><title>Jix&apos; Site: Introducing partial_ref</title><link>https://jix.one/introducing-partial_ref/</link><description><![CDATA[Recently there has been some discussion about interprocedural borrowing conflicts in rust. This is something I’ve been fighting with a lot, especially while working on my SAT solver varisat. Around the time Niko Matsakis published his blog post about this, I realized that the existing workarounds I’ve been using in varisat have become a maintenance nightmare. Making simple changes to the code required lots of changes in the boilerplate needed to thread various references to the places where they’re needed.

While I didn’t think that a new language feature to solve this would be something I’d be willing to wait for, I decided to sit down and figure out how such a language feature would have to look like. I knew that I wanted something that allows for partial borrows across function calls. I also prefer this to work with annotations instead of global inference. While trying to come up with a coherent design that fits neatly into the existing type and trait system, I realized that most of what I wanted can be realized in stable rust today.]]></description><guid isPermaLink="false">2508ab68-2b48-4066-a6b4-a15a4f061025</guid><pubDate>Mon, 24 Dec 2018 14:07:10 +0100</pubDate><dc:creator>Jannis Harder</dc:creator></item><item><title>Rust 2019: Ignorant Thoughts</title><link>http://www.russet.org.uk/blog/3207</link><description><![CDATA[I’ve written a single library in Rust, called Horned-OWL for manipulating OWL. The experience has been positive. There is already a good and complete library for manipulating OWL called the OWL API, so I needed a strong motivation for writing another. That motivation is simple: the OWL API is in Java and it is slow. Rust has fulfilled it’s promise for me; Horned-OWL is an order of magnitude faster thatn the OWL API. What have I learned from the experience though, and what could be improved?]]></description><guid isPermaLink="false">5a894193-9c56-4f80-8e38-546cadf5da44</guid><pubDate>Mon, 24 Dec 2018 09:05:36 +0000</pubDate><dc:creator>Phillip Lord</dc:creator></item><item><title>Rust in 2019</title><link>https://blog.strake.me.uk/archives/93</link><description><![CDATA[Rust made good progress in 2018: const fn in particular was a welcome and sorely needed feature. With #[panic_handler] now stable, we can finally write no_std binary crates on stable and not worry the next release will break it. We got some other useful features, including the following: u128, NonNull, fixed-length slice patterns, LTO, #[repr(transparent)], #[repr(align(_))] In 2019, I have one major wish for Rust: Const Generics.]]></description><guid isPermaLink="false">f90bfac4-bbae-4d28-baec-d46eadb5e2cb</guid><pubDate>Mon, 24 Dec 2018 02:52:50 +0000</pubDate><dc:creator>Strake</dc:creator></item><item><title>Rust for algorithms</title><link>https://ilyabiz.com/2018/12/rust-for-algorithms/</link><description><![CDATA[How I decided to challenge myself and solve coding tasks using Rust]]></description><guid isPermaLink="false">525bee43-14cb-422e-8b91-58322a8d2c63</guid><pubDate>Sun, 23 Dec 2018 20:54:31 +0000</pubDate><dc:creator>Ilya Bizyaev</dc:creator></item><item><title>Rust &amp; Python—A Gentle Comparison using Simple Neural Networks</title><link>https://blog.digital-horror.com/rust-python-comparison/</link><description><![CDATA[A gentle comparison between Rust & Python from multiple perspectives against a small, relatively simple problem.]]></description><guid isPermaLink="false">6aa36df9-001c-478b-830e-56e2b896303b</guid><pubDate>Sun, 23 Dec 2018 17:10:39 +0000</pubDate><dc:creator>Juxhin Dyrmishi Brigjaj</dc:creator></item><item><title>On Rust</title><link>https://dehora.net/journal/2018/12/23/on-rust</link><description><![CDATA[Back in 2013, I started a series of posts on programming languages I found interesting. One of the languages I wanted to write about at that time was Rust. As often happens, life got in the way, and it’s only now, in the twilight of 2018 I’m coming round to a long overdue post.]]></description><guid isPermaLink="false">0717e76b-2097-4ee0-87b1-5f6cffadbdf0</guid><pubDate>Sun, 23 Dec 2018 16:34:59 +0000</pubDate><dc:creator>Bill de hÓra</dc:creator></item><item><title>Visualizing Crates.io</title><link>https://8-p.info/visualizing-crates-io/</link><description><![CDATA[Visualizing Rust's growing ecosystem through crates.io, Rust's central package repository.]]></description><guid isPermaLink="false">7dd6ca97-374d-4c01-86fb-f3fed29bb6f6</guid><pubDate>Sun, 23 Dec 2018 12:06:00 +0000</pubDate><dc:creator>Kazuyoshi Kato</dc:creator></item><item><title>Serverless Rust: Revisited</title><link>https://medium.com/@softprops/serverless-rust-revisited-f2c79f4039bb</link><description><![CDATA[A refreshing new story for running Rust on AWS Lambda.]]></description><guid isPermaLink="false">164aa143-a832-491e-b1c0-304913959b8d</guid><pubDate>Sat, 22 Dec 2018 15:43:04 +0000</pubDate><dc:creator>Doug Tangren</dc:creator></item><item><title>Converting a Python library to Rust</title><link>https://alantrick.ca/writings/programming/python_to_rust/</link><description><![CDATA[I rewrote a Python project in Rust. The rewrite took a fair bit longer than expected, but the results were good (about 9 times faster and ½ the memory usage). In the process, I learned a fair bit about Rust.]]></description><guid isPermaLink="false">f6f38aae-10b9-4c71-b4fd-c0412a56e064</guid><pubDate>Sat, 22 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Alan Trick</dc:creator></item><item><title>Methods for Array Initialization in Rust</title><link>https://www.joshmcguigan.com/blog/array-initialization-rust/</link><description><![CDATA[Arrays in Rust are fixed size, and Rust requires that every element in an array is initialized to a valid value when the array is initialized. The result of these requirements is array initialization in Rust is a much deeper topic then it would seem.]]></description><guid isPermaLink="false">5e9ee3df-617a-4a7c-b8bd-ade701971b10</guid><pubDate>Sat, 22 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Josh Mcguigan</dc:creator></item><item><title>Azure Functions written in Rust</title><link>https://robertohuertas.com/2018/12/22/azure-function-rust/</link><description><![CDATA[A few days ago, we discussed how to write AWS Lambdas in Rust. Today, we’re going to learn how to create and deploy an Azure Function using Rust and the azure-functions-sdk library.]]></description><guid isPermaLink="false">f0df7d96-1aae-46ea-b454-d4d2ce7d3efd</guid><pubDate>Sat, 22 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Roberto Huertas</dc:creator></item><item><title>Rust2019</title><link>https://medium.com/@softprops/rust2019-83ebfe46602e</link><description><![CDATA[It’s the time year to reflect on the past and to make wishful prospects for the future.]]></description><guid isPermaLink="false">1c724779-9e18-4c1a-94db-7799f444f6b3</guid><pubDate>Fri, 21 Dec 2018 05:47:42 +0000</pubDate><dc:creator>Doug Tangren</dc:creator></item><item><title>Six years with Rust</title><link>https://words.steveklabnik.com/six-years-with-rust</link><description><![CDATA[This past year was… intense. Rust 1.31 was basically Rust 2.0, at least in the marketing sense. I burned myself out getting the first edition of the book together for Rust 1.0, and I burned myself out getting the edition shipped.

Let’s talk about the bad and the good. Bad first so we end on the high notes.]]></description><guid isPermaLink="false">deb0916b-c8e3-47b1-b957-bfa8015b73ff</guid><pubDate>Fri, 21 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Steve Klabnik</dc:creator></item><item><title>Procedural Macros in Rust 2018</title><link>https://blog.rust-lang.org/2018/12/21/Procedural-Macros-in-Rust-2018.html</link><description><![CDATA[Perhaps my favorite feature in the Rust 2018 edition is procedural macros. Procedural macros have had a long and storied history in Rust (and will continue to have a storied future!), and now is perhaps one of the best times to get involved with them because the 2018 edition has so dramatically improved the experience both defining and using them.

Here I'd like to explore what procedural macros are, what they're capable of, notable new features, and some fun use cases of procedural macros. I might even convince you that this is Rust 2018's best feature as well!]]></description><guid isPermaLink="false">e01f334f-a14e-4a54-b7d7-76c9cc6ccdc7</guid><pubDate>Fri, 21 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Alex Crichton</dc:creator></item><item><title>Rust in 2019: Working through the growing pains</title><link>https://isaacwoods.tk/rust_2019/</link><description><![CDATA[TLDR: this post is not as eloquent as I’d like it to be, but the main takeaway
is that Rust is still a fast growing language, and has experienced expected growing pains,
both social and technological. This is okay, and we as the community need to
work through these pains, with the teams, not despite them.]]></description><guid isPermaLink="false">df592561-9217-416a-bb32-5d610d948fad</guid><pubDate>Wed, 19 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Isaac Woods</dc:creator></item><item><title>Rust 2019: Stabilization</title><link>https://blog.ryanlevick.com/posts/rust-2019/</link><description><![CDATA[If you’re familiar with the history of Rust you might be confused with a call to stabilization. After all, Rust 2015 (a.k.a 1.0) was all about stabilization and the team has actually done a pretty good job with achieving this goal. So what gives?

While Rust 2015 defined stabilization around language backward compatibility, it’s time for the language, the tooling, the ecosystem and the governance to stabilize. Each of these characterize stability in a different way. Let me explain a bit more what I mean.]]></description><guid isPermaLink="false">1b761099-8ee4-4e1c-86b1-2aeac151507c</guid><pubDate>Wed, 19 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Ryan Levick</dc:creator></item><item><title>gbl: A typestate-powered zero-copy crate for GBL firmware update files</title><link>https://blog.1aim.com/post/gbl-release/</link><description><![CDATA[After a few weeks of reverse-engineering, internal dogfooding, and API design discussion, we're finally publishing our gbl crate for good.

The library implements a parser and writer for GBL firmware update containers, which are used to perform secure OTA updates for certain microcontrollers.]]></description><guid isPermaLink="false">aa59c999-cba6-4f20-80cc-888e8e257a73</guid><pubDate>Wed, 19 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Jonas Schievink</dc:creator></item><item><title>How to Become a Rust Super-developer</title><link>https://hashnode.com/post/how-to-become-a-rust-super-developer-cjpv1ee7e000buhs2aqrdw2ym</link><description><![CDATA[This is an article and a tutorial about stumbling and failing. It is about trying hard, and giving up - just to start all over again. All for the one goal - becoming the master of coding in Rust.]]></description><guid isPermaLink="false">5bfa329e-1d71-4b98-af03-90c1672ebb8b</guid><pubDate>Wed, 19 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Marco Alka</dc:creator></item><item><title>A great 2018, an even better 2019</title><link>https://tokio.rs/blog/2018-12-recap-2018/</link><description><![CDATA[A year ago, Tokio was a very different library. It includes the (now deprecated) tokio-core which provided a future executor, I/O selector, and basic TCP/UDP types in a single library. It also included tokio-proto, but we won't talk about that. Over the past year, Tokio has grown to become Rust's asynchronous I/O platform. It has been adopted by a number of large companies to build apps.]]></description><guid isPermaLink="false">8abe1072-74b2-4cc8-b349-ba38a3bfae1b</guid><pubDate>Wed, 19 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Carl Lerche</dc:creator></item><item><title>RTFM v0.4: +stable, software tasks, message passing and a timer queue</title><link>https://blog.japaric.io/rtfm-v4/</link><description><![CDATA[Today I’m pleased to announce v0.4.0 of the Real Time for The Masses framework (AKA RTFM), a concurrency framework for building real time applications. This release also packs quite a few new features which I’ll briefly cover in this post. For a more throughout explanation of RTFM’s task model and its capabilities check out the RTFM book, which includes examples you can run on your laptop (yay for emulation), and the API documentation.]]></description><guid isPermaLink="false">72e699cc-6b46-4f3b-9295-fef767681af8</guid><pubDate>Wed, 19 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Jorge Aparicio</dc:creator></item><item><title>My wishlist for Rust ‘19</title><link>https://apiraino.github.io/2018/12/19/call-for-2019-roadmap.html</link><description><![CDATA[This isn’t exactly a blog so this won’t be exactly a “post”, but I’d like to write down my thoughts on this notepad answering the call for a wishlist for Rust 2019. Opinions expressed are from the point of view of an enthusiast, Rust apprentice, that happened to be knee-deep involved in organizing the RustFest in Rome. It’s fun to pin today some thoughts and see in 12 months how things will have evolved!]]></description><guid isPermaLink="false">1a96907b-61a3-4b4f-aba9-640a5b6ac00e</guid><pubDate>Wed, 19 Dec 2018 00:00:00 +0100</pubDate><dc:creator>apiraino</dc:creator></item><item><title>Rust 2019: Bootstrapping Minorities</title><link>https://internals.rust-lang.org/t/rust-2019-bootstrapping-minorities/9053</link><description><![CDATA[As a response of https://blog.rust-lang.org/2018/12/06/call-for-rust-2019-roadmap-blogposts.html 3 for tooling improvement. Nice to see rust improved so much these few years on productivity but I think there is room for improvement. This would be my first post about Rust after hanging around for quite some time.]]></description><guid isPermaLink="false">3edd04cc-9a58-4b57-ab93-d948575875d9</guid><pubDate>Tue, 18 Dec 2018 14:08:45 +0000</pubDate><dc:creator>Ivan Tham</dc:creator></item><item><title>Intermission</title><link>https://azriel.im/will/2018/12/18/intermission/</link><description><![CDATA[Things I would like prioritized in the 2019 roadmap: Reduced Compilation Times, Refined Tools.]]></description><guid isPermaLink="false">f11f3bca-353a-4c96-b50d-7a28acb0d7ec</guid><pubDate>Tue, 18 Dec 2018 11:31:13 +1300</pubDate><dc:creator>Azriel Hoh</dc:creator></item><item><title>Rust 2019 wish-list</title><link>https://www.reddit.com/r/rust/comments/a6y6my/rust_2019_wishlist/</link><description><![CDATA[I'm writing in Rust a lot less than what I'd like, in part because of the lack of time, in part because the language and developer experience are already good. What I found missing is...]]></description><guid isPermaLink="false">536bfa8b-ba21-44b5-b570-3e5850de6320</guid><pubDate>Mon, 17 Dec 2018 20:06:00 +0000</pubDate><dc:creator>Matteo Bertini</dc:creator></item><item><title>Tools in the 2018 edition</title><link>https://blog.rust-lang.org/2018/12/17/Rust-2018-dev-tools.html</link><description><![CDATA[In this blog post I'll cover Clippy and Rustfmt – two tools that have been around for a few years and are now stable and ready for general use. I'll also cover IDE support – a key workflow for many users which is now much better supported. I'll start by talking about Rustfix, a new tool which was central to our edition migration plans.]]></description><guid isPermaLink="false">629810d5-0f02-4ef1-9826-32cd4bc2f048</guid><pubDate>Mon, 17 Dec 2018 00:00:00 +0000</pubDate><dc:creator>The Dev-tools team</dc:creator></item><item><title>Rust 2019: Go Slow</title><link>https://blog.hwc.io/posts/rust-2019/</link><description><![CDATA[I have many technical wishes for Rust, the language, in 2019. However, I’m not going to mention any in particular in this post. In fact, I can almost say that I’d prefer for there to not be a focus on achieving technical milestones in the next year.]]></description><guid isPermaLink="false">8d54d930-66a9-438f-8dad-de13e2fe8c3c</guid><pubDate>Sun, 16 Dec 2018 15:39:32 -0500</pubDate><dc:creator>hwc</dc:creator></item><item><title>Rust 2019</title><link>https://gist.github.com/xd009642/083a689c1fe460459d6bc792a626604e</link><description><![CDATA[This is a bit of a brain dump of my thoughts about Rust 2019. Mainly I work on my own code coverage tool tarpaulin, embedded rust and random little tools. So my perspective will be coloured by this.]]></description><guid isPermaLink="false">34b69da0-cd61-4a16-8bfe-21d8d98dd4bd</guid><pubDate>Sun, 16 Dec 2018 15:22:21 +0000</pubDate><dc:creator>xd009642</dc:creator></item><item><title>My thoughts on Rust 2019</title><link>https://raphlinus.github.io/rust/2018/12/16/rust-2019.html</link><description><![CDATA[Recently, the Rust Core Team solicited blog posts on where Rust should be headed in 2019. Here’s mine.]]></description><guid isPermaLink="false">94ad8d78-4b62-41ff-86c3-44690a1dbf66</guid><pubDate>Sun, 16 Dec 2018 14:55:42 +0000</pubDate><dc:creator>Raph Levien</dc:creator></item><item><title>Making Rust Float Parsing Fast and Correct</title><link>https://www.reddit.com/r/rust/comments/a6j5j1/making_rust_float_parsing_fast_and_correct/</link><description><![CDATA[Previously, I wrote about how Rust parsing is atypically slow comparing Rust's libcore implementation to a rudimentary parser I wrote. However, as others noted, the comparison was fairly limited. It didn't compare Rust's implementation to other implementations, such as glibc's strtod or Go's ParseFloat. The parser I implemented wasn't correct, it led to rounding error for most representations, by using floats for intermediate values. Furthermore, the comparisons used data unlikely to be encountered in real-world datasets, overstating the performance differences by forcing Rust to use slower algorithms. So, naturally, I aimed to address all these concerns. And finally, I forgot to disable CPU scaling, meaning CPU throttling could have led to inconsistent benchmarks.]]></description><guid isPermaLink="false">f848772a-4132-4e4f-b817-c4a6dec365b7</guid><pubDate>Sun, 16 Dec 2018 08:39:39 +1100</pubDate><dc:creator>u/ialex32_2</dc:creator></item><item><title>QADAPT - debug_assert! for your memory usage</title><link>https://speice.io/2018/12/allocation-safety.html</link><description><![CDATA[I think it’s part of the human condition to ignore perfectly good advice when it comes our way. A bit over a month ago, I was dispensing sage wisdom for the ages: I had a really great idea: build a custom allocator that allows you to track your own allocations. I gave it a shot, but learned very quickly: never write your own allocator. I proceeded to ignore it, because we never really learn from our mistakes. There’s another part of the human condition that derives joy from seeing things explode. And that’s the part I’m going to focus on.]]></description><guid isPermaLink="false">e72d0a8e-198f-4bd2-bf1e-7e0e94fac9d5</guid><pubDate>Sat, 15 Dec 2018 00:00:00 -0500</pubDate><dc:creator>Bradlee Speice</dc:creator></item><item><title>Creating an empty iterator of a certain type in Rust</title><link>https://www.freedomlayer.org/offst/option-iterator/</link><description><![CDATA[I am working these days on the development of offst's Index server. I needed to implement a basic directed graph structure, allowing to run the BFS algorithm to find routes with a certain amount of capacity. During the work on the Index server I had the problem of wanting to return an empty iterator in an early flow of a function.]]></description><guid isPermaLink="false">3f750cea-55f1-44cf-b965-b3a2803de32b</guid><pubDate>Sat, 15 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Freedomlayer</dc:creator></item><item><title>Rust Analyzer in 2018 and 2019</title><link>https://ferrous-systems.com/blog/rust-analyzer-2019/</link><description><![CDATA[Hi! I am Aleksey Kladov (aka @matklad). In the past, I've worked at Jet Brains where I've helped to create the IntelliJ Rust plug-in, and now I am a part of the Ferrous Systems team.

I've spent a significant amount of the last year experimenting with various approaches to make the Rust IDE story better. The culmination of my experiments is the rust-analyzer project – an experimental Rust compiler frontend, targeting the IDE/Language Server Protocol use case.]]></description><guid isPermaLink="false">bf6eb06b-346b-4f0c-a294-ee1dde663418</guid><pubDate>Sat, 15 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Aleksey Kladov</dc:creator></item><item><title>Kubernetes config management in Rust</title><link>https://clux.github.io/probes/post/2018-12-15-config-management-in-rust/</link><description><![CDATA[At babylon health we have a ton of microservices running on kubernetes that are, in turn, controlled by hundreds of thousands of lines of autogenerated yaml. So for our own sanity, we built shipcat - a standardisation tool (powered by rust-lang and serde) to control the declarative format and lifecycle of every microservice.]]></description><guid isPermaLink="false">0ee5d609-1891-4f10-9085-93696f564382</guid><pubDate>Sat, 15 Dec 2018 00:00:00 +0000</pubDate><dc:creator>clux</dc:creator></item><item><title>Rust and WebAssembly in 2019</title><link>http://fitzgeraldnick.com/2018/12/14/rust-and-webassembly-in-2019.html</link><description><![CDATA[Compiling Rust to WebAssembly should be the best choice for fast, reliable code for the Web. Additionally, the same way that Rust integrates with C calling conventions and libraries on native targets, Rust should also integrate with JavaScript and HTML5 on the Web. These are the Rust and WebAssembly domain working group’s core values. In 2018, we made it possible to surgically replace performance-sensitive JavaScript with Rust-generated WebAssembly. I propose that we make larger-scale adoption of Rust and WebAssembly practical in 2019.]]></description><guid isPermaLink="false">f12043be-3b2d-4ab3-8ce1-51463ffad905</guid><pubDate>Fri, 14 Dec 2018 00:00:00 -0800</pubDate><dc:creator>Nick Fitzgerald</dc:creator></item><item><title>Rust 2019</title><link>https://hsivonen.fi/rust2019/</link><description><![CDATA[The Rust team encouraged people to write blog posts reflecting on Rust in 2018 and proposing goals and directions for 2019. Here’s mine. This is knowingly blatantly focused on the niche that is immediately relevant to my work. I don’t even pretend this to represent any kind of overall big picture.]]></description><guid isPermaLink="false">2bc063a6-80f5-4f7b-aea3-329ceef00a8e</guid><pubDate>Fri, 14 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Henri Sivonen</dc:creator></item><item><title>My Wishes for Rust 2019</title><link>https://cetra3.github.io/blog/rust-2019/</link><description><![CDATA[2018 was a massive year for rust, and it's great to reflect back on how far we've all come. My main wish for the new year is to put on the breaks a little bit, and finish off what has been started without taking on anything majorly new.]]></description><guid isPermaLink="false">fde9a5b7-9e92-41aa-994a-15bdb87d2909</guid><pubDate>Fri, 14 Dec 2018 00:00:00 +0000</pubDate><dc:creator>cetra3</dc:creator></item><item><title>Rust 2019 - my 2¢</title><link>https://www.reddit.com/r/rust/comments/a5s024/rust_2019_my_2/</link><description><![CDATA[I will not be really original here, but I really hope to see the following features to land on stable in 2019: const generics, async/await, GATs, inherent traits, minimum supported Rust version:]]></description><guid isPermaLink="false">dd6ec508-904b-4cd2-96ca-3df2ed99b074</guid><pubDate>Thu, 13 Dec 2018 20:24:49 +1100</pubDate><dc:creator>u/newpavlov</dc:creator></item><item><title>Rust Raps - Ferris Crab (Rust Raps 2018 Edition)</title><link>http://fitzgeraldnick.com/2018/12/13/rust-raps.html</link><description><![CDATA[Just released: the hot new single “Ferris Crab (Rust Raps 2018 Edition)” by Rusta Rhymes off their upcoming debut album impl Drop for Mic {}.]]></description><guid isPermaLink="false">733eb57b-95f6-490b-b3aa-ba223cacb0f5</guid><pubDate>Thu, 13 Dec 2018 00:00:00 -0800</pubDate><dc:creator>Rusta Rhymes</dc:creator></item><item><title>Yet another Rust 2018 wishlist</title><link>https://www.reddit.com/r/rust/comments/a5q7eb/yet_another_rust_2018_wishlist/</link><description><![CDATA[The 2018 year brought a lot of incredible new features and I'm impressed with all the work that was put in to make the 2018 edition happen. I want to join the other users asking for 2019 to be a year we adjust to all the new changes and focus on cleaning and polishing, not entirely new projects*. For the upcoming year I'd like to see progress on compilation speed and maintenance attention in the library ecosystem.]]></description><guid isPermaLink="false">d4acf845-6f69-4f54-bd37-96d62f83a54c</guid><pubDate>Thu, 13 Dec 2018 15:38:32 +1100</pubDate><dc:creator>u/Saefroch</dc:creator></item><item><title>Async in Rust, circa 2018</title><link>https://rust-lang-nursery.github.io/wg-net/2018/12/13/async-update.html</link><description><![CDATA[Rust 2018 has shipped, and we’re closing in on the end of the year. While we didn’t manage to ship async/await as part of the edition itself, the community has made quite a lot of progress toward that goal. This post summarizes the state of play, and announces the publication of several crates intended to facilitate use of async/await on the nightly ecosystem.]]></description><guid isPermaLink="false">53c9e07b-f4d5-423f-8a84-05e119814fda</guid><pubDate>Thu, 13 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Aaron Turon</dc:creator></item><item><title>Edge programming with Rust and WebAssembly</title><link>https://www.fastly.com/blog/edge-programming-rust-web-assembly</link><description><![CDATA[Take a developer deep dive into Terrarium, our multi-language, browser-based editor and deployment platform at the edge. Learn how to compile Rust programs to WebAssembly right on your local machine, interact with the Terrarium system, and explore some applications we’ve built with it.]]></description><guid isPermaLink="false">78791a3b-395e-4d3b-b091-66aa2fa2c577</guid><pubDate>Wed, 12 Dec 2018 16:00:00 +0000</pubDate><dc:creator>Pat Hickey</dc:creator></item><item><title>Sinistersnare&apos;s Rust 2019 Wishlist</title><link>https://drs.is/post/rust-wishlist-2019/</link><description><![CDATA[Rust needs to focus on less glamorous features in 2019. We have added a lot of great features since 1.0, but we need to address the warts that we have had for a long time. I mostly echo sentiments from Jonathan Turner, Nathan Vegdahl, and many others in my ‘fallow-year’ sentiments. Overall, Compilation speed and generic constants are my two most wished-for features. On top of that, I would like to see more ecosystem work to make embedded applications more feasible and easy to use. Finally, Rust needs a moratorium on adding syntactic sugar for 2019.]]></description><guid isPermaLink="false">9e8f8e34-8fe9-4b4b-b40a-970e0a85a993</guid><pubDate>Wed, 12 Dec 2018 08:10:44 -0500</pubDate><dc:creator>Davis Ross Silverman</dc:creator></item><item><title>Rust 2019 - It&apos;s the Little Things</title><link>https://blog.cessen.com/post/2018_12_12_rust_2019_its_the_little_things</link><description><![CDATA[This might be an uncommon opinion—especially among those motivated enough to write a Rust 2019 post—but I actually think Rust is pretty much at a good place now. For the kinds of things that I want to do (e.g. my path tracer), there isn't much that Rust is lacking as a language. There are some fiddly things like "placement new" that could be useful, but nothing really major. And of course, well-designed new features are always welcome, they just don't seem particularly critical to me at this point. In other words, I'm pretty much satisfied. Mission accomplished, as far as I'm concerned. I think the rest is just polish. Just the little things.]]></description><guid isPermaLink="false">a884801e-f80b-4ea4-8441-a86c2c736086</guid><pubDate>Wed, 12 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Nathan Vegdahl</dc:creator></item><item><title>Rust 2019: Technical Debt, Continued Productivity, and Stability</title><link>https://gist.github.com/mark-i-m/2c3508ab7a9f2c48f634f0b5da3bb000</link><description><![CDATA[I hope this post doesn't come across as a laundry list of stuff to do. Mainly, I consider a lot of this to be technical debt, and I would like to see it paid down a bit. Most of them also happen to be pain points that I have come across in my own usage of Rust, so perhaps I'm biased! Feel free to let me know...]]></description><guid isPermaLink="false">7ebb05f4-2bc2-4637-b38d-fd29d4a1cc3c</guid><pubDate>Tue, 11 Dec 2018 23:47:53 +0000</pubDate><dc:creator>@mark-i-m</dc:creator></item><item><title>Rust 2019: Think Bigger</title><link>http://fitzgeraldnick.com/2018/12/11/rust-2019-think-bigger.html</link><description><![CDATA[Rust shines when we find ways to have our cake and eat it too: memory safety without runtime garbage collection, abstraction without overhead, threading without data races. We must find new ways to continue this tradition for Rust 2019 and beyond.]]></description><guid isPermaLink="false">c0d67320-edd6-4eef-b345-bbf3288acaae</guid><pubDate>Tue, 11 Dec 2018 00:00:00 -0800</pubDate><dc:creator>Nick Fitzgerald</dc:creator></item><item><title>Rust in 2022</title><link>https://www.ncameron.org/blog/rust-in-2022/</link><description><![CDATA[A response to the call for 2019 roadmap blog posts. In case you missed it, we released our second edition of Rust this year! An edition is an opportunity to make backwards incompatible changes, but more than that it's an opportunity to bring attention to how programming in Rust has changed. With the 2018 edition out of the door, now is the time to think about the next edition: how do we want programming in Rust in 2022 to be different to programming in Rust today? Once we've worked that out, lets work backwards to what should be done in 2019.]]></description><guid isPermaLink="false">4259e940-d508-4de3-8971-3c3df7b30f98</guid><pubDate>Tue, 11 Dec 2018 04:34:31 +0000</pubDate><dc:creator>Nick Cameron</dc:creator></item><item><title>Bootstrapping Rust</title><link>https://www.gnu.org/software/guix/blog/2018/bootstrapping-rust/</link><description><![CDATA[It has been a long-standing tradition to develop a language far enough to be able to write the language's compiler in the same language, and Rust does the same. Rust is nowadays written in Rust. We've tracked down the earlier Rust versions, which were written in OCaml, and were planning to use these to bootstrap Rust. But in parallel, John Hudge (Mutabah) developed a Rust compiler, called "mrustc", written in C++. mrustc is now good enough to compile Rust 1.19.0. Using mrustc, we were able to build Rust entirely from source with a bootstrap chain]]></description><guid isPermaLink="false">6bf8dccd-51b6-4dcb-a9eb-e38923d28a2c</guid><pubDate>Tue, 11 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Danny Milosavljevic</dc:creator></item><item><title>Positive-Sum Games</title><link>https://llogiq.github.io/2018/12/11/sum.html</link><description><![CDATA[One thing I learned from Aaron Turon is to search for positive-sum games. First what does that even mean? In most arguments you may run into, it will be easy to find a zero-sum game: Your win is my loss and vice versa. However, in many situations, it is actually possible to go above those petty games and find a variant that allows us both to win.]]></description><guid isPermaLink="false">2fdb4722-43ce-4bad-b37e-67dae34eecb2</guid><pubDate>Tue, 11 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Llogiq</dc:creator></item><item><title>Dynamically Generating Dockerfiles for K8s</title><link>https://medium.com/docql/dynamically-generating-dockerfiles-for-k8s-d2baf7bfef5a</link><description><![CDATA[Hello everyone! Today I am excited to announce that DocQL is open-sourcing a Rust crate (a library) which we built internally called…]]></description><guid isPermaLink="false">00b55ed6-da3d-4c6a-90ed-ebea6191afd8</guid><pubDate>Mon, 10 Dec 2018 19:43:10 +0000</pubDate><dc:creator>Anthony Dodd</dc:creator></item><item><title>Lokathor&apos;s Rust 2019 wishpost</title><link>https://www.reddit.com/r/rust/comments/a4ygji/lokathors_rust_2019_wishpost</link><description><![CDATA[Recently I've been using Rust for GBA development (repo link), and before that I spent most of my Rust time with Handmade Hero work (the actual repo is private to handmade hero backers, so that link is just the main website). As you might expect, this has given me a quite different view of what I want to see from Rust. Basically, I don't want more crates. I want language, and tools, and most importantly education.]]></description><guid isPermaLink="false">dcaa5235-2614-4f61-b0b4-8b1f2e0d136e</guid><pubDate>Tue, 11 Dec 2018 05:47:42 +1100</pubDate><dc:creator>u/Lokathor</dc:creator></item><item><title>Existential types in Rust</title><link>https://adelbertc.github.io/posts/2018-12-10-rust-existentials.html</link><description><![CDATA[The Rust project I am working on is a caching layer, currently backed by Redis, and it came to a point where I needed to leverage pipelining. On its own, pipelining is straightforward as the redis crate implements it already. However all notions of a cache in our code are abstracted out behind a trait so we can have alternative implementations, such as an in-memory HashMap-backed implementation.

The problem arises with representing the pipeline in code. It would force any implementation of our cache to Redis’s notion of a pipeline. Not only would this make it difficult to introspect during testing, but it would also be nonsensical for our HashMap-backed cache. My usual answer to this in languages that support higher-kinded types is to use tagless-final algebras, but Rust’s type system currently doesn’t support higher-kinded types1. Fortunately, there is a pretty good alternative that Rust does support: existential types.]]></description><guid isPermaLink="false">4fe3c55c-a091-40c2-ada0-8c5d371afc31</guid><pubDate>Mon, 10 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Adelbert Chang</dc:creator></item><item><title>Using Web Assembly in the Browser</title><link>https://ljcode.org/blog/wasm-part1/</link><description><![CDATA[WebAssembly (abbreviated Wasm) is a binary instruction format for a stack-based virtual machine. This essentially means that is is fast, because the program is compiled to a much more compact format, making it faster to parse. Wasm can be written by hand if you're looking for a challenge, but is primarily meant to be written in another language, and then compiled to Wasm. You may know a little about Assembly language and how it works - here's a quick refresher in-case you're rusty.]]></description><guid isPermaLink="false">27a7e602-da8a-4c0b-9ec1-81cc22c00df9</guid><pubDate>Mon, 10 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Luke Jones</dc:creator></item><item><title>Building Alexa Skills in Rust</title><link>https://medium.com/@amalec/building-alexa-skills-in-rust-4cf54a497ea4</link><description><![CDATA[My favorite way to explore Lambdas is to build Alexa skills because of the immediate feedback: you write a little code, and a home device talks to you. It’s a peek into the long promised of world of easy service composition.

Unfortunately, Rust didn’t have complete Alexa skill request/response handling (there is a crate from 2 years ago that handled only the basics), so I wrote one called alexa_sdk. (It’s basically a struct plus serde wrapper around the Alexa JSON spec, with some helpers.]]></description><guid isPermaLink="false">36dce8e1-2508-4e34-8aaf-1eb43a8b17e1</guid><pubDate>Sun,  9 Dec 2018 21:30:38 +0000</pubDate><dc:creator>Arien Malec</dc:creator></item><item><title>Rust 2019 -- Correctness and stabilizations</title><link>https://internals.rust-lang.org/t/rust-2019-correctness-and-stabilizations/8991</link><description><![CDATA[Last year for Rust 2018 I didn’t write a post like this, hoping to see other people write it. But even with a hundred plus posts that didn’t happen, so this year it’s the moment to speak up. I have used many different languages in past and when I started studying Rust at version 1.0 I was quickly impressed by its very good design, I was mostly in agreement with most of its design decisions, despite every useful language has a messy implementation. Even small things were designed with care. And I loved how much Rust cares for code correctness. I prefer to avoid long debug sessions and to use more time in the design and coding phases. So I’ve kept learning and using it ever since. For 2019 and beyond I’d like Rust to keep working on finishing its many unfinished parts.]]></description><guid isPermaLink="false">db72fed1-63a5-41eb-868f-716f694cd52e</guid><pubDate>Sun,  9 Dec 2018 11:38:40 +0000</pubDate><dc:creator>leonardo</dc:creator></item><item><title>Rust 2019 — let us pursue composability</title><link>https://medium.com/@GolDDranks/rust-2019-let-us-pursue-composability-70f1eb2238c3</link><description><![CDATA[We should drive home the goals set in spirit of productivity in 2019. We should also consider composibility as the next overarching theme.]]></description><guid isPermaLink="false">0e733a02-5972-4106-98a7-d0613485cac1</guid><pubDate>Sun,  9 Dec 2018 02:50:51 +0000</pubDate><dc:creator>Pyry Kontio</dc:creator></item><item><title>Rust 2019</title><link>https://vfoley.xyz/rust-2019/</link><description><![CDATA[In 2019, there are three areas where I would like to see the Rust community focus its efforts: Improved compile times, A community effort to review crates, More “80% solutions”.]]></description><guid isPermaLink="false">a02deaa2-0f75-48c6-86ef-f6a314be6355</guid><pubDate>Sun,  9 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Vincent Foley</dc:creator></item><item><title>Inside Rust’s Async Transform</title><link>https://blag.nemo157.com/2018/12/09/inside-rusts-async-transform.html</link><description><![CDATA[As you likely know if you’re reading this post Rust has an upcoming async/await feature being tested in nightly. Because of Rust’s unique features and positioning fully understanding the implementation powering this syntax is very different to understanding other well-known implementations (C# and JavaScript’s being the ones I am familiar with). Instead of thinking of a CPS-like transform where an async function is split into a series of continuations that are chained together via a Future::then method, Rust instead uses a generator/coroutine transform to turn the function into a state machine (C# and probably most JavaScript implementations use a similar transform under the hood, but as far as I’m aware because of the garbage collector these are indistinguishable from the naive CPS transform they are normally described as). For more detail on why Rust is taking this approach you should read eRFC 2033: Experimental Coroutines, that lays out the why’s much better than I could here.

What I’m going to try and provide instead, is a look into how this actually works today. What steps the compiler takes to turn an async fn into a normal function returning a state machine that you could write if you wanted to (but you definitely don’t).]]></description><guid isPermaLink="false">9303577c-bd85-4bfa-9b0c-30685300155c</guid><pubDate>Sun,  9 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Wim Looman</dc:creator></item><item><title>Spirit Tutorial</title><link>https://vorner.github.io/2018/12/09/Spirit-Tutorial.html</link><description><![CDATA[In short, when writing a daemon or a service, we have the „muscle“ of the application ‒ whatever we write the daemon for. And we have a whole lot of infrastructure around that: logging, command line parsing, configuration. And while there are Rust libraries for all that, one needs nontrivial amount of boilerplate code to bridge all this together. Spirit aims to be this bridge.]]></description><guid isPermaLink="false">8f8ef893-ae80-4991-9d17-93049ee0adc6</guid><pubDate>Sun,  9 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Michal &apos;vorner&apos; Vaner</dc:creator></item><item><title>Rocket v0.4: Typed URIs, Database Support, Revamped Queries, &amp; More!</title><link>https://rocket.rs/v0.4/news/2018-12-08-version-0.4/</link><description><![CDATA[I am elated to announce that the next major release of Rocket is now available! Rocket 0.4 is a step forward in every direction: it is packed with features and improvements that increase developer productivity, improve application security and robustness, provide new opportunities for extensibility, and deliver a renewed degree of toolchain stability.]]></description><guid isPermaLink="false">9e21d91f-ef59-43f5-98c9-ba96d003fcb3</guid><pubDate>Sat,  8 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Sergio Benitez</dc:creator></item><item><title>Rust 2019 – The Road Ahead</title><link>https://llogiq.github.io/2018/12/08/rust.html</link><description><![CDATA[The Rust community team is soliciting blog posts to help plan the 2019 efforts. So here’s my take. I’ll start by looking back at the last year. We’ve seen great and impactful changes in the Rust landscape, such as non-lexical lifetimes, the stabilization of procedural macros and const fn, stable clippy and rustfmt, the further development of powerful IDE integration such as IntelliJ, Atom and VSCode.]]></description><guid isPermaLink="false">57aae12d-0d27-4eec-b3f3-4ff99f294435</guid><pubDate>Sat,  8 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Llogiq</dc:creator></item><item><title>The Fallow Year, my Rust2019 post</title><link>https://www.jonathanturner.org/2018/12/the-fallow-year.html</link><description><![CDATA[Rust is an amazing project. It’s unlike anything I’ve ever seen. Not only are we seeing an ever-growing number of big name users of Rust, we also continue to see leaps in productivity and functionality. Yesterday, the Rust 2018 edition shipped. The culmination of three years of work, it shows off what the community is capable of: new features, backwards compatibility, new ergonomics without sacrificing performance, and the list goes on and on.

Which is why it might comes as a little bit of a surprise that I suggest we let the field rest for the year. More specifically, that we should let one field rest while we plant another. Rather than focusing on new designs, I suggest we turn our attention outside of RFCs to other areas of Rust.]]></description><guid isPermaLink="false">8f026251-f6df-4816-a89f-855741aacbf6</guid><pubDate>Sat,  8 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Jonathan Turner</dc:creator></item><item><title>A simple agenda for the Rust Game Development WG</title><link>https://medium.com/rustgamedev/a-simple-agenda-for-the-rust-game-development-wg-485cfc72b088</link><description><![CDATA[Proposing Amethyst as our flagship project.]]></description><guid isPermaLink="false">e7334cc0-fe8a-4b16-b96f-c25b2073dc52</guid><pubDate>Fri,  7 Dec 2018 23:51:48 +0000</pubDate><dc:creator>Erlend S. Heggen</dc:creator></item><item><title>Rust in the new age</title><link>https://quietmisdreavus.net/code/2018/12/07/rust-in-the-new-age/</link><description><![CDATA[A wishlist of what I would like to accomplish with Rust in 2019.]]></description><guid isPermaLink="false">97627c69-e162-420e-8d30-22c0755d0b76</guid><pubDate>Fri,  7 Dec 2018 17:00:00 -0600</pubDate><dc:creator>QuietMisdreavus</dc:creator></item><item><title>The Swiss Army Knife of Hashmaps</title><link>https://blog.waffles.space/2018/12/07/deep-dive-into-hashbrown/</link><description><![CDATA[A while back, there was a discussion comparing the performance of using the hashbrown crate (based on Google’s SwissTable implementation) in the Rust compiler. In the last RustFest, Amanieu was experimenting on integrating his crate into stdlib, which turned out to have some really promising results. As a result, it’s being planned to move the crate into stdlib.

While the integration is still ongoing, there’s currently no blog post out there explaining SwissTable at the moment. So, I thought I’d dig deeper into the Rust implementation to try and explain how its (almost) identical twin hashbrown::HashMap works.]]></description><guid isPermaLink="false">4ea6d02a-6279-4eef-af2f-bd67424d6de8</guid><pubDate>Fri,  7 Dec 2018 16:58:46 +0000</pubDate><dc:creator>Ravi Shankar</dc:creator></item><item><title>Plans for 2019</title><link>https://pcwalton.github.io/2018/12/07/plans-for-2019.html</link><description><![CDATA[Many people have asked me what I’m working on lately, and I thought I’d give a quick rundown of my status and plans for 2019. I intend to keep this post updated with the status of projects as they progress.]]></description><guid isPermaLink="false">e20c3d81-ce4b-491d-98e1-632aeb5e40a4</guid><pubDate>Fri,  7 Dec 2018 12:49:00 +0000</pubDate><dc:creator>Patrick Walton</dc:creator></item><item><title>Debugging Cargo Test</title><link>https://www.wihlidal.com/blog/general/2018-12-07-debugging-cargo-test/</link><description><![CDATA[While developing some crates in rust, I ran into a few crashes in certain situations when using these crates from another application. In order to more easily reproduce the problem, and also minimize or eliminate future regressions, I decided to write some unit tests for these issues, and use them to more easily debug the problems… or so I thought!]]></description><guid isPermaLink="false">b9206a7e-5ee3-4336-b756-afab50e9992f</guid><pubDate>Fri,  7 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Graham Wihlidal</dc:creator></item><item><title>Making Rust a perfect fit for high-performance computations</title><link>https://gist.github.com/HadrienG2/e9a875bdf98b528594f4e20f8176bb68</link><description><![CDATA[I think Rust could help at the task of writing performant computational software, because its expressiveness, flexibility and degree of low-level control rivals that of C++, which is the de facto dominant programming language of this community where sophisticated abstractions and high performance are both desired. All the while being vastly easier to learn, and to use correctly and efficiently at the same time.]]></description><guid isPermaLink="false">a3f673ea-49c8-4942-96a3-8565d6191ec5</guid><pubDate>Thu,  6 Dec 2018 21:06:21 +0000</pubDate><dc:creator>Hadrien G.</dc:creator></item><item><title>2019 Roadmap? More like a wishlist</title><link>https://www.reddit.com/r/rust/comments/a3sav1/2019_roadmap_more_like_a_wishlist_finish_and_ship/</link><description><![CDATA[I think there is too much unfinished and unpolished stuff in Rust. My wish for 2019 would be to ship most of this. If I had to choose a theme for Rust 2021 that would be "Reliability", to convey that what is shipped has actually been polished to the point that it does not fail.]]></description><guid isPermaLink="false">efb83d26-14fa-4649-b4f2-e792f0e8a658</guid><pubDate>Fri,  7 Dec 2018 08:06:04 +1100</pubDate><dc:creator>u/0b_0101_001_1010</dc:creator></item><item><title>Rust: Error handling – Learning Rust</title><link>https://medium.com/learning-rust/rust-error-handling-72a8e036dd3</link><description><![CDATA[Welcome Back! This is the fifth post of Learning Rust series. Rust is a well designed language and safety is one of the main focus area of it. Its design decisions have been taken to prevent errors and major issues of systems programs like data races, null pointer exceptions, sensitive data leakage through exceptions and etc. So today, we are going to talk more about the concepts behind Error Handling in Rust.]]></description><guid isPermaLink="false">3c8b4f15-959d-40cc-a79c-1a375f498bb0</guid><pubDate>Thu,  6 Dec 2018 19:11:01 +0000</pubDate><dc:creator>Dumindu Madunuwan</dc:creator></item><item><title>Rust 2018 is here… but what is it?</title><link>https://hacks.mozilla.org/2018/12/rust-2018-is-here/</link><description><![CDATA[Starting today, the Rust 2018 edition is in its first release. With this edition, we’ve focused on making Rust developers as productive as they can be. But beyond that, it can be hard to explain exactly what Rust 2018 is.]]></description><guid isPermaLink="false">a9fa887f-3615-45d9-ab2d-d400d30f1039</guid><pubDate>Thu,  6 Dec 2018 16:13:55 +0000</pubDate><dc:creator>Lin Clark</dc:creator></item><item><title>Reflecting on Rust and WebAssembly in 2018</title><link>https://rustwasm.github.io/2018/12/06/reflecting-on-rust-and-wasm-in-2018.html</link><description><![CDATA[🎉 The 2018 edition of Rust has officially shipped, and the initial Rust and WebAssembly development story along with it! 🎉 To see how far we’ve come, let’s reflect on the Rust and WebAssembly story a year ago: rustc could emit WebAssembly binaries for you, but that was about it. As far as communication with JavaScript went, you had to work with raw wasm imports and exports yourself. That meant you could only pass 32- and 64-bit integers and floats back and forth. No Rust structs, JavaScript objects, strings, or slices could be passed back forth. And distributing your library’s .wasm so that other downstream projects could depend on it? Good luck.]]></description><guid isPermaLink="false">c0eb769f-4785-436d-b0b9-4bff16b30ef8</guid><pubDate>Thu,  6 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Rust and WebAssembly</dc:creator></item><item><title> A call for Rust 2019 Roadmap blog posts</title><link>https://blog.rust-lang.org/2018/12/06/call-for-rust-2019-roadmap-blogposts.html</link><description><![CDATA[Starting today and running until of January 15, we’d like to ask the community to write blogposts reflecting on Rust in 2018 and proposing goals and directions for Rust in 2019.]]></description><guid isPermaLink="false">3234baba-f03d-467c-b032-d7d0dec7a12d</guid><pubDate>Thu,  6 Dec 2018 00:00:00 +0000</pubDate><dc:creator>The Rust Community Team</dc:creator></item><item><title> Announcing Rust 1.31 and Rust 2018</title><link>https://blog.rust-lang.org/2018/12/06/Rust-1.31-and-rust-2018.html</link><description><![CDATA[The Rust team is happy to announce a new version of Rust, 1.31.0, and "Rust 2018" as well. Rust is a programming language that empowers everyone to build reliable and efficient software.]]></description><guid isPermaLink="false">18cf1853-dbff-4634-8045-fbcaf36bd4fc</guid><pubDate>Thu,  6 Dec 2018 00:00:00 +0000</pubDate><dc:creator>The Rust Core Team</dc:creator></item><item><title>Wherefore art thou Romio?</title><link>http://boats.gitlab.io/blog/post/romio/</link><description><![CDATA[This blog post is about a project called Romio that I’ve been working on over the past two or three weeks. Romio is a port of a small part of the Tokio project to the newer futures APIs.

I started the project to get some experience porting code from the old futures API to the new API. However, we realized that this code could also be useful to other people who want to experiment with networking code using the new async/await syntax, so with the help of others we polished it up during the RustFest Rome “impl days” and now its being released for people to experiment with.]]></description><guid isPermaLink="false">deadc4e1-1e13-49ca-b62b-cd8af455a164</guid><pubDate>Wed,  5 Dec 2018 00:00:00 +0000</pubDate><dc:creator>withoutboats</dc:creator></item><item><title>GitHub Actions: An introductory look and first impressions</title><link>https://mgattozzi.com/github-actions-an-introductory-look-and-first-impressions/</link><description><![CDATA[I cover first impressions on GitHub actions using Rust as well as how to make it do a simple merge with a comment!]]></description><guid isPermaLink="false">a60ffa53-800e-42b3-a0df-feadc7a9e931</guid><pubDate>Tue,  4 Dec 2018 23:21:39 +0000</pubDate><dc:creator>Michael Gattozzi</dc:creator></item><item><title>More on RLS version numbering</title><link>https://www.ncameron.org/blog/more-on-rls-version-numbering/</link><description><![CDATA[In a few days the 2018 edition is going to roll out, and that will include some new framing around Rust's tooling. We've got a core set of developer tools which are stable and ready for widespread use. We're going to have a blog post all about that, but for]]></description><guid isPermaLink="false">2b4ef111-3f3b-416d-b94d-55fe01a94455</guid><pubDate>Tue,  4 Dec 2018 03:00:20 +0000</pubDate><dc:creator>Nick Cameron</dc:creator></item></channel></rss>