<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/"><channel><title>Read Rust - All Posts</title><link>https://readrust.net/</link><description>All Posts posts on Read Rust</description><item><title>Organizational Debt</title><link>https://boats.gitlab.io/blog/post/rust-2019/</link><description><![CDATA[We all know that classic aphorism: Year comes to an end, Rust blog post press send. This is mine.

There are lots of cool technical improvements to Rust that I want the project to achieve this year, and a few in particular that I’m definitely going to be putting a lot of time into. But this blog post is going to talk about none of them. Instead, I want to talk about organizational debt, and how badly the Rust project needs to deal with it in 2019.]]></description><guid isPermaLink="false">f0adf24b-6589-4306-a580-6cef894ad3b7</guid><pubDate>Mon, 16 Dec 2019 00:00:00 +0000</pubDate><dc:creator>withoutboats</dc:creator></item><item><title>Intermission</title><link>https://azriel.im/will/2018/12/18/intermission/</link><description><![CDATA[Things I would like prioritized in the 2019 roadmap: Reduced Compilation Times, Refined Tools.]]></description><guid isPermaLink="false">f11f3bca-353a-4c96-b50d-7a28acb0d7ec</guid><pubDate>Tue, 18 Dec 2018 11:31:13 +1300</pubDate><dc:creator>Azriel Hoh</dc:creator></item><item><title>Tools in the 2018 edition</title><link>https://blog.rust-lang.org/2018/12/17/Rust-2018-dev-tools.html</link><description><![CDATA[In this blog post I'll cover Clippy and Rustfmt – two tools that have been around for a few years and are now stable and ready for general use. I'll also cover IDE support – a key workflow for many users which is now much better supported. I'll start by talking about Rustfix, a new tool which was central to our edition migration plans.]]></description><guid isPermaLink="false">629810d5-0f02-4ef1-9826-32cd4bc2f048</guid><pubDate>Mon, 17 Dec 2018 00:00:00 +0000</pubDate><dc:creator>The Dev-tools team</dc:creator></item><item><title>Rust 2019: Go Slow</title><link>https://blog.hwc.io/posts/rust-2019/</link><description><![CDATA[I have many technical wishes for Rust, the language, in 2019. However, I’m not going to mention any in particular in this post. In fact, I can almost say that I’d prefer for there to not be a focus on achieving technical milestones in the next year.]]></description><guid isPermaLink="false">8d54d930-66a9-438f-8dad-de13e2fe8c3c</guid><pubDate>Sun, 16 Dec 2018 15:39:32 -0500</pubDate><dc:creator>hwc</dc:creator></item><item><title>Rust 2019</title><link>https://gist.github.com/xd009642/083a689c1fe460459d6bc792a626604e</link><description><![CDATA[This is a bit of a brain dump of my thoughts about Rust 2019. Mainly I work on my own code coverage tool tarpaulin, embedded rust and random little tools. So my perspective will be coloured by this.]]></description><guid isPermaLink="false">34b69da0-cd61-4a16-8bfe-21d8d98dd4bd</guid><pubDate>Sun, 16 Dec 2018 15:22:21 +0000</pubDate><dc:creator>xd009642</dc:creator></item><item><title>My thoughts on Rust 2019</title><link>https://raphlinus.github.io/rust/2018/12/16/rust-2019.html</link><description><![CDATA[Recently, the Rust Core Team solicited blog posts on where Rust should be headed in 2019. Here’s mine.]]></description><guid isPermaLink="false">94ad8d78-4b62-41ff-86c3-44690a1dbf66</guid><pubDate>Sun, 16 Dec 2018 14:55:42 +0000</pubDate><dc:creator>Raph Levien</dc:creator></item><item><title>Making Rust Float Parsing Fast and Correct</title><link>https://www.reddit.com/r/rust/comments/a6j5j1/making_rust_float_parsing_fast_and_correct/</link><description><![CDATA[Previously, I wrote about how Rust parsing is atypically slow comparing Rust's libcore implementation to a rudimentary parser I wrote. However, as others noted, the comparison was fairly limited. It didn't compare Rust's implementation to other implementations, such as glibc's strtod or Go's ParseFloat. The parser I implemented wasn't correct, it led to rounding error for most representations, by using floats for intermediate values. Furthermore, the comparisons used data unlikely to be encountered in real-world datasets, overstating the performance differences by forcing Rust to use slower algorithms. So, naturally, I aimed to address all these concerns. And finally, I forgot to disable CPU scaling, meaning CPU throttling could have led to inconsistent benchmarks.]]></description><guid isPermaLink="false">f848772a-4132-4e4f-b817-c4a6dec365b7</guid><pubDate>Sun, 16 Dec 2018 08:39:39 +1100</pubDate><dc:creator>u/ialex32_2</dc:creator></item><item><title>Creating an empty iterator of a certain type in Rust</title><link>https://www.freedomlayer.org/offst/option-iterator/</link><description><![CDATA[I am working these days on the development of offst's Index server. I needed to implement a basic directed graph structure, allowing to run the BFS algorithm to find routes with a certain amount of capacity. During the work on the Index server I had the problem of wanting to return an empty iterator in an early flow of a function.]]></description><guid isPermaLink="false">3f750cea-55f1-44cf-b965-b3a2803de32b</guid><pubDate>Sat, 15 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Freedomlayer</dc:creator></item><item><title>Rust Analyzer in 2018 and 2019</title><link>https://ferrous-systems.com/blog/rust-analyzer-2019/</link><description><![CDATA[Hi! I am Aleksey Kladov (aka @matklad). In the past, I've worked at Jet Brains where I've helped to create the IntelliJ Rust plug-in, and now I am a part of the Ferrous Systems team.

I've spent a significant amount of the last year experimenting with various approaches to make the Rust IDE story better. The culmination of my experiments is the rust-analyzer project – an experimental Rust compiler frontend, targeting the IDE/Language Server Protocol use case.]]></description><guid isPermaLink="false">bf6eb06b-346b-4f0c-a294-ee1dde663418</guid><pubDate>Sat, 15 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Aleksey Kladov</dc:creator></item><item><title>Kubernetes config management in Rust</title><link>https://clux.github.io/probes/post/2018-12-15-config-management-in-rust/</link><description><![CDATA[At babylon health we have a ton of microservices running on kubernetes that are, in turn, controlled by hundreds of thousands of lines of autogenerated yaml. So for our own sanity, we built shipcat - a standardisation tool (powered by rust-lang and serde) to control the declarative format and lifecycle of every microservice.]]></description><guid isPermaLink="false">0ee5d609-1891-4f10-9085-93696f564382</guid><pubDate>Sat, 15 Dec 2018 00:00:00 +0000</pubDate><dc:creator>clux</dc:creator></item><item><title>Rust and WebAssembly in 2019</title><link>http://fitzgeraldnick.com/2018/12/14/rust-and-webassembly-in-2019.html</link><description><![CDATA[Compiling Rust to WebAssembly should be the best choice for fast, reliable code for the Web. Additionally, the same way that Rust integrates with C calling conventions and libraries on native targets, Rust should also integrate with JavaScript and HTML5 on the Web. These are the Rust and WebAssembly domain working group’s core values. In 2018, we made it possible to surgically replace performance-sensitive JavaScript with Rust-generated WebAssembly. I propose that we make larger-scale adoption of Rust and WebAssembly practical in 2019.]]></description><guid isPermaLink="false">f12043be-3b2d-4ab3-8ce1-51463ffad905</guid><pubDate>Fri, 14 Dec 2018 00:00:00 -0800</pubDate><dc:creator>Nick Fitzgerald</dc:creator></item><item><title>My Wishes for Rust 2019</title><link>https://cetra3.github.io/blog/rust-2019/</link><description><![CDATA[2018 was a massive year for rust, and it's great to reflect back on how far we've all come. My main wish for the new year is to put on the breaks a little bit, and finish off what has been started without taking on anything majorly new.]]></description><guid isPermaLink="false">fde9a5b7-9e92-41aa-994a-15bdb87d2909</guid><pubDate>Fri, 14 Dec 2018 00:00:00 +0000</pubDate><dc:creator>cetra3</dc:creator></item><item><title>Rust 2019 - my 2¢</title><link>https://www.reddit.com/r/rust/comments/a5s024/rust_2019_my_2/</link><description><![CDATA[I will not be really original here, but I really hope to see the following features to land on stable in 2019: const generics, async/await, GATs, inherent traits, minimum supported Rust version:]]></description><guid isPermaLink="false">dd6ec508-904b-4cd2-96ca-3df2ed99b074</guid><pubDate>Thu, 13 Dec 2018 20:24:49 +1100</pubDate><dc:creator>u/newpavlov</dc:creator></item><item><title>Rust Raps - Ferris Crab (Rust Raps 2018 Edition)</title><link>http://fitzgeraldnick.com/2018/12/13/rust-raps.html</link><description><![CDATA[Just released: the hot new single “Ferris Crab (Rust Raps 2018 Edition)” by Rusta Rhymes off their upcoming debut album impl Drop for Mic {}.]]></description><guid isPermaLink="false">733eb57b-95f6-490b-b3aa-ba223cacb0f5</guid><pubDate>Thu, 13 Dec 2018 00:00:00 -0800</pubDate><dc:creator>Rusta Rhymes</dc:creator></item><item><title>Yet another Rust 2018 wishlist</title><link>https://www.reddit.com/r/rust/comments/a5q7eb/yet_another_rust_2018_wishlist/</link><description><![CDATA[The 2018 year brought a lot of incredible new features and I'm impressed with all the work that was put in to make the 2018 edition happen. I want to join the other users asking for 2019 to be a year we adjust to all the new changes and focus on cleaning and polishing, not entirely new projects*. For the upcoming year I'd like to see progress on compilation speed and maintenance attention in the library ecosystem.]]></description><guid isPermaLink="false">d4acf845-6f69-4f54-bd37-96d62f83a54c</guid><pubDate>Thu, 13 Dec 2018 15:38:32 +1100</pubDate><dc:creator>u/Saefroch</dc:creator></item><item><title>Async in Rust, circa 2018</title><link>https://rust-lang-nursery.github.io/wg-net/2018/12/13/async-update.html</link><description><![CDATA[Rust 2018 has shipped, and we’re closing in on the end of the year. While we didn’t manage to ship async/await as part of the edition itself, the community has made quite a lot of progress toward that goal. This post summarizes the state of play, and announces the publication of several crates intended to facilitate use of async/await on the nightly ecosystem.]]></description><guid isPermaLink="false">53c9e07b-f4d5-423f-8a84-05e119814fda</guid><pubDate>Thu, 13 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Aaron Turon</dc:creator></item><item><title>Edge programming with Rust and WebAssembly</title><link>https://www.fastly.com/blog/edge-programming-rust-web-assembly</link><description><![CDATA[Take a developer deep dive into Terrarium, our multi-language, browser-based editor and deployment platform at the edge. Learn how to compile Rust programs to WebAssembly right on your local machine, interact with the Terrarium system, and explore some applications we’ve built with it.]]></description><guid isPermaLink="false">78791a3b-395e-4d3b-b091-66aa2fa2c577</guid><pubDate>Wed, 12 Dec 2018 16:00:00 +0000</pubDate><dc:creator>Pat Hickey</dc:creator></item><item><title>Sinistersnare&apos;s Rust 2019 Wishlist</title><link>https://drs.is/post/rust-wishlist-2019/</link><description><![CDATA[Rust needs to focus on less glamorous features in 2019. We have added a lot of great features since 1.0, but we need to address the warts that we have had for a long time. I mostly echo sentiments from Jonathan Turner, Nathan Vegdahl, and many others in my ‘fallow-year’ sentiments. Overall, Compilation speed and generic constants are my two most wished-for features. On top of that, I would like to see more ecosystem work to make embedded applications more feasible and easy to use. Finally, Rust needs a moratorium on adding syntactic sugar for 2019.]]></description><guid isPermaLink="false">9e8f8e34-8fe9-4b4b-b40a-970e0a85a993</guid><pubDate>Wed, 12 Dec 2018 08:10:44 -0500</pubDate><dc:creator>Davis Ross Silverman</dc:creator></item><item><title>Rust 2019 - It&apos;s the Little Things</title><link>https://blog.cessen.com/post/2018_12_12_rust_2019_its_the_little_things</link><description><![CDATA[This might be an uncommon opinion—especially among those motivated enough to write a Rust 2019 post—but I actually think Rust is pretty much at a good place now. For the kinds of things that I want to do (e.g. my path tracer), there isn't much that Rust is lacking as a language. There are some fiddly things like "placement new" that could be useful, but nothing really major. And of course, well-designed new features are always welcome, they just don't seem particularly critical to me at this point. In other words, I'm pretty much satisfied. Mission accomplished, as far as I'm concerned. I think the rest is just polish. Just the little things.]]></description><guid isPermaLink="false">a884801e-f80b-4ea4-8441-a86c2c736086</guid><pubDate>Wed, 12 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Nathan Vegdahl</dc:creator></item><item><title>Rust 2019: Think Bigger</title><link>http://fitzgeraldnick.com/2018/12/11/rust-2019-think-bigger.html</link><description><![CDATA[Rust shines when we find ways to have our cake and eat it too: memory safety without runtime garbage collection, abstraction without overhead, threading without data races. We must find new ways to continue this tradition for Rust 2019 and beyond.]]></description><guid isPermaLink="false">c0d67320-edd6-4eef-b345-bbf3288acaae</guid><pubDate>Tue, 11 Dec 2018 00:00:00 -0800</pubDate><dc:creator>Nick Fitzgerald</dc:creator></item><item><title>Rust in 2022</title><link>https://www.ncameron.org/blog/rust-in-2022/</link><description><![CDATA[A response to the call for 2019 roadmap blog posts. In case you missed it, we released our second edition of Rust this year! An edition is an opportunity to make backwards incompatible changes, but more than that it's an opportunity to bring attention to how programming in Rust has changed. With the 2018 edition out of the door, now is the time to think about the next edition: how do we want programming in Rust in 2022 to be different to programming in Rust today? Once we've worked that out, lets work backwards to what should be done in 2019.]]></description><guid isPermaLink="false">4259e940-d508-4de3-8971-3c3df7b30f98</guid><pubDate>Tue, 11 Dec 2018 04:34:31 +0000</pubDate><dc:creator>Nick Cameron</dc:creator></item><item><title>Bootstrapping Rust</title><link>https://www.gnu.org/software/guix/blog/2018/bootstrapping-rust/</link><description><![CDATA[It has been a long-standing tradition to develop a language far enough to be able to write the language's compiler in the same language, and Rust does the same. Rust is nowadays written in Rust. We've tracked down the earlier Rust versions, which were written in OCaml, and were planning to use these to bootstrap Rust. But in parallel, John Hudge (Mutabah) developed a Rust compiler, called "mrustc", written in C++. mrustc is now good enough to compile Rust 1.19.0. Using mrustc, we were able to build Rust entirely from source with a bootstrap chain]]></description><guid isPermaLink="false">6bf8dccd-51b6-4dcb-a9eb-e38923d28a2c</guid><pubDate>Tue, 11 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Danny Milosavljevic</dc:creator></item><item><title>Positive-Sum Games</title><link>https://llogiq.github.io/2018/12/11/sum.html</link><description><![CDATA[One thing I learned from Aaron Turon is to search for positive-sum games. First what does that even mean? In most arguments you may run into, it will be easy to find a zero-sum game: Your win is my loss and vice versa. However, in many situations, it is actually possible to go above those petty games and find a variant that allows us both to win.]]></description><guid isPermaLink="false">2fdb4722-43ce-4bad-b37e-67dae34eecb2</guid><pubDate>Tue, 11 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Llogiq</dc:creator></item><item><title>Dynamically Generating Dockerfiles for K8s</title><link>https://medium.com/docql/dynamically-generating-dockerfiles-for-k8s-d2baf7bfef5a</link><description><![CDATA[Hello everyone! Today I am excited to announce that DocQL is open-sourcing a Rust crate (a library) which we built internally called…]]></description><guid isPermaLink="false">00b55ed6-da3d-4c6a-90ed-ebea6191afd8</guid><pubDate>Mon, 10 Dec 2018 19:43:10 +0000</pubDate><dc:creator>Anthony Dodd</dc:creator></item><item><title>Lokathor&apos;s Rust 2019 wishpost</title><link>https://www.reddit.com/r/rust/comments/a4ygji/lokathors_rust_2019_wishpost</link><description><![CDATA[Recently I've been using Rust for GBA development (repo link), and before that I spent most of my Rust time with Handmade Hero work (the actual repo is private to handmade hero backers, so that link is just the main website). As you might expect, this has given me a quite different view of what I want to see from Rust. Basically, I don't want more crates. I want language, and tools, and most importantly education.]]></description><guid isPermaLink="false">dcaa5235-2614-4f61-b0b4-8b1f2e0d136e</guid><pubDate>Tue, 11 Dec 2018 05:47:42 +1100</pubDate><dc:creator>u/Lokathor</dc:creator></item><item><title>Existential types in Rust</title><link>https://adelbertc.github.io/posts/2018-12-10-rust-existentials.html</link><description><![CDATA[The Rust project I am working on is a caching layer, currently backed by Redis, and it came to a point where I needed to leverage pipelining. On its own, pipelining is straightforward as the redis crate implements it already. However all notions of a cache in our code are abstracted out behind a trait so we can have alternative implementations, such as an in-memory HashMap-backed implementation.

The problem arises with representing the pipeline in code. It would force any implementation of our cache to Redis’s notion of a pipeline. Not only would this make it difficult to introspect during testing, but it would also be nonsensical for our HashMap-backed cache. My usual answer to this in languages that support higher-kinded types is to use tagless-final algebras, but Rust’s type system currently doesn’t support higher-kinded types1. Fortunately, there is a pretty good alternative that Rust does support: existential types.]]></description><guid isPermaLink="false">4fe3c55c-a091-40c2-ada0-8c5d371afc31</guid><pubDate>Mon, 10 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Adelbert Chang</dc:creator></item><item><title>Using Web Assembly in the Browser</title><link>https://ljcode.org/blog/wasm-part1/</link><description><![CDATA[WebAssembly (abbreviated Wasm) is a binary instruction format for a stack-based virtual machine. This essentially means that is is fast, because the program is compiled to a much more compact format, making it faster to parse. Wasm can be written by hand if you're looking for a challenge, but is primarily meant to be written in another language, and then compiled to Wasm. You may know a little about Assembly language and how it works - here's a quick refresher in-case you're rusty.]]></description><guid isPermaLink="false">27a7e602-da8a-4c0b-9ec1-81cc22c00df9</guid><pubDate>Mon, 10 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Luke Jones</dc:creator></item><item><title>Building Alexa Skills in Rust</title><link>https://medium.com/@amalec/building-alexa-skills-in-rust-4cf54a497ea4</link><description><![CDATA[My favorite way to explore Lambdas is to build Alexa skills because of the immediate feedback: you write a little code, and a home device talks to you. It’s a peek into the long promised of world of easy service composition.

Unfortunately, Rust didn’t have complete Alexa skill request/response handling (there is a crate from 2 years ago that handled only the basics), so I wrote one called alexa_sdk. (It’s basically a struct plus serde wrapper around the Alexa JSON spec, with some helpers.]]></description><guid isPermaLink="false">36dce8e1-2508-4e34-8aaf-1eb43a8b17e1</guid><pubDate>Sun,  9 Dec 2018 21:30:38 +0000</pubDate><dc:creator>Arien Malec</dc:creator></item><item><title>Rust 2019 — let us pursue composability</title><link>https://medium.com/@GolDDranks/rust-2019-let-us-pursue-composability-70f1eb2238c3</link><description><![CDATA[We should drive home the goals set in spirit of productivity in 2019. We should also consider composibility as the next overarching theme.]]></description><guid isPermaLink="false">0e733a02-5972-4106-98a7-d0613485cac1</guid><pubDate>Sun,  9 Dec 2018 02:50:51 +0000</pubDate><dc:creator>Pyry Kontio</dc:creator></item><item><title>Rust 2019</title><link>https://vfoley.xyz/rust-2019/</link><description><![CDATA[In 2019, there are three areas where I would like to see the Rust community focus its efforts: Improved compile times, A community effort to review crates, More “80% solutions”.]]></description><guid isPermaLink="false">a02deaa2-0f75-48c6-86ef-f6a314be6355</guid><pubDate>Sun,  9 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Vincent Foley</dc:creator></item><item><title>Inside Rust’s Async Transform</title><link>https://blag.nemo157.com/2018/12/09/inside-rusts-async-transform.html</link><description><![CDATA[As you likely know if you’re reading this post Rust has an upcoming async/await feature being tested in nightly. Because of Rust’s unique features and positioning fully understanding the implementation powering this syntax is very different to understanding other well-known implementations (C# and JavaScript’s being the ones I am familiar with). Instead of thinking of a CPS-like transform where an async function is split into a series of continuations that are chained together via a Future::then method, Rust instead uses a generator/coroutine transform to turn the function into a state machine (C# and probably most JavaScript implementations use a similar transform under the hood, but as far as I’m aware because of the garbage collector these are indistinguishable from the naive CPS transform they are normally described as). For more detail on why Rust is taking this approach you should read eRFC 2033: Experimental Coroutines, that lays out the why’s much better than I could here.

What I’m going to try and provide instead, is a look into how this actually works today. What steps the compiler takes to turn an async fn into a normal function returning a state machine that you could write if you wanted to (but you definitely don’t).]]></description><guid isPermaLink="false">9303577c-bd85-4bfa-9b0c-30685300155c</guid><pubDate>Sun,  9 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Wim Looman</dc:creator></item><item><title>Spirit Tutorial</title><link>https://vorner.github.io/2018/12/09/Spirit-Tutorial.html</link><description><![CDATA[In short, when writing a daemon or a service, we have the „muscle“ of the application ‒ whatever we write the daemon for. And we have a whole lot of infrastructure around that: logging, command line parsing, configuration. And while there are Rust libraries for all that, one needs nontrivial amount of boilerplate code to bridge all this together. Spirit aims to be this bridge.]]></description><guid isPermaLink="false">8f8ef893-ae80-4991-9d17-93049ee0adc6</guid><pubDate>Sun,  9 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Michal &apos;vorner&apos; Vaner</dc:creator></item><item><title>Rocket v0.4: Typed URIs, Database Support, Revamped Queries, &amp; More!</title><link>https://rocket.rs/v0.4/news/2018-12-08-version-0.4/</link><description><![CDATA[I am elated to announce that the next major release of Rocket is now available! Rocket 0.4 is a step forward in every direction: it is packed with features and improvements that increase developer productivity, improve application security and robustness, provide new opportunities for extensibility, and deliver a renewed degree of toolchain stability.]]></description><guid isPermaLink="false">9e21d91f-ef59-43f5-98c9-ba96d003fcb3</guid><pubDate>Sat,  8 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Sergio Benitez</dc:creator></item><item><title>Rust 2019 – The Road Ahead</title><link>https://llogiq.github.io/2018/12/08/rust.html</link><description><![CDATA[The Rust community team is soliciting blog posts to help plan the 2019 efforts. So here’s my take. I’ll start by looking back at the last year. We’ve seen great and impactful changes in the Rust landscape, such as non-lexical lifetimes, the stabilization of procedural macros and const fn, stable clippy and rustfmt, the further development of powerful IDE integration such as IntelliJ, Atom and VSCode.]]></description><guid isPermaLink="false">57aae12d-0d27-4eec-b3f3-4ff99f294435</guid><pubDate>Sat,  8 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Llogiq</dc:creator></item><item><title>The Fallow Year, my Rust2019 post</title><link>https://www.jonathanturner.org/2018/12/the-fallow-year.html</link><description><![CDATA[Rust is an amazing project. It’s unlike anything I’ve ever seen. Not only are we seeing an ever-growing number of big name users of Rust, we also continue to see leaps in productivity and functionality. Yesterday, the Rust 2018 edition shipped. The culmination of three years of work, it shows off what the community is capable of: new features, backwards compatibility, new ergonomics without sacrificing performance, and the list goes on and on.

Which is why it might comes as a little bit of a surprise that I suggest we let the field rest for the year. More specifically, that we should let one field rest while we plant another. Rather than focusing on new designs, I suggest we turn our attention outside of RFCs to other areas of Rust.]]></description><guid isPermaLink="false">8f026251-f6df-4816-a89f-855741aacbf6</guid><pubDate>Sat,  8 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Jonathan Turner</dc:creator></item><item><title>A simple agenda for the Rust Game Development WG</title><link>https://medium.com/rustgamedev/a-simple-agenda-for-the-rust-game-development-wg-485cfc72b088</link><description><![CDATA[Proposing Amethyst as our flagship project.]]></description><guid isPermaLink="false">e7334cc0-fe8a-4b16-b96f-c25b2073dc52</guid><pubDate>Fri,  7 Dec 2018 23:51:48 +0000</pubDate><dc:creator>Erlend S. Heggen</dc:creator></item><item><title>Rust in the new age</title><link>https://quietmisdreavus.net/code/2018/12/07/rust-in-the-new-age/</link><description><![CDATA[A wishlist of what I would like to accomplish with Rust in 2019.]]></description><guid isPermaLink="false">97627c69-e162-420e-8d30-22c0755d0b76</guid><pubDate>Fri,  7 Dec 2018 17:00:00 -0600</pubDate><dc:creator>QuietMisdreavus</dc:creator></item><item><title>The Swiss Army Knife of Hashmaps</title><link>https://blog.waffles.space/2018/12/07/deep-dive-into-hashbrown/</link><description><![CDATA[A while back, there was a discussion comparing the performance of using the hashbrown crate (based on Google’s SwissTable implementation) in the Rust compiler. In the last RustFest, Amanieu was experimenting on integrating his crate into stdlib, which turned out to have some really promising results. As a result, it’s being planned to move the crate into stdlib.

While the integration is still ongoing, there’s currently no blog post out there explaining SwissTable at the moment. So, I thought I’d dig deeper into the Rust implementation to try and explain how its (almost) identical twin hashbrown::HashMap works.]]></description><guid isPermaLink="false">4ea6d02a-6279-4eef-af2f-bd67424d6de8</guid><pubDate>Fri,  7 Dec 2018 16:58:46 +0000</pubDate><dc:creator>Ravi Shankar</dc:creator></item><item><title>Plans for 2019</title><link>https://pcwalton.github.io/2018/12/07/plans-for-2019.html</link><description><![CDATA[Many people have asked me what I’m working on lately, and I thought I’d give a quick rundown of my status and plans for 2019. I intend to keep this post updated with the status of projects as they progress.]]></description><guid isPermaLink="false">e20c3d81-ce4b-491d-98e1-632aeb5e40a4</guid><pubDate>Fri,  7 Dec 2018 12:49:00 +0000</pubDate><dc:creator>Patrick Walton</dc:creator></item><item><title>Debugging Cargo Test</title><link>https://www.wihlidal.com/blog/general/2018-12-07-debugging-cargo-test/</link><description><![CDATA[While developing some crates in rust, I ran into a few crashes in certain situations when using these crates from another application. In order to more easily reproduce the problem, and also minimize or eliminate future regressions, I decided to write some unit tests for these issues, and use them to more easily debug the problems… or so I thought!]]></description><guid isPermaLink="false">b9206a7e-5ee3-4336-b756-afab50e9992f</guid><pubDate>Fri,  7 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Graham Wihlidal</dc:creator></item><item><title>Making Rust a perfect fit for high-performance computations</title><link>https://gist.github.com/HadrienG2/e9a875bdf98b528594f4e20f8176bb68</link><description><![CDATA[I think Rust could help at the task of writing performant computational software, because its expressiveness, flexibility and degree of low-level control rivals that of C++, which is the de facto dominant programming language of this community where sophisticated abstractions and high performance are both desired. All the while being vastly easier to learn, and to use correctly and efficiently at the same time.]]></description><guid isPermaLink="false">a3f673ea-49c8-4942-96a3-8565d6191ec5</guid><pubDate>Thu,  6 Dec 2018 21:06:21 +0000</pubDate><dc:creator>Hadrien G.</dc:creator></item><item><title>2019 Roadmap? More like a wishlist</title><link>https://www.reddit.com/r/rust/comments/a3sav1/2019_roadmap_more_like_a_wishlist_finish_and_ship/</link><description><![CDATA[I think there is too much unfinished and unpolished stuff in Rust. My wish for 2019 would be to ship most of this. If I had to choose a theme for Rust 2021 that would be "Reliability", to convey that what is shipped has actually been polished to the point that it does not fail.]]></description><guid isPermaLink="false">efb83d26-14fa-4649-b4f2-e792f0e8a658</guid><pubDate>Fri,  7 Dec 2018 08:06:04 +1100</pubDate><dc:creator>u/0b_0101_001_1010</dc:creator></item><item><title>Rust: Error handling – Learning Rust</title><link>https://medium.com/learning-rust/rust-error-handling-72a8e036dd3</link><description><![CDATA[Welcome Back! This is the fifth post of Learning Rust series. Rust is a well designed language and safety is one of the main focus area of it. Its design decisions have been taken to prevent errors and major issues of systems programs like data races, null pointer exceptions, sensitive data leakage through exceptions and etc. So today, we are going to talk more about the concepts behind Error Handling in Rust.]]></description><guid isPermaLink="false">3c8b4f15-959d-40cc-a79c-1a375f498bb0</guid><pubDate>Thu,  6 Dec 2018 19:11:01 +0000</pubDate><dc:creator>Dumindu Madunuwan</dc:creator></item><item><title>Rust 2018 is here… but what is it?</title><link>https://hacks.mozilla.org/2018/12/rust-2018-is-here/</link><description><![CDATA[Starting today, the Rust 2018 edition is in its first release. With this edition, we’ve focused on making Rust developers as productive as they can be. But beyond that, it can be hard to explain exactly what Rust 2018 is.]]></description><guid isPermaLink="false">a9fa887f-3615-45d9-ab2d-d400d30f1039</guid><pubDate>Thu,  6 Dec 2018 16:13:55 +0000</pubDate><dc:creator>Lin Clark</dc:creator></item><item><title>Reflecting on Rust and WebAssembly in 2018</title><link>https://rustwasm.github.io/2018/12/06/reflecting-on-rust-and-wasm-in-2018.html</link><description><![CDATA[🎉 The 2018 edition of Rust has officially shipped, and the initial Rust and WebAssembly development story along with it! 🎉 To see how far we’ve come, let’s reflect on the Rust and WebAssembly story a year ago: rustc could emit WebAssembly binaries for you, but that was about it. As far as communication with JavaScript went, you had to work with raw wasm imports and exports yourself. That meant you could only pass 32- and 64-bit integers and floats back and forth. No Rust structs, JavaScript objects, strings, or slices could be passed back forth. And distributing your library’s .wasm so that other downstream projects could depend on it? Good luck.]]></description><guid isPermaLink="false">c0eb769f-4785-436d-b0b9-4bff16b30ef8</guid><pubDate>Thu,  6 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Rust and WebAssembly</dc:creator></item><item><title> A call for Rust 2019 Roadmap blog posts</title><link>https://blog.rust-lang.org/2018/12/06/call-for-rust-2019-roadmap-blogposts.html</link><description><![CDATA[Starting today and running until of January 15, we’d like to ask the community to write blogposts reflecting on Rust in 2018 and proposing goals and directions for Rust in 2019.]]></description><guid isPermaLink="false">3234baba-f03d-467c-b032-d7d0dec7a12d</guid><pubDate>Thu,  6 Dec 2018 00:00:00 +0000</pubDate><dc:creator>The Rust Community Team</dc:creator></item><item><title> Announcing Rust 1.31 and Rust 2018</title><link>https://blog.rust-lang.org/2018/12/06/Rust-1.31-and-rust-2018.html</link><description><![CDATA[The Rust team is happy to announce a new version of Rust, 1.31.0, and "Rust 2018" as well. Rust is a programming language that empowers everyone to build reliable and efficient software.]]></description><guid isPermaLink="false">18cf1853-dbff-4634-8045-fbcaf36bd4fc</guid><pubDate>Thu,  6 Dec 2018 00:00:00 +0000</pubDate><dc:creator>The Rust Core Team</dc:creator></item><item><title>Wherefore art thou Romio?</title><link>http://boats.gitlab.io/blog/post/romio/</link><description><![CDATA[This blog post is about a project called Romio that I’ve been working on over the past two or three weeks. Romio is a port of a small part of the Tokio project to the newer futures APIs.

I started the project to get some experience porting code from the old futures API to the new API. However, we realized that this code could also be useful to other people who want to experiment with networking code using the new async/await syntax, so with the help of others we polished it up during the RustFest Rome “impl days” and now its being released for people to experiment with.]]></description><guid isPermaLink="false">deadc4e1-1e13-49ca-b62b-cd8af455a164</guid><pubDate>Wed,  5 Dec 2018 00:00:00 +0000</pubDate><dc:creator>withoutboats</dc:creator></item><item><title>More on RLS version numbering</title><link>https://www.ncameron.org/blog/more-on-rls-version-numbering/</link><description><![CDATA[In a few days the 2018 edition is going to roll out, and that will include some new framing around Rust's tooling. We've got a core set of developer tools which are stable and ready for widespread use. We're going to have a blog post all about that, but for]]></description><guid isPermaLink="false">2b4ef111-3f3b-416d-b94d-55fe01a94455</guid><pubDate>Tue,  4 Dec 2018 03:00:20 +0000</pubDate><dc:creator>Nick Cameron</dc:creator></item><item><title>Safe Web Services with Actix and Sentry</title><link>https://blog.sentry.io/2018/12/04/safe-web-services-actix-sentry</link><description><![CDATA[Enjoy this quick introduction to creating a web server with Actix and monitoring it with Sentry.]]></description><guid isPermaLink="false">05ee17e8-44f9-41c4-9f29-b4a5be430158</guid><pubDate>Tue,  4 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Jan Michael Auer</dc:creator></item><item><title>cargo-call-stack: Whole program static stack analysis</title><link>https://github.com/japaric/cargo-call-stack#cargo-call-stack</link><description><![CDATA[The tool produces a call graph of the selected program as a dot file. Each node (function) in the call graph includes the local stack usage of the function, if provided by LLVM (see -Z emit-stack-sizes). If the call graph contains no cycles then the tool also computes the maximum stack usage of each function, that is the stack usage that includes the stack usage of the functions the function may invoke.]]></description><guid isPermaLink="false">afa2fbf0-9866-4be5-aa97-247c58bbccf7</guid><pubDate>Mon,  3 Dec 2018 23:31:00 +0000</pubDate><dc:creator>Jorge Aparicio</dc:creator></item><item><title>CFG Game: Put your CS skills to good use and craft burgers</title><link>http://rickyhan.com/jekyll/update/2018/12/03/make-burgers-context-free-grammar.html</link><description><![CDATA[This past weekend I made a game for Ludum Dare 43. Tools used: Aseprite, quicksilver. Inspired by Zachtronics. It is written in Rust and compiled to WebAssembly.]]></description><guid isPermaLink="false">5493161b-6e7d-4b81-887f-af80a0d2c410</guid><pubDate>Mon,  3 Dec 2018 04:37:02 +0000</pubDate><dc:creator>Ricky Han</dc:creator></item><item><title>How I Wrote a Modern C++ Library in Rust</title><link>https://hsivonen.fi/modern-cpp-in-rust/</link><description><![CDATA[Since version 56, Firefox has had a new character encoding conversion library called encoding_rs. It is written in Rust and replaced the old C++ character encoding conversion library called uconv that dated from early 1999. Initially, all the callers of the character encoding conversion library were C++ code, so the new library, despite being written in Rust, needed to feel usable when used from C++ code. In fact, the library appears to C++ callers as a modern C++ library. Here are the patterns that I used to accomplish that.]]></description><guid isPermaLink="false">823c892a-d7a2-4185-b80f-ba0b47899b25</guid><pubDate>Mon,  3 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Henri Sivonen</dc:creator></item><item><title>8 Lessons from First Days of Advent of Code 2018</title><link>https://sts10.github.io/2018/12/02/lessons-from-first-two-days-of-advent-of-code-2018.html</link><description><![CDATA[I’ve got two days of Advent of Code 2018 under my belt and four stars to show for it! But I’ll be the first to admit that I had plenty of help, so I thought it only fair that I write out some of the things I’ve already learned about Rust.]]></description><guid isPermaLink="false">f8aa1176-9ae2-447f-b914-a6950612d7f2</guid><pubDate>Sun,  2 Dec 2018 23:22:00 +0000</pubDate><dc:creator>Sam Schlinkert</dc:creator></item><item><title>Dice.rs: Rust on Lambda</title><link>https://kellenfujimoto.com/posts/dicers-rust-on-lambda/</link><description><![CDATA[Rust support on AWS Lambda was recently released, which seems like as good an opportunity as any to share some code and the solutions to challenges I encountered along the way ☺. I’ve decided to create a little diceware service, and the lambda-runtime crate provides a great API to make this a breeze.]]></description><guid isPermaLink="false">c52eda57-1761-4ec3-9e59-c4c45d665574</guid><pubDate>Sun,  2 Dec 2018 14:18:59 +0100</pubDate><dc:creator>Kellen Frodelius-Fujimoto</dc:creator></item><item><title>Creating my first AWS Lambda using Rust</title><link>https://medium.com/@kkostov/rust-aws-lambda-30a1b92d4009</link><description><![CDATA[Taking advantage of AWS Lambda Runtime support for Rust]]></description><guid isPermaLink="false">7df2b166-e70e-4b15-bf6e-9475a81096e9</guid><pubDate>Sun,  2 Dec 2018 12:40:16 +0000</pubDate><dc:creator>Konstantin</dc:creator></item><item><title>Announcing RustaCUDA v0.1.0</title><link>https://bheisler.github.io/post/announcing-rustacuda/</link><description><![CDATA[In my post on GPGPU in Rust, I declared that I intended to work on improving the state of CUDA support in Rust. Since then, I’ve been mostly radio-silent. I’m pleased to announce that I have actually been working on something, and I’ve finally published that something.
RustaCUDA RustaCUDA is a new wrapper crate for the CUDA driver API. It allows the programmer to allocate and free GPU memory, copy data to and from the GPU, load CUDA modules and launch kernels, all with a mostly-safe, programmer-friendly, Rust-y interface.]]></description><guid isPermaLink="false">05addab4-8c30-4a75-9221-e156ea5d319c</guid><pubDate>Sat,  1 Dec 2018 15:00:00 -0600</pubDate><dc:creator>Brook Heisler</dc:creator></item><item><title>cargo-inspect: A Little Tool for Exploring Rust Internals</title><link>https://matthias-endler.de/2018/cargo-inspect/</link><description><![CDATA[Rust allows for a lot of syntactic sugar, that makes it a pleasure to write. It is sometimes hard, however, to look behind the curtain and see what the compiler is really doing with our code. I wondered if there was a tool, which revealed what Rust was doing behind the curtains.]]></description><guid isPermaLink="false">20ba5c8d-b4f2-4ae5-af75-7631ccc05f12</guid><pubDate>Sat,  1 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Matthias Endler</dc:creator></item><item><title>Rust Runtime for AWS Lambda</title><link>https://aws.amazon.com/blogs/opensource/rust-runtime-for-aws-lambda/</link><description><![CDATA[AWS Lambda, which makes it easy for developers to run code for virtually any type of application or backend service with zero administration, has just announced the Runtime APIs. The Runtime APIs define an HTTP-based specification of the Lambda programming model which can be implemented in any programming language. To accompany the API launch, we have open sourced a runtime for the Rust language.]]></description><guid isPermaLink="false">48218be5-130b-4274-b41a-7bfa20086f0d</guid><pubDate>Thu, 29 Nov 2018 18:02:27 +0000</pubDate><dc:creator>Stefano Buliani</dc:creator></item><item><title>Rust Flow, Part Two</title><link>https://myrrlyn.net/blog/misc/rust-flow-part-two</link><description><![CDATA[Rust doesn’t have a language-level concept of generic mutability, which makes “method threading” (which take `self` by some handle, and return it in the same way) hard to write. This article covers how to write in that pattern in a less painful way.]]></description><guid isPermaLink="false">5a0c9b1f-c433-44e6-947e-74076725fc32</guid><pubDate>Thu, 29 Nov 2018 00:00:00 +0000</pubDate><dc:creator>Alexander Payne</dc:creator></item><item><title>A new look for rust-lang.org</title><link>https://blog.rust-lang.org/2018/11/29/a-new-look-for-rust-lang-org.html</link><description><![CDATA[Today, we’d like to announce a beta of the new rust-lang.org. If you go to https://beta.rust-lang.org, you’ll see a preview of the new site.]]></description><guid isPermaLink="false">6afc7e52-af6d-4ecd-a5af-fb9e27a6ccf6</guid><pubDate>Thu, 29 Nov 2018 00:00:00 +0000</pubDate><dc:creator>The Rust Core Team</dc:creator></item><item><title>Rust Quiz</title><link>https://dtolnay.github.io/rust-quiz/</link><description><![CDATA[Test your Rust knowledge with tricky Rust questions.]]></description><guid isPermaLink="false">8c1f73a9-291c-4aa2-9e50-2cf4538f36db</guid><pubDate>Thu, 29 Nov 2018 00:00:00 +0000</pubDate><dc:creator>David Tolnay and Alex Crichton</dc:creator></item><item><title>Serverless HTTP in Rust</title><link>https://medium.com/@softprops/serverless-http-9a58f9b2df60</link><description><![CDATA[Throw down your main! Rustlang Serverless HTTP applications won’t need them where they’re going]]></description><guid isPermaLink="false">c1576100-8199-418d-bd9a-03c71f1b5559</guid><pubDate>Wed, 28 Nov 2018 11:11:52 +0000</pubDate><dc:creator>Doug Tangren</dc:creator></item><item><title>Writing MapReduce Jobs Using Rust and Efflux</title><link>https://whitfin.io/writing-mapreduce-jobs-using-rust/</link><description><![CDATA[During my work life, I spend a lot of time working with MapReduce-style workflows, particularly with Hadoop infrastructure. A lot of this work is spent with larger amounts of data in order to implement the batch layer of the Lambda architecture. Due to this, the largest concern is that the behaviour is consistent across both the batch layer and the realtime layer - naturally you wouldn't want sporadic behaviour across the two. The easiest way to do this is to share code across the layers, to avoid having to keep implementations in sync. We have recently been working with Rust, which has been a little difficult to integrate with Hadoop MapReduce flows due to the fact it's mainly written in Java. It's because of this that I began to work on a small library named Efflux. It's designed as a very small interface to the MapReduce pattern, and implemented in Rust to allow us to share code across the batch layer easily.]]></description><guid isPermaLink="false">00a3f85a-45c7-42b3-8fac-605dcb945229</guid><pubDate>Wed, 28 Nov 2018 07:00:49 +0000</pubDate><dc:creator>Isaac Whitfield</dc:creator></item><item><title>Rust Web Survey Results 2018</title><link>https://rust-lang-nursery.github.io/wg-net/2018/11/28/wg-net-survey.html</link><description><![CDATA[We recently sent out a survey regarding the state of the current Rust web ecosystem and we got over a 1000 responses! We really appreciate the feedback from the community. This will help us continue to improve upon the state of the Rust web ecosystem. Today, we would like to go over the responses and understand the results.]]></description><guid isPermaLink="false">881d8c07-ccf4-48be-ab22-bd76cc7c848d</guid><pubDate>Wed, 28 Nov 2018 00:00:00 +0000</pubDate><dc:creator>Bhargav Voleti</dc:creator></item><item><title>Rust Language Cheat Sheet</title><link>https://cheats.rs/</link><description><![CDATA[This is the "Rust Language Cheat Sheet". It is for users who: are early Rust professionals (experienced programmers, intermediate Rust users), and prefer visual, example-driven content. Use cases, in order of priority: "identification guide" for unknown or symbolic constructs encountered in code. Provide further reading from easy to advanced (Book to Nomicon). Quick lookup for language related problems. Discover constructs in the language you might not know.]]></description><guid isPermaLink="false">ed652ceb-f7cd-4566-b37c-757f6d089240</guid><pubDate>Wed, 28 Nov 2018 00:00:00 +0000</pubDate><dc:creator>Ralf Biedert</dc:creator></item><item><title>Firecracker: Secure and Fast microVM for Serverless Computing</title><link>https://aws.amazon.com/blogs/opensource/firecracker-open-source-secure-fast-microvm-serverless/</link><description><![CDATA[In the fall of 2017, we decided to write Firecracker in Rust, a modern programming language that guarantees thread and memory safety and prevents buffer overflows and many other types of memory safety errors that can lead to security vulnerabilities. Read more details about the features and architecture of the Firecracker VMM at Firecracker Design.

Firecracker microVMs improve efficiency and utilization with a low memory overhead of < 5 MiB per microVMs. This means that you can pack thousands of microVMs onto a single machine. You can use an in-process rate limiter to control, with fine granularity, how network and storage resources are shared, even across thousands of microVMs. All hardware compute resources can be safely oversubscribed, to maximize the number of workloads that can run on a host.]]></description><guid isPermaLink="false">50e86e16-57e4-4740-8251-b7eb6340d9ad</guid><pubDate>Tue, 27 Nov 2018 05:02:08 +0000</pubDate><dc:creator>Arun Gupta</dc:creator></item><item><title>Tide’s evolving middleware approach</title><link>https://rust-lang-nursery.github.io/wg-net/2018/11/27/tide-middleware-evolution.html</link><description><![CDATA[Since the last post on Tide, there have been a number of excellent contributions from a bunch of new contributors! In this post, I want to talk about the work that @tirr-c has done to substantially improve the middleware story.]]></description><guid isPermaLink="false">abba07ed-5ffb-4b29-ba29-f1e6dbdce718</guid><pubDate>Tue, 27 Nov 2018 00:00:00 +0000</pubDate><dc:creator>Aaron Turon</dc:creator></item><item><title>Rust Survey 2018 Results</title><link>https://blog.rust-lang.org/2018/11/27/Rust-survey-2018.html</link><description><![CDATA[Another year means another Rust survey, and this year marks Rust’s third annual survey. This year, the survey launched for the first time in multiple languages. In total 14 languages, in addition to English, were covered. The results from non-English languages totalled 25% of all responses and helped pushed the number of responses to a new record of 5991 responses. Before we begin the analysis, we just want to give a big “thank you!” to all the people who took the time to respond and give us your thoughts. It’s because of your help that Rust will continue to improve year after year.]]></description><guid isPermaLink="false">5ed5c8fa-d94a-44ab-836b-35ee61f1f048</guid><pubDate>Tue, 27 Nov 2018 00:00:00 +0000</pubDate><dc:creator>The Rust Survey Team</dc:creator></item><item><title>Haskell and Rust</title><link>https://www.fpcomplete.com/blog/2018/11/haskell-and-rust</link><description><![CDATA[Learn more about how the Rust programming language shares many of the advantages offered by Haskell such as a strong type system, great tooling, polymorphism, immutability, concurrency, and great software testing methodologies.  Rust is a good choice when you need to squeeze in extra performance.]]></description><guid isPermaLink="false">400c4c0d-78d0-41fe-bd07-c4a720ade708</guid><pubDate>Mon, 26 Nov 2018 17:33:00 +0000</pubDate><dc:creator>Chris Allen</dc:creator></item><item><title>The Seedling Sees the Light of Day: Sequoia-PGP Initial Release</title><link>https://sequoia-pgp.org/blog/2018/11/26/initial-release/</link><description><![CDATA[On October 16, 2017, we made the first commit to the Sequoia repository. Just over a year and a thousand commits later, Sequoia’s low-level API is nearly feature complete, and is already usable. For instance, a port of the p≡p engine to Sequoia is almost finished, and the code is significantly simpler than the version using the current OpenPGP library. We’ve also made experimental ports of other software that use OpenPGP, and written some new software to further validate the completeness and ergonomics of the API.]]></description><guid isPermaLink="false">5d14453d-3a6f-4f26-8aa1-20edec9e9347</guid><pubDate>Mon, 26 Nov 2018 10:08:17 +0100</pubDate><dc:creator>Neal H. Walfield, Justus Winter, and Kai Michaelis</dc:creator></item><item><title>Generating Sudoku Boards pt. 3: Rust for WebAssembly</title><link>https://medium.com/@rossharrison/generating-sudoku-boards-pt-3-rust-for-webassembly-85bd7294c34a</link><description><![CDATA[Adjusting an existing Rust project to build a native binary and library for WASM, load in JS. Details on working through build issues.]]></description><guid isPermaLink="false">108e3952-7d7b-4fcc-9c76-073646f2ddee</guid><pubDate>Mon, 26 Nov 2018 00:18:40 +0000</pubDate><dc:creator>Ross Harrison</dc:creator></item><item><title>Getting started with nightly async/await support</title><link>https://jsdw.me/posts/rust-asyncawait-preview/</link><description><![CDATA[Following on from my last post, I thought I would look at async/await support in Rust. The async/await support coming to Rust brings with it a much more ergonomic way to work with asynchronous computations. In this post I'll introduce std::future::Future, and run through how to make use of them, and how to interoperate with the current ecosystem which is built around version 0.1 of the futures package.]]></description><guid isPermaLink="false">c1afc363-1078-4dbd-a3e4-e0f05f255d62</guid><pubDate>Mon, 26 Nov 2018 00:00:00 +0000</pubDate><dc:creator>James Wilson</dc:creator></item><item><title>Converting AsyncRead and AsyncWrite to Futures, Sinks and Streams</title><link>https://jsdw.me/posts/rust-futures-tokio/</link><description><![CDATA[Prior to this experience, I had thought that Futures, Sinks and Streams were the smallest building blocks in the world of Tokio, and so I went looking through the Tokio documentation for these things. Actually, all of the fundamental objects to read and write bytes to things implement one or both of AsyncRead and AsyncWrite, but not the Future, Sink or Stream traits. In fact, there are lots of poll_x methods dotted around, so I realised I needed to figure out how to make use of them.]]></description><guid isPermaLink="false">22495ae4-a7be-4899-92ab-ede35669df1b</guid><pubDate>Sun, 25 Nov 2018 00:00:00 +0000</pubDate><dc:creator>James Wilson</dc:creator></item><item><title>WIP: A no_std Rust crate for reading SD/MMC cards</title><link>https://www.reddit.com/r/rust/comments/a07k6e/wip_a_no_std_rust_crate_for_reading_sdmmc_cards/</link><description><![CDATA[To make it easier to load programs on to the Monotron, I've been working on a crate to make it really simple to read data from SD and SDHC cards formatted with FAT16 or FAT32. The crate is written without `alloc` so it uses zero heap, and I try to keep no more than one 512 byte block on the stack at a time.]]></description><guid isPermaLink="false">30b59cbd-a9ce-4f67-846b-93a30d134e5d</guid><pubDate>Sun, 25 Nov 2018 00:00:00 +0000</pubDate><dc:creator>Jonathan Pallant</dc:creator></item><item><title>Rust+GNOME Hackfest #4</title><link>http://antoyo.ml/rust-gnome-hackfest-thessaloniki</link><description><![CDATA[Less than 2 weeks ago, I was working on improving the integration of Rust with GNOME libraries at the fourth Hackfest, which happened this time in Thessaloniki.]]></description><guid isPermaLink="false">c9feb6f2-ba42-42ca-a0a3-dc37f4ce69ff</guid><pubDate>Sun, 25 Nov 2018 00:00:00 +0000</pubDate><dc:creator>Antoni Boucher</dc:creator></item><item><title>Amethyst Foundation Created</title><link>https://www.amethyst.rs/blog/non-profit-announce/</link><description><![CDATA[The Amethyst team has some special announcements. A non-profit foundation has been formed and a new community forums site has been created.]]></description><guid isPermaLink="false">1e18d220-093b-46bd-b260-640ed3d74deb</guid><pubDate>Fri, 23 Nov 2018 00:00:00 +0000</pubDate><dc:creator>Moxinilian (Théo Degioanni)</dc:creator></item><item><title>Rusty clock: An alarm clock with environment stats in pure bare metal embedded Rust</title><link>https://github.com/TeXitoi/rusty-clock/blob/master/README.md</link><description><![CDATA[This alarm clock is programed in bare metal rust (no OS). It features pressure, temperature, humidity, monophonic alarm on a e-paper display.]]></description><guid isPermaLink="false">4c4ca2bc-0e59-4c24-92c1-2b37630f2280</guid><pubDate>Wed, 21 Nov 2018 23:03:26 +0000</pubDate><dc:creator>Guillaume P.</dc:creator></item><item><title>Implementing an EBNF grammar in pest</title><link>https://compenguy.github.io/hobbies/rust/ebnf-to-pest.html</link><description><![CDATA[A recent project has led me to have a go at writing an XML parser. I thought I’d document my experiences using pest to implement a lexer using the EBNF-esque formal grammar.]]></description><guid isPermaLink="false">fd9c743c-fb89-4e75-8a46-a837c02174a1</guid><pubDate>Thu, 22 Nov 2018 05:46:00 +1100</pubDate><dc:creator>Will Page</dc:creator></item><item><title>Generic Methods in Rust: How Exonum Shifted from Iron to Actix-web</title><link>https://medium.com/meetbitfury/generic-methods-in-rust-how-exonum-shifted-from-iron-to-actix-web-7a2752171388</link><description><![CDATA[In this article, we describe how we ported the Exonum framework to actix-web using generic programming.]]></description><guid isPermaLink="false">c5b56719-bdcd-4d91-8b61-85a27cd5315c</guid><pubDate>Wed, 21 Nov 2018 10:51:32 +0000</pubDate><dc:creator>Exonum</dc:creator></item><item><title>Wait-Free Per-Object Thread-Local Storage</title><link>https://bzim.gitlab.io/blog/posts/wait-free-per-object-thread-local-storage.html</link><description><![CDATA[In this post, I present a wait-free thread-local storage using the Rust language.]]></description><guid isPermaLink="false">3c9dc7f2-978e-4663-900e-8a49c10bf57f</guid><pubDate>Sun, 18 Nov 2018 00:00:00 +0000</pubDate><dc:creator>Bruno Corrêa Zimmermann</dc:creator></item><item><title>Compile Time Feature Flags in Rust</title><link>https://www.worthe-it.co.za/programming/2018/11/18/compile-time-feature-flags-in-rust.html</link><description><![CDATA[Toggling feature flags when you compile for zero runtime cost]]></description><guid isPermaLink="false">24375765-7fa7-4729-8b69-734c409c47fb</guid><pubDate>Sun, 18 Nov 2018 00:00:00 +0000</pubDate><dc:creator>Justin Worthe</dc:creator></item><item><title>Introducing pest into glsl and hindsight about nom vs. pest (part 2)</title><link>https://phaazon.net/blog/glsl-pest-part-2</link><description><![CDATA[This is the second article about my experience at supporting pest in my glsl crate – without, for now, removing the nom parser.]]></description><guid isPermaLink="false">84353bd7-6977-4894-883f-b917ccef0b45</guid><pubDate>Sat, 17 Nov 2018 20:40:00 +0000</pubDate><dc:creator>Dimitri Sabadie</dc:creator></item><item><title>Synthesizing Structures with immense</title><link>https://paytonturnage.com/writing/2018-11-17-synthesizing-structures-with-immense/</link><description><![CDATA[I wrote a nightly Rust library called immense for synthesizing 3D structures with simple composable rules, inspired by Structure Synth. In the docs I cover the basics, and in this article I’ll go over making a mesh from start to finish.]]></description><guid isPermaLink="false">04284ee3-1ace-4204-bb2f-e2d27249c8c2</guid><pubDate>Sat, 17 Nov 2018 12:09:00 +0000</pubDate><dc:creator>Payton Turnage</dc:creator></item><item><title>Introducing pest into glsl and hindsight about nom vs. pest (part 1)</title><link>https://phaazon.net/blog/glsl-pest-part-1</link><description><![CDATA[This is the first article out of a (I guess?!) series of upcoming articles about… parsing. More specifically, I’ve been writing the glsl crate for a while now and the current, in-use parser is backed with nom. nom is a parser combinator crate written originally by @geal and there has been a lot of fuzz around nom vs. pest lately.

Soooooooooooo. Because glsl is written with nom in its third iteration and because nom is now at version 4, I decided it was time to update the parser code of glsl. I heard about the comparison between pest and nom and decided to write an implementation with pest.

This is the first article of a series about how writing a pest looks like is fun compared to writing the nom parser. I’ll post several articles as I advance and see interesting matter to discuss and share.]]></description><guid isPermaLink="false">2a3a85cf-b4ac-49ff-9a27-4d377cd3d0cb</guid><pubDate>Sat, 17 Nov 2018 05:00:00 +0000</pubDate><dc:creator>Dimitri Sabadie</dc:creator></item><item><title>Build Your Own Shell using Rust</title><link>https://www.joshmcguigan.com/blog/build-your-own-shell-rust/</link><description><![CDATA[This is a tutorial on building your own shell using Rust, in the spirit of the build-your-own-x list. Creating a shell is a great way to understand how the shell, terminal emulator, and OS work together.]]></description><guid isPermaLink="false">5527d11f-6f5e-47f4-b208-c90499764f04</guid><pubDate>Sat, 17 Nov 2018 00:00:00 +0000</pubDate><dc:creator>Josh Mcguigan</dc:creator></item><item><title>Can you Drop it?</title><link>http://optimistictypes.com/can-you-drop-it/</link><description><![CDATA[Resource allocation & the implementation of drop logic in Rust.]]></description><guid isPermaLink="false">18ce3041-0f7a-4bf8-8e5a-ccea2a6c8053</guid><pubDate>Sat, 17 Nov 2018 00:00:00 +0000</pubDate><dc:creator>J Haigh</dc:creator></item><item><title>Gutenberg is out, Zola 0.5.0 is in</title><link>https://www.vincentprouillet.com/blog/releasing-zola-0-5-0/</link><description><![CDATA[Gutenberg changes name to Zola and gets a big release to celebrate.]]></description><guid isPermaLink="false">6b8f2916-9634-4d6b-ae64-02d565c58659</guid><pubDate>Sat, 17 Nov 2018 00:00:00 +0000</pubDate><dc:creator>Vincent Prouillet</dc:creator></item><item><title>Bringing Elm’s architecture to Rust and Webassembly</title><link>https://sindrejohansen.no/blog/willow/rust/elm/2018/11/16/willow-elm-in-rust.html</link><description><![CDATA[I really like Elm. It is a delightful language with an amazing ecosystem. It has an interesting architecture called TEA, The Elm Architecture. Another language I like is Rust. On paper, Rust is completely different from Elm, but in using them both, I have seen some resemblance. Having used both Elm and Rust I had something I wanted to try. Would it be possible to create The Elm Architecture in Rust?]]></description><guid isPermaLink="false">ad136bed-3540-4ced-8a77-448b94426ba3</guid><pubDate>Fri, 16 Nov 2018 16:35:22 +0000</pubDate><dc:creator>Sindre</dc:creator></item><item><title>Programming Servo: A background-hang-monitor</title><link>https://medium.com/programming-servo/programming-servo-a-background-hang-monitor-73e89185ce1</link><description><![CDATA[Let’s say you’re contributing to a system in Rust consisting of a bunch of different components, running in their own threads or processes, for example an engine to make the Web run.

When one of those components seemingly hangs on something, how can you find out what it is hanging on? Maybe a backtrace of what that component is doing at that time would be useful?

That’s easy, for that we have thebacktrace-rs crate, right?

Well, there’s a catch: how do we call Backtrace::new() from a thread that is hanging?]]></description><guid isPermaLink="false">40ed3562-277a-453f-84a6-29ab5314ed0c</guid><pubDate>Fri, 16 Nov 2018 12:30:06 +0000</pubDate><dc:creator>Gregory Terzian</dc:creator></item><item><title>Stacked Borrows Implemented</title><link>https://www.ralfj.de/blog/2018/11/16/stacked-borrows-implementation.html</link><description><![CDATA[Three months ago, I proposed Stacked Borrows as a model for defining what kinds of aliasing are allowed in Rust, and the idea of a validity invariant that has to be maintained by all code at all times. Since then I have been busy implementing both of these, and developed Stacked Borrows further in doing so. This post describes the latest version of Stacked Borrows, and reports my findings from the implementation phase: What worked, what did not, and what remains to be done. There will also be an opportunity for you to help the effort!]]></description><guid isPermaLink="false">4d211c62-3ab3-4db5-a900-94731f798765</guid><pubDate>Fri, 16 Nov 2018 00:00:00 +0000</pubDate><dc:creator>Ralf Jung</dc:creator></item><item><title>Program Synthesis is Possible in Rust</title><link>http://fitzgeraldnick.com/2018/11/15/program-synthesis-is-possible-in-rust.html</link><description><![CDATA[Program synthesis is the act of automatically constructing a program thatfulfills a given specification. I recently stumbled across Adrian Sampson’s Program Synthesis is Possible blog post. Adrian describes and implements minisynth, a toy program synthesizer that generates constants for holes in a template program when given a specification. What fun! As a way to learn more about program synthesis myself, I ported minisynth to Rust.]]></description><guid isPermaLink="false">e8b911ca-d007-441e-93e3-d8f1f1b89a00</guid><pubDate>Thu, 15 Nov 2018 00:00:00 -0800</pubDate><dc:creator>Nick Fitzgerald</dc:creator></item><item><title>Rust And Game Development</title><link>https://alexene.github.io/2018/11/15/Rust-and-game-development.html</link><description><![CDATA[Rust is excellent for performance crucial applications that run on multi-processor architectures and these two aspects are also critical for game development. Rust has already seen a bunch of interest from games developers like Chucklefish, Embark Studios, Ready at Dawn, etc. - but in order to really excel I’d love to organize some structured efforts to improve the ecosystem and I think it would be great if the 2019 roadmap will include game development.]]></description><guid isPermaLink="false">dabab963-1e9e-4b55-bb85-d0173a1db54a</guid><pubDate>Thu, 15 Nov 2018 00:00:00 +0000</pubDate><dc:creator>Alexandru Ene</dc:creator></item><item><title>Rust, MongoDB &amp; Wither 0.6</title><link>https://medium.com/docql/https-medium-com-docql-rust-mongodb-wither-13e803c9ae72</link><description><![CDATA[Hello everyone! I would like to share an update on an open source project which I have been developing for a little while now. It is a Rust project called Wither which attempts to “provide a simple, sane & predictable interface into MongoDB, based on data models”. This post is about the 0.6 release of this crate, and I would like to dive into some of the aspects of developing this release which I really enjoyed or which I found interesting.]]></description><guid isPermaLink="false">b21ca2e0-5670-4a7b-af11-3a6c1312d5e2</guid><pubDate>Wed, 14 Nov 2018 18:33:12 +0000</pubDate><dc:creator>Anthony Dodd</dc:creator></item><item><title>This Year in Embedded Rust</title><link>https://rust-embedded.github.io/blog/2018-11-14-this-year-in-embedded-rust/</link><description><![CDATA[This year the Embedded WG set out to build the solid foundation that the embedded Rust ecosystem requires to thrive. As we approach the date of the 2018 edition release we reflect on our progress and share our achievements with you in this post.]]></description><guid isPermaLink="false">68074e79-2747-4170-970f-0e56b936578c</guid><pubDate>Wed, 14 Nov 2018 00:00:00 +0000</pubDate><dc:creator>The Embedded Working Group</dc:creator></item><item><title>Running Rust natively in AWS Lambda and testing it locally</title><link>https://medium.com/@bernardo.belchior1/running-rust-natively-in-aws-lambda-and-testing-it-locally-57080421426d</link><description><![CDATA[Abusing Go runtime in AWS to run Rust binaries]]></description><guid isPermaLink="false">97715a00-432f-4cfa-9c11-92f0d74ff60e</guid><pubDate>Mon, 12 Nov 2018 14:23:33 +0000</pubDate><dc:creator>Bernardo Belchior</dc:creator></item><item><title>Things Rust doesn’t let you do</title><link>https://medium.com/@GolDDranks/things-rust-doesnt-let-you-do-draft-f596a3c740a5</link><description><![CDATA[A survey of things that Rust doesn’t let you do although arguably safe.]]></description><guid isPermaLink="false">858249f6-6979-48c9-a138-1b7fd2fc9502</guid><pubDate>Mon, 12 Nov 2018 01:34:25 +0000</pubDate><dc:creator>Pyry Kontio</dc:creator></item><item><title>Rust Flow: Function and Method Sequences in Rust</title><link>https://myrrlyn.net/blog/misc/rust-flow</link><description><![CDATA[Rust allows for a very functional style of value “flow” without sacrificing the performance of a more traditionally imperative sequence. Furthermore, the functional flow may offer more clarity about value lifetimes and error handling that the imperative sequence might obscure.]]></description><guid isPermaLink="false">d435191e-e40d-477d-a5ee-908808ee5eee</guid><pubDate>Sun, 11 Nov 2018 14:44:00 +0000</pubDate><dc:creator>Alexander Payne</dc:creator></item><item><title>Truly Zero Cost</title><link>https://vorner.github.io/2018/11/11/truly-zero-cost.html</link><description><![CDATA[I know it is claimed how Rust has zero cost abstractions and such and that all these levels of abstractions will just go away in a release build. But there’s a difference in hearing the theory and seeing it really happen in practice. And I don’t appreciate it because I’d consider it magic, but more because I understand how that is being done and it still looks cool.]]></description><guid isPermaLink="false">c6c90807-5108-434e-9dc0-c5ba8135420d</guid><pubDate>Sun, 11 Nov 2018 00:00:00 +0000</pubDate><dc:creator>Michal &apos;vorner&apos; Vaner</dc:creator></item><item><title>Serve archived static files over HTTP</title><link>https://deterministic.space/serve-archived-static-files-over-http.html</link><description><![CDATA[Say you want to store a huge number of very small filesthat you will only access over HTTP.For example:You are using rustdoc to render the documentation of a library.Without much work you’ll end up with about 100k HTML filesthat are about 10kB each.As it turns out,this number of small files is very annoying for any kind of file system performance.Best case: making copies/backups is slow.Worst case: You’re using an anti virus software and it takes ages.]]></description><guid isPermaLink="false">b2687a6e-55b3-4d3b-a025-fc9e7c592e8e</guid><pubDate>Sun, 11 Nov 2018 00:00:00 +0100</pubDate><dc:creator>Pascal Hertleif</dc:creator></item></channel></rss>