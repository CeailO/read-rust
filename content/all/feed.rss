<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/"><channel><title>Read Rust - All Posts</title><link>https://readrust.net/</link><description>All Posts posts on Read Rust</description><item><title>Organizational Debt</title><link>https://boats.gitlab.io/blog/post/rust-2019/</link><description><![CDATA[We all know that classic aphorism: Year comes to an end, Rust blog post press send. This is mine.

There are lots of cool technical improvements to Rust that I want the project to achieve this year, and a few in particular that I’m definitely going to be putting a lot of time into. But this blog post is going to talk about none of them. Instead, I want to talk about organizational debt, and how badly the Rust project needs to deal with it in 2019.]]></description><guid isPermaLink="false">f0adf24b-6589-4306-a580-6cef894ad3b7</guid><pubDate>Mon, 16 Dec 2019 00:00:00 +0000</pubDate><dc:creator>withoutboats</dc:creator></item><item><title>Wasm By Example</title><link>https://wasmbyexample.dev/</link><description><![CDATA[A hands-on introduction into WebAssembly ( Wasm ). Containing simple examples and tutorials on how to implement concepts and various tasks using Wasm.]]></description><guid isPermaLink="false">2c73c05a-7fb3-494d-8fb3-896cf3a343b3</guid><pubDate>Wed, 26 Jun 2019 03:28:00 +0000</pubDate><dc:creator>Aaron Turner</dc:creator></item><item><title>Rust type language - journey to rust</title><link>https://medium.com/journey-to-rust/rust-type-language-48e1c43b1ef4</link><description><![CDATA[Disclaimer: If you are learning Rust, take this with grain of salt. I’m learning Rust too and I may be utterly wrong in my guesses. The more I read and do Rust, the more I realize, that Rust consists of two (three, if macros counts) languages.]]></description><guid isPermaLink="false">4b9faf2d-145a-4deb-909d-ac58ea05bdc8</guid><pubDate>Tue, 25 Jun 2019 14:10:43 +0000</pubDate><dc:creator>George Shuklin</dc:creator></item><item><title>Rustexp: A Rust regular expression editor &amp; tester</title><link>https://rustexp.lpil.uk/</link><description><![CDATA[A Rust regular expression editor & tester inspired by Rubular.]]></description><guid isPermaLink="false">b9742776-a64f-4358-beff-fabdf075d65d</guid><pubDate>Tue, 25 Jun 2019 00:00:00 +0000</pubDate><dc:creator>Louis Pilfold</dc:creator></item><item><title>Why we&apos;re using Rust for cloud rendering</title><link>https://www.digitalbridge.com/blog/why-were-using-rust-for-cloud-rendering</link><description><![CDATA[We initially began replacing a small component of our stack using Rust, but it quickly became clear that a larger effort would allow a great reduction in complexity. In the end, all the C, C++, and Python components of the service were rebuilt, with Rust used from task loading through to dispatching GPU operations.]]></description><guid isPermaLink="false">91f9b804-7782-4a78-ade2-e4d8008923cf</guid><pubDate>Mon, 24 Jun 2019 12:07:47 +0000</pubDate><dc:creator>Iain MacIver</dc:creator></item><item><title>Building Standalone Python Applications with PyOxidizer</title><link>https://gregoryszorc.com/blog/2019/06/24/building-standalone-python-applications-with-pyoxidizer/</link><description><![CDATA[Today, I'm excited to announce the first release of PyOxidizer (project, documentation), an open source utility that aims to solve the Python application distribution problem! (The installation instructions are in the docs.) PyOxidizer's marquee feature is that it can produce a single file executable containing a fully-featured Python interpreter, its extensions, standard library, and your application's modules and resources.]]></description><guid isPermaLink="false">6a4e1bf9-728a-4c25-919d-05ae4664366c</guid><pubDate>Mon, 24 Jun 2019 09:00:00 +0000</pubDate><dc:creator>Gregory Szorc</dc:creator></item><item><title>swym: Are we lock-free yet?</title><link>https://mtak-blog.github.io/are-we-lock-free-yet</link><description><![CDATA[swym is a transactional memory library that prioritizes performance. It’s not lock-free, but it does have progress guarantees. This post will explore some of the recent work on swym’s progress promises, as well as some comparisons with non-blocking algorithms. I’m not an expert on schedulers or OS’s, so please correct me if anything is wrong. It might benefit swym!]]></description><guid isPermaLink="false">c274055b-d2a2-43f1-9ef3-a9fc15521878</guid><pubDate>Mon, 24 Jun 2019 00:00:00 +0000</pubDate><dc:creator>mtak-</dc:creator></item><item><title>nom, the Rust parser combinators library, is now available at version 5</title><link>http://unhandledexpression.com/general/2019/06/17/nom-5-is-here.html</link><description><![CDATA[nom, the Rust parser combinators library, is now available at version 5. This is the most mature version of nom. This is the one that feels “done”. This is the parser library that I wanted when I started nom 5 years ago. It’s here at last. nom 5 is a complete rewrite of the internal architecture, to use functions instead of macros, while keeping backward compatibility with existing macros based parsers, and making the error type completely generic.]]></description><guid isPermaLink="false">f6a2f624-a597-4ae7-b89a-e621ebb50c55</guid><pubDate>Mon, 24 Jun 2019 00:00:00 +0000</pubDate><dc:creator>Geoffroy Couprie</dc:creator></item><item><title>Real Time For the Masses goes multi-core</title><link>https://blog.japaric.io/multicore-rtfm/</link><description><![CDATA[v0.5.0 of Real Time For the Masses (RTFM), the embedded concurrency framework, is coming out soon-ish – some time after Rust 1.36 is released – and will include experimental support for homogeneous and heterogeneous multi-core Cortex-M devices. This blog post covers the upcoming multi-core API and includes a refresher on the single-core API.]]></description><guid isPermaLink="false">fafe9330-b614-4ea0-a2eb-1958d77fc8f4</guid><pubDate>Sun, 23 Jun 2019 00:00:00 +0000</pubDate><dc:creator>Jorge Aparicio</dc:creator></item><item><title>Implementing HTSP in Rust</title><link>https://www.rubdos.be/rust/async/programming/2019/06/22/implementing-htsp-in-rust.html</link><description><![CDATA[As with most hobby projects, my htsp-rs implementation became a side-side-side project, and it will probably stay that way. Another property of those hobby projects is that I now-and-then pick them up again, and htsp-rs has come to that point now. The reason for picking it up again is different from the reason of its existence though, and that’s a good thing: it means I have multiple reasons for the crate’s existence. Initially, I wanted it as a back-end for a livestreaming app on SailfishOS. Today, I want it as back-end for mpd’s TVHeadend support.]]></description><guid isPermaLink="false">0770f016-861d-4bc1-9ce0-cad6b6e374f2</guid><pubDate>Sat, 22 Jun 2019 00:00:00 +0000</pubDate><dc:creator>Ruben De Smet</dc:creator></item><item><title>Rust for OOP - Enums &amp; Pattern Matching - Part 2</title><link>https://oribenshir.github.io/afternoon_rusting//blog/enum-and-pattern-matching-part-2</link><description><![CDATA[We will continue the previous post with two complementary examples. Both will demonstrate the capability of enums to push various language constructs and states into the type system. As an example for it, imagine we could create a type which represents an if statement, and then hand over instances of it around our program. Enums tends to work better than using the underlying concepts for various reason, starting from the complexity of the borrow checkers and lifetimes, through the powerful type system in Rust. And not less important, allowing you to code common patterns as functions, in a way otherwise wouldn’t be available to you. We will see all of this today. Later in the series, we will revisit those examples, and we will demonstrate how well they can compose with other code we can write.]]></description><guid isPermaLink="false">0f371197-7406-4f9f-8460-b8a9e951ec27</guid><pubDate>Sat, 22 Jun 2019 00:00:00 +0000</pubDate><dc:creator>Ori Ben-Shir</dc:creator></item><item><title>RSoC: Implementing ptrace for Redox OS - part 1</title><link>https://www.redox-os.org/news/rsoc-ptrace-1/</link><description><![CDATA[After having a pretty clear goal to meet specified by the RFC, time to get things moving. I started with what I thought would be low hanging fruit: Reading the registers of another process. It ended up being more difficult than I thought, but it ended up being really interesting and I want to share it with you :)]]></description><guid isPermaLink="false">25660960-3e2c-44ba-a511-2dd73afc6a32</guid><pubDate>Sat, 22 Jun 2019 00:00:00 +0000</pubDate><dc:creator>jD91mZM2</dc:creator></item><item><title>Gtk-rs: New release - more complete, safer</title><link>https://gtk-rs.org/blog/2019/06/22/new-release.html</link><description><![CDATA[Welcome everyone to this whole new gtk-rs release! Time to check what was added/updated in this new version.]]></description><guid isPermaLink="false">0f224e61-b4f3-40f2-b99a-431cf41ec5d8</guid><pubDate>Sat, 22 Jun 2019 00:00:00 +0000</pubDate><dc:creator>Gtk-rs Developers</dc:creator></item><item><title>The smooth resize test</title><link>https://raphlinus.github.io/rust/gui/2019/06/21/smooth-resize-test.html</link><description><![CDATA[Today is an exciting point in the evolution of native GUI in Rust. There is much exploration, and a number of promising projects, but I also think we don’t yet know the recipe to make GUI truly great. As I develop my own vision in this space, druid, I hope more that the efforts will learn from each other and that an excellent synthesis will emerge, more so than simply hoping that druid will win.

In my work, I have come across a problem that is as seemingly simple, yet as difficult to get right, as making decent tea: handling smooth window resizing. Very few GUI toolkits get it perfect, with some failing spectacularly. This is true across platforms, though Windows poses special challenges. It’s also pretty easy to test (as opposed to requiring sophisticated latency measurements, which I also plan to develop). I suggest it become one of the basic tests to evaluate a GUI toolkit.]]></description><guid isPermaLink="false">1898399d-d60a-46fc-a3e0-cb8a73fb546e</guid><pubDate>Fri, 21 Jun 2019 19:50:42 +0000</pubDate><dc:creator>Raph Levien</dc:creator></item><item><title>Collaborative Editor in Rust</title><link>https://caolan.org/posts/collaborative_editor_in_rust.html</link><description><![CDATA[I've been experimenting with techniques for collaborative editing in Rust recently and I'd like to share my first functional prototype with you. The demo uses Rust and WebAssembly, and I implemented it using a conflict-free replicated data type (CRDT) based on LOGOOT, which I modified to work with variable-sized strings rather than individual characters or lines.]]></description><guid isPermaLink="false">54d40e7f-c5c5-4c69-86e2-9913c6a88200</guid><pubDate>Fri, 21 Jun 2019 00:00:00 +0000</pubDate><dc:creator>Caolan McMahon</dc:creator></item><item><title>Getting Started with Rust: Working with Files and Doing File I/O</title><link>https://www.linuxjournal.com/content/getting-started-rust-working-files-and-doing-file-io</link><description><![CDATA[This article demonstrates how to perform basic file and file I/O operations in Rust, and also introduces Rust's ownership concept and the Cargo tool. If you are seeing Rust code for the first time, this article should provide a pretty good idea of how Rust deals with files and file I/O, and if you've used Rust before, you still will appreciate the code examples in this article. ]]></description><guid isPermaLink="false">c03bd61e-3c2d-4e4d-a081-ffa0e3b641ed</guid><pubDate>Thu, 20 Jun 2019 00:00:00 +0000</pubDate><dc:creator>Mihalis Tsoukalos</dc:creator></item><item><title>Asyncifying an Actix Web App and Upgrading it to 1.0 - zupzup</title><link>https://zupzup.org/asyncify-rust-webapp/</link><description><![CDATA[In a previous post, we created an Actix 0.7 Web App, which was not fully non-blocking. In this post, we'll become fully non-blocking and upgrade the app to Actix 1.0]]></description><guid isPermaLink="false">a5730863-ff70-4122-8595-81c11ee59697</guid><pubDate>Thu, 20 Jun 2019 00:00:00 +0000</pubDate><dc:creator>Mario Zupan</dc:creator></item><item><title>A Detailed Look at Rust Streams</title><link>https://blog.yoshuawuyts.com/rust-streams/</link><description><![CDATA[As Rust's async story is evolving, so is Rust's streaming story. In this post we'll take a look at how Rust's streaming model works, how to use it effectively, and where things are heading in the future.]]></description><guid isPermaLink="false">7602cf1d-bae1-41bb-bfb8-4d7967af1704</guid><pubDate>Thu, 20 Jun 2019 00:00:00 +0000</pubDate><dc:creator>Yoshua Wuyts</dc:creator></item><item><title>Distributed Systems Training in Rust and Go</title><link>https://tikv.org/blog/talent-training/</link><description><![CDATA[PingCAP is creating a series of training courses on writing distributed systems in Rust and Go. These courses consist of:

Practical Networked Applications in Rust. A series of projects that incrementally develop a single Rust project from the ground up into a high-performance, networked, parallel and asynchronous key/value store. Along the way various real-world and practical Rust development subject matter are explored and discussed.

Distributed Systems in Rust. Adapted from the MIT 6.824 distributed systems coursework, this course focuses on implementing important distributed algorithms, including the Raft consensus algorithm, and the Percolator distributed transaction protocol.]]></description><guid isPermaLink="false">f756eb13-90c3-407a-a304-66e198248d3b</guid><pubDate>Thu, 20 Jun 2019 00:00:00 +0000</pubDate><dc:creator>Brian Anderson</dc:creator></item><item><title>Rust crates – frehberg’s annotated catalogue</title><link>https://frehberg.com/2019/06/rust-crates-frehbergs-annotated-catalogue/</link><description><![CDATA[The base of Rust users and contributors is growing steadily. The amount of libraries (aka crates) at http://crates.io is growing quickly; the overall “noise” is increasing. Some libraries might not be maintained any longer 🙁

This annotated catalogue shall help the Rust-users to find specific, popular, mature Rust crates. This list is WIP (Work In Progress), reflecting my personal shortlist. The ordering in the table top-down doesn’t express any preference.]]></description><guid isPermaLink="false">f1697ece-4d5e-46b8-88b5-d5a2e729ae96</guid><pubDate>Wed, 19 Jun 2019 19:13:23 +0000</pubDate><dc:creator>Frank Rehberger</dc:creator></item><item><title>Experiment with streams, reading files with futures</title><link>https://chilimatic.hashnode.dev/experiment-with-streams-reading-files-with-futures-cjx1q0gmo001eurs1pt0c27kz</link><description><![CDATA[We were experimenting with streams and I wanted to play around with them as well. There are some tokio implementations for async file reading futuers, but since linux filesystems before kernel 5.1 do not really support non blocking file operations. I thought lets have fun breaking things ourselves. As I mentioned this is not really non blocking I/O esp. since there are two ways to view futures in their current state. ]]></description><guid isPermaLink="false">98e8bcf7-00d1-4f6d-ba28-ea41f2d7b705</guid><pubDate>Tue, 18 Jun 2019 00:00:00 +0000</pubDate><dc:creator>j</dc:creator></item><item><title>On Memoization in Rust</title><link>https://medium.com/swlh/on-memoization-291fd1dd924</link><description><![CDATA[A detailed walk through how to memoize function calls in Rust.]]></description><guid isPermaLink="false">b26fcca3-2a79-4340-88fd-80c6f70c95d1</guid><pubDate>Mon, 17 Jun 2019 12:30:14 +0000</pubDate><dc:creator>Andrew Pritchard</dc:creator></item><item><title>Amethyst 0.11.0 has been released!</title><link>https://amethyst.rs/posts/release-0-11</link><description><![CDATA[Amethyst 0.11.0 comes packed with the Rendy integration & many small additions throughout the engine.]]></description><guid isPermaLink="false">13cf6e76-809f-4987-997d-4cb45a26114d</guid><pubDate>Mon, 17 Jun 2019 00:31:00 +0000</pubDate><dc:creator>Thomas Schaller</dc:creator></item><item><title>Rust for OOP - Enums &amp; Pattern Matching - Part 1</title><link>https://oribenshir.github.io/afternoon_rusting/blog/enum-and-pattern-matching-part-1</link><description><![CDATA[We continue our series “Rust for OOP” with Enums & Pattern Matching, one of my preferred features of Rust. I didn’t hear about it before getting into the language, yet immediately fell in love with it. Enums are simple, expressive, reducing code bloat, enable encapsulation, easy to understand, and reason with. It also enables many useful design pattern. ]]></description><guid isPermaLink="false">e7bf2504-b854-4a1d-b946-38075e83e97a</guid><pubDate>Mon, 17 Jun 2019 00:00:00 +0000</pubDate><dc:creator>Ori Ben-Shir</dc:creator></item><item><title>Makepad, a live Rust authoring tool for 2D vector design, shaders and animation</title><link>https://github.com/makepad/makepad</link><description><![CDATA[The vision is to build a livecoding / design hybrid program, where procedural design and code are fused in one environment. If you have missed 'learnable programming' please check this out: http://worrydream.com/LearnableProgramming/ Makepad aims to fulfill (some) of these ideas using a completely from-scratch renderstack built on the GPU and Rust. It will be like an IDE meets a vector designtool, and had offspring. Direct manipulation of the vectors modifies the code, the code modifies the vectors.

However before we can make this awesome application, we need to build a UI stack. The aim of this toolkit is to be our stepping stone into building a livecoding IDE and designtools that don't suck or fall to pieces along the way.]]></description><guid isPermaLink="false">87146592-5c10-431e-8655-5272eec53ed9</guid><pubDate>Mon, 17 Jun 2019 00:00:00 +0000</pubDate><dc:creator>makepad</dc:creator></item><item><title>Rust on the ESP and how to get started</title><link>https://dentrassi.de/2019/06/16/rust-on-the-esp-and-how-to-get-started/?pk_campaign=twitter</link><description><![CDATA[Read about a simple quickstart with Rust on the ESP, using a ready-to-run container setup that should make this as easy as possible.]]></description><guid isPermaLink="false">38752604-badd-4d11-a3e3-92b6091d2153</guid><pubDate>Sun, 16 Jun 2019 14:18:55 +0000</pubDate><dc:creator>Jens Reimann</dc:creator></item><item><title>A simple plugin interface for the Rust FFI</title><link>http://kmdouglass.github.io/posts/a-simple-plugin-interface-for-the-rust-ffi/</link><description><![CDATA[I present a straight-forward design of a plugin interface using the Rust FFI.]]></description><guid isPermaLink="false">d0496592-58c8-4e56-8cfb-890df49f7b6c</guid><pubDate>Sun, 16 Jun 2019 07:33:33 +0000</pubDate><dc:creator>Kyle M. Douglass</dc:creator></item><item><title>rga: ripgrep, but also search in PDFs, E-Books, Office documents, zip, tar.gz, etc.</title><link>https://phiresky.github.io/blog/2019/rga--ripgrep-for-zip-targz-docx-odt-epub-jpg/</link><description><![CDATA[rga is a line-oriented search tool that allows you to look for a regex in a multitude of file types. rga wraps the awesome ripgrep and enables it to search in pdf, docx, sqlite, jpg, zip, tar.*, movie subtitles (mkv, mp4), etc.]]></description><guid isPermaLink="false">10bad307-4122-4dd4-a0b2-4347b1da1a12</guid><pubDate>Sun, 16 Jun 2019 00:00:00 +0000</pubDate><dc:creator>phiresky</dc:creator></item><item><title>Hagrid: A New Verifying Key Server Built on Sequoia</title><link>https://sequoia-pgp.org/blog/2019/06/14/20190614-hagrid/</link><description><![CDATA[On Wednesday, Vincent launched a new key server at keys.openpgp.org! What makes this launch special is that keys.openpgp.org is running Hagrid —“The Keeper of Keys”—a new verifying key server, which is written in Rust and based on Sequoia. Even though the launch didn’t receive much media attention, 700 people have already verified their keys in the 48 hours since the announcement.]]></description><guid isPermaLink="false">81657ee0-b628-449d-b5c3-3258a0219756</guid><pubDate>Fri, 14 Jun 2019 14:21:35 +0200</pubDate><dc:creator>Neal</dc:creator></item><item><title>On public API and private implementation</title><link>https://phaazon.net/blog/public-api-private-implementation</link><description><![CDATA[In this blog article, I want to explore a problem I’ve been facing from time to time in luminance. The manual dispatch problem. The idea is simple: you are writing a crate and want to expose an API to people. You want them to know which type they can use with a given operation (let’s call it update). However, the actual implementation of this update function is not performed directly by your API but is deferred to a backend implementation. Some people usually like to do that with several crates; in my case, I really don’t care and let’s think in terms of types / modules instead.]]></description><guid isPermaLink="false">7fc0def8-20e5-4923-922d-33732b5fc86c</guid><pubDate>Thu, 13 Jun 2019 17:05:00 +0000</pubDate><dc:creator>Dimitri Sabadie</dc:creator></item><item><title>Help Wanted Solving Our BLE Stack Problem</title><link>https://mckeogh.tech/help-wanted-ble/</link><description><![CDATA[Jonas Schievink and I have been working on a Bluetooth Low Energy stack in Rust, Rubble. It is now in a state where hard-coded services can be created and used, with all lower layers of the stack functioning.

The next step is designing and implementing both an interface for managing Services and Characteristics, as well as a system for notifications when a value is changed. This is fairly complex, with no clear or obvious solution hence the call for help.]]></description><guid isPermaLink="false">db087996-8806-49fc-8d6e-78f4158cf0f6</guid><pubDate>Thu, 13 Jun 2019 00:00:00 +0000</pubDate><dc:creator>Ferdia McKeogh</dc:creator></item><item><title>Emu - GPU programming language for Rust</title><link>https://calebwin.github.io/emu/</link><description><![CDATA[Emu is a language for programming GPUs from Rust. Emu provides the emu! macro for compiling functions written in the Emu language to an intermediate code which gets stored in the EMU global constant. You can then run your code using a binding to OpenCL such as ocl or rust-opencl or use the build! macro which generates Rust functions that can be called to run your Emu functions.]]></description><guid isPermaLink="false">3fab26a6-a1c1-4107-a0c0-c69f2c297342</guid><pubDate>Thu, 13 Jun 2019 00:00:00 +0000</pubDate><dc:creator>Caleb Winston</dc:creator></item><item><title>The Rust Module System and Useful Crates for CLI Apps</title><link>https://ngoldbaum.github.io/posts/helpful-rust-cli-crates/</link><description><![CDATA[Today I’ll be continuing my series of posts on the rust implementation of the Mercurial version control system I’ve been working on. In this post I’ll be focusing on what I learned this week about the rust module system as well as a few helpful crates I discovered to aid in command-line argument parsing and error handling.]]></description><guid isPermaLink="false">24f33796-8ad9-4162-b8a1-1048ab285062</guid><pubDate>Wed, 12 Jun 2019 10:06:24 -0400</pubDate><dc:creator>Nathan Goldbaum</dc:creator></item><item><title>Green Threads Explained in 200 Lines of Rust</title><link>https://cfsamson.gitbook.io/green-threads-explained-in-200-lines-of-rust/</link><description><![CDATA[This book aims to explain green threads by using a small example where we implement a simple but working program where we use our own green threads to execute code.]]></description><guid isPermaLink="false">87fc989d-1a0d-47ce-9663-105f4e93a217</guid><pubDate>Wed, 12 Jun 2019 00:00:00 +0000</pubDate><dc:creator>cfsamson</dc:creator></item><item><title>5 Year Anniversary</title><link>https://gfx-rs.github.io/2019/06/12/anniversary-5.html</link><description><![CDATA[gfx-rs project started with a simple idea: separate the API-specific logic of interaction with the graphic driver from a Rust application. That idea was brewing in the heads of @kvark and @bjz precisely 5 years ago, when they realized the common goal and kicked off the project. The Rust game dev community at the time consisted of a few prominent projects (like kiss3d, claymore, and q3) driven by individuals. They used gl-rs for rendering with no strong separation between higher levels, built as mostly monolithic systems. Because GL was known to keep the CPU occupied on the owning thread, we wanted to provide a separate thread dedicated to talking to the GPU. We had a lot to learn, some great contributors to meet, and hoped to eventually make Rust ecosystem a better place.]]></description><guid isPermaLink="false">5d2b3bb3-b939-4e5a-851f-31963f805af4</guid><pubDate>Wed, 12 Jun 2019 00:00:00 +0000</pubDate><dc:creator>gfx-rs</dc:creator></item><item><title>Bzip2 in Rust: porting the randomization table</title><link>https://people.gnome.org/~federico/blog/bzip2-in-rust-randomization-table.html</link><description><![CDATA[Here is a straightforward port of some easy code. randtable.c has a lookup table with seemingly-random numbers. This table is used by the following macros in bzlib_private.h]]></description><guid isPermaLink="false">05531a2c-35fc-4e51-ad25-77b362b99e03</guid><pubDate>Tue, 11 Jun 2019 14:30:17 -0500</pubDate><dc:creator>Federico Mena Quintero</dc:creator></item><item><title>How do you impl Display for Vec?</title><link>https://medium.com/apolitical-engineering/how-do-you-impl-display-for-vec-b8dbb21d814f</link><description><![CDATA[Or, more generally, how do you implement any trait that is outside of your crate, for a type that is also outside of your crate? Lets create a micro app that helps us explore the problem. We’ll create a simple struct, implement Display for that, then try to implement Display for a Vec of that struct. Once we understand the problem we’ll discuss a simple solution and how to make that solution more idiomatic.]]></description><guid isPermaLink="false">6ca39c1c-1424-4f6f-86c0-8e93f84718c0</guid><pubDate>Mon, 10 Jun 2019 14:03:02 +0000</pubDate><dc:creator>Daniel Mason</dc:creator></item><item><title>Hosting Embedded Rust apps on Apache Mynewt with STM32 Blue Pill</title><link>https://medium.com/@ly.lee/hosting-embedded-rust-apps-on-apache-mynewt-with-stm32-blue-pill-c86b119fe5f?sk=f58f4cf6c608fded4b354063e474a93b</link><description><![CDATA[Today’s microcontrollers (like the STM32 Blue Pill) pack so many features in a tiny package… yet few embedded programmers are capable of exploiting the full potential of modern microcontrollers. Many of us (my IoT students included) seem to be stuck in the 1980s — painstakingly writing C programs for small computers.

It’s time to drop our legacy programming practices and adopt smarter, safer ways to exploit these microcontrollers… starting with Apache Mynewt and Rust.]]></description><guid isPermaLink="false">4676f66e-29a0-4d5d-9da8-34c09f104ca2</guid><pubDate>Sun,  9 Jun 2019 14:47:44 +0000</pubDate><dc:creator>Lup Yuen Lee 李立源</dc:creator></item><item><title>Auth Web Microservice with rust using Actix-Web 1.0 - Complete Tutorial</title><link>https://gill.net.in/posts/auth-microservice-rust-actix-web1.0-diesel-complete-tutorial/</link><description><![CDATA[We are going to create a web-server in rust that only deals with user registration and authentication. I will be explaining the steps in each file as we go. The complete project code is here repo. Please take all this with a pinch of salt as I’m a still a noob to rust 😉.]]></description><guid isPermaLink="false">5150f924-ef3f-4327-a3ba-c5f16076a22b</guid><pubDate>Sun,  9 Jun 2019 00:00:00 +0000</pubDate><dc:creator>Harry Gill</dc:creator></item><item><title>Nannou Update - Vulkan, LASERs and more!</title><link>https://nannou.cc/posts/nannou_v0.9</link><description><![CDATA[Nannou is an open source, creative coding framework for Rust. Today marks one of the biggest milestones for the project since its launch - the release of version 0.9. This version is particularly special for our community as it lands the last eight months of progress into master and onto crates.io. While some of us have already been using the work-in-progress 0.9 branch in our personal and commercial work over the past few months, it is a relief to finally be able to land and share the progress with the wider world!]]></description><guid isPermaLink="false">0f7e8d0a-81fa-4f1a-aa4d-418554873fe6</guid><pubDate>Sun,  9 Jun 2019 00:00:00 +0000</pubDate><dc:creator>Nannou team</dc:creator></item><item><title>Announcing Contrie: concurrent maps and sets</title><link>https://vorner.github.io/2019/06/09/announcing-contrie.html</link><description><![CDATA[This is partly an announcement of a new crate folks might find useful, partly a call for participation and help and partly a journal like story how the crate came to being. Read on (or not) or skip to the parts that seem interesting to you.]]></description><guid isPermaLink="false">aaa397b7-d0b2-43d0-af75-0934ac4bfe73</guid><pubDate>Sun,  9 Jun 2019 00:00:00 +0000</pubDate><dc:creator>Michal &apos;vorner&apos; Vaner</dc:creator></item><item><title>How macros make your Rust life easier and generally better</title><link>https://blog.x5ff.xyz/blog/easy-programming-with-rust-macros/</link><description><![CDATA[Let’s explore a topic that has been quite foreign to me for a long time: macros.]]></description><guid isPermaLink="false">170dcb20-7011-4222-afe7-e3eb2298a661</guid><pubDate>Fri,  7 Jun 2019 00:00:00 +0000</pubDate><dc:creator>Claus</dc:creator></item><item><title>Release Notes for v0.6.0</title><link>https://www.rs-pbrt.org/blog/v0-6-0-release-notes/</link><description><![CDATA[The biggest change for this release is that I started writing a parser for binary Blender files. There is a blog post, where I talk a bit about that, how to explore binary Blender files, and basically how to reconstruct useful information from their DNA.]]></description><guid isPermaLink="false">42c2c580-96cc-4fc8-9485-b29364da6144</guid><pubDate>Fri,  7 Jun 2019 00:00:00 +0000</pubDate><dc:creator>Jan Douglas Bert Walter</dc:creator></item><item><title>Threads in rust</title><link>https://chilimatic.hashnode.dev/threads-in-rust-cjwmbxw9e003pzjs19n7pa0bt</link><description><![CDATA[In our regular hacksession, the current season ;), we are focusing on threading. Concurrency/Multithreading is a really hard topic it has a lot of very specific nomenclature and there are different 'levels' of concurrency one might say. I will start with the nomenclature starting from the programmers / OS perspective.]]></description><guid isPermaLink="false">922ec00d-8aa7-48eb-9344-c1d1eacc44ec</guid><pubDate>Fri,  7 Jun 2019 00:00:00 +0000</pubDate><dc:creator>j</dc:creator></item><item><title>Determining if a Rust Vector has all equal elements</title><link>https://sts10.github.io/2019/06/06/is-all-equal-function.html</link><description><![CDATA[Earlier today, I tooted out a Rust question: How would you write a function to determine if a Vector of integers are all the same, or not. Anyway, the Fediverse is wonderful and full of helpful Rust friends – I ended up getting about a dozen solutions (none exactly the same I don’t think?)]]></description><guid isPermaLink="false">c4166c18-6984-4c64-bda0-68d98d5b3ae7</guid><pubDate>Thu,  6 Jun 2019 22:11:00 +0000</pubDate><dc:creator>Sam Schlinkert</dc:creator></item><item><title>Solutions to the first 20 project euler problems</title><link>https://ngoldbaum.github.io/posts/project-euler/</link><description><![CDATA[I’m getting more and more used to thinking about Rust code in an idiomatic way, but I don’t think I’m comfortable enough to call myself a rustacean yet. To further my goal of oxidizing my brain with rust knowledge, I decided to start working through project euler problems sequentially. I’ve recently finished the first 20 problems and I though I’d share the highlights of what I learned about rust along the way.]]></description><guid isPermaLink="false">30deb171-6751-4af4-9f56-202fe6a78110</guid><pubDate>Thu,  6 Jun 2019 10:23:45 -0400</pubDate><dc:creator>Nathan Goldbaum</dc:creator></item><item><title>Automating Rust and NodeJS deployment on AWS Lambda using layers</title><link>https://medium.com/clevyio/automating-rust-and-nodejs-deployment-on-aws-lambda-using-layers-2d47d129a6bc</link><description><![CDATA[Part of our stack at Clevy is written in Rust, and we use Neon to ease the bindings with other parts of the stack written in NodeJS. Recently, we needed to deploy this stack on AWS Lambda, which runs a very specific NodeJS runtime, not cross-compatible with our existing stack. Since we struggled a little bit with getting Lambda/Rust/Node to play nicely together, I figured I would post a short how-to of what we found worked well for us. You can of course take this as a base and change it to your liking!]]></description><guid isPermaLink="false">dd7226ff-eb20-4edf-b420-9e6bdecf4ddc</guid><pubDate>Thu,  6 Jun 2019 11:28:57 +0000</pubDate><dc:creator>Francois Falala-Sechet</dc:creator></item><item><title>Sealed Rust</title><link>https://ferrous-systems.com/blog/sealed-rust-the-pitch/</link><description><![CDATA[This is the first post in a series detailing Ferrous System's plan to qualify the Rust Language and Compiler for use in the Safety Critical domain. We call this effort Sealed Rust.]]></description><guid isPermaLink="false">b3f6b505-fb93-4330-a039-d97e148e80d5</guid><pubDate>Thu,  6 Jun 2019 02:21:00 +0000</pubDate><dc:creator>James Munns</dc:creator></item><item><title>Speed Up Your JavaScript With Rust</title><link>https://medium.com/paloit/speed-up-your-javascript-with-rust-7661922562fa</link><description><![CDATA[For a recent personal project, I had only needed a fairly simple node.js server to do exponential and costly computing tasks. To be honest, I could have switched the entire tech stack, but I estimated that the development time of such a choice wasn’t worth it… Still, I had some functions taking ages to compute. So I had a look around, and decided to let that task be handled by a more appropriate language, in this case Rust.]]></description><guid isPermaLink="false">e3be782c-4057-4e64-9c1a-0ff81761d5d7</guid><pubDate>Thu,  6 Jun 2019 01:54:49 +0000</pubDate><dc:creator>Johan Paasche</dc:creator></item><item><title>Actix - Actor System and Web Framework for Rust</title><link>https://actix.rs/</link><description><![CDATA[Actix web 1.0.0 is released - a small, pragmatic, and extremely fast web framework.]]></description><guid isPermaLink="false">ae6027ab-b71f-4bce-9ab8-e1853aa24030</guid><pubDate>Wed,  5 Jun 2019 15:38:00 +0000</pubDate><dc:creator>Nikolay Kim</dc:creator></item><item><title>Overlapping blanket impls</title><link>https://codesandwich.github.io/overlapping_blanket_impls/</link><description><![CDATA[Rust doesn’t allow multiple impls of a trait on the same type. This rule keeps resolution transparent and reliable. It also has an ugly side effect, that for every trait there can be only 1 blanket impl. Compiler is completely distrustful here. What if somebody somewhere created a structure that implemented both ToString and Clone? Should such combination suddenly be forbidden? What about String and u32? This rule prevents type hierarchy from sliding into minefield of odd rules and breakages on every other dependency update.]]></description><guid isPermaLink="false">37400230-0f89-41d9-a9e4-a0d7460217ab</guid><pubDate>Wed,  5 Jun 2019 12:00:00 +0000</pubDate><dc:creator>CodeSandwich</dc:creator></item><item><title>The design and implementation of a lock-free ring-buffer with contiguous reservations</title><link>https://ferrous-systems.com/blog/lock-free-ring-buffer/</link><description><![CDATA[Berlin based technology consultancy specialising in the rust programming language and related services.]]></description><guid isPermaLink="false">c12ced69-039d-4d8a-99f3-ed518947537a</guid><pubDate>Wed,  5 Jun 2019 03:02:00 +0000</pubDate><dc:creator>Andrea Lattuada and James Munns</dc:creator></item><item><title>The Typestate Pattern in Rust</title><link>http://cliffle.com/blog/rust-typestate/</link><description><![CDATA[The typestate pattern is an API design pattern that encodes information about an object's run-time state in its compile-time type. This pattern is so easy in Rust that it's almost obvious, to the point that you may have already written code that uses it, perhaps without realizing it. I haven't seen a detailed examination of the nuances of this pattern, so here's my contribution.]]></description><guid isPermaLink="false">7d1887a3-55d1-448d-8643-2a520bfddc41</guid><pubDate>Wed,  5 Jun 2019 00:00:00 +0000</pubDate><dc:creator>Cliff L. Biffle</dc:creator></item><item><title>A generic kubernetes client</title><link>https://clux.github.io/probes/post/2019-06-04-towards-a-generic-kube-client/</link><description><![CDATA[It’s been about a month since we released kube, a new rust client library for kubernetes. We covered the initial release, but it was full of naive optimism and uncertainty. Would the generic setup work with native objects? How far would it extend? Non-standard objects? Patch handling? Event handling? Surely, it’d be a fools errand to write an entire client library?]]></description><guid isPermaLink="false">c26ac9a2-3fbe-4cb3-b845-58e08b05502c</guid><pubDate>Tue,  4 Jun 2019 00:00:00 +0000</pubDate><dc:creator>clux</dc:creator></item><item><title>Announcing The Triage WG</title><link>https://users.rust-lang.org/t/announcing-the-triage-wg/28909</link><description><![CDATA[The Release team is pleased to announce the triage working group , which will assume responsibility from the release team for triaging issues and pull requests in the rust-lang repositories as well as for diagnosing failures in Crater runs.]]></description><guid isPermaLink="false">254cd239-bad6-4331-ad8e-fe00edfb834d</guid><pubDate>Mon,  3 Jun 2019 16:15:03 +0000</pubDate><dc:creator>Dylan DPC</dc:creator></item><item><title>Announcing our Verifiable Random Function (VRF) Rust library</title><link>https://medium.com/witnet/announcing-our-verifiable-random-function-vrf-rust-library-2e042c29a4f7</link><description><![CDATA[Recently Gorka Irazoqui Apecechea and me proudly published a VRF crate as an open source project under the MIT license. The library is a fast, flexible and general-purpose Verifiable Random Function (VRF) library written in Rust, which follows the IETF standard draft written by Sharon Goldberg, Moni Naor, Dimitris Papadopoulos, Leonid Reyzin, and Jan Včelák.]]></description><guid isPermaLink="false">aea12212-4a3a-4c00-baa5-313f5c998977</guid><pubDate>Mon,  3 Jun 2019 15:03:50 +0000</pubDate><dc:creator>Mario Cao</dc:creator></item><item><title>essential rust tools</title><link>https://www.ultrasaurus.com/2019/06/essential-rust-tools/</link><description><![CDATA[Rust has a “community of developers empowered by their tools and each other” (via Katharina Fey in “An async story“). The Rust community helps each other through effective narrative documentation and attention to error messages, and the robust tooling around Rust drives momentum, overcoming some of the natural hurdles when diving into a new language.

Here’s my list of essential rust tools (so far).]]></description><guid isPermaLink="false">f9c3c42b-87f8-4edf-820b-aad48a409482</guid><pubDate>Mon,  3 Jun 2019 14:19:23 +0000</pubDate><dc:creator>Sarah Allen</dc:creator></item><item><title>The Governance WG is going public</title><link>https://blog.rust-lang.org/2019/06/03/governance-wg-announcement.html</link><description><![CDATA[Hey all! Today we're happy to announce the Governance Working Group is going public. We've been spending the last couple weeks finding our bearings and structuring the working group.]]></description><guid isPermaLink="false">d325b708-16d9-45b7-a1d8-6f9e5a331da5</guid><pubDate>Mon,  3 Jun 2019 00:00:00 +0000</pubDate><dc:creator>The Rust Governance WG</dc:creator></item><item><title>Evoli - an official Amethyst showcase game</title><link>https://amethyst.rs/posts/evoli-an-official-amethyst-showcase-game</link><description><![CDATA[Today marks the first stable release of Evoli, an evolution-inspired simulation game made in Amethyst. We’ve successfully completed the MVP spec (and then some) as it was laid out back in February.]]></description><guid isPermaLink="false">b1731301-ca91-4f8c-a66a-48320013705b</guid><pubDate>Sun,  2 Jun 2019 00:00:00 +0000</pubDate><dc:creator>Erlend Sogge Heggen</dc:creator></item><item><title>Gopher Server in Rust</title><link>https://gkbrk.com/2019/06/gopher-server/</link><description><![CDATA[I find Gopher really cool. I think it’s a really nice way to organize information into trees and hierarchies, and as we all know programmers can’t resist trees. So recently I took an interest in Gopher and started writing my own server.

But recently it’s been gaining traction; so we should provide a decent landscape for new gophers, full of oxidised servers. Since I started using Gopher more often, it’s beneficial for me if there’s more content out there. So I’m writing this blog post to walk you through how to write your own server. We’ll be doing this in Rust.]]></description><guid isPermaLink="false">91ae37e0-3d4f-4c78-879d-47e635f8fbda</guid><pubDate>Sun,  2 Jun 2019 01:00:00 +0100</pubDate><dc:creator>Gokberk Yaltirakli</dc:creator></item><item><title>How to Package Rust Applications Into Minimal Docker Containers</title><link>https://alexbrand.dev/post/how-to-package-rust-applications-into-minimal-docker-containers/</link><description><![CDATA[In the Go world, it is common to use docker’s multi-stage build feature to produce the app’s docker image in two stages. The first stage uses the golang image and is where we build the application into a statically-linked binary. Once built, we copy the binary into a scratch container in the second stage. The result is a rather small image that has nothing other than the application.

I was looking to do the same thing for my Rust application. While I was at it, I also wanted to leverage the docker build cache to avoid having to download crates on every docker build.]]></description><guid isPermaLink="false">2c6b8329-385a-4e19-ba91-4c84b1ebf4bc</guid><pubDate>Sat,  1 Jun 2019 09:00:00 -0400</pubDate><dc:creator>Alexander Brand</dc:creator></item><item><title>Toward Piston 1.0</title><link>http://blog.piston.rs/2019/06/01/toward-piston-1.0/</link><description><![CDATA[The Piston core is a set of libraries that defines a core abstraction for user inputs, window and event loop. If you take a look at the dependency graph in the README, it might look a bit scary: In this post I will go through each library, explain what it does and describe the status of stability.]]></description><guid isPermaLink="false">f6a4f101-2fc4-4bb8-827c-c1e54d5dc877</guid><pubDate>Sat,  1 Jun 2019 00:00:00 +0000</pubDate><dc:creator>Sven Nilsen</dc:creator></item><item><title>dua: Disk Usage Analyzer</title><link>https://github.com/Byron/dua-cli</link><description><![CDATA[dua (-> Disk Usage Analyzer) is a tool to conveniently learn about the usage of disk space of a given directory. It's parallel by default and will max out your SSD, providing relevant information as fast as possible.]]></description><guid isPermaLink="false">2ebb2e7a-9b56-4fe3-8605-91c8deb394a9</guid><pubDate>Sat,  1 Jun 2019 00:00:00 +0000</pubDate><dc:creator>Sebastian Thiel</dc:creator></item><item><title>LambdaCore Programming Language</title><link>https://sites.google.com/view/lcore</link><description><![CDATA[An interpreted language written in Rust inspired by the Lisp family of languages.]]></description><guid isPermaLink="false">d4eee998-344f-4863-9402-c8636ff8afc0</guid><pubDate>Sat,  1 Jun 2019 00:00:00 +0000</pubDate><dc:creator>Pebaz</dc:creator></item><item><title>Poking the macOS IO Kit with Rust</title><link>https://svartalf.info/posts/2019-05-31-poking-the-macos-io-kit-with-rust/</link><description><![CDATA[How to fetch batteries information from the macOS APIs with Rust]]></description><guid isPermaLink="false">da8a8064-82b9-4b6f-a37e-d8560a353283</guid><pubDate>Fri, 31 May 2019 00:00:00 +0000</pubDate><dc:creator>Nikita Kuznetsov</dc:creator></item><item><title>Bzip2 in Rust - Basic infrastructure and CRC32 computation</title><link>https://people.gnome.org/~federico/blog/bzip2-in-rust-basic-infra.html</link><description><![CDATA[I have started a little experiment in porting bits of the widely-used bzip2/bzlib to Rust. I hope this can serve to refresh bzip2, which had its last release in 2010 and has been nominally unmaintained for years.

I hope to make several posts detailing how this port is done. In this post, I'll talk about setting up a Rust infrastructure for bzip2 and my experiments in replacing the C code that does CRC32 computations.]]></description><guid isPermaLink="false">332be129-192f-46d1-aefc-c3765e5b1b56</guid><pubDate>Thu, 30 May 2019 10:36:19 -0500</pubDate><dc:creator>Federico Mena Quintero</dc:creator></item><item><title>Debugging with and without parameter in Rust</title><link>https://blog.knoldus.com/debugging-with-and-without-parameter-in-rust/</link><description><![CDATA[Rust 1.32.0 introduced a macro dbg! for quick and dirty debugging with which you can inspect the value of a given expression. Rust 1.35.0 announced an improvement in this macro to make it more usable for Rustaceans. Now you can trace any fine and line number using this macro without passing any parameter.]]></description><guid isPermaLink="false">56e998a6-89d0-4a99-b11c-a541d35dc9a1</guid><pubDate>Thu, 30 May 2019 04:33:10 +0000</pubDate><dc:creator>Ayush Mishra</dc:creator></item><item><title>Rust&apos;s custom derives in a hexagonal architecture: Incompatible ideas?</title><link>https://blog.eizinger.io/5835/rust-s-custom-derives-in-a-hexagonal-architecture-incompatible-ideas</link><description><![CDATA[This blog post is a manifestation of a problem that has been floating around in my head for quite a while now. It is about the seemingly incompatible idea of fully embracing Rust's custom derive system in an application that puts a strong focus on a hexagonal architecture.

To discuss this problem, I am going to first write about both concepts individually. Feel free to skip over those sections if you are already familiar with the topics. The blog post finishes off with some ideas on how Rust could be extended to better support these kind of usecases.]]></description><guid isPermaLink="false">d6200716-96c2-4c9c-890d-0047906b7c72</guid><pubDate>Thu, 30 May 2019 00:00:00 +0000</pubDate><dc:creator>Thomas Eizinger</dc:creator></item><item><title>battop: top for your laptop battery</title><link>https://github.com/svartalf/rust-battop</link><description><![CDATA[battop is an interactive viewer, similar to top, htop and other *top utilities, but about batteries installed in your notebook.]]></description><guid isPermaLink="false">834cc4e5-1dd6-446d-966e-8a869ff45f79</guid><pubDate>Thu, 30 May 2019 00:00:00 +0000</pubDate><dc:creator>Nikita Kuznetsov</dc:creator></item><item><title>Orkhon: ML Inference Framework and Server Runtime</title><link>https://docs.rs/orkhon/0.1.0/orkhon/</link><description><![CDATA[Orkhon is Rust framework for Machine Learning to run/use inference/prediction code written in Python, frozen models and process unseen data. It is mainly focused on serving models and processing unseen data in a performant manner. Instead of using Python directly and having scalability problems for servers this framework tries to solve them with built-in async API.]]></description><guid isPermaLink="false">0904d040-f6c1-4b6a-a9ee-328a5ed55d2d</guid><pubDate>Wed, 29 May 2019 21:32:00 +0000</pubDate><dc:creator>Mahmut Bulut</dc:creator></item><item><title>[blend_info] Rust and Blender</title><link>https://www.janwalter.org/jekyll/blender/rust/blendinfo/2019/05/28/blend_info.html</link><description><![CDATA[To explore a bit the Blender binary file format and provide tools to read and use them I started a new repository on Codeberg. Finally I want to read Blender files directly, and render them with my own renderer. But on my way to develop such a thing, there are many other possibilities, e.g. one could convert Blender files to a new file format, which does not only work for Blender and one single renderer, but would allow any Digital Content Creation (DCC) tool to save to, and any renderer to read from. Anyway, that's a complicated topic and let's start far simpler, by exploring Blender's file format. You get the source code of Blender for reverse engineering (create a debug version and single step through file related code with a debugger) and some Rust code (provided by me) to see what I have figured out so far...]]></description><guid isPermaLink="false">c8b3f39e-8427-42db-93fa-ea196b956607</guid><pubDate>Tue, 28 May 2019 00:00:00 +0000</pubDate><dc:creator>Jan Walter</dc:creator></item><item><title>Update on await syntax</title><link>https://boats.gitlab.io/blog/post/await-decision-ii/</link><description><![CDATA[In my previous post I said that the lang team would be making our final decision about the syntax of the await operator in the May 23 meeting. That was last Thursday, and we did reach a decision. In brief, we decided to go forward with the preliminary proposal I outlined earlier: a postfix dot syntax, future.await. For more background, in addition the previous post on my blog, you can read this write up about some of the trade offs from April.]]></description><guid isPermaLink="false">b3ca84bd-3574-43f7-aef3-988cbc6389a4</guid><pubDate>Tue, 28 May 2019 00:00:00 +0000</pubDate><dc:creator>boats</dc:creator></item><item><title>Eight million pixels and counting – A look at pathfinder</title><link>https://nical.github.io/posts/a-look-at-pathfinder.html</link><description><![CDATA[This post is about pathfinder, a GPU vector graphics renderer written in Rust by Patrick Walton as part of his work in the emerging technologies team at Mozilla. Pathfinder can be used to render glyph atlases and larger scenes such as SVG paths. The two use cases are handled a bit differently and in this post I will be focusing on the latter.]]></description><guid isPermaLink="false">cbb3c7f8-1ff0-4a30-b924-08c79542c259</guid><pubDate>Tue, 28 May 2019 00:00:00 +0000</pubDate><dc:creator>Nical</dc:creator></item><item><title>Creating a Static HTTP Server with Rust – Part 2</title><link>http://concisecoder.io/2019/05/27/creating-a-static-http-server-with-rust-part-2/</link><description><![CDATA[In this series, we are creating a basic static HTTP 1.0 server with Rust. If you haven’t seen Part 1 yet, go do that first. At the end of Part 2, our server will do the following: Read and serve files from a predefined directory on the host server, Generate appropriate HTTP responses to incoming requests, Log information about the response to standard output.]]></description><guid isPermaLink="false">4e723122-0527-43dc-b95b-ff4fd5cd5d28</guid><pubDate>Mon, 27 May 2019 13:25:29 +0000</pubDate><dc:creator>Levi Payne</dc:creator></item><item><title>Writing a Raytracer in Rust: part 2</title><link>https://canmom.github.io/programming/graphics/raytracer/rust-raytracer-part-2</link><description><![CDATA[After I posted the previous post, one of my friends remarked, "i like the way there is no raytracing in the first post its just faffing to get a window". This is an entirely accurate diagnosis. But, right now, have a representation of a frame buffer as a container (probably a vector) of pixels, which we can pass to the window to render a frame. Now we need to figure out what we’re drawing to it!

There are a couple of tweaks I need to make to this - a representation of the framebuffer in linear float space, for example. But let’s come back to that. I want to trace rays.]]></description><guid isPermaLink="false">5503b5d1-aef0-4bb5-8d51-c050b3d4fb1e</guid><pubDate>Mon, 27 May 2019 00:00:00 +0000</pubDate><dc:creator>bryn dickinson</dc:creator></item><item><title>Calling a Go Library from Rust: A Case Study with SQIP</title><link>https://blog.arranfrance.com/post/cgo-sqip-rust/</link><description><![CDATA[A brief run-down of how to wrap a Go library in a CGO FFI to enable its functions to be called by Rust.]]></description><guid isPermaLink="false">ec3d6230-6b29-4459-8a62-c40a8ef08430</guid><pubDate>Mon, 27 May 2019 00:00:00 +0000</pubDate><dc:creator>Arran France</dc:creator></item><item><title>Programming Servo: Zen and the art of removing blocks from your system</title><link>https://medium.com/@polyglot_factotum/programming-servo-zen-and-the-art-of-removing-blocks-from-your-system-51c1b7d404e3</link><description><![CDATA[It all started with a simple issue, a “quick fix”, or so I thought.]]></description><guid isPermaLink="false">0cc7297b-a14f-443d-a02a-073685c663a3</guid><pubDate>Sun, 26 May 2019 09:41:02 +0000</pubDate><dc:creator>Gregory Terzian</dc:creator></item><item><title>Creating a &apos;paged&apos; Vec in Rust</title><link>https://dev.to/kdrakon/creating-a-paged-vec-in-rust-193l</link><description><![CDATA[In this post I'll show you some code I wrote for paginating over a Vec collection in Rust. I needed this for a CLI tool I wrote which was meant to display all the vector entries retrieved from a remote server. In most cases, I expected to receive a lot of results, so to display them in a terminal efficiently, I couldn't reasonably render them all. I decided I would page the results.]]></description><guid isPermaLink="false">51cdd7b5-fed9-439c-b6f8-c50ee7f93ea2</guid><pubDate>Fri, 24 May 2019 06:36:49 +0000</pubDate><dc:creator>Sean Policarpio</dc:creator></item><item><title>Announcing j4rs</title><link>https://astonbitecode.github.io/blog/post/j4rs_0.6.0/</link><description><![CDATA[j4rs stands for “Java for Rust” and allows effortless calls to Java code, from Rust. Some time ago, on a need to call Java code from Rust, I started the j4rs project. The main idea was to implement a crate that would give the ability to its users to make calls to Java easily, so that they can benefit from the huge Java ecosystem.]]></description><guid isPermaLink="false">f94980b0-dfbb-421b-b861-16e158c7c0c2</guid><pubDate>Fri, 24 May 2019 00:10:10 +0000</pubDate><dc:creator>Aston</dc:creator></item><item><title>Announcing Mockiato - A strict, yet friendly mocking library for Rust 2018</title><link>https://blog.myelin.ch/2019/05/24/mockiato-announcement.html</link><description><![CDATA[We’re proud to announce mockiato! For the last few months, we tackled the issue of creating a usable mocking library. Our primary goals were: Ease of use: The mocks are written in idiomatic Rust and don’t rely on custom macro syntax. Maintainability: The entire code base strives to follow the rules of Clean Code and Clean Architecture as specified by Robert C. Martin.  Strict expectation enforcement: Mockiato catches unexpected behavior as soon as it happens instead of returning default values.]]></description><guid isPermaLink="false">635d3c1f-b71e-4883-b72e-52efe1ab01d0</guid><pubDate>Fri, 24 May 2019 00:00:00 +0000</pubDate><dc:creator>Jeremy, Ruben, Jan, Mathias</dc:creator></item><item><title>Hawk-Rust Series: Actuation of Raspberry Pi Camera</title><link>https://blog.knoldus.com/hawk-rust-series-actuation-of-raspberry-pi-camera/</link><description><![CDATA[In this project, we have used Raspberry Pi and its camera to authenticate whether the RFID card is punched by the card’s owner or not. HAWK is a Rust based Image Recognition project, which implements a two-factor authentication by using the RFID card for user identification and Image for user validation. In this blog, I’ll show you how to trigger RPi’s camera using Rust Programming Language. To know more about HAWK click here]]></description><guid isPermaLink="false">4d542211-c76e-41b8-b9fd-d008c06ed937</guid><pubDate>Thu, 23 May 2019 08:51:49 +0000</pubDate><dc:creator>Pawan Bisht</dc:creator></item><item><title>Blockchain-Flavored WASI</title><link>https://medium.com/oasislabs/blockchain-flavored-wasi-50e3612b8eba</link><description><![CDATA[General purpose computation on the blockchain using Web Assembly System Interface (WASI).]]></description><guid isPermaLink="false">fe48ce77-ad77-4983-a08d-1fb9cf951bb1</guid><pubDate>Thu, 23 May 2019 04:07:55 +0000</pubDate><dc:creator>Nick Hynes</dc:creator></item><item><title>Rust&apos;s Bindgen + Fuse in 2019</title><link>https://dev.to/kdrakon/rust-s-bindgen-fuse-in-2019-2e8l</link><description><![CDATA[I will quickly show how I got bindgen (https://rust-lang.github.io/rust-bindgen) to generate the bindings to Fuse (libfuse) with the current stable1 release of Rust. By doing so, this should demonstrate how to bootstrap writing your own Fuse file system in Rust.

I do realise that there are some crates that already exist that aid in making Fuse drivers in Rust, but this was more or less an excuse to also try out bindgen, which I don't believe those existing libraries utilise.]]></description><guid isPermaLink="false">6abeffb3-1d06-4642-9a7d-9c089fd1a030</guid><pubDate>Thu, 23 May 2019 03:56:28 +0000</pubDate><dc:creator>Sean Policarpio</dc:creator></item><item><title>Announcing Rust 1.35.0</title><link>https://blog.rust-lang.org/2019/05/23/Rust-1.35.0.html</link><description><![CDATA[The highlight of this release is the implementation of the FnOnce, FnMut, and Fn closure traits for Box<dyn FnOnce>, Box<dyn FnMut>, and Box<dyn Fn> respectively. Additionally, closures may now be coerced to unsafe function pointers. The dbg! macro introduced in Rust 1.32.0 can now also be called without arguments. Moreover, there were a number of standard library stabilizations. Read on for a few highlights, or see the detailed release notes for additional information.]]></description><guid isPermaLink="false">53c0e6e9-a95e-4509-b70a-74e945e74e92</guid><pubDate>Thu, 23 May 2019 00:00:00 +0000</pubDate><dc:creator>The Rust Release Team</dc:creator></item><item><title>Speeding up Ruby MRI with Rust</title><link>https://medium.com/@flixdescteaux/speeding-up-ruby-mri-with-rust-a7c914d2f9d0</link><description><![CDATA[Let me start by saying I really like Ruby. I tend to agree with the statement saying Ruby is optimized for developer happiness. However, nothing comes for free. Programming ecstasy is a double-edged sword and writing slow Ruby is as easy as it is pleasant.]]></description><guid isPermaLink="false">63fcd49a-f8d8-46f4-92dd-58cb8d77082c</guid><pubDate>Tue, 21 May 2019 13:58:31 +0000</pubDate><dc:creator>Félix Descôteaux</dc:creator></item><item><title>Rebuffing the Attack of the Clones</title><link>https://thenewwazoo.github.io/clone.html</link><description><![CDATA[I left a comment on HN about how I teach new users not to clone, and someone asked me if I’d written more, so here we go!

When new users are writing Rust code, it’s reasonably common to “fight with the borrow checker”. I personally find this to be quite a misnomer, as it is not a fight so much as a misunderstanding of the nature of Rust’s semantics. In an attempt to make the errors go away, users will understandably take the path of least resistance, according to the docs they’ve got. They dutifully read up, and eventually land on the clone method. This makes the errors go away! Great! Except if you were my newbie, in the code review I’d tell you clone is banned unless you can tell me why you need it.]]></description><guid isPermaLink="false">ecccd5a6-53e0-4e7a-9ece-f02450f3eb2f</guid><pubDate>Tue, 21 May 2019 00:00:00 +0000</pubDate><dc:creator>Brandon Matthews</dc:creator></item><item><title>Putting the stack back into Stacked Borrows</title><link>https://www.ralfj.de/blog/2019/05/21/stacked-borrows-2.1.html</link><description><![CDATA[Less than a month ago, I announced Stacked Borrows 2. In particular, I hoped that that version would bring us closer to proper support for two-phase borrows. Turns out I was a bit too optimistic! Last week, @Manishearth asked on Zulip why Miri rejected a certain program, and it turned out that the issue was related to two-phase borrows: in combination with interior mutability, behavior wasn’t always what we wanted it to be. So, I went back to the drawing board and tried to adjust Stacked Borrows.

In the end, I decided to give up on “proper” support for two-phase borrows for now, which I explained here. But I also made some tweaks to Stacked Borrows that affect all accesses (not just two-phase borrows), and that’s what this post is about. I am referring to this as “Stacked Borrows 2.1”.]]></description><guid isPermaLink="false">c12cd1dc-8523-4caf-add8-4ba0322a3cb6</guid><pubDate>Tue, 21 May 2019 00:00:00 +0000</pubDate><dc:creator>Ralf Jung</dc:creator></item><item><title>Here&apos;s My Type, So Initialize Me Maybe (mem::uninitialized is deprecated)</title><link>https://gankro.github.io/blah/initialize-me-maybe/</link><description><![CDATA[Rust's infamous mem::uninitialized method has been deprecated in today's nightly build. Its replacement, MaybeUninit, has been stabilized. If you are using the former, you should migrate to using the latter as soon as possible (probably when it hits stable in 6 weeks). This was done because it was determined that mem::uninitialized was fundamentally broken, and could not be made to work.]]></description><guid isPermaLink="false">bab17ec7-d45f-40fa-963b-10c3085fa7bf</guid><pubDate>Tue, 21 May 2019 00:00:00 +0000</pubDate><dc:creator>Alexis Beingessner</dc:creator></item><item><title>dtolnay/case-studies: Analysis of various tricky Rust code</title><link>https://github.com/dtolnay/case-studies</link><description><![CDATA[This repository showcases some examples of tricky Rust code that I have encountered during my years working with a variety of advanced macro libraries in Rust (my own and others').]]></description><guid isPermaLink="false">4dfd194e-9cc6-4b75-b2f4-8900d8fdebcd</guid><pubDate>Tue, 21 May 2019 00:00:00 +0000</pubDate><dc:creator>David Tolnay</dc:creator></item><item><title>mini-aio: the new async IO library for Rust</title><link>http://antoyo.ml/mini-aio-new-async-io-library</link><description><![CDATA[During my work at Adgear, I’ve been working for a while on an async IO library for Rust. This post will present this new library. This library takes a very different approach than most other async IO libraries in Rust: it is actually inspired by the Pony programming language. So, it does not use futures, it does not use async/await: it just provides simple trait]]></description><guid isPermaLink="false">db12537e-42d3-4bba-9c68-7adc1afec917</guid><pubDate>Mon, 20 May 2019 00:00:00 +0000</pubDate><dc:creator>Antoni Boucher</dc:creator></item><item><title>Polyglot Projects</title><link>https://myrrlyn.net/blog/misc/polyglot-projects</link><description><![CDATA[An exploration of how I wrote a C++ binding API for my Rust library.]]></description><guid isPermaLink="false">812b46b0-ec10-45f3-9fc6-4aaa2ae2534e</guid><pubDate>Mon, 20 May 2019 00:00:00 +0000</pubDate><dc:creator>Alexander Payne</dc:creator></item><item><title>The 2019 Rust Event Lineup</title><link>https://blog.rust-lang.org/2019/05/20/The-2019-Rust-Event-Lineup.html</link><description><![CDATA[We're excited for the 2019 conference season, which we're actually late in writing up. Some incredible events have already happened! Read on to learn more about all the events occurring around the world, past and future.]]></description><guid isPermaLink="false">5c93aa16-acee-46d1-8a08-462d9ce7c09f</guid><pubDate>Mon, 20 May 2019 00:00:00 +0000</pubDate><dc:creator>Rust Community Team</dc:creator></item><item><title>powerset-enum - anonymous enum and a PoC for how that feature can be used to improve Rust&apos;s error handling</title><link>https://www.reddit.com/r/rust/comments/bqn9e6/announcing_the_powersetenum_crate_a_poor_mans/</link><description><![CDATA[My crate offers a powerset enum - an enum that can be parametrized to any subset of it's variants. I also included a macro for doing this parametrization by providing the types of the variants - so for example Error![std::io::Error, serde_json::Error] would generate a subset of the enum that can only have IO and JSON parsing errors.]]></description><guid isPermaLink="false">feed408e-361c-4a9c-9432-5729aed1e789</guid><pubDate>Mon, 20 May 2019 08:50:00 +1000</pubDate><dc:creator>someboddy</dc:creator></item><item><title>Scala Developer Journey into Rust - Part 5: Domain Models</title><link>http://blog.madhukaraphatak.com/rust-scala-part-5/</link><description><![CDATA[Rust is one of the major programming languages that’s been getting popular in recent years. It has many advanced high level language features like Scala. This made me interested to learn Rust. So in this next series of blogs I will share my experience with Rust from a Scala developer point of view. I would like to explore how these two language approach things. I would like to explore the similarities and their differences.

This is fifth post in the series. In this post, I will be talking about domain models.]]></description><guid isPermaLink="false">d6fe8e42-6394-4db9-858e-e572740e0915</guid><pubDate>Sun, 19 May 2019 00:00:00 +0000</pubDate><dc:creator>Madhukara Phatak</dc:creator></item><item><title>Rust In Avast</title><link>https://vorner.github.io/2019/05/19/rust-in-avast.html</link><description><![CDATA[When I joined Avast about a year and a half ago, I did it because of two things:  I wanted to work on interesting problems and I wanted to share the Wisdom of Rust with few more people.

Originally, I was hired because of my experience with writing software for „bigger embedded“ (think a home router or Raspberry PI ‒ it runs Linux kernel, has a shell, but the file system is a bad joke, your libc has bunch of weird bugs features, you really need to think twice not to waste RAM needlessly and you have to cross-compile), low-level networking knowledge and C++.

But I don’t enjoy writing C++ (not speaking about the libc features). And I have other skills I like to practice too. So I would drop an occasional comment about how this or that would be better done in Rust. I’ve done internal courses and workshops about Rust for whoever was interested, in the hope more people would start asking to be allowed to do stuff in Rust and I could participate in such projects.]]></description><guid isPermaLink="false">eedb81ef-265f-4dc2-a1d9-559d2d68594d</guid><pubDate>Sun, 19 May 2019 00:00:00 +0000</pubDate><dc:creator>Michal &apos;vorner&apos; Vaner</dc:creator></item><item><title>Rust for OOP - Project Management</title><link>https://oribenshir.github.io/afternoon_rusting/blog/project-management</link><description><![CDATA[The basics of Rust project layout are simple, and common to many other languages. You have the artifacts of your project. The basics artifacts are executables(binaries) and libraries. You use binaries whenever you want to produce a runnable application. For reusable code, use libraries. Nothing remarkable in Rust. In my projects, I prefer to write almost everything inside libraries, as one can never know when he will reuse a piece of code. Usually, I want my executable to be a thin wrapper around my libraries. Rust has a uniform name for a single library or binary: crate. Meaning crate is either an executable or a library. Creating either a library or a binary crate is straightforward.]]></description><guid isPermaLink="false">e8a7784f-8334-4e7a-b912-a6c3cfbb5522</guid><pubDate>Sat, 18 May 2019 00:00:00 +0000</pubDate><dc:creator>Ori Ben-Shir</dc:creator></item><item><title>Momo · Get Back Some Compile Time From Monomorphization</title><link>https://llogiq.github.io/2019/05/18/momo.html</link><description><![CDATA[Monomorphization has one problem (apart from being a ridiculous word that I’ll probably spell wrong every time): It generates rather a lot of code, bloating binary size and potentially pessimizing execution cache usage. Often, generics aren’t really needed for speed, but for ergonomics: Library code might want to present an easy-to-use generic interface that will automate some conversions. However, this often means that almost each user gets their own version of the code, leading to the aforementioned bloat (case in point: Earlier clap versions were notorious for adding hundreds of kilobytes to the binary size – for a simple command line parser).]]></description><guid isPermaLink="false">568fdc54-427f-47be-8849-dd040bafe8dd</guid><pubDate>Sat, 18 May 2019 00:00:00 +0000</pubDate><dc:creator>Llogiq</dc:creator></item><item><title>Image processing experiments (1)</title><link>https://toswak.net/blog/image-processing-experiments-1-rust/</link><description><![CDATA[I implemented an image processing experiment in Rust and was positively surprised.]]></description><guid isPermaLink="false">1c9745cb-ea4b-4d95-81b4-c51c4a217602</guid><pubDate>Sat, 18 May 2019 00:00:00 +0000</pubDate><dc:creator>Tobias Watzek</dc:creator></item><item><title>My Project to Write Embedded OS in Rust</title><link>https://medium.com/@garasubo/my-project-to-write-embedded-os-in-rust-eadf83f5ee37</link><description><![CDATA[My experience writing embedded OS in Rust. The target architecture is Arm Cortex-M series. My application is running on Nucleo-F4291ZI board and QEMU. Currently, I implemented those functionality: Round-robin scheduler to schedule processes running in Thread mode, SVC interfaces to call kernel function for user processes (e.g. print messages using USART, sleep to wait for interrupts), Move to sleep mode to wait for interrupt when there is no executable processes. There are only a few functionality yet, but the core structure is being completed, I think.]]></description><guid isPermaLink="false">a534602d-8f20-4c12-800d-adbab4f62ca0</guid><pubDate>Fri, 17 May 2019 23:01:00 +0000</pubDate><dc:creator>garasubo (ガラスボー)</dc:creator></item><item><title>Evaluating pipelined rustc compilation</title><link>https://internals.rust-lang.org/t/evaluating-pipelined-rustc-compilation/10199</link><description><![CDATA[Recently landed in nightly is the ability for Cargo to execute rustc in a “pipelined” fashion which has the promise of faster build times across the ecosystem. This support is turned off by default and the Cargo team is interested to gather more data and information about this feature, and that’s where you come in! If you’re interested in faster compiles, we’re interested in getting your feedback on this feature!]]></description><guid isPermaLink="false">64f26c72-e208-4900-90b5-cd1c61ec450b</guid><pubDate>Fri, 17 May 2019 16:09:30 +0000</pubDate><dc:creator>Alex Crichton</dc:creator></item></channel></rss>