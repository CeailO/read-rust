<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/"><channel><title>Read Rust - All Posts</title><link>https://readrust.net/</link><description>All Posts posts on Read Rust</description><item><title>CSS in librsvg is now in Rust, courtesy of Mozilla Servo</title><link>https://people.gnome.org/~federico/blog/css-in-librsvg-is-now-in-rust.html</link><description><![CDATA[After an epic amount of refactoring, librsvg now does all CSS parsing and matching in Rust, without using libcroco. In addition, the CSS engine comes from Mozilla Servo, so it should be able to handle much more complex CSS than librsvg ever could before. This is the story of CSS support in librsvg.]]></description><guid isPermaLink="false">2f92e5a1-d218-459f-a417-c5e4f58be832</guid><pubDate>Mon, 11 Nov 2019 19:36:04 -0600</pubDate><dc:creator>Federico Mena Quintero</dc:creator></item><item><title>Neotron - The Embedded Rust Home Computer Platform</title><link>https://neotron-compute.github.io/Neotron-Book/</link><description><![CDATA[Neotron is an attempt to make computers simple again, whilst also taking advantage of the very latest in programming language development. It is based around four simple concepts: The ARM Thumb-v7M instruction set, A standardised OS interface, A standardised BIOS interface, and Use of the Rust Programming Language.]]></description><guid isPermaLink="false">f178fe2d-82b8-4e04-ad1e-6e90bc4299c3</guid><pubDate>Mon, 11 Nov 2019 05:07:11 +0000</pubDate><dc:creator>Jonathan Pallant</dc:creator></item><item><title>Announcing async-std 1.0</title><link>https://async.rs/blog/announcing-async-std-1-0/</link><description><![CDATA[async-std is a port of Rust’s standard library to the async world. It comes with a fast runtime and is a pleasure to use. We’re happy to finally announce async-std 1.0. As promised in our first announcement blog post, the stable release coincides with the release of Rust 1.39, the release adding async/.await. We would like to thank the active community around async-std for helping get the release through the door.]]></description><guid isPermaLink="false">7e260d4f-38ce-456b-be84-83ad8c13f4df</guid><pubDate>Mon, 11 Nov 2019 00:00:00 +0000</pubDate><dc:creator>Florian Gilcher</dc:creator></item><item><title>Release - Mun v0.1.0</title><link>https://mun-lang.org/blog/2019/11/11/release-mun-v0-1-0/</link><description><![CDATA[We are proud to present Mun v0.1.0 - our first milestone release. As a language, Mun is still far from production-ready, but this release gives you a glimpse of what natively supported hot reloading will look like in the future. The purpose of this release is to showcase our progress and gather feedback from those brave souls willing to try out Mun at this early stage.]]></description><guid isPermaLink="false">8147f2fb-fdcf-4382-9a84-ad4e935c220a</guid><pubDate>Mon, 11 Nov 2019 00:00:00 +0000</pubDate><dc:creator>The Mun Team</dc:creator></item><item><title>The Demystifying Asynchronous Rust Book</title><link>https://teh-cmc.github.io/rust-async/html/</link><description><![CDATA[This book is targeted towards experienced programmers that already feel somewhat comfortable with vanilla Rust (you definitely do not need to be an "expert" though, I certainly am not) and would like to dip their toes into its async ecosystem.

As the title indicates, this is not so much a book about how to use async Rust as much as it is about trying to build a solid understanding of how it all works under the hood. From there, efficient usage should come naturally.]]></description><guid isPermaLink="false">b6cc68e0-c563-4eb0-a374-7c11dad01824</guid><pubDate>Mon, 11 Nov 2019 00:00:00 +0000</pubDate><dc:creator>Clement Rey</dc:creator></item><item><title>Rust 2020 Suggestions</title><link>https://www.reddit.com/r/rust/comments/ducnqy/rust_2020_suggestions/?utm_source=share&amp;utm_medium=ios_app&amp;utm_name=iossmf</link><description><![CDATA[7 votes and 2 comments so far on Reddit]]></description><guid isPermaLink="false">c8c2efa0-e798-4951-b23d-7df4075c3b51</guid><pubDate>Mon, 11 Nov 2019 00:00:00 +0000</pubDate><dc:creator>u/AnyPolicy</dc:creator></item><item><title>Sulis - a turn based tactical RPG written in Rust</title><link>https://sulisgame.com/</link><description><![CDATA[Sulis, a turn based tactical RPG written in Rust. Sulis is open source with turn based, tactical combat, deep character customization and an engaging storyline. The game has been built from the ground up with modding and custom content in mind. Currently supported on Windows and Linux platforms.]]></description><guid isPermaLink="false">e49868f7-34ff-4d50-a55d-39eec1e36f37</guid><pubDate>Mon, 11 Nov 2019 00:00:00 +0000</pubDate><dc:creator>Jared Stephen</dc:creator></item><item><title>ptail - Stream and display a fixed number of lines from a processes output</title><link>https://github.com/orf/ptail</link><description><![CDATA[ptail is a small, and likely useless, utility that truncates the output from processes. Unlike tail -f it will not show more than the specified number of lines in your terminal. This could be useful if you are executing a command as part of a shell script and you do not wish to show the full and verbose output, but you do want to be able to see what is happening.]]></description><guid isPermaLink="false">7c3d9c87-a7a2-47b7-9e75-f23648d7de14</guid><pubDate>Mon, 11 Nov 2019 00:00:00 +0000</pubDate><dc:creator>Tom Forbes</dc:creator></item><item><title>Rust 2020: Finish what we started and a bit about proc macros</title><link>https://repnop.dev/posts/rust-2020/</link><description><![CDATA[Its that time of year again and its been exciting watching the language grow over this past year! Looking back through the Rust releases for the entire year, starting with 1.32.0 there’s been some fantastic progress, which is pretty easy to forget! So why not start with a bit of a recap of some of the big things from each release.]]></description><guid isPermaLink="false">dbe27f0a-48ce-492f-9200-688fc471a263</guid><pubDate>Sun, 10 Nov 2019 15:00:00 -0500</pubDate><dc:creator>repnop</dc:creator></item><item><title>First Shortwave Internet Radio Player Beta</title><link>https://blogs.gnome.org/haeckerfelix/2019/11/10/first-shortwave-beta/</link><description><![CDATA[Shortwave is an internet radio player that lets you search for stations, listen to them and record songs automatically.]]></description><guid isPermaLink="false">08c1b771-fd3b-4408-bb1d-2c076e443698</guid><pubDate>Sun, 10 Nov 2019 16:24:38 +0000</pubDate><dc:creator>Felix Häcker</dc:creator></item><item><title>Wasmtime — a small and efficient runtime for WebAssembly &amp; WASI</title><link>https://wasmtime.dev/</link><description><![CDATA[Wasmtime is a standalone wasm-only optimizing runtime for WebAssembly and WASI, using Cranelift. It runs WebAssembly code outside of the Web, and can be used both as a command-line utility or as a library embedded in a larger application.]]></description><guid isPermaLink="false">48b43e12-00d0-4eb5-aff6-b57873cc6533</guid><pubDate>Sat,  9 Nov 2019 08:56:22 +0000</pubDate><dc:creator>Wasmtime Developers</dc:creator></item><item><title>Posititivity and the RustConf keynote</title><link>https://yakshav.es/rustconf-keynote-thoughts/</link><description><![CDATA[I wrote down some rough thoughts on the RustConf keynote together with Steve Klabnik on my personal snippet space. Had we gone with our initial idea for it, it would maybe have been more "reflective", but also a disservice to many.]]></description><guid isPermaLink="false">f1e28b81-6178-4b2d-88ca-f1b242e2c6cd</guid><pubDate>Sat,  9 Nov 2019 06:30:17 +0000</pubDate><dc:creator>Florian Gilcher</dc:creator></item><item><title>Roguelike Tutorial - In Rust</title><link>http://bfnightly.bracketproductions.com/rustbook/</link><description><![CDATA[This tutorial is primarily about learning to make roguelikes (and by extension other games), but it should also help you get used to Rust and RLTK - The Roguelike Tool Kit we'll be using to provide input/output. Even if you don't want to use Rust, my hope is that you can benefit from the structure, ideas and general game development advice.]]></description><guid isPermaLink="false">cd4ffee6-edb3-4ef3-8dbe-1a9b7f4ba199</guid><pubDate>Sat,  9 Nov 2019 04:26:11 +0000</pubDate><dc:creator>Herbert Wolverson</dc:creator></item><item><title>VeoLuz: A generative art tool visualizing the paths of photons</title><link>https://jaredforsyth.com/veoluz/</link><description><![CDATA[VeoLuz is an exploration-focused playground and an artistic tool. It attempts to mimic the behavior of photons as they interact with barriers of various kinds − those that absorb light, those that reflect light, and those that refract light.]]></description><guid isPermaLink="false">b5ef3ed4-ac3e-4483-8a04-abe7cd4afa92</guid><pubDate>Sat,  9 Nov 2019 04:26:11 +0000</pubDate><dc:creator>Jared Forsyth</dc:creator></item><item><title>Osgood is a secure, fast, and simple platform for running JavaScript HTTP servers</title><link>https://github.com/IntrinsicLabs/osgood</link><description><![CDATA[Osgood is a secure, fast, and simple platform for running JavaScript HTTP servers. It is written using Rust and V8. Services written today share a common flaw: Being over-privileged. Osgood is an attempt to build a platform from the ground up, one which applies the Principle of Least Privilege at its very core. Osgood requires that policies be written ahead of time describing the I/O requirements of an application. If such an operation hasn't been whitelisted, it will fail. Developers familiar with JavaScript development in the web browser should feel right at home with the APIs provided in Osgood.]]></description><guid isPermaLink="false">6cb73c7e-777a-4c23-b279-4e94c8cf70cf</guid><pubDate>Sat,  9 Nov 2019 03:48:13 +0000</pubDate><dc:creator>Thomas Hunter II</dc:creator></item><item><title>My first ever zine, titled &quot;String and &amp;str in Rust&quot;</title><link>https://github.com/jeenalee/zines/blob/master/string-and-andstr-in-rust.pdf</link><description><![CDATA[Zines (pronounced “zeens") are small publications that come in the form of mini pamphlets or magazines!]]></description><guid isPermaLink="false">6fcfe5a8-280a-4f20-a269-7f1354c314e8</guid><pubDate>Sat,  9 Nov 2019 00:33:18 +0000</pubDate><dc:creator>Jeena Lee</dc:creator></item><item><title>Rust 2020 - Loose Ends and Small Details</title><link>https://crepererum.net/rust-2020/</link><description><![CDATA[This is my answer to call for blogs 2020 and somewhat an update to my post from last year. You don't need to read the old post though, since this post is written in way that it incorporates that content as well.

For every topic, I will present my personal favorite parts, split into Completed (compared to the post from last year or was not on the list but is nice anyway), Open (existed last year and is still relevant), and New (got relevant or new idea).]]></description><guid isPermaLink="false">f7f1b3da-3847-4653-9410-cadb223b8e06</guid><pubDate>Sat,  9 Nov 2019 00:00:00 +0000</pubDate><dc:creator>Marco Neumann</dc:creator></item><item><title>iou: Rust bindings for liburing</title><link>https://boats.gitlab.io/blog/post/iou/</link><description><![CDATA[Today I’m releasing a library called iou. This library provides idiomatic Rust bindings to the C library called liburing, which itself is a higher interface for interacting with the io_uring Linux kernel interface. Here are the answers to some questions I expect that may provoke.

What is io_uring? io_uring is an interface added to the Linux kernel in version 5.1. Concurrent with that, the primary maintainer of that interface has also been publishing a library for interacting with it called liburing.]]></description><guid isPermaLink="false">eab14a89-9177-44ce-8259-07c6ae33bdfa</guid><pubDate>Fri,  8 Nov 2019 00:00:00 +0000</pubDate><dc:creator>boats</dc:creator></item><item><title>Using Rust in Windows</title><link>https://msrc-blog.microsoft.com/2019/11/07/using-rust-in-windows/</link><description><![CDATA[This blog describes part of the story of Rust adoption at Microsoft. Recently, I’ve been tasked with an experimental rewrite of a low-level system component of the Windows codebase (sorry, we can’t say which one yet). Instead of rewriting the code in C++, I was asked to use Rust, a memory-safe alternative. Though the project is not yet finished, I can say that my experience with Rust has been generally positive. It’s a good choice for those looking to avoid common mistakes that often lead to security vulnerabilities in C++ code bases. ]]></description><guid isPermaLink="false">fe4ddd77-07fd-4693-a8e4-684b4b0d825c</guid><pubDate>Thu,  7 Nov 2019 16:11:27 +0000</pubDate><dc:creator>Adam Burch</dc:creator></item><item><title>Rust 2020: towards a 1.0 crate ecosystem</title><link>https://tonyarcieri.com/rust-2020-towards-a-1-0-crate-ecosystem</link><description><![CDATA[The Rust language itself went 1.0 in 2015. And yet, almost 5 years later, at least in my anecdotal assessment talking to and reading things written by current or potential users, there is still a sense that the language is still in some way unfinished and a bit rough around the edges. I sympathize with these concerns.]]></description><guid isPermaLink="false">27428e03-39e4-450a-9e5d-2337865349d1</guid><pubDate>Thu,  7 Nov 2019 07:30:37 -0800</pubDate><dc:creator>Tony Arcieri</dc:creator></item><item><title>Learning Rust by Contrasting with TypeScript: Part 1</title><link>https://codeburst.io/learning-rust-by-contrasting-with-typescript-part-1-afb2e3f6ead8</link><description><![CDATA[Seeing Rust as a potential successor to TypeScript, we go through through the Rust Book with TypeScript in mind.]]></description><guid isPermaLink="false">276689b1-ba19-4308-9168-21951f3f372c</guid><pubDate>Thu,  7 Nov 2019 14:28:54 +0000</pubDate><dc:creator>John Tucker</dc:creator></item><item><title>Putting Rust in the kernel with eBPF</title><link>https://blog.redsift.com/labs/putting-rust-in-the-kernel-with-ebpf/</link><description><![CDATA[During the product development process monitoring our pipelines proved challenging, and we wanted more visibility into our containers. After a short period of exploration, we found that eBPF would address most of the pain points and dark spots we were encountering.

There was one catch: no eBPF tooling would help us deploy and maintain new probes within our small, but focused ops team. BCC, while great for tinkering, requires significant effort to roll out to production. It also makes it difficult to integrate our toolkit into our usual CI/CD deployment models.

Faced with this dilemma, we decided the only option was for us to write our own Rust-based agent that integrated well with our testing and deployment strategies.]]></description><guid isPermaLink="false">f735529c-9db9-454e-802d-82e7367e6b92</guid><pubDate>Thu,  7 Nov 2019 11:34:52 +0000</pubDate><dc:creator>Peter Parkanyi</dc:creator></item><item><title>Battle of the Serverless — Part 2: AWS Lambda Cold Start Times</title><link>https://medium.com/@shouldroforion/battle-of-the-serverless-part-2-aws-lambda-cold-start-times-1d770ef3a7dc</link><description><![CDATA[This experiment continues the work done in our pretend suite of microservices exposed via API Gateway to form an API with a code name of Slipspace in a mock company called STG. Slipspace drives are how the ships in the Halo universe travel so quickly to different sectors of the galaxy through something called Slipstream Space, so thought it was cool for a name requiring awesome warp API speeds.]]></description><guid isPermaLink="false">48cf21ce-5244-4667-82c3-9c54bb469bbf</guid><pubDate>Thu,  7 Nov 2019 03:15:40 +0000</pubDate><dc:creator>Mark Fowler</dc:creator></item><item><title>How Swift Achieved Dynamic Linking Where Rust Couldn&apos;t</title><link>https://gankra.github.io/blah/swift-abi/</link><description><![CDATA[For those who don't follow Swift's development, ABI stability has been one of its most ambitious projects and possibly it's defining feature, and it finally shipped in Swift 5. The result is something I find endlessly fascinating, because I think Swift has pushed the notion of ABI stability farther than any language without much compromise.

So I decided to write up a bunch of the interesting high-level details of Swift's ABI. This is not a complete reference for Swift's ABI, but rather an abstract look at its implementation strategy. If you really want to know exactly how it allocates registers or mangles names, look somewhere else.

Also for context on why I'm writing this, I'm just naturally inclined to compare the design of Swift to Rust, because those are the two languages I have helped develop. Also some folks like to complain that Rust doesn't bother with ABI stability, and I think looking at how Swift does helps elucidate why that is.]]></description><guid isPermaLink="false">225f7f8a-4d16-4eee-9022-bbb1d35e26a9</guid><pubDate>Thu,  7 Nov 2019 00:00:00 +0000</pubDate><dc:creator>Alexis Beingessner</dc:creator></item><item><title>This Month in Rust GameDev #3 - October 2019</title><link>https://rust-gamedev.github.io/2019/11/07/newsletter-003.html</link><description><![CDATA[Huge round-up of updates to Rust games, libraries, and tools.]]></description><guid isPermaLink="false">5e3bc6b8-53e2-4b7a-966b-901727f317c8</guid><pubDate>Thu,  7 Nov 2019 00:00:00 +0000</pubDate><dc:creator>Rust Game Development Working Group</dc:creator></item><item><title>Simple data stitching</title><link>http://segfaultsourcery.s3-website.eu-central-1.amazonaws.com/snippets/rust/stitching/landing.html#simple-data-stitching</link><description><![CDATA[I found myself in a situation where I had a number of CSV files that all shared some key data, and all had to be put together to a larger dataset. I figured that the easiest way to do this would be to deserialize the files, then stitch them together using a portion of their data as a key.

I decided to try my hand at writing a macro to solve the issue, and I ended up with two of them; one for one-to-one relations, and one for one-to-many.]]></description><guid isPermaLink="false">a09f683f-9aec-46cc-83e8-0aa1acf20f31</guid><pubDate>Thu,  7 Nov 2019 00:00:00 +0000</pubDate><dc:creator>Kim Hå</dc:creator></item><item><title>Comparing parallel Rust and C++</title><link>https://parallel-rust-cpp.github.io/</link><description><![CDATA[In this tutorial, we will implement a Rust program that attempts to utilize 100% of the theoretical capacity of three relatively modern, mid-range CPUs. We'll use an existing, highly efficient C++ implementation as a reference point to compare how our Rust program is doing. We start with a simple baseline solution of 3 nested for-loops, and keep improving on the baseline solution incrementally, implementing 8 versions in total, until the program is going so fast it can hardly go faster. We'll approach the problem from the point of view of a C++ programmer who already knows how the reference implementation solves the problem, but is interested in an approach using the Rust language.]]></description><guid isPermaLink="false">9e49b1b3-2b2a-46f0-951e-bda659adca6e</guid><pubDate>Thu,  7 Nov 2019 00:00:00 +0000</pubDate><dc:creator>Matias Lindgren</dc:creator></item><item><title>Async-await on stable Rust!</title><link>https://blog.rust-lang.org/2019/11/07/Async-await-stable.html</link><description><![CDATA[On Thursday, November 7, async-await syntax hit stable Rust, as part of the 1.39.0 release. This work has been a long time in development -- the key ideas for zero-cost futures, for example, were first proposed by Aaron Turon and Alex Crichton in 2016! -- and we are very proud of the end result. We believe that Async I/O is going to be an increasingly important part of Rust's story.]]></description><guid isPermaLink="false">35e06989-4cc4-4d3b-ab76-5830da233ebd</guid><pubDate>Thu,  7 Nov 2019 00:00:00 +0000</pubDate><dc:creator>Niko Matsakis</dc:creator></item><item><title>Announcing Rust 1.39.0</title><link>https://blog.rust-lang.org/2019/11/07/Rust-1.39.0.html</link><description><![CDATA[The Rust team is happy to announce a new version of Rust, 1.39.0. The highlights of Rust 1.39.0 include async/.await, shared references to by-move bindings in match guards, and attributes on function parameters.]]></description><guid isPermaLink="false">dfcf2420-e465-4c62-8b31-f7e2792c2e94</guid><pubDate>Thu,  7 Nov 2019 00:00:00 +0000</pubDate><dc:creator>The Rust Release Team</dc:creator></item><item><title>Rust 2020 - Rust needs to be boring</title><link>https://andygrove.io/2019/11/rust-2020-rust-needs-to-be-boring/</link><description><![CDATA[I’ve been following Rust for long enough that I remember the early days (pre 1.0) where the language would keep changing from under me and I’d have to regularly rewrite parts of my project using the latest syntax. Fun times!

Of course, things have changed a lot since then. The language has stabilized and we have Rust Editions to rely on for major releases. However, even though changes to the language are backwards compatible, there is still quite a lot of churn due to new features being added.]]></description><guid isPermaLink="false">d06968c3-bc41-4dda-966b-e46850d76549</guid><pubDate>Thu,  7 Nov 2019 00:00:00 +0000</pubDate><dc:creator>Andy Grove</dc:creator></item><item><title>Rust focus for 2020</title><link>https://gist.github.com/starkat99/32fd5156e5c744c30dde61e82ed7bcd9</link><description><![CDATA[In response to Rust's call for blogs about Rust development in 2020, here's a few of my own thoughts: Improve Error ergonomics, Stabilize existing approved features, Stabilize more ecosystem libraries.]]></description><guid isPermaLink="false">7d25a259-4131-4a03-8d9a-cea51b7790cb</guid><pubDate>Wed,  6 Nov 2019 19:07:44 +0000</pubDate><dc:creator>Kathryn Long</dc:creator></item><item><title>Rust 2020: Funding</title><link>https://fasterthanli.me/blog/2019/rust-2020-funding/</link><description><![CDATA[Blog posts that praise Rust are many but funding is generally in short supply. If even a small percentage of the money Rust saves companies was put back into the ecosystem it would help secure the future of the platform tremendously.]]></description><guid isPermaLink="false">3b951b73-7ad8-448c-8c25-27d745fae481</guid><pubDate>Wed,  6 Nov 2019 17:30:02 +0000</pubDate><dc:creator>Amos</dc:creator></item><item><title>Rust in 2020: A User’s Perspective</title><link>https://flocknetworks.com/rust2020/</link><description><![CDATA[I’m a Rust user rather than a Rust developer. I have been writing Rust code since just before the 1.0 release, and have followed the development of the language since then. I believe the future of systems programming is likely to be in Rust. I am certainly invested in the Rust language. Last month I resigned from my job writing embedded C, so I could start my own company, producing IP Networking software in Rust.]]></description><guid isPermaLink="false">10b9ba68-29df-4218-b086-e17e4d8894cc</guid><pubDate>Wed,  6 Nov 2019 15:05:41 +0000</pubDate><dc:creator>Nick Carter</dc:creator></item><item><title>2020 : Milestones?</title><link>https://internals.rust-lang.org/t/2020-milestones/11246</link><description><![CDATA[When I read the Nick Cameron's 2020 blog post, I thought about something that might be interesting about editions. One of the Nick points was that a 2021 edition would be useful as a rallying point to highlight progress on “async”. I agree that a rallying point is desirable, but I believe the edition system is a terrible way to do that...]]></description><guid isPermaLink="false">53feabca-bda0-4d45-8dff-ee1a898c36c4</guid><pubDate>Wed,  6 Nov 2019 06:12:46 +0000</pubDate><dc:creator>Uther</dc:creator></item><item><title>Rust 2020</title><link>https://hsivonen.fi/rust2020/</link><description><![CDATA[It’s again the time of year when the Rust Core Team calls for blog posts for input into the next year’s roadmap. This is my contribution. It’s mostly a re-run of my Rust 2018 and Rust 2019 posts. Apart from the LLVM bound check optimization item, the theme here continues to be: Please mark features that have worked since 2015 as done.]]></description><guid isPermaLink="false">e13462c4-9629-4a6a-9118-c6f918a4bae3</guid><pubDate>Wed,  6 Nov 2019 00:00:00 +0000</pubDate><dc:creator>Henri Sivonen</dc:creator></item><item><title>Rust 2020: are we compile yet? are we cache yet? are we doc yet?</title><link>https://www.reddit.com/r/rust/comments/dsfi5m/rust_2020_are_we_compile_yet_are_we_cache_yet_are/</link><description><![CDATA[I'm using Rust actively and it's mostly great. That said, there are some pain points: We are not compile just yet, We aren't cache yet, and We are mostly doc already, but not completely.]]></description><guid isPermaLink="false">49edb12f-3491-4965-abd5-dd2f936a5ea4</guid><pubDate>Wed,  6 Nov 2019 00:00:00 +0000</pubDate><dc:creator>u/unpleasant_truthz</dc:creator></item><item><title>My Rust adventure begins: building the WinRT language projection for Rust</title><link>https://kennykerr.ca/2019/11/05/rust/</link><description><![CDATA[I have come to the point with C++/WinRT where I am largely satisfied with how it works and leverages C++ to the best of its ability. There is always room for improvement and I will continue to evolve and optimize C++/WinRT as the C++ language itself advances. But as a technology, the Windows Runtime has always been about more than just one language and we have started working on a few different projects to add support for various languages. None of these efforts could however draw me away from C++… that is until Rust showed up on my radar.

Rust is an intriguing language for me. It closely resembles C++ in many ways, hitting all the right notes when it comes to compilation and runtime model, type system and deterministic finalization, that I could not help but get a little excited about this fresh new take on language design. And so it is that I have started building the WinRT language projection for Rust.]]></description><guid isPermaLink="false">94453690-596e-423d-afa4-6fbcb91594a1</guid><pubDate>Tue,  5 Nov 2019 15:05:41 +0000</pubDate><dc:creator>Kenny Kerr</dc:creator></item><item><title>Nushell 0.5.0</title><link>http://www.jonathanturner.org/2019/11/nushell-0_5_0.html</link><description><![CDATA[We've just released Nushell 0.5.0! New - login shell support, recycle bin support, better string matching, parameter help, new commands, and more!]]></description><guid isPermaLink="false">2add05cc-7028-465f-baee-42535290fc10</guid><pubDate>Tue,  5 Nov 2019 00:00:00 +0000</pubDate><dc:creator>Jonathan Turner</dc:creator></item><item><title>Rust 2021: Confidence</title><link>https://swatinem.de/blog/rust-2020/</link><description><![CDATA[It is that time of year again. The Rust Team is soliciting ideas about rusts roadmap for the next years, so here goes mine. Thinking about the tagline I would give the coming editions, it is this: Rust 2015: Stability, Rust 2018: Productivity, Rust 2021: Confidence. I will explain what this means for me, but lets digress a bit first]]></description><guid isPermaLink="false">3cd6a436-b878-4ccd-82d2-75231ed6ed1a</guid><pubDate>Tue,  5 Nov 2019 00:00:00 +0000</pubDate><dc:creator>Arpad Borsos</dc:creator></item><item><title>Rust 2020</title><link>https://www.ncameron.org/blog/rust-2020/</link><description><![CDATA[I'll start by arguing in favour of an edition in 2021. Then I will indulge in some rumination on the nature and necessity of roadmaps. Finally I'll make some probably obvious points in a long-winded way. Tl;dr, money is a thing we need to think about, async programming and WASM are important, and the compiler should be faster. For good measure, I will re-open a can of worms concerning the standard library.]]></description><guid isPermaLink="false">dc4dd0c3-6f8b-4450-b779-7ed4f60024a0</guid><pubDate>Mon,  4 Nov 2019 20:24:52 +0000</pubDate><dc:creator>Nick Cameron</dc:creator></item><item><title>Rust concurrency patterns: condvars and locks</title><link>https://medium.com/@polyglot_factotum/rust-concurrency-patterns-condvars-and-locks-e278f18db74f</link><description><![CDATA[I’ve spent quite a lot of time extolling the virtues of message-passing in concurrent Rust. However, there are times when shared-state is the right approach, sometimes just because it’s the historical approach chosen in a module and you want to add something to it without refactoring the whole thing. So today we’re going to talk about using shared-state, with the help of condvars and locks.]]></description><guid isPermaLink="false">155c1b1a-4660-4feb-8ab9-3dc8c211afb2</guid><pubDate>Mon,  4 Nov 2019 14:52:14 +0000</pubDate><dc:creator>Gregory Terzian</dc:creator></item><item><title>My share on Rust 2020</title><link>https://dev.to/augustocdias/my-share-on-rust-2020-27m8</link><description><![CDATA[Some weeks ago the rust-lang team made a blog post asking for opinions on what the priorities for the next year should be. It really amazes me how the team hears everybody and how friendly the community is.

I have been learning rust for more than a year already, but this year was the first where I tried to write something real and production ready with it. I've gotta say I had a lot of ups and downs with it, but I'm still amazed by the language and its ecosystem. ]]></description><guid isPermaLink="false">b42bc892-2146-4ac9-b2a1-5e1536abcddc</guid><pubDate>Mon,  4 Nov 2019 12:14:01 +0000</pubDate><dc:creator>Augusto</dc:creator></item><item><title>After completing Rust.Tokyo</title><link>https://medium.com/@dorayakikun/after-completing-rust-tokyo-fc4db37d2652</link><description><![CDATA[I would like to write about my gratitude to each person who was involved in Rust.Tokyo, and my thoughts about Rust.Tokyo.]]></description><guid isPermaLink="false">189fd57c-47f6-4854-8ca2-0c5b07af21e8</guid><pubDate>Mon,  4 Nov 2019 02:41:29 +0000</pubDate><dc:creator>dorayakikun</dc:creator></item><item><title>Rust 2020: the RFC process and distributions</title><link>https://spacekookie.de/blog/rust-2020-the-rfc-process-and-distributions/</link><description><![CDATA[I must have missed an e-mail in my inbox, because recently I started seeing people publish Rust 2020 blogposts so I thought, why not. I haven't been incredibly involved in the development of Rust in the last few months, (navigating the delicate balance of being self employed, working on free software and not burning out) but I feel like that might change again. And also, I still have feelings about software.

This post was also largely inspired by my friend XAMPPRocky's post, as well as attending NixCon a few weeks ago, and generally interacting with the NixOS RFC process.]]></description><guid isPermaLink="false">2df19538-8f67-4338-9eb8-9536c03a77c9</guid><pubDate>Mon,  4 Nov 2019 00:00:00 +0000</pubDate><dc:creator>Katharina Fey</dc:creator></item><item><title>Yet another HackerNews CLI written in Rust</title><link>https://github.com/yayoc/hn</link><description><![CDATA[Yet another HackerNews CLI written in Rust.]]></description><guid isPermaLink="false">a1e98a1c-84fa-4aad-8b14-03762ad6079b</guid><pubDate>Mon,  4 Nov 2019 00:00:00 +0000</pubDate><dc:creator>yayoc</dc:creator></item><item><title>Rust 2020</title><link>https://thomashartmann.dev/blog/rust-2020/</link><description><![CDATA[In which I respond to the recent call for blogs put out by the Rust core team and write down my wishes for Rust in 2020. Yup, GATs and const generics are there, but also slice patterns and a request for better documentation around async development.]]></description><guid isPermaLink="false">2e31e9ad-357b-4a9a-b76b-fe8c5b5e993a</guid><pubDate>Mon,  4 Nov 2019 00:00:00 +0000</pubDate><dc:creator>Thomas Hartmann</dc:creator></item><item><title>Rust 2020: Discoverability</title><link>https://apiraino.github.io/2019/11/04/call-for-2020-roadmap.html</link><description><![CDATA[Here we come with the "Request for Comment" about Rust for the next 2020 year. I'm sure 2020 will be a great year, also because it's easy and fast to write :) My wishlist will be short and to the point. Looking back to what I wished for 2019 I'd like first to see what has changed, from my point of view.]]></description><guid isPermaLink="false">d2c358d7-aae8-4cb8-93ac-edfaa975072b</guid><pubDate>Mon,  4 Nov 2019 00:00:00 +0100</pubDate><dc:creator>apiraino</dc:creator></item><item><title>How to make your C codebase rusty: rewriting keyboard firmware keymap in Rust</title><link>https://about.houqp.me/posts/rusty-c/</link><description><![CDATA[Recently, my colleague introduced me to QMK 1, an open-source keyboard firmware. Like many non-trivia C projects, macro is heavily used everywhere, especially in keymap files 2. It didn’t bother me much since I have been programming C for many years. But I kept thinking to myself, “what would it look like if I can start from scratch and redesign everything using Rust’s more powerful macro system?” After couple nights of hacking, I was able to come up with something I am quite happy with.]]></description><guid isPermaLink="false">6880443a-d817-4bb3-b7b6-aeaee053df1c</guid><pubDate>Sat,  2 Nov 2019 21:56:49 -0700</pubDate><dc:creator>Hou, Qingping (QP)</dc:creator></item><item><title>Mental experiments with io_uring</title><link>https://vorner.github.io/2019/11/03/io-uring-mental-experiments.html</link><description><![CDATA[Recently, a new Linux kernel interface, called io_uring, appeared. I have been looking into it a little bit and I can’t help but wondering about it. Unfortunately, I’ve had only enough time to keep thinking and reading about it. Nevertheless, I’ve decided to share what I’ve been thinking about so far in case someone wants to write some actual code and experiment. Basically, I have an idea for a crate and I’d love someone else to write it 😇.]]></description><guid isPermaLink="false">2fa36367-ad2e-4773-a3c8-9eea6f166a01</guid><pubDate>Sun,  3 Nov 2019 00:00:00 +0000</pubDate><dc:creator>Michal &apos;vorner&apos; Vaner</dc:creator></item><item><title>Runtime Diagnostics</title><link>https://blog.yoshuawuyts.com/runtime-diagnostics/</link><description><![CDATA[Rust is well-known for its helpful error messages, good tooling, and generally empathic compiler interface. If something goes wrong, Rust tries hard to help you get back on track. In this post I'd like to talk about the runtime aspect of debugging errors.]]></description><guid isPermaLink="false">02e9c871-0bac-4650-8fc3-1c8c64e95c7e</guid><pubDate>Sun,  3 Nov 2019 00:00:00 +0000</pubDate><dc:creator>Yoshua Wuyts</dc:creator></item><item><title>My Rust 2020 wish list: playing nice</title><link>https://blog.dend.ro/my-rust-2020-wishlist/</link><description><![CDATA[This year I decided to jot down some thoughts for the Rust 2020 call for blog posts. I think the general theme here will be integration or "playing well", on different levels. A lot of these here are not language changes, and most of them already exist in some form. Probably none of them are new ideas.]]></description><guid isPermaLink="false">4177b33f-0805-4527-b833-259cf518761a</guid><pubDate>Sun,  3 Nov 2019 00:00:00 +0000</pubDate><dc:creator>Laurențiu Nicola</dc:creator></item><item><title>Rust 2020: Write Once, Run Anywhere</title><link>https://www.boringcactus.com/2019/11/03/rust-2020.html</link><description><![CDATA[Thing that is cool: writing the same codebase and having it run on desktop, mobile, and web thing that is lame: JavaScript is the only language where people really do that right now, outside of big commercial game engines things that need to happen for Rust to get there…]]></description><guid isPermaLink="false">eeeecc4b-3e3d-43f1-b362-1fb59995d8c0</guid><pubDate>Sun,  3 Nov 2019 00:00:00 +0000</pubDate><dc:creator>Melody Horn</dc:creator></item><item><title>mrustc 0.9 - Now with rust 1.29.0 support</title><link>https://www.reddit.com/r/rust/comments/dqi1u1/mrustc_09_now_with_rust_1290_support/</link><description><![CDATA[I'm finally happy to announce that I've "finished" the 1.29 branch of mrustc (for those who don't know, mrustc is my attempt at making a rust compiler, primarily for breaking the bootstrap chain).

This version is capable of compiling both rustc 1.29 (and packaged cargo) AND rustc 1.19, both of which can compile their successors (1.20 and 1.30 - and 1.30 results in a binary equal output).]]></description><guid isPermaLink="false">3e6e0860-0ced-48d0-9f44-a2cfe3355a63</guid><pubDate>Sat,  2 Nov 2019 00:00:00 +0000</pubDate><dc:creator>John Hodge (Mutabah)</dc:creator></item><item><title>Announcing safety-dance: removing unnecessary unsafe code from popular crates</title><link>https://www.reddit.com/r/rust/comments/dq8df4/announcing_safetydance_removing_unnecessary/</link><description><![CDATA[One of the main selling points of Rust is memory safety. However, it is undermined every time people opt out of the checks and write an unsafe block.

A while ago I decided to check just how prevalent that is in widely used code, and I was astonished by what I've found: many popular and widely used Rust crates contain quite a few unsafe blocks, even when they're not doing anything inherently unsafe, and a surprising number of them can be converted into safe code without losing performance.]]></description><guid isPermaLink="false">7c53cfec-7842-4ca1-a1bb-183b2d6c1444</guid><pubDate>Sat,  2 Nov 2019 00:00:00 +0000</pubDate><dc:creator>Sergey &quot;Shnatsel&quot; Davidoff</dc:creator></item><item><title>Rust 2020: Generics &amp; cargo features</title><link>https://blog.turbo.fish/rust-2020/</link><description><![CDATA[This is my personal wishlist of things I'd like to see in 2020 relating to Rust. It only contains technical items, not because I disagree with the people who say we should prioritize some non-technical things, but because I feel like I don't have much of value to add to that topic.]]></description><guid isPermaLink="false">2c81b74e-4e60-42e9-961d-be0ebb810c87</guid><pubDate>Sat,  2 Nov 2019 00:00:00 +0000</pubDate><dc:creator>Jonas Platte</dc:creator></item><item><title>Rust 2020: what about feedbacks?</title><link>https://blog.guillaume-gomez.fr/articles/2019-11-01+Rust+2020%3A+what+about+feedbacks%3F</link><description><![CDATA[I've been working on the Rust compiler for years. It got stabilized, then matured through the years. From my point of view, it now has most of the features I wanted. So what would I want for Rust 2020 and what's coming after? To sum it up: feedbacks.]]></description><guid isPermaLink="false">15458bd0-19bb-4bf6-8460-5857ec6aecdc</guid><pubDate>Fri,  1 Nov 2019 21:30:00 +0000</pubDate><dc:creator>Guillaume Gomez</dc:creator></item><item><title>Rust 2020 - Libraries, Libraries, Libraries!</title><link>https://beyermatthias.de/blog/2019/11/01/rust-2020-libraries-libraries-libraries/</link><description><![CDATA[The call for blogs was just issues a few days ago - and here I am writing about my biggest pains this year… because that’s what the call for blogs basically is for me… I write down my pains with Rust and hope things get better slowly next year.

Don’t misunderstand what I want to say here though: Rust is awesome, has an awesome community, awesome tooling, awesome everything… well not completely (because otherwise I wouldn’t have to write this article, right?]]></description><guid isPermaLink="false">702fd8df-1263-4a2b-ae50-ea9b5e27e35a</guid><pubDate>Fri,  1 Nov 2019 20:45:00 +0000</pubDate><dc:creator>Matthias Beyer</dc:creator></item><item><title>Rust 2020: A better ecosystem</title><link>https://omarabid.com/rust-2020</link><description><![CDATA[I’m fairly new to Rust, and thus my perspective is that of someone who is not quite sophisticated with the language. I think Rust is hard to learn but should be manageable for your average software developer given enough persistence. Once you are over that barrier, you start thinking of building something in Rust. Probably, for the web, or a desktop application, or a mobile application; because that’s largely what many developers are building today.]]></description><guid isPermaLink="false">b2e770a7-f957-470a-8d0b-e5ba86c9872e</guid><pubDate>Fri,  1 Nov 2019 13:37:48 -0700</pubDate><dc:creator>Abid Omar</dc:creator></item><item><title>Linearity among the toctou</title><link>https://www.cloudatomiclab.com/toctou/</link><description><![CDATA[I have been reading a lot of papers on linear types recently. Originally it was to understand better why Rust went down the path it did, but I found a lot more interesting stuff there. While some people now are familiar with linear typesas the basis for Rust’s memory management, they have been around for a long time and have lots of other potential uses. In particular they are interesting for improving resource allocation in functional programming languages by reusing storage in place where possible. Generally they are useful for reasoning about resource allocation. While the Rust implementation is probably the most widely used at present, it kind of obscures the underlying simple principles by adding borrowing, so I will only mention it a little in this post.]]></description><guid isPermaLink="false">511a9fb7-b477-4d17-9c06-fd507b580a21</guid><pubDate>Fri,  1 Nov 2019 17:27:00 +0000</pubDate><dc:creator>Justin Cormack</dc:creator></item><item><title>Always Bump Downwards</title><link>https://fitzgeraldnick.com/2019/11/01/always-bump-downwards.html</link><description><![CDATA[When writing a bump allocator, always bump downwards. That is, allocate from high addresses, down towards lower addresses by decrementing the bump pointer. Although it is perhaps less natural to think about, it is more efficient than incrementing the bump pointer and allocating from lower addresses up to higher ones.]]></description><guid isPermaLink="false">a251550c-42ad-42d6-8780-eae69e3bc85f</guid><pubDate>Fri,  1 Nov 2019 00:00:00 -0700</pubDate><dc:creator>Nick Fitzgerald</dc:creator></item><item><title>This month in rustsim #8 (August − September - October 2019)</title><link>https://www.rustsim.org/blog/2019/11/01/this-month-in-rustsim/</link><description><![CDATA[Welcome to the eighth edition of This month in rustsim! This monthly newsletter will provide you with a summary of important update that occurred within the rustsim community. This includes in particular updates about the nphysics (physics engine), salva (fluid simulation), ncollide (for collision-detection), nalgebra (for linear algebra), and alga (for abstract algebra) crates. This eighth edition will actually contain updates for the past three months (I got sick between the second and third month so I did not get the time to write a new post then. Sorry!)]]></description><guid isPermaLink="false">6b61d3a8-a487-4399-a347-43e16c50abc1</guid><pubDate>Fri,  1 Nov 2019 00:00:00 +0000</pubDate><dc:creator>Sébastien Crozet</dc:creator></item><item><title>Bayard is a full-text search and indexing server written in Rust</title><link>https://github.com/bayard-search/bayard</link><description><![CDATA[Bayard is a full-text search and indexing server written in Rust built on top of Tantivy that implements The Raft Consensus Algorithm (raft-rs) and The gRPC (grpc-rs). Achieves consensus across all the nodes, ensures every change made to the system is made to a quorum of nodes. Bayard makes easy for programmers to develop search applications with advanced features and high availability.]]></description><guid isPermaLink="false">fb00840d-e1ce-4791-9b05-7e1567701082</guid><pubDate>Fri,  1 Nov 2019 00:00:00 +0000</pubDate><dc:creator>Bayard Search</dc:creator></item><item><title>Completing the transition to the new borrow checker</title><link>https://blog.rust-lang.org/2019/11/01/nll-hard-errors.html</link><description><![CDATA[For most of 2018, we've been issuing warnings about various bugs in the borrow checker that we plan to fix -- about two months ago, in the current Rust nightly, those warnings became hard errors. In about two weeks, when the nightly branches to become beta, those hard errors will be in the beta build, and they will eventually hit stable on December 19th, as part of Rust 1.40.0. If you're testing with Nightly, you should be all set -- but otherwise, you may want to go and check to make sure your code still builds. If not, we have advice for fixing common problems below.]]></description><guid isPermaLink="false">290147b3-4275-4b38-86d1-48ead00c7e9f</guid><pubDate>Fri,  1 Nov 2019 00:00:00 +0000</pubDate><dc:creator>Niko Matsakis</dc:creator></item><item><title>@notriddle&apos;s Rust 2020 wishlist, or, Rust 2021: Integration</title><link>http://txti.es/notriddle-rust-2020</link><description><![CDATA[This is just a brain dump. Doing all of this is not going to happen, but all of it is stuff I know of that impacts Rust's integration with the rest of the world and eventually becoming Too Big To Fail like C++ is.]]></description><guid isPermaLink="false">a2f9e31b-3a47-48f0-981b-0f00fe03471e</guid><pubDate>Fri,  1 Nov 2019 00:00:00 +0000</pubDate><dc:creator>notriddle</dc:creator></item><item><title>Rust 2021: Sustainability</title><link>https://xampprocky.github.io/public/blog/rust-2021/</link><description><![CDATA[For the 2019 roadmap Jonathan Turner wrote a blog post called the The Fallow Year that posited that we should let the new designs "field" rest (go fallow) while we focus on other areas. To extend that metaphor, I would say Rust has fallen into monocropping in 2019 by focusing too much on our technical debt, when we needed to be addressing our social debt.]]></description><guid isPermaLink="false">5458741c-97c2-4a8f-bb9e-73daf7317c81</guid><pubDate>Fri,  1 Nov 2019 00:00:00 +0000</pubDate><dc:creator>XAMPPRocky</dc:creator></item><item><title>Rust 2020: Let’s embrace the Eternal September</title><link>https://tim.mcnamara.nz/post/188733729327/rust-2020-lets-embrace-the-eternal-september</link><description><![CDATA[User growth means accepting people that haven’t been exposed to Rust’s norms yet. Let’s not fracture because of an argument over top-posting vs bottom-quoting or something equally trivial. We need to make sure that Rust is prepared to welcome people who are just learning about Rust today. We don’t want anyone to feel like they’re late to the party.]]></description><guid isPermaLink="false">05982a72-c4dd-49ff-8384-3af1783e7211</guid><pubDate>Fri,  1 Nov 2019 00:00:00 +0000</pubDate><dc:creator>Tim McNamara</dc:creator></item><item><title>Rust 2020: GUI and community</title><link>https://raphlinus.github.io/rust/druid/2019/10/31/rust-2020.html</link><description><![CDATA[In response to the call for blogs about the vision for Rust for 2020, I’m going to write about GUI. I believe the time is right for a native GUI toolkit written in Rust, and that such a thing would fill a very important niche. There is a demand for performance (which, to me, includes startup time, RAM footprint, and binary size), and Rust is in the best position to deliver on that.]]></description><guid isPermaLink="false">e6cb0f49-a174-4d58-9acd-2253bbf3bfbe</guid><pubDate>Thu, 31 Oct 2019 19:27:42 +0000</pubDate><dc:creator>Raph Levien</dc:creator></item><item><title>Rust 2020</title><link>https://bes.github.io/guide/2019/10/31/rust-2020-call-for-blogs.html</link><description><![CDATA[We have all been called upon by @rustlang to share our thoughts on what we want from Rust in 2020. My wants are centered around the developer/debug experience more than the language itself. I find the language to be expressive and attractive for many types of development, and I find the community to be very pleasant.]]></description><guid isPermaLink="false">688e00b5-4286-4181-af3e-31bf8090ae74</guid><pubDate>Thu, 31 Oct 2019 17:34:11 +0000</pubDate><dc:creator>Erik Zivkovic</dc:creator></item><item><title>My Rust 2020 ideas</title><link>https://phaazon.net/blog/rust-2020-ideas</link><description><![CDATA[This blog article is a small reply to the public call for blog posts 2020 in the Rust community. I will express what I would like Rust to go to, keeping in mind that it’s solely my ideas and opinions others’ might differ. The points expressed here are written by decreasing priority, starting with the feature I would like the most to see implemented as soon as possible.]]></description><guid isPermaLink="false">3f06b972-507b-441b-a4ce-9fbf0cdfcf96</guid><pubDate>Thu, 31 Oct 2019 15:15:00 +0000</pubDate><dc:creator>Dimitri Sabadie</dc:creator></item><item><title>Rust 2020</title><link>https://blog.hwc.io/posts/rust-2020/</link><description><![CDATA[Every year there’s a call for blogs reflecting on goals for Rust for the upcoming year. For me, the theme is “Community First”.]]></description><guid isPermaLink="false">2f4398a8-473f-47e8-9c7a-616caba80e6d</guid><pubDate>Thu, 31 Oct 2019 10:31:16 -0400</pubDate><dc:creator>hwc</dc:creator></item><item><title>Announcing cfnts: Cloudflare&apos;s implementation of Network Time Security (NTS) in Rust</title><link>https://blog.cloudflare.com/announcing-cfnts/</link><description><![CDATA[Several months ago we announced that we were providing a new public time service. Part of what we were providing was the first major deployment of the new Network Time Security (NTS) protocol, with a newly written implementation of NTS in Rust. In the process, we received helpful advice from the NTP community, especially from the NTPSec and Chrony projects. We’ve also participated in several interoperability events. Now we are returning something to the community: Our implementation, cfnts, is now open source and we welcome your pull requests and issues.]]></description><guid isPermaLink="false">abea3139-f0fb-4680-abbf-1e7f4b368534</guid><pubDate>Thu, 31 Oct 2019 13:00:00 +0000</pubDate><dc:creator>Watson Ladd and Pop Chunhapanya</dc:creator></item><item><title>WIP 3D Rendering Engine</title><link>https://www.reddit.com/r/rust/comments/dpa3ar/wip_rendering_engine/</link><description><![CDATA[My project for the last few months has been creating a 3D rendering engine in Rust, which turned out to be much harder than expected. The original intent was to make a game-engine style thing with built-in support for object loading, cameras, scene graphs, and all that good stuff. What I've ended up with is three separate crates: a small helper for creating command buffers and managing windows, a Vulkan abstraction, and a set of demos showing off what the Vulkan abstraction can do (not much, right now). Pretty.rs in the test-render-engine repository is what's shown in the video, the other demos are less interesting.]]></description><guid isPermaLink="false">0fb9cbaa-4762-4055-bd41-870fe8a93f35</guid><pubDate>Thu, 31 Oct 2019 00:00:00 +0000</pubDate><dc:creator>cynic64</dc:creator></item><item><title>Rust 2020 reflections</title><link>https://gist.github.com/mark-i-m/a39320449a1311515ac62e43ddd9dee0</link><description><![CDATA[This year, I am quite divided due to a bunch of competing desires: I still want all of the things that I wanted last year. In particular, it would be great if OS developement could finally be done on stable rust. Things like inline asm are blocking this. I think there is still a great deal of technical debt left over. I'll talk more about this later. It's not clear what the right balance of new features and working on technical debt is.]]></description><guid isPermaLink="false">3ece4d28-616e-4ea1-b182-f194738e220f</guid><pubDate>Wed, 30 Oct 2019 14:27:23 +0000</pubDate><dc:creator>mark-i-m</dc:creator></item><item><title>“Beating C” with 120 Lines of Rust: wc</title><link>https://medium.com/@martinmroz/beating-c-with-120-lines-of-rust-wc-a0db679fe920</link><description><![CDATA[It’s something of a meme lately to see whether your programming language of choice can take on the venerable wc, and what that might look like. The format seems to be: first do it simply, then idiomatically, and finally much faster. Of course, we’re not really “beating C” but rather “tackling a fun interview question in our favorite programming language.” My go-to these days is Rust, and since I’ve fielded the question of whether Rust is “my Haskell,” this all was too much to pass up. Let’s get started.]]></description><guid isPermaLink="false">7eda1c5a-b463-4d8b-a024-68fe21c735d0</guid><pubDate>Wed, 30 Oct 2019 07:07:06 +0000</pubDate><dc:creator>Martin Mroz</dc:creator></item><item><title>Release Notes for rs-pbrt (Physically Based Rendering) v0.7.2</title><link>https://www.rs-pbrt.org/blog/v0-7-2-release-notes/</link><description><![CDATA[Release Notes for v0.7.2]]></description><guid isPermaLink="false">ef081ecf-9f2e-49b6-ad6a-0836394f828c</guid><pubDate>Wed, 30 Oct 2019 00:00:00 +0000</pubDate><dc:creator>Jan Douglas Bert Walter</dc:creator></item><item><title>Rust 2020</title><link>https://insanitybit.github.io/2019/10/30/rust-2020-wishlist-stabilize-the-ecosystem</link><description><![CDATA[In 2019 the big focus was async/await, or at least as an outsider that is how it has appeared. The end result looks like it will deliver what we’ve all been waiting for - efficient async code that works well with Rust’s borrow checker. As 2019 is coming to a close and async/await is stabilizing, there is the obvious question - what next?]]></description><guid isPermaLink="false">071c6a14-46cc-468f-a9c7-fd456360ffe9</guid><pubDate>Wed, 30 Oct 2019 00:00:00 +0000</pubDate><dc:creator>InsanityBit</dc:creator></item><item><title>Implementing a job queue in Rust</title><link>https://www.poor.dev/posts/what-job-queue/</link><description><![CDATA[I recently finished my first rust project - a command line utility called “what” that displays network utilization information. As a newcomer to rust, this project offered quite some challenges for me. This post is a write up of one of them, going into detail on the parts that I personally found most difficult to understand.

In this first post, I’d like to talk about implementing a job queue to resolve IPs into their hostnames by querying a remote DNS server.]]></description><guid isPermaLink="false">5fd6f3d5-2732-4d86-9824-78928983ebdf</guid><pubDate>Wed, 30 Oct 2019 00:00:00 +0000</pubDate><dc:creator>Aram Drevekenin</dc:creator></item><item><title>My Wishes for Rust 2020</title><link>https://cetra3.github.io/blog/rust-2020/</link><description><![CDATA[2019 was another huge year for rust, but instead of implementing the shiny new thing, it's been a focus on refining existing ideas. Having being using rust professionally for over 3 years, I feel I will very soon be regailing new rust developers of the times before NLL & async, where we had to play lexicon-fu to get things like caches to work in a reasonable fashion, or using super dooper combinator chains and wrestling with futures types (Either::A/B anyone?). So I'd like to make clear my acknowledgement that I am happy with the direction that the rust language is heading in, and these requests are really nice to haves.]]></description><guid isPermaLink="false">96de766f-57ab-48b5-a1ad-97c4fe3d67eb</guid><pubDate>Wed, 30 Oct 2019 00:00:00 +0000</pubDate><dc:creator>Cetra</dc:creator></item><item><title>Rust 2020: exploit dominance in web assembly and no_std</title><link>https://www.reddit.com/r/rust/comments/dp1omc/rust_2020_exploit_dominance_in_web_assembly_and/</link><description><![CDATA[I'm a no name who's just grateful to play around with Rust. The most exciting aspects of Rust is seeing a expressive language go where other languages can barely tread (wasm,linux kernels, microcontrollers). I hope Rust continues to be the bleeding edge tech in web assembly land. I would dream for a world where Rust team works closely with browsers and what new wasm features will drop, and Rust is first to get it. no_std, async, and alloc have added a lot of fascinating new capabilities to the wasm ecosystem, i'd love to see some aspects get stabilized in this realm.]]></description><guid isPermaLink="false">a9a47fee-f918-46f1-bd89-5ddbcbd69f32</guid><pubDate>Wed, 30 Oct 2019 00:00:00 +0000</pubDate><dc:creator>u/richardanaya</dc:creator></item><item><title>Rust 2020 – More Or Less</title><link>https://llogiq.github.io/2019/10/30/rust-2020.html</link><description><![CDATA[The Rust team asked for 2020 roadmap blog posts, so here goes: Let’s do more of what we’ve been doing so far.]]></description><guid isPermaLink="false">71a819be-cc9f-43fc-bc00-a9c182229efc</guid><pubDate>Wed, 30 Oct 2019 00:00:00 +0000</pubDate><dc:creator>Llogiq</dc:creator></item><item><title>Rust 2020: Private enum variants</title><link>https://www.reddit.com/r/rust/comments/dov6ox/rust_2020_private_enum_variants/</link><description><![CDATA[For the 2021 edition of Rust, I'd like to see private enum variants.]]></description><guid isPermaLink="false">1b2c0d1d-3b43-444e-8755-e8e4a60cb2b7</guid><pubDate>Wed, 30 Oct 2019 00:00:00 +0000</pubDate><dc:creator>u/joshlf_</dc:creator></item><item><title>My Rust 2020 blog post</title><link>https://www.reddit.com/r/rust/comments/dot5pk/my_rust_2020_blog_post/</link><description><![CDATA[The 2019 goals for the Rust project were to finish some old language and library features that have had a lot of design but have not been pushed through the finish line.]]></description><guid isPermaLink="false">86590c31-b27d-4d59-b6d8-23eaae5c3dac</guid><pubDate>Wed, 30 Oct 2019 00:00:00 +0000</pubDate><dc:creator>u/0b_0101_001_1010</dc:creator></item><item><title>A call for blogs 2020</title><link>https://www.reddit.com/r/rust/comments/dorinl/a_call_for_blogs_2020/</link><description><![CDATA[Comments on the call for blog posts in 2020 on Reddit, some of which include 2020 wishes.]]></description><guid isPermaLink="false">a32d1a1c-6453-4222-b0a6-9a7f996f6864</guid><pubDate>Wed, 30 Oct 2019 00:00:00 +0000</pubDate><dc:creator>Commenters on Reddit</dc:creator></item><item><title>Vision for Rust 2020 - Integration</title><link>https://www.hardmo.de/article/2019-10-29-rust-2020-vision.md</link><description><![CDATA[With async close the completion everything looks to fall perfectly in place for maintaining the developer momentum that Rust has picked up. The language has surely shown to be approachable, flexible for new concepts and continues to be loved. So are we done? Of course not. I would like to see next years theme be Integration.]]></description><guid isPermaLink="false">a11ab1b4-86e3-4200-8cea-1c5ceb185dd8</guid><pubDate>Tue, 29 Oct 2019 20:58:00 +0000</pubDate><dc:creator>Andreas Molzer</dc:creator></item><item><title>Music Visualization VI: RTFM</title><link>https://dflemstr.io/posts/music-visualization-6/</link><description><![CDATA[Let's actually hook up our LED matrix driver to the RTFM (RealTime For the Masses) library]]></description><guid isPermaLink="false">9d9858e5-ff84-4a20-b687-e96e9119e0dc</guid><pubDate>Tue, 29 Oct 2019 00:00:00 +0000</pubDate><dc:creator>David Flemström</dc:creator></item><item><title>A call for blogs 2020</title><link>https://blog.rust-lang.org/2019/10/29/A-call-for-blogs-2020.html</link><description><![CDATA[We are accepting ideas about almost anything having to do with Rust: language features, tooling needs, community programs, ecosystem needs... if it's related to Rust, we want to hear about it.

One big question for this year: will there be a Rust 2021 edition? If so, 2020 would be the year to do a lot of associated work and plan the details. What would the edition's theme be?]]></description><guid isPermaLink="false">9dd9b6b4-1ab5-4421-b806-61594b0f5f98</guid><pubDate>Tue, 29 Oct 2019 00:00:00 +0000</pubDate><dc:creator>The Rust Core Team</dc:creator></item><item><title>Dreadbot: A Discord Bot for Magic The Gathering in Rust</title><link>https://bcarrigan.com/2019/10/28/dreadbot/</link><description><![CDATA[There is a wonderful Magic: The Gathering scene here in Durham, NC. Unfortunately, Magic often deserves the trope that it gets of being an expensive hobby. In order to enjoy the game on a budget, myself and a group of locals created a new format: Paper Dreadful. The format is simple: create a 60 card deck with a maximum of 4 of any card (other than basic lands) and the total cost must be $20 or less on that day. The same rule applies with the sideboard, except it must by $5 or less.

The problem here is that Magic cards change in price all the time. What happens if I build a deck and then a card skyrockets in price?]]></description><guid isPermaLink="false">1ca114e3-a283-4b4c-ae16-4d5966e0ffcf</guid><pubDate>Mon, 28 Oct 2019 12:00:00 +0000</pubDate><dc:creator>Brian Carrigan</dc:creator></item><item><title>Making Good On Momo’s Compile-Time Promise</title><link>https://llogiq.github.io/2019/10/28/momo-fast.html</link><description><![CDATA[When I announced momo, I wanted its users to save both binary size and compile time while keeping their code simple. I succeeded in the first goal, but failed regarding the second. The reason was that momo requires syn and quote which (unless you have other proc macros in your dependencies) add their own compile time to yours.]]></description><guid isPermaLink="false">61d6deeb-4ef7-4ad7-b6d8-3d9c650501c8</guid><pubDate>Mon, 28 Oct 2019 00:00:00 +0000</pubDate><dc:creator>Llogiq</dc:creator></item><item><title>Quantum computing in Rust, part 1</title><link>https://walther.guru/blog/impl-quantum-part-1/</link><description><![CDATA[What is a ket? How do traits work? Implementing a quantum computer simulator in Rust.]]></description><guid isPermaLink="false">bf08077b-89c9-4880-9b0b-5b869fd21252</guid><pubDate>Mon, 28 Oct 2019 00:00:00 +0000</pubDate><dc:creator>Veeti Haapsamo</dc:creator></item><item><title>How to use gRPC with Rust Tonic and PostgreSQL database</title><link>https://www.steadylearner.com/blog/read/How-to-use-gRPC-with-Rust-Tonic-and-Postgresql-database</link><description><![CDATA[In this post, we will learn how to use Rust Tonic gRPC crate. We will learn how to implement CRUD with Postgresql database. The purpose of it is to help you to have the working Rust Tonic code and start your own porject immediately with it.]]></description><guid isPermaLink="false">2948d871-de13-48a8-bc6b-06cdfcf0104e</guid><pubDate>Mon, 28 Oct 2019 00:00:00 +0000</pubDate><dc:creator>Steadylearner</dc:creator></item><item><title>The Rustc Learning Working Group - An Introduction</title><link>https://blog.rust-lang.org/inside-rust/2019/10/28/rustc-learning-working-group-introduction.html</link><description><![CDATA[The Learning Working Group, formed in April 2019, is focused on making the compiler easier to learn by ensuring that rustc-guide and API docs are "complete". It is one of the many efforts by the Rust Compiler team to decrease the barrier of contributing to the compiler.]]></description><guid isPermaLink="false">884f2a1b-a04c-44b4-ae44-c7f1b489cbc6</guid><pubDate>Mon, 28 Oct 2019 00:00:00 +0000</pubDate><dc:creator>Amanjeev Sethi</dc:creator></item><item><title>A closer look at Ownership in Rust</title><link>https://blog.thoughtram.io/ownership-in-rust/</link><description><![CDATA[In this article we'll take a closer look at Rust's Ownership model and how it manages memory.]]></description><guid isPermaLink="false">f625696c-a751-4e36-8ede-0cd24cf05534</guid><pubDate>Mon, 28 Oct 2019 00:00:00 +0000</pubDate><dc:creator>Pascal Precht</dc:creator></item><item><title>Rust error handling with Result and Option (WebAssembly ABI)</title><link>https://brionv.com/log/2019/10/27/rust-error-handling-with-result-and-option-webassembly-abi/</link><description><![CDATA[In our last adventure we looked at C++ exceptions in WebAssembly with the emscripten compiler. Now we’re taking a look at the main error handling system for another language targeting WebAssembly, Rust. Rust has a “panic”/”unwind” system similar to C++ exceptions, but it’s generally recommended against catching panics.]]></description><guid isPermaLink="false">cef4b4b5-5c64-4da9-a91a-89155efd377f</guid><pubDate>Sun, 27 Oct 2019 19:59:33 +0000</pubDate><dc:creator>Brion Vibber</dc:creator></item><item><title>Programming Servo: the incredibly shrinking timer</title><link>https://medium.com/programming-servo/programming-servo-the-incredibly-shrinking-timer-7283ae2a2669</link><description><![CDATA[How to build a timer in Rust in five easy evolutionary steps.]]></description><guid isPermaLink="false">49a2176c-55b0-4603-8f20-d0d15ab56ca4</guid><pubDate>Sun, 27 Oct 2019 15:40:54 +0000</pubDate><dc:creator>Gregory Terzian</dc:creator></item><item><title>Audio Processing for Dummies</title><link>http://adventures.michaelfbryan.com/posts/audio-processing-for-dummies/</link><description><![CDATA[In my spare time I’m an emergency services volunteer, and one of the tasks our unit has is to run the radio network and keep track of what’s happening. This can be a pretty stressful job, especially when there’s lots of radio traffic, and it’s not unusual to miss words or entire transmissions.

To help with a personal project that could make the job easier I’d like to implement a basic component of audio processing, the Noise Gate.]]></description><guid isPermaLink="false">6d1c1c33-6e97-4911-af35-4b6e621da968</guid><pubDate>Sun, 27 Oct 2019 23:34:00 +0800</pubDate><dc:creator>Michael-F-Bryan</dc:creator></item><item><title>sorted-vec: A sorted array with O(lg n) access and O(√n) inserts and deletes</title><link>https://github.com/senderista/sorted-vec</link><description><![CDATA[This repository contains implementations, unit tests, and benchmark code for the "2-level rotated array" structure, first published in Munro and Suwanda's 1979 paper "Implicit Data Structures for Fast Search and Update" (which also introduced the much better-known beap data structure). This structure is further developed and discussed in "Implicit Data Structures for the Dictionary Problem" (1983) and "Succinct Dynamic Data Structures" (2001). (The latter generalizes the idea to the dynamic array abstract data type, rather than a sorted array.)

The theoretical advantage of a 2-level rotated array over an ordinary sorted array is that it provides the same search performance (O(log n)), with much better insert and delete performance (O(√n), compared to O(n) for a sorted array), in exactly the same amount of space (i.e., no more than the data itself).]]></description><guid isPermaLink="false">30aad534-3914-4d3a-90f3-bc092652d92b</guid><pubDate>Sun, 27 Oct 2019 00:00:00 +0000</pubDate><dc:creator>Tobin Baker</dc:creator></item><item><title>Rust once and share it with Android, iOS and Flutter</title><link>https://robertohuertas.com/2019/10/27/rust-for-android-ios-flutter/</link><description><![CDATA[What if I told you that you could use the same very performant code in Android, iOS or even in Flutter. In this article, we’ll see how to achieve this with Rust.]]></description><guid isPermaLink="false">9d326b39-4675-4c5f-9509-d388a4e41486</guid><pubDate>Sun, 27 Oct 2019 00:00:00 +0000</pubDate><dc:creator>Roberto Huertas</dc:creator></item><item><title>Ferris Fencing - player-programmed bots combat each other on a RISC-V virtual machine</title><link>http://www.ferrisfencing.org/</link><description><![CDATA[Ferris Fencing is a live tournament in which player-programmed bots combat each other on a RISC-V virtual machine.  It is a showcase of CKB-VM, a simple implementation of the RISC-V instruction set, written in the Rust programming language.  ]]></description><guid isPermaLink="false">40f6a583-f5e8-4198-af0c-8ff6129d288a</guid><pubDate>Sun, 27 Oct 2019 00:00:00 +0000</pubDate><dc:creator>Aimee Zhu and Brian Anderson</dc:creator></item><item><title>Why async fn in traits are hard</title><link>http://smallcultfollowing.com/babysteps/blog/2019/10/26/async-fn-in-traits-are-hard/</link><description><![CDATA[After reading boat’s excellent post on asynchronous destructors, I thought it might be a good idea to write some about async fn in traits. Support for async fn in traits is probably the single most common feature request that I hear about. It’s also one of the more complex topics. So I thought it’d be nice to do a blog post kind of giving the “lay of the land” on that feature – what makes it complicated? What questions remain open?]]></description><guid isPermaLink="false">da517b10-2b8a-4b94-97c3-34b0c049de42</guid><pubDate>Sat, 26 Oct 2019 00:00:00 -0400</pubDate><dc:creator>Niko Matsakis</dc:creator></item><item><title>Using Type-Level Programming in Rust to Make Safer Hardware Abstractions</title><link>https://blog.auxon.io/2019/10/25/type-level-registers/</link><description><![CDATA[In the world of systems programming where one may find themselves writing hardware drivers or interacting directly with memory-mapped devices, that interaction is almost always through memory-mapped registers provided by the hardware. We typically interact with these things through bitwise operations on some fixed-width numeric type.]]></description><guid isPermaLink="false">1f8ce13c-5661-4d07-aad2-11ea948a5a16</guid><pubDate>Fri, 25 Oct 2019 00:00:00 +0000</pubDate><dc:creator>Dan Pittman</dc:creator></item></channel></rss>