<rss version="2.0"><channel><title>Read Rust - All Posts</title><link>https://readrust.net/</link><description>All Posts posts on Read Rust</description><item><title>Organizational Debt</title><link>https://boats.gitlab.io/blog/post/rust-2019/</link><description><![CDATA[We all know that classic aphorism: Year comes to an end, Rust blog post press send. This is mine.

There are lots of cool technical improvements to Rust that I want the project to achieve this year, and a few in particular that I’m definitely going to be putting a lot of time into. But this blog post is going to talk about none of them. Instead, I want to talk about organizational debt, and how badly the Rust project needs to deal with it in 2019.]]></description><guid isPermaLink="false">f0adf24b-6589-4306-a580-6cef894ad3b7</guid><pubDate>Mon, 16 Dec 2019 00:00:00 +0000</pubDate><dc:creator>withoutboats</dc:creator></item><item><title>Fuzz rising: how fuzz testing is making memory unsafe languages untenable</title><link>https://www.cloudatomiclab.com/fuzz/</link><description><![CDATA[Go and read the excellent blog post from Cloudflare on their recent outage if you haven’t already. I am not going to talk about most of it, just a few small points that especially interest me right now, which are definitely not the most important things from the outage point of view. This post got a bit long so I split it up, so this is part one.]]></description><guid isPermaLink="false">cc336a90-bbf5-49c3-94b7-e3c4454cbc53</guid><pubDate>Sun, 21 Jul 2019 20:52:00 +0000</pubDate><dc:creator>Justin Cormack</dc:creator></item><item><title>Localizing the Rust Website to Traditional Chinese</title><link>https://medium.com/coding-neutrino-blog/localize-the-rust-website-to-traditional-chinese-473413f44d21</link><description><![CDATA[I am glad to announce that the Traditional Chinese (正體中文) version of the Rust official website has been launched. Thanks to all contributors in the community. This article records our experience to achieve the work.]]></description><guid isPermaLink="false">52f43349-8161-4996-95ad-138528adcf21</guid><pubDate>Fri, 19 Jul 2019 16:38:55 +0000</pubDate><dc:creator>Liu An Chi (tigercosmos)</dc:creator></item><item><title>How to use Torch in Rust with tch-rs</title><link>http://vegapit.com/article/how-to-use-torch-in-rust-with-tch-rs</link><description><![CDATA[Thanks to the diligent work of Laurent Mazare on his tch-rs crate, the Rust community can now enjoy an easy access to the powerful Torch neural net framework. Being personally an avid user of both Rust and Torch, stumbling on this repo has been nothing but a belated birthday present. In this post, I would like to dive into two examples to present its most fundamental functionalities.]]></description><guid isPermaLink="false">4f959a60-5f69-4997-b6d8-6cf6e8311e1f</guid><pubDate>Fri, 19 Jul 2019 13:18:00 +0100</pubDate><dc:creator>Vegapit</dc:creator></item><item><title>Introducing Abscissa: iqlusion&apos;s security-oriented Rust application framework</title><link>https://iqlusion.blog/introducing-abscissa-rust-application-framework</link><description><![CDATA[Earlier this month we released Abscissa: our security-oriented Rust application framework. After releasing v0.1, we’ve spent the past few weeks further polishing it up in tandem with this blog post, and just released a follow-up v0.2.]]></description><guid isPermaLink="false">9ec74f93-14a2-47ec-8572-24b9efe51a62</guid><pubDate>Thu, 18 Jul 2019 07:00:51 -0700</pubDate><dc:creator>Tony Arcieri</dc:creator></item><item><title>The Temptation of Unsafe</title><link>https://inejge.github.io/blog/2019/07/18/The-Temptation-of-Unsafe.html</link><description><![CDATA[Recently, another round of discussion concerning the use of Rust’s unsafe features in the Actix web framework happened, or rather erupted, on Reddit, even more heated and acrimonious than the first time around. (I am not linking to any of the threads, as I believe that they don’t need any more exposure. Use your favorite search engine.) This proves, if more proof is needed, that people hold passionate beliefs about the matter.]]></description><guid isPermaLink="false">a0f3d2bb-e52e-440b-809f-169497494769</guid><pubDate>Thu, 18 Jul 2019 00:00:00 +0000</pubDate><dc:creator>inejge</dc:creator></item><item><title>How to speed up the Rust compiler in 2019</title><link>https://blog.mozilla.org/nnethercote/2019/07/17/how-to-speed-up-the-rust-compiler-in-2019/</link><description><![CDATA[I have written previously about my efforts to speed up the Rust compiler in 2016 (part 1, part 2) and 2018 (part 1, part 2, NLL edition). It’s time for an update on the first half of 2019.]]></description><guid isPermaLink="false">688a7c2c-4cb7-4da6-a9d5-3cf4d5f7571a</guid><pubDate>Wed, 17 Jul 2019 02:54:57 +0000</pubDate><dc:creator>Nicholas Nethercote</dc:creator></item><item><title>Announcing heim: async library for system information fetching</title><link>https://svartalf.info/posts/2019-07-17-announcing-heim-project/</link><description><![CDATA[If you are familiar with Python ecosystem, probably you had heard about psutil package — a cross-platform library for retrieving information about system processes and system utilization (CPU, memory, disks, network and so on). It is very popular and actively used package, which has analogs in other languages: gopsutil for Golang, oshi for Java, you name it. Rust, of course, is not an exception here: we do have psutil, sysinfo, sys-info and systemstat crates.

Now, despite the tremendous work that had been done already by the authors of these crates, I’m excited to announce what I’ve been working on for the past three months: “heim” project — library for system information fetching.]]></description><guid isPermaLink="false">c91d6ec8-c734-495e-89ad-e63da5825eb0</guid><pubDate>Wed, 17 Jul 2019 00:00:00 +0000</pubDate><dc:creator>Nikita Kuznetsov</dc:creator></item><item><title>Announcing Ballista - Distributed Compute with Rust, Apache Arrow, and Kubernetes</title><link>https://andygrove.io/2019/07/announcing-ballista/</link><description><![CDATA[After taking a break from working on Arrow and DataFusion for a couple of months to focus on some deliverables at work, I have now started a new PoC project to have a second attempt at building a distributed platform with Rust, and this time around I have the advantage of already having some foundational pieces in place, namely Arrow and DataFusion. I have also been gaining experience with Kubernetes recently and I could clearly see how this would simplify the creation of a distributed platform. The pieces really are starting to fall into place.

The new project is called Ballista and is a fast moving PoC taking a top down approach to building a distributed platform.]]></description><guid isPermaLink="false">f47a9bfe-394d-44b0-a4b1-683976a2cee2</guid><pubDate>Tue, 16 Jul 2019 00:00:00 +0000</pubDate><dc:creator>Andy Grove</dc:creator></item><item><title>New tools for 2D game development in Amethyst</title><link>https://amethyst.rs/posts/tools-for-2d-games</link><description><![CDATA[Are you looking to build 2D games with Amethyst? Well, we've got some great news for you! Getting started just became a whole lot easier. There's been 2 recent project releases that we want to tell you more about; encourage you to use them, give us feedback and maybe even contribute!]]></description><guid isPermaLink="false">69f76932-86e3-4ee1-b2ee-f9d986b25389</guid><pubDate>Tue, 16 Jul 2019 00:00:00 +0000</pubDate><dc:creator>happens</dc:creator></item><item><title>Perils of Constructors</title><link>https://matklad.github.io/2019/07/16/perils-of-constructors.html</link><description><![CDATA[One of my favorite blog posts about Rust is Things Rust Shipped Without by Graydon Hoare. To me, footguns that don’t exist in a language are usually more important than expressiveness. In this slightly philosophical essay, I want to tell about a missing Rust feature I especially like: constructors.]]></description><guid isPermaLink="false">85b61a6b-91ab-4194-a236-43a690cc3f2f</guid><pubDate>Tue, 16 Jul 2019 00:00:00 +0300</pubDate><dc:creator>Aleksey Kladov</dc:creator></item><item><title>Rust in one of the biggest music festival Atlas Weekend 2019</title><link>https://www.reddit.com/r/rust/comments/cdg5b4/rust_in_the_on_of_the_biggest_music_festival/</link><description><![CDATA[I'm happy to announce, that we've just finished one of the biggest European music festival Atlas Weekend which took place in Kyiv, Ukraine. As a year ago, backend for technical purposes of festival is written with Rust: Tickets exchange, entrance control, powerful user management with distributed configurable permissions, backstage pass, control of security workers, their work time, cars entrance, warehouse system for rfid bracelets with full history and control of each rfid. This year we registered more than 6000 workers, each of them has full info tied to bracelet: name, phone, photo, available permissions, time to access festival.]]></description><guid isPermaLink="false">0026c42e-9e3b-4a14-96dc-1fe3609e8957</guid><pubDate>Mon, 15 Jul 2019 00:00:00 +0000</pubDate><dc:creator>/u/maxfrai</dc:creator></item><item><title>Cactus Harvesting: Cycle-Aware Reference Counting in Rust</title><link>https://hyperbo.la/w/cactus-harvesting/</link><description><![CDATA[🌵 CactusRef is a single-threaded, cycle-aware, reference counting smart pointer [docs] [code]. CactusRef is nearly a drop-in replacement for std::rc1 from the Rust standard library.]]></description><guid isPermaLink="false">f1fef443-d169-4ff1-a74e-262d273c9b9d</guid><pubDate>Mon, 15 Jul 2019 00:00:00 +0000</pubDate><dc:creator>Ryan Lopopolo</dc:creator></item><item><title>Rust as the new C. Part 1: building and combining native libs into C API</title><link>http://hotforknowledge.com/2019/07/14/6-rust-the-new-c/</link><description><![CDATA[In this blog series, I will experiment with Rust as a safer and simpler C/C++ replacement. The idea is to combine a couple of C dependencies in Rust, to do some work using the dependencies in Rust and to expose a final API from a Rust library via C ABI. Then I will consume the same exported Rust methods from a number of modern languages/platforms such as C#, Python, Java, Nodejs, R, Go and even back from C/C++.]]></description><guid isPermaLink="false">342aba54-6554-4ec9-9d92-cd93edfbc8a2</guid><pubDate>Sun, 14 Jul 2019 16:12:00 +0300</pubDate><dc:creator>Victor Baybekov</dc:creator></item><item><title>cedarwood: Efficiently-Updatable Double Array Trie in Rust</title><link>https://blog.paulme.ng/posts/2019-07-14-cedarwood:-efficiently-updatable-double-array-trie-in-rust.html</link><description><![CDATA[Cedarwood is an effort to speed up jieba-rs, an efficient implementation of trie is needed in order to satisfying the following needs.]]></description><guid isPermaLink="false">44e12e0f-4572-479e-a63c-c4539b2c9ae8</guid><pubDate>Sun, 14 Jul 2019 00:00:00 +0000</pubDate><dc:creator>Paul Meng</dc:creator></item><item><title>RPG Name Generation</title><link>https://www.wihlidal.com/blog/general/2019-07-14-name-generation/</link><description><![CDATA[Role-playing and adventure games often require a considerably high number of names to describe characters, locations, items, events, abilities, etc. Humans are very awful generators of randomness, especially upon request. Writers and designers can come up with a handful of well devised names for important identifiers, but having a human generate 100 character names will likely result in many duplicates or boring derivatives. There are a few approaches to this problem: Pattern substitution of a data set with explicit rule-based probability. Using Markov chains to synthesize new results from a data set. Training a neural network to synthesize new results from a data set.]]></description><guid isPermaLink="false">15701ed9-bc70-4c65-bd7b-616363d7d3d4</guid><pubDate>Sun, 14 Jul 2019 00:00:00 +0000</pubDate><dc:creator>Graham Wihlidal</dc:creator></item><item><title>How to use NPM packages with Rust Frontend</title><link>https://www.steadylearner.com/blog/read/How-to-use-NPM-packages-with-Rust-Frontend</link><description><![CDATA[In the previous post full-stack Rust with Yew, we learnt how to prepare minimal files to build a full stack Rust web app. You can do whatever Rust allows with it.]]></description><guid isPermaLink="false">4979dc89-2295-48da-ae2b-cb84dc37fd8c</guid><pubDate>Sun, 14 Jul 2019 00:00:00 +0000</pubDate><dc:creator>Steadylearner</dc:creator></item><item><title>&quot;What The Hardware Does&quot; is not What Your Program Does: Uninitialized Memory</title><link>https://www.ralfj.de/blog/2019/07/14/uninit.html</link><description><![CDATA[This post is about uninitialized memory, but also about the semantics of highly optimized “low-level” languages in general. I will try to convince you that reasoning by “what the hardware does” is inherently flawed when talking about languages such as Rust, C or C++. These are not low-level languages. I have made this point before in the context of pointers; this time it is going to be about uninitialized memory.]]></description><guid isPermaLink="false">3161bc30-9df4-4273-8ff7-301ea0426d9f</guid><pubDate>Sun, 14 Jul 2019 00:00:00 +0000</pubDate><dc:creator>Ralf Jung</dc:creator></item><item><title>RSoC: Implementing ptrace for Redox OS - part 4</title><link>https://www.redox-os.org/news/rsoc-ptrace-4/</link><description><![CDATA[Once again, last weeks action was merged, which means the full ptrace feature was merged, and it’s time to start tackling the final issues which I have delayed for so long. But, before that, I decided to try to get some basic ptrace compatibility in relibc, so we could see just how far away software like gdb is from being ported, and what concerns I haven’t thought about yet. redox-nix update: That said, I took a little break from the madness, to instead lay my focus on another interesting problem: Newer redoxer couldn’t be compiled using carnix, because of some dependency that used a cargo feature carnix didn’t support. Let me first explain what carnix is, and why this is a problem.]]></description><guid isPermaLink="false">c7551d1c-be90-4dd7-be38-5fcb78c51ef0</guid><pubDate>Sat, 13 Jul 2019 00:00:00 +0000</pubDate><dc:creator>jD91mZM2</dc:creator></item><item><title>Visual Programming with Embedded Rust? Yes we can with Apache Mynewt and Google Blockly!</title><link>https://medium.com/@ly.lee/visual-programming-with-embedded-rust-yes-we-can-with-apache-mynewt-and-google-blockly-8b67ef7412d7</link><description><![CDATA[I gotta admit — Embedded Programs are getting darned hard to code on modern microcontrollers, sensors and networks. Faced with the ultra-daunting task of coding a readable, reusable, open-source NB-IoT application for STM32, I asked myself… Could Visual Programming with Embedded Rust solve this problem? Like this…]]></description><guid isPermaLink="false">22d99aab-bb46-4d9b-9cf5-1e977c639f16</guid><pubDate>Fri, 12 Jul 2019 21:52:53 +0000</pubDate><dc:creator>Lup Yuen Lee 李立源</dc:creator></item><item><title>What Is Rust&apos;s unsafe?</title><link>https://nora.codes/post/what-is-rusts-unsafe/</link><description><![CDATA[I’ve seen a lot of misconceptions around what the unsafe keyword means for the utility and validity of Rust and its marketing as a “safe systems language”. The truth is a lot more complicated than a single pithy tweet can possibly sum up, unfortunately; here it is as I see it.

Basically, the unsafe keyword does not turn off the advanced type system that keeps Rust code honest. It only allows a few select “superpowers”, like dereferencing raw pointers. It is used to implement safe abstractions over a fundamentally unsafe world so that the majority of Rust code can use those abstractions and avoid memory unsafety.]]></description><guid isPermaLink="false">a05e51b1-ea5d-4365-949c-80c0c3e48d54</guid><pubDate>Fri, 12 Jul 2019 10:00:00 -0700</pubDate><dc:creator>Leonora Tindall</dc:creator></item><item><title>Testable Component Design in Rust</title><link>http://iextendable.com/2019/07/12/testable-component-design-in-rust/</link><description><![CDATA[I consider myself an advanced beginner in Rust. There is still much I’m wrapping my head around–and I still get caught off guard by the “move” and “mutability” rules Rust enforces. However, in keeping with my personal emphasis, I’ve devoted my efforts to learning how to create automated tests in Rust. The below guidelines are not exhaustive, but represent my learning so far. Feedback is welcome!]]></description><guid isPermaLink="false">20553a37-476d-45bb-8180-3de54aa932cd</guid><pubDate>Fri, 12 Jul 2019 13:57:01 +0000</pubDate><dc:creator>Chris McKenzie</dc:creator></item><item><title>Rust Questions from Beginners, Including Me</title><link>https://rust.graystorm.com/2019/07/11/rust-questions-from-beginners-including-me/</link><description><![CDATA[Information overload and I’m still trying to find a bigger project I can work on that interests me. I have the Interpreter to work on still, and that will take some serious work! But I’m also thinking of going back to small systems of my programming past and playing with writing them in Rust. In the meantime, I thought I’d sneak around the Rust #beginners channel on Discord and give everyone a peak at some questions (and hopefully some answers) that beginners are asking about their early Rust code.]]></description><guid isPermaLink="false">5d130478-b1c5-46b7-af4b-9e217dd138b2</guid><pubDate>Thu, 11 Jul 2019 23:48:17 +0000</pubDate><dc:creator>Jeff Culverhouse</dc:creator></item><item><title>Fullstack Rust with Yew</title><link>https://www.steadylearner.com/blog/read/Fullstack-Rust-with-Yew</link><description><![CDATA[In the previous post How to use Rust Yew, we learnt how to prepare minimal files to build webassembly files with Yew for Rust frontend. We will advance it with some Rust server side code and write a bash file to automate the process.]]></description><guid isPermaLink="false">28d2b0b9-8bfb-4541-b2f5-f84ed2670d56</guid><pubDate>Thu, 11 Jul 2019 00:00:00 +0000</pubDate><dc:creator>Steadylearner</dc:creator></item><item><title>Stream combinators implemented using for await syntax</title><link>https://www.reddit.com/r/rust/comments/cbvhq9/stream_combinators_implemented_using_for_await/</link><description><![CDATA[ I am a big fan of simplifying the existent code in futures-rs using async/await syntax. My goal was to rewrite the combinators in such a way that even a newbie can understand what was going on. However I met several issues with Stream combinators because it was a little bit hard to construct an impl Stream without defining a struct with a ::poll_next method. So I used Stream::unfold that can create streams from a closure.]]></description><guid isPermaLink="false">907a2ee8-f215-4259-8179-bc4d542a7647</guid><pubDate>Thu, 11 Jul 2019 00:00:00 +0000</pubDate><dc:creator>Roman Proskuryakov</dc:creator></item><item><title>timetill.rs: highlighting all the Rust conferences around the world</title><link>https://timetill.rs/</link><description><![CDATA[timetill.rs is a community project focused on highlighting all the Rust conferences around the world. Timetill.rs is an open project that anyone in the community can contribute to.]]></description><guid isPermaLink="false">eecb5f26-323a-4d45-8a03-4fef1b0943e0</guid><pubDate>Thu, 11 Jul 2019 00:00:00 +0000</pubDate><dc:creator>XAMPPRocky</dc:creator></item><item><title>AiC: Unbounded queues and lang design</title><link>http://smallcultfollowing.com/babysteps/blog/2019/07/10/aic-unbounded-queues-and-lang-design/</link><description><![CDATA[I have been thinking about how language feature development works in Rust1. I wanted to write a post about what I see as one of the key problems: too much concurrency in our design process, without any kind of “back-pressure” to help keep the number of “open efforts” under control. This setup does enable us to get a lot of things done sometimes, but I believe it also leads to a number of problems.

Although I don’t make any proposals in this post, I am basically advocating for changes to our process that can help us to stay focused on a few active things at a time. Basically, incorporating a notion of capacity such that, if we want to start something new, we either have to finish up with something or else find a way to grow our capacity.]]></description><guid isPermaLink="false">6d02baa8-8fcd-45fa-9f96-d36a635a2379</guid><pubDate>Wed, 10 Jul 2019 00:00:00 -0400</pubDate><dc:creator>Niko Matsakis</dc:creator></item><item><title>The Computer Language Benachmarks Game: Rust ranks #1 for n-body</title><link>https://frehberg.com/2019/07/the-computer-language-benachmarks-game-rust-ranks-1-for-n-body/</link><description><![CDATA[The Computer Language Benchmarks Game is a free software project for comparing how a given subset of simple algorithms can be implemented in various popular programming languages. I converted the fastest (dating early 2019) n-body C-implementation (#4) to Rust (#7) in a one-to-one fashion, gaining a performance encreasement by factor 1.6 to my own surprise.]]></description><guid isPermaLink="false">07e226de-482b-4f51-af76-adb65b4a35dc</guid><pubDate>Tue,  9 Jul 2019 16:53:57 +0000</pubDate><dc:creator>Frank Rehberger</dc:creator></item><item><title>CHIP-8 Emulator Rust Port</title><link>https://ryp.github.io/emu/rust/chip8/2019/07/09/chip8-emulator-rust/</link><description><![CDATA[I thought it would be a nice start to just take existing code and try to see how well it would translate from C++. I simply took my previous CHIP-8 emu and started to chip at it with the help of the docs. If you want to dive right in, here’s the code on GitHub. Anyway, it was my first go at Rust so go easy on me! =)]]></description><guid isPermaLink="false">7a2ae69b-3b31-45da-855b-592a86d96a6b</guid><pubDate>Tue,  9 Jul 2019 15:00:00 +0000</pubDate><dc:creator>Ryp</dc:creator></item><item><title>Rust, a Raspberry Pi and Addressable LED&apos;s</title><link>https://blog.tomarrell.com/post/rust_and_leds</link><description><![CDATA[I'd been playing around with a couple of LED matrices bought from AliExpress. The LED's on one of the matrices were the very popular WS2812b variant. These panels are made up of addressable RGB LED's soldered to a flexible PCB, giving you three wires out the back -- data, 5V, and ground.

After not being able to find a Rust library which supported these things at the time (a few have popped up since), I decided I would instead learn the protocol and try to fiddle with it myself. This is a brief overview of that experience.<Paste>]]></description><guid isPermaLink="false">ff6ab953-5b21-4852-b0e5-058c730767f5</guid><pubDate>Tue,  9 Jul 2019 00:00:00 +0000</pubDate><dc:creator>Tom Arrell</dc:creator></item><item><title>Migrating a crate from futures 0.1 to 0.3</title><link>https://www.ncameron.org/blog/migrating-a-crate-from-futures-0-1-to-0-3/</link><description><![CDATA[I recently migrated a small/medium-sized crate from Futures 0.1 to 0.3. It was fairly easy, but there were some tricky bits and some things that were not well documented, so I think it is worth me writing up my experience.]]></description><guid isPermaLink="false">84e8a302-326a-4c95-a6ae-78d4e8fa1029</guid><pubDate>Mon,  8 Jul 2019 21:24:28 +0000</pubDate><dc:creator>Nick Cameron</dc:creator></item><item><title>Collecting broadcast UDP packets using async networking in Rust</title><link>https://medium.com/tresorit-engineering/collecting-broadcast-udp-packets-using-async-networking-in-rust-7fd93a631eac</link><description><![CDATA[Creating a simple console application in Rust for fun and profit, including some nice tricks to push async programming to the limits.]]></description><guid isPermaLink="false">66342269-5693-4c70-a15c-917b7818dc07</guid><pubDate>Mon,  8 Jul 2019 10:39:21 +0000</pubDate><dc:creator>Péter Budai</dc:creator></item><item><title>Drawing in GTK in Rust (part 1)</title><link>https://medium.com/journey-to-rust/drawing-in-gtk-in-rust-part-1-4a401eecc4e0</link><description><![CDATA[It’s a double challenge: I’m learning Rust (but I can say I more or less know the language by now), and I’m trying to use GTK in Rust. I’m a complete beginner in GTK, and even if I know Rust, it does not mean I can use it properly. So I’ll learn a huge library (written in C) by using it in a complex and hard language I just learned. Well, well, good luck, me.]]></description><guid isPermaLink="false">05694ac8-0c6b-413c-9853-a487c3d25652</guid><pubDate>Mon,  8 Jul 2019 07:10:41 +0000</pubDate><dc:creator>George Shuklin</dc:creator></item><item><title>Async-await status report #2</title><link>http://smallcultfollowing.com/babysteps/blog/2019/07/08/async-await-status-report-2/</link><description><![CDATA[I wanted to give an update on the status of the “async-await foundations” working group. This post aims to cover three things: the “async await MVP” that we are currently targeting; how that fits into the bigger picture; and how you can help, if you’re so inclined;]]></description><guid isPermaLink="false">815aa1ce-d98e-484c-8dbf-a91fce9a4167</guid><pubDate>Mon,  8 Jul 2019 00:00:00 -0400</pubDate><dc:creator>Niko Matsakis</dc:creator></item><item><title>Method for Emulating Higher-Kinded Types in Rust</title><link>https://gist.github.com/edmundsmith/855fcf0cb35dd467c29a9350481f0ecf</link><description><![CDATA[I've been fiddling about with an idea lately, looking at how higher-kinded types can be represented in such a way that we can reason with them in Rust here and now, without having to wait a couple years for what would be a significant change to the language and compiler.

There have been multiple discussions on introducing higher-ranked polymorphism into Rust, using Haskell-style Higher-Kinded Types (HKTs) or Scala-looking Generalised Associated Types (GATs). The benefit of higher-ranked polymorphism is to allow higher-level, richer abstractions and pattern expression than just the rank-1 polymorphism we have today.]]></description><guid isPermaLink="false">55481592-1914-40bc-a2be-f7be9702c5c7</guid><pubDate>Sun,  7 Jul 2019 20:47:09 +0000</pubDate><dc:creator>Edmund Smith</dc:creator></item><item><title>Safer, Simpler Embedded Rust with Apache Mynewt on STM32 Blue Pill</title><link>https://medium.com/@ly.lee/safer-simpler-embedded-rust-with-apache-mynewt-on-stm32-blue-pill-d8fcb41969ac</link><description><![CDATA[Declarative and Procedural Macros (plus bindgen and tips for Visual Studio Code) to protect Embedded Rust coders from stumbling into embedded traps.]]></description><guid isPermaLink="false">cfa3bc39-5cbc-4544-ae37-488a111411ef</guid><pubDate>Sun,  7 Jul 2019 04:58:53 +0000</pubDate><dc:creator>Lup Yuen Lee</dc:creator></item><item><title>RSoC: Implementing ptrace for Redox OS - part 3</title><link>https://www.redox-os.org/news/rsoc-ptrace-3/</link><description><![CDATA[Before I dive in to this week’s actions, I am pleased to announce that all the last weeks’ work is merged! This merge means you can now experiment with basic ptrace functionality using only basic registers and PTRACE_SYSCALL/PTRACE_SINGLESTEP. I have already opened the second PR in the batch: Ptrace memory reading and floating point registers support which will supply the “final bits” of the initial implementation, before all the nitpicking of final concerns can start (not to underestimate the importance and difficulty of these nitpicks - there are some areas of ptrace that aren’t even thought about yet and those will need tending to)! I will comment on these changes in this blog post, as there are some interesting things going on!]]></description><guid isPermaLink="false">dc58ea4c-1cea-4142-b9e7-00e066527e35</guid><pubDate>Sun,  7 Jul 2019 00:00:00 +0000</pubDate><dc:creator>jD91mZM2</dc:creator></item><item><title>RSoC: Ion as a Library, week 5</title><link>https://www.redox-os.org/news/rsoc-ion-lib-4/</link><description><![CDATA[Wrapping up the Ion as a library project. It is now possible to embed Ion in any Rust application. Ion takes any Read instance and can execute it (so yes, it is possible to run Ion without ever collecting the script’s binary stream). It takes care of expanding the input and managing the running applications in an efficient manner, with a comprehensive set of errors. Ion is now the rust-based, pipe-oriented liblua alternative.]]></description><guid isPermaLink="false">6b3f54a7-e579-456f-8ee8-7753db3f7ee4</guid><pubDate>Sun,  7 Jul 2019 00:00:00 +0000</pubDate><dc:creator>AdminXVII</dc:creator></item><item><title>Rust vs C++ - Implementing a Neural Network</title><link>http://nicktasios.nl/posts/rust-vs-c%2B%2B-implementing-a-neural-network.html</link><description><![CDATA[I first learned Rust back in 2014, before it was stable. Rust is definitely a very interesting language so I have decided to revisit it by programming a simple neural network. For comparison, I also implemented the network in C++, the language I'm looking to replace.]]></description><guid isPermaLink="false">649aefcc-0d0c-4e1c-b2d2-337d3110c606</guid><pubDate>Sat,  6 Jul 2019 19:18:48 +0200</pubDate><dc:creator>Nick Tasios</dc:creator></item><item><title>Speedy Desktop Apps With GTK and Rust</title><link>https://nora.codes/tutorial/speedy-desktop-apps-with-gtk-and-rust/</link><description><![CDATA[The web platform is the delivery mechanism of choice for a ton of software these days, either through the web browser itself or through Electron, but that doesn’t mean there isn’t a place for a good old fashioned straight-up desktop application in the picture.

Fortunately, it’s easier than ever to write a usable, pretty, and performant desktop app, using my language of choice (Rust) and the wildly successful cross-platform GUI framework GTK. In this blog post, we’ll walk through the source code of gDiceRoller. In future posts, I’ll explain how I packaged it for different systems.]]></description><guid isPermaLink="false">04a62a1c-2acd-4ee3-8d83-eac3e9bcbca7</guid><pubDate>Fri,  5 Jul 2019 14:00:00 -0700</pubDate><dc:creator>Leonora Tindall</dc:creator></item><item><title>Functional Programming Jargon in Rust</title><link>https://functional.works-hub.com/learn/functional-programming-jargon-in-rust-1b555</link><description><![CDATA[Github Repository: https://github.com/JasonShin/functional-programming-jargon.rsFunctional programming (FP) provides many advantages, and its popula...]]></description><guid isPermaLink="false">3d786e81-3097-48f1-aea9-9a86473f6957</guid><pubDate>Fri,  5 Jul 2019 00:00:00 +0000</pubDate><dc:creator>Jason Shin</dc:creator></item><item><title>Cargo --offline ✈️</title><link>https://www.ncameron.org/blog/cargo-offline/</link><description><![CDATA[Rust 1.36 is released on the 4th July and includes a bunch of new stuff. This blog post is about one newly stable feature in Cargo: --offline.]]></description><guid isPermaLink="false">4ab235dc-fc27-4dfe-aefc-1bcc16a23199</guid><pubDate>Thu,  4 Jul 2019 08:13:57 +0000</pubDate><dc:creator>Nick Cameron</dc:creator></item><item><title>Rust std study series: alloc</title><link>https://ehsanmkermani.com/2019/07/03/rust-std-study-series-alloc/</link><description><![CDATA[Let’s get deep into std::alloc! The very basic need for any program to compile and execute is having access to either physical memory or virtual memory. An allocator is responsible for providing such an access. You can think of an allocator as a service, taking some sort of requests and either giving back a (pointer) to block of memory or some errors. In Rust, a request is a Layout i.e. some meta-data about how the memory we want is supposed to take up the space.]]></description><guid isPermaLink="false">a11e4440-7ad1-4e28-95d7-db6cc8a4544b</guid><pubDate>Thu,  4 Jul 2019 00:20:38 +0000</pubDate><dc:creator>Ehsan M. Kermani</dc:creator></item><item><title>Announcing Rust 1.36.0</title><link>https://blog.rust-lang.org/2019/07/04/Rust-1.36.0.html</link><description><![CDATA[This release brings many changes, including the stabilization of the Future trait, the alloc crate, the MaybeUninit<T> type, NLL for Rust 2015, a new HashMap<K, V> implementation, and --offline support in Cargo. Read on for a few highlights, or see the detailed release notes for additional information.]]></description><guid isPermaLink="false">75040309-d3a6-4941-a8d1-28c6f8bdfc19</guid><pubDate>Thu,  4 Jul 2019 00:00:00 +0000</pubDate><dc:creator>The Rust Release Team</dc:creator></item><item><title>Create Dev&apos;s offline page with Rust and WebAssembly 🦄💡✨</title><link>https://dev.to/sendilkumarn/create-dev-s-offline-page-with-rust-and-webassembly-21gn</link><description><![CDATA[Dev's offline page is fun. Can we do that with Rust and WebAssembly? The answer is yes. Let us do it.]]></description><guid isPermaLink="false">b5b706cb-863b-4856-843d-6a894a7fc280</guid><pubDate>Wed,  3 Jul 2019 23:14:51 +0000</pubDate><dc:creator>Sendil Kumar N</dc:creator></item><item><title>Increase Rust and WebAssembly performance</title><link>https://dev.to/sendilkumarn/increase-rust-and-webassembly-performance-382h</link><description><![CDATA[What are we gonna do? Create a WebAssembly application that takes a string in markdown format and converts that into HTML.]]></description><guid isPermaLink="false">faa1d1ec-2bcd-4363-832a-2e03e35d8124</guid><pubDate>Tue,  2 Jul 2019 00:40:25 +0000</pubDate><dc:creator>Sendil Kumar N</dc:creator></item><item><title>The Embedded Working Group Newsletter - 18</title><link>https://rust-embedded.github.io/blog/newsletter-18/</link><description><![CDATA[This is the eighteenth newsletter of the Embedded WG where we highlight new progress, celebrate cool projects, thank the community, and advertise projects that need help!]]></description><guid isPermaLink="false">e716273a-01bd-4a08-a120-09a0511c71a3</guid><pubDate>Tue,  2 Jul 2019 00:00:00 +0000</pubDate><dc:creator>The Embedded Working Group</dc:creator></item><item><title>Rust WebAssembly Hello World - Deep Dive with wasm-bindgen and wasm2wat</title><link>https://www.webassemblyman.com/rust_webassembly_hello_world.html</link><description><![CDATA[In this article we are going to create a WebAssembly Hello World program with Rust. You might be thinking that a WebAssembly Hello World tutorial could be found almost everywhere, including one on Mozilla website and rustwasm.github.io.]]></description><guid isPermaLink="false">247efda7-549d-4c38-8af1-733755fc4aa7</guid><pubDate>Tue,  2 Jul 2019 00:00:00 +0000</pubDate><dc:creator>nicole</dc:creator></item><item><title>Status of rust-analyzer: Achievements and Open Collective</title><link>https://ferrous-systems.com/blog/rust-analyzer-status-opencollective/</link><description><![CDATA[rust-analyzer is an experimental compiler frontend for the Rust programming language. The ultimate goal for this project is to provide the perfect IDE experience for Rust, with all IDE features working flawlessly while editing code. This post talks about what happened to rust-analyzer in between the all-hands and today, discusses future plans, and also announces the rust-analyzer Open Collective.]]></description><guid isPermaLink="false">09564ee8-19af-4b03-95c4-b231ffd7f24f</guid><pubDate>Mon,  1 Jul 2019 22:00:00 +0000</pubDate><dc:creator>Aleksey Kladov</dc:creator></item><item><title>Building crates so they look like C(ABI) Libraries</title><link>https://dev.to/luzero/building-crates-so-they-look-like-c-abi-libraries-1ibn</link><description><![CDATA[How to write a well behaved C-API library in Rust.]]></description><guid isPermaLink="false">fdaab910-4937-451e-9fe4-3cfd693069b8</guid><pubDate>Mon,  1 Jul 2019 19:40:21 +0000</pubDate><dc:creator>Luca Barbato</dc:creator></item><item><title>Rust modules vs files</title><link>https://amos.me/blog/2019/rust-modules-vs-files/</link><description><![CDATA[A while back, I asked on Twitter what people found confusing in Rust, and one of the top topics was “how the module system maps to files”. I remember struggling with that a lot when I first started Rust, so I’ll try to explain it in a way that makes sense to me.]]></description><guid isPermaLink="false">ec53084d-522d-4916-90b2-c8adda4b75f2</guid><pubDate>Mon,  1 Jul 2019 00:00:00 +0000</pubDate><dc:creator>amos</dc:creator></item><item><title>TLS performance: rustls versus OpenSSL</title><link>https://jbp.io/2019/07/01/rustls-vs-openssl-performance.html</link><description><![CDATA[There are quite a few dimensions to how performance can vary between TLS libraries such as handshake performance and bulk performance. This series of blog posts measures and compares the performance of rustls (a TLS library in rust) and OpenSSL.]]></description><guid isPermaLink="false">ead392a4-baff-4c08-9820-8fd74ef14200</guid><pubDate>Mon,  1 Jul 2019 00:00:00 +0000</pubDate><dc:creator>Joseph Birr-Pixton</dc:creator></item><item><title>One Program Written in Python, Go, and Rust</title><link>http://www.nicolas-hahn.com/python/go/rust/programming/2019/07/01/program-in-python-go-rust/</link><description><![CDATA[This is a subjective, primarily developer-ergonomics-based comparison of the three languages from the perspective of a Python developer, but you can skip the prose and go to the code samples, the performance comparison if you want some hard numbers, the takeaway for the tl;dr, or the Python, Go, and Rust diffimg implementations.]]></description><guid isPermaLink="false">a7b2c09d-06ca-4ae2-89c2-70bf78282396</guid><pubDate>Mon,  1 Jul 2019 00:00:00 +0000</pubDate><dc:creator>Nicolas Hahn</dc:creator></item><item><title>Sharing references between Python and Rust</title><link>https://raphaelgomes.dev/blog/articles/2019-07-01-sharing-references-between-python-and-rust.html</link><description><![CDATA[In 2018, the Mercurial project decided to use Rust to improve performance and maintainability of previous high-performance code. We have faced some interesting challenges when bridging the Python implementation with the new Rust code, and this is one that I have not found any literature about.]]></description><guid isPermaLink="false">38abc54a-6b27-48ec-8789-363ead337d8a</guid><pubDate>Mon,  1 Jul 2019 00:00:00 +0000</pubDate><dc:creator>Raphaël Gomès</dc:creator></item><item><title>Aelve Codesearch: Regex-based search across all of crates.io</title><link>https://codesearch.aelve.com/rust</link><description><![CDATA[Search the code of all crates published to crates.io.]]></description><guid isPermaLink="false">c7f25b3a-3d76-4b05-85df-6bf59fb5c92a</guid><pubDate>Mon,  1 Jul 2019 00:00:00 +0000</pubDate><dc:creator>Aelve</dc:creator></item><item><title>How to use Rust Yew</title><link>https://www.steadylearner.com/blog/read/How-to-use-Rust-Yew</link><description><![CDATA[In this post, we will prepare development environment for Rust Yew. Then, we will write minimal code with it and learn how to deploy it in your website also.]]></description><guid isPermaLink="false">db9d60ca-f153-4abf-9654-ac53ec91472e</guid><pubDate>Sun, 30 Jun 2019 00:00:00 +0000</pubDate><dc:creator>Steadylearner</dc:creator></item><item><title>Optimizing jieba-rs to be 33% faster than cppjieba</title><link>https://blog.paulme.ng/posts/2019-06-30-optimizing-jieba-rs-to-be-33percents-faster-than-cppjieba.html</link><description><![CDATA[This blog post is mainly to share my experience on taking an emerging programming language’s ecosystem seriously and evaluating it by working on a serious project, and see how far we can go in terms of performance and development experience. The project I chose as mentioned in the title is jieba-rs, the rust implementation of a popular Chinese word segmentation library: Jieba.]]></description><guid isPermaLink="false">9618e311-ec84-431c-97ab-c9f010c3c65c</guid><pubDate>Sun, 30 Jun 2019 00:00:00 +0000</pubDate><dc:creator>Paul Meng</dc:creator></item><item><title>RSoC: Implementing ptrace for Redox OS - part 2</title><link>https://www.redox-os.org/news/rsoc-ptrace-2/</link><description><![CDATA[The next step in the journey of ptrace was to bite the bullet (or at least I thought) and implement system-call tracing. Since the kernel must be able to handle system-calls of processes, it’s quite obvious that the way to set a breakpoint should involve the kernel, running in the context of the tracee, should notify the tracer and wait. So the biggest challenge would be to figure out how kernel synchronization worked.]]></description><guid isPermaLink="false">a3749f41-8d22-4fa8-9f5d-bb1e699f333c</guid><pubDate>Sun, 30 Jun 2019 00:00:00 +0000</pubDate><dc:creator>jD91mZM2</dc:creator></item><item><title>Compiling Rust Apps for Termux with nix-shell</title><link>https://blog.geemili.xyz/blog/rust-app-on-termux-with-nix/</link><description><![CDATA[I've been building a program to track how I spend my time, and a couple of the requirements are an interface on my phone, and sync between multiple devices. Since I haven't built an android app in forever, I decided to target termux, at least initially. This will allow me to use the app and test out the synchronization protocol without a ton of upfront effort into building a graphical user interface.]]></description><guid isPermaLink="false">bce3d472-5591-44cc-b52a-2573bf8d9f55</guid><pubDate>Sat, 29 Jun 2019 06:54:28 -0500</pubDate><dc:creator>LeRoyce Pearson</dc:creator></item><item><title>How to Emulate a Game Boy: The Book</title><link>https://blog.ryanlevick.com/DMG-01/</link><description><![CDATA[DMG-01 is a guide for how to emulate a Game Boy. Together, we'll explore the insides of one of the world's most beloved computers.]]></description><guid isPermaLink="false">f545777e-e75d-40c5-af12-a6c8b2d962f4</guid><pubDate>Sat, 29 Jun 2019 00:00:00 +0000</pubDate><dc:creator>Ryan Levick</dc:creator></item><item><title>async log</title><link>https://blog.yoshuawuyts.com/async-log/</link><description><![CDATA[Today we'd like to introduce async-log, a general-purpose crate that extends the standard log crate with asynchronous metadata. This is a first step in introducing full-fledged asynchronous tracing capabilities to Rust.]]></description><guid isPermaLink="false">f85b4664-304e-4eeb-a93b-2377b74263cd</guid><pubDate>Sat, 29 Jun 2019 00:00:00 +0000</pubDate><dc:creator>Yoshua Wuyts</dc:creator></item><item><title>Writing a small ray tracer in Rust and Zig</title><link>https://nelari.us/post/raytracer_with_rust_and_zig/</link><description><![CDATA[The two languages that I spent most of my time daydreaming about writing code in are Rust and Zig. Would the lack of features in Zig make me more or less productive than with Rust’s feature overload? Which language is more enjoyable to use for writing a small, self-contained computer graphics project?  To find out, I decided to implement the same simple project in both languages: a small ray tracer, following the book Ray Tracing in One Weekend.]]></description><guid isPermaLink="false">6e2a2811-942b-4e62-b173-6d2b0d3e0acd</guid><pubDate>Thu, 27 Jun 2019 20:00:00 +0200</pubDate><dc:creator>Johann Muszynski</dc:creator></item><item><title>termimad: A library to display rich (Markdown) snippets and texts in a Rust terminal application</title><link>https://github.com/Canop/termimad</link><description><![CDATA[A simple tool to display static or dynamic Markdown snippets in the terminal, with skin isolation. Based on crossterm so works on most terminals (even on windows).]]></description><guid isPermaLink="false">9f8dfcb3-e67c-456d-94d5-76ea84f8caa8</guid><pubDate>Thu, 27 Jun 2019 00:00:00 +0000</pubDate><dc:creator>Canop</dc:creator></item><item><title>Non-Lexical Lifetimes arrives for everyone</title><link>http://blog.pnkfx.org/blog/2019/06/26/breaking-news-non-lexical-lifetimes-arrives-for-everyone/</link><description><![CDATA[It has been literally years since I last posted to this blog. I have been doing a bunch of Rust compiler work. One big feature has been deployed: Non-Lexical Lifetimes (hereafter denoted “NLL”).

The motivation for this blog post: The next version of Rust, 1.36, is going to have NLL turned on for the 2015 edition. Going forward, all editions of Rust will now use NLL.]]></description><guid isPermaLink="false">d682ecb5-9935-4073-8865-f5a66f2a65f5</guid><pubDate>Wed, 26 Jun 2019 12:54:29 +0200</pubDate><dc:creator>Felix S. Klock II</dc:creator></item><item><title>Understanding Closures in Rust</title><link>https://medium.com/swlh/understanding-closures-in-rust-21f286ed1759</link><description><![CDATA[Summary: Closures are a combination of a function pointer (fn) and a context. A closure with no context is just a function pointer. A closure which has an immutable context belongs to Fn. A closure which has a mutable context belongs to FnMut. A closure that owns its context belongs to FnOnce.]]></description><guid isPermaLink="false">c39c6210-76a8-46f1-ab2d-b6f1be909232</guid><pubDate>Wed, 26 Jun 2019 10:27:58 +0000</pubDate><dc:creator>Andrew Pritchard</dc:creator></item><item><title>Wasm By Example</title><link>https://wasmbyexample.dev/</link><description><![CDATA[A hands-on introduction into WebAssembly ( Wasm ). Containing simple examples and tutorials on how to implement concepts and various tasks using Wasm.]]></description><guid isPermaLink="false">2c73c05a-7fb3-494d-8fb3-896cf3a343b3</guid><pubDate>Wed, 26 Jun 2019 03:28:00 +0000</pubDate><dc:creator>Aaron Turner</dc:creator></item><item><title>RESS (Rusty EcmaScript Scanner) 0.7.0 bring large performance improvements</title><link>https://wiredforge.com/blog/ress-7/</link><description><![CDATA[A blog about learning computer science concepts with practical projects]]></description><guid isPermaLink="false">876033ef-0f64-4108-89c6-8ce8d6536ac7</guid><pubDate>Wed, 26 Jun 2019 00:00:00 +0000</pubDate><dc:creator>Robert Masen</dc:creator></item><item><title>Writing an OS in Rust: Heap Allocation</title><link>https://os.phil-opp.com/heap-allocation/</link><description><![CDATA[This post adds support for heap allocation to our kernel. First, it gives an introduction to dynamic memory and shows how the borrow checker prevents common allocation errors. It then implements the basic allocation interface of Rust, creates a heap memory region, and sets up an allocator crate. At the end of this post all the allocation and collection types of the built-in alloc crate will be available to our kernel.]]></description><guid isPermaLink="false">cd714c38-04f4-4e7c-a98e-4af4eb7d7464</guid><pubDate>Wed, 26 Jun 2019 00:00:00 +0000</pubDate><dc:creator>Philipp Oppermann</dc:creator></item><item><title>Writing a proxy in Rust and why it is the language of the future</title><link>https://medium.com/swlh/writing-a-proxy-in-rust-and-why-it-is-the-language-of-the-future-265d8bf7c6d2</link><description><![CDATA[It’s been a year since I wrote a little proxy with Rust, it is one of my first projects with this language and I learned a lot writing it. To sum up a bit, the main goal of this proxy is to be really simple to use and easy to extend with middlewares. It targets HTTP APIs and can be used in front of a lot of services. This proxy has been used in multiple projects, with microservices architecture and so on…]]></description><guid isPermaLink="false">ae8feddf-191a-444f-9423-e7a3e0b4b356</guid><pubDate>Tue, 25 Jun 2019 14:43:21 +0000</pubDate><dc:creator>Terry Raimondo</dc:creator></item><item><title>Rust type language - journey to rust</title><link>https://medium.com/journey-to-rust/rust-type-language-48e1c43b1ef4</link><description><![CDATA[Disclaimer: If you are learning Rust, take this with grain of salt. I’m learning Rust too and I may be utterly wrong in my guesses. The more I read and do Rust, the more I realize, that Rust consists of two (three, if macros counts) languages.]]></description><guid isPermaLink="false">4b9faf2d-145a-4deb-909d-ac58ea05bdc8</guid><pubDate>Tue, 25 Jun 2019 14:10:43 +0000</pubDate><dc:creator>George Shuklin</dc:creator></item><item><title>std time</title><link>https://blog.yoshuawuyts.com/std-time/</link><description><![CDATA[Over the past month we've been hard at work to add time support to the Runtime crate. One of the things we've had to think about has been examples. Which means we've had a chance to become intimately familiar with the good and less good parts of the std::time API.

In this post we'll look at the std::time API, and some of the proposed changes to smooth things out a bit. Also disclaimer: I've been involved with these proposals, hehe.]]></description><guid isPermaLink="false">f0491f48-a0cd-4f35-a781-a8907f277e8a</guid><pubDate>Tue, 25 Jun 2019 00:00:00 +0000</pubDate><dc:creator>Yoshua Wuyts</dc:creator></item><item><title>Rustexp: A Rust regular expression editor &amp; tester</title><link>https://rustexp.lpil.uk/</link><description><![CDATA[A Rust regular expression editor & tester inspired by Rubular.]]></description><guid isPermaLink="false">b9742776-a64f-4358-beff-fabdf075d65d</guid><pubDate>Tue, 25 Jun 2019 00:00:00 +0000</pubDate><dc:creator>Louis Pilfold</dc:creator></item><item><title>Why we&apos;re using Rust for cloud rendering</title><link>https://www.digitalbridge.com/blog/why-were-using-rust-for-cloud-rendering</link><description><![CDATA[We initially began replacing a small component of our stack using Rust, but it quickly became clear that a larger effort would allow a great reduction in complexity. In the end, all the C, C++, and Python components of the service were rebuilt, with Rust used from task loading through to dispatching GPU operations.]]></description><guid isPermaLink="false">91f9b804-7782-4a78-ade2-e4d8008923cf</guid><pubDate>Mon, 24 Jun 2019 12:07:47 +0000</pubDate><dc:creator>Iain MacIver</dc:creator></item><item><title>Building Standalone Python Applications with PyOxidizer</title><link>https://gregoryszorc.com/blog/2019/06/24/building-standalone-python-applications-with-pyoxidizer/</link><description><![CDATA[Today, I'm excited to announce the first release of PyOxidizer (project, documentation), an open source utility that aims to solve the Python application distribution problem! (The installation instructions are in the docs.) PyOxidizer's marquee feature is that it can produce a single file executable containing a fully-featured Python interpreter, its extensions, standard library, and your application's modules and resources.]]></description><guid isPermaLink="false">6a4e1bf9-728a-4c25-919d-05ae4664366c</guid><pubDate>Mon, 24 Jun 2019 09:00:00 +0000</pubDate><dc:creator>Gregory Szorc</dc:creator></item><item><title>swym: Are we lock-free yet?</title><link>https://mtak-blog.github.io/are-we-lock-free-yet</link><description><![CDATA[swym is a transactional memory library that prioritizes performance. It’s not lock-free, but it does have progress guarantees. This post will explore some of the recent work on swym’s progress promises, as well as some comparisons with non-blocking algorithms. I’m not an expert on schedulers or OS’s, so please correct me if anything is wrong. It might benefit swym!]]></description><guid isPermaLink="false">c274055b-d2a2-43f1-9ef3-a9fc15521878</guid><pubDate>Mon, 24 Jun 2019 00:00:00 +0000</pubDate><dc:creator>mtak-</dc:creator></item><item><title>nom, the Rust parser combinators library, is now available at version 5</title><link>http://unhandledexpression.com/general/2019/06/17/nom-5-is-here.html</link><description><![CDATA[nom, the Rust parser combinators library, is now available at version 5. This is the most mature version of nom. This is the one that feels “done”. This is the parser library that I wanted when I started nom 5 years ago. It’s here at last. nom 5 is a complete rewrite of the internal architecture, to use functions instead of macros, while keeping backward compatibility with existing macros based parsers, and making the error type completely generic.]]></description><guid isPermaLink="false">f6a2f624-a597-4ae7-b89a-e621ebb50c55</guid><pubDate>Mon, 24 Jun 2019 00:00:00 +0000</pubDate><dc:creator>Geoffroy Couprie</dc:creator></item><item><title>My iterator is returning a reference to a reference</title><link>https://blog.tawhidhannan.co.uk/rust/tidbits/rust-double-ref</link><description><![CDATA[Sometimes you mean it. Other times you really don't. It can be a bit of a headscratcher, but is not a particularly complicated situation, just easy to stumble into on a tired afternoon. In the end it all comes down to the ensuring you're being purposeful about what you're iterating over. I'll take a relatively brief dive into what can cause this, and how you can get back to iterating over what you want to iterate over.]]></description><guid isPermaLink="false">cb4c2736-6856-435e-a605-8d7b2155a1c3</guid><pubDate>Sun, 23 Jun 2019 00:00:00 +0000</pubDate><dc:creator>Tawhid Hannan</dc:creator></item><item><title>Real Time For the Masses goes multi-core</title><link>https://blog.japaric.io/multicore-rtfm/</link><description><![CDATA[v0.5.0 of Real Time For the Masses (RTFM), the embedded concurrency framework, is coming out soon-ish – some time after Rust 1.36 is released – and will include experimental support for homogeneous and heterogeneous multi-core Cortex-M devices. This blog post covers the upcoming multi-core API and includes a refresher on the single-core API.]]></description><guid isPermaLink="false">fafe9330-b614-4ea0-a2eb-1958d77fc8f4</guid><pubDate>Sun, 23 Jun 2019 00:00:00 +0000</pubDate><dc:creator>Jorge Aparicio</dc:creator></item><item><title>Implementing HTSP in Rust</title><link>https://www.rubdos.be/rust/async/programming/2019/06/22/implementing-htsp-in-rust.html</link><description><![CDATA[As with most hobby projects, my htsp-rs implementation became a side-side-side project, and it will probably stay that way. Another property of those hobby projects is that I now-and-then pick them up again, and htsp-rs has come to that point now. The reason for picking it up again is different from the reason of its existence though, and that’s a good thing: it means I have multiple reasons for the crate’s existence. Initially, I wanted it as a back-end for a livestreaming app on SailfishOS. Today, I want it as back-end for mpd’s TVHeadend support.]]></description><guid isPermaLink="false">0770f016-861d-4bc1-9ce0-cad6b6e374f2</guid><pubDate>Sat, 22 Jun 2019 00:00:00 +0000</pubDate><dc:creator>Ruben De Smet</dc:creator></item><item><title>Rust for OOP - Enums &amp; Pattern Matching - Part 2</title><link>https://oribenshir.github.io/afternoon_rusting//blog/enum-and-pattern-matching-part-2</link><description><![CDATA[We will continue the previous post with two complementary examples. Both will demonstrate the capability of enums to push various language constructs and states into the type system. As an example for it, imagine we could create a type which represents an if statement, and then hand over instances of it around our program. Enums tends to work better than using the underlying concepts for various reason, starting from the complexity of the borrow checkers and lifetimes, through the powerful type system in Rust. And not less important, allowing you to code common patterns as functions, in a way otherwise wouldn’t be available to you. We will see all of this today. Later in the series, we will revisit those examples, and we will demonstrate how well they can compose with other code we can write.]]></description><guid isPermaLink="false">0f371197-7406-4f9f-8460-b8a9e951ec27</guid><pubDate>Sat, 22 Jun 2019 00:00:00 +0000</pubDate><dc:creator>Ori Ben-Shir</dc:creator></item><item><title>RSoC: Implementing ptrace for Redox OS - part 1</title><link>https://www.redox-os.org/news/rsoc-ptrace-1/</link><description><![CDATA[After having a pretty clear goal to meet specified by the RFC, time to get things moving. I started with what I thought would be low hanging fruit: Reading the registers of another process. It ended up being more difficult than I thought, but it ended up being really interesting and I want to share it with you :)]]></description><guid isPermaLink="false">25660960-3e2c-44ba-a511-2dd73afc6a32</guid><pubDate>Sat, 22 Jun 2019 00:00:00 +0000</pubDate><dc:creator>jD91mZM2</dc:creator></item><item><title>Gtk-rs: New release - more complete, safer</title><link>https://gtk-rs.org/blog/2019/06/22/new-release.html</link><description><![CDATA[Welcome everyone to this whole new gtk-rs release! Time to check what was added/updated in this new version.]]></description><guid isPermaLink="false">0f224e61-b4f3-40f2-b99a-431cf41ec5d8</guid><pubDate>Sat, 22 Jun 2019 00:00:00 +0000</pubDate><dc:creator>Gtk-rs Developers</dc:creator></item><item><title>The smooth resize test</title><link>https://raphlinus.github.io/rust/gui/2019/06/21/smooth-resize-test.html</link><description><![CDATA[Today is an exciting point in the evolution of native GUI in Rust. There is much exploration, and a number of promising projects, but I also think we don’t yet know the recipe to make GUI truly great. As I develop my own vision in this space, druid, I hope more that the efforts will learn from each other and that an excellent synthesis will emerge, more so than simply hoping that druid will win.

In my work, I have come across a problem that is as seemingly simple, yet as difficult to get right, as making decent tea: handling smooth window resizing. Very few GUI toolkits get it perfect, with some failing spectacularly. This is true across platforms, though Windows poses special challenges. It’s also pretty easy to test (as opposed to requiring sophisticated latency measurements, which I also plan to develop). I suggest it become one of the basic tests to evaluate a GUI toolkit.]]></description><guid isPermaLink="false">1898399d-d60a-46fc-a3e0-cb8a73fb546e</guid><pubDate>Fri, 21 Jun 2019 19:50:42 +0000</pubDate><dc:creator>Raph Levien</dc:creator></item><item><title>Winit 0.20, the state of windowing in Rust, and a request for help</title><link>https://users.rust-lang.org/t/winit-0-20-the-state-of-windowing-in-rust-and-a-request-for-help/29485</link><description><![CDATA[I’m one of the maintainers of Winit, the main pure-Rust window creation library. Even if you haven’t used it directly, you’ve probably heard of projects that depend on it - Servo and Alacritty being the best-known applications that depend on our codebase. If you’ve done any graphics programming in Rust using Glutin (or dependent projects including gfx-rs, Glium, and Amethyst) we’ve been the ones making the windows actually show up on your desktop.

This announcement details the major changes since Winit 0.19. Also, we are looking for new contributors! If you are interested in working on the foundations of Rust’s GUI story, now is a great time to join the project.]]></description><guid isPermaLink="false">1ea200e9-2dda-4cad-9190-7aec92439026</guid><pubDate>Fri, 21 Jun 2019 16:16:03 +0000</pubDate><dc:creator>Osspial</dc:creator></item><item><title>Collaborative Editor in Rust</title><link>https://caolan.org/posts/collaborative_editor_in_rust.html</link><description><![CDATA[I've been experimenting with techniques for collaborative editing in Rust recently and I'd like to share my first functional prototype with you. The demo uses Rust and WebAssembly, and I implemented it using a conflict-free replicated data type (CRDT) based on LOGOOT, which I modified to work with variable-sized strings rather than individual characters or lines.]]></description><guid isPermaLink="false">54d40e7f-c5c5-4c69-86e2-9913c6a88200</guid><pubDate>Fri, 21 Jun 2019 00:00:00 +0000</pubDate><dc:creator>Caolan McMahon</dc:creator></item><item><title>Getting Started with Rust: Working with Files and Doing File I/O</title><link>https://www.linuxjournal.com/content/getting-started-rust-working-files-and-doing-file-io</link><description><![CDATA[This article demonstrates how to perform basic file and file I/O operations in Rust, and also introduces Rust's ownership concept and the Cargo tool. If you are seeing Rust code for the first time, this article should provide a pretty good idea of how Rust deals with files and file I/O, and if you've used Rust before, you still will appreciate the code examples in this article. ]]></description><guid isPermaLink="false">c03bd61e-3c2d-4e4d-a081-ffa0e3b641ed</guid><pubDate>Thu, 20 Jun 2019 00:00:00 +0000</pubDate><dc:creator>Mihalis Tsoukalos</dc:creator></item><item><title>Asyncifying an Actix Web App and Upgrading it to 1.0 - zupzup</title><link>https://zupzup.org/asyncify-rust-webapp/</link><description><![CDATA[In a previous post, we created an Actix 0.7 Web App, which was not fully non-blocking. In this post, we'll become fully non-blocking and upgrade the app to Actix 1.0]]></description><guid isPermaLink="false">a5730863-ff70-4122-8595-81c11ee59697</guid><pubDate>Thu, 20 Jun 2019 00:00:00 +0000</pubDate><dc:creator>Mario Zupan</dc:creator></item><item><title>A Detailed Look at Rust Streams</title><link>https://blog.yoshuawuyts.com/rust-streams/</link><description><![CDATA[As Rust's async story is evolving, so is Rust's streaming story. In this post we'll take a look at how Rust's streaming model works, how to use it effectively, and where things are heading in the future.]]></description><guid isPermaLink="false">7602cf1d-bae1-41bb-bfb8-4d7967af1704</guid><pubDate>Thu, 20 Jun 2019 00:00:00 +0000</pubDate><dc:creator>Yoshua Wuyts</dc:creator></item><item><title>Distributed Systems Training in Rust and Go</title><link>https://tikv.org/blog/talent-training/</link><description><![CDATA[PingCAP is creating a series of training courses on writing distributed systems in Rust and Go. These courses consist of:

Practical Networked Applications in Rust. A series of projects that incrementally develop a single Rust project from the ground up into a high-performance, networked, parallel and asynchronous key/value store. Along the way various real-world and practical Rust development subject matter are explored and discussed.

Distributed Systems in Rust. Adapted from the MIT 6.824 distributed systems coursework, this course focuses on implementing important distributed algorithms, including the Raft consensus algorithm, and the Percolator distributed transaction protocol.]]></description><guid isPermaLink="false">f756eb13-90c3-407a-a304-66e198248d3b</guid><pubDate>Thu, 20 Jun 2019 00:00:00 +0000</pubDate><dc:creator>Brian Anderson</dc:creator></item><item><title>Rust crates – frehberg’s annotated catalogue</title><link>https://frehberg.com/2019/06/rust-crates-frehbergs-annotated-catalogue/</link><description><![CDATA[The base of Rust users and contributors is growing steadily. The amount of libraries (aka crates) at http://crates.io is growing quickly; the overall “noise” is increasing. Some libraries might not be maintained any longer 🙁

This annotated catalogue shall help the Rust-users to find specific, popular, mature Rust crates. This list is WIP (Work In Progress), reflecting my personal shortlist. The ordering in the table top-down doesn’t express any preference.]]></description><guid isPermaLink="false">f1697ece-4d5e-46b8-88b5-d5a2e729ae96</guid><pubDate>Wed, 19 Jun 2019 19:13:23 +0000</pubDate><dc:creator>Frank Rehberger</dc:creator></item><item><title>Fuzzing rust code: cargo-fuzz and honggfuzz</title><link>https://www.wzdftpd.net/blog/rust-fuzzers.html</link><description><![CDATA[This post explains how to test Rust code using fuzzers. Parsers are good target for fuzzers, especially because they usually are functions that only takes bytes as input.]]></description><guid isPermaLink="false">ea3f2d4d-b907-4611-9aaf-d5f6311863a2</guid><pubDate>Wed, 19 Jun 2019 00:00:00 +0200</pubDate><dc:creator>Pollux</dc:creator></item><item><title>Rust std study series: Interior mutability</title><link>https://ehsanmkermani.com/2019/06/18/rust-std-study-series-interior-mutability/</link><description><![CDATA[Continuing the standard library study, it’s time for Cell<T>!]]></description><guid isPermaLink="false">ca449299-1f7d-493f-9857-b1954e1f371d</guid><pubDate>Tue, 18 Jun 2019 20:27:25 +0000</pubDate><dc:creator>Ehsan M. Kermani</dc:creator></item><item><title>Rust Creator Graydon Hoare Talks About Security, History, and Rust</title><link>https://thenewstack.io/rust-creator-graydon-hoare-talks-about-security-history-and-rust/</link><description><![CDATA[We’re approaching the 9th anniversary of the day Graydon Hoare (and numerous contributors) first revealed to the world the newly-designed Rust programming language. So we thought it’d be a good time to assess our current landscape.

Hoare graciously agreed, sharing his thoughts on everything from the state of systems programming, to the difficulty of defining safety on ever-more complex systems — and whether we’re truly more secure today, or confronting an inherited software mess that will take decades to clean up.]]></description><guid isPermaLink="false">f6b00396-a786-403b-b392-16e784f32241</guid><pubDate>Tue, 18 Jun 2019 13:00:49 +0000</pubDate><dc:creator>David Cassel</dc:creator></item><item><title>Experiment with streams, reading files with futures</title><link>https://chilimatic.hashnode.dev/experiment-with-streams-reading-files-with-futures-cjx1q0gmo001eurs1pt0c27kz</link><description><![CDATA[We were experimenting with streams and I wanted to play around with them as well. There are some tokio implementations for async file reading futuers, but since linux filesystems before kernel 5.1 do not really support non blocking file operations. I thought lets have fun breaking things ourselves. As I mentioned this is not really non blocking I/O esp. since there are two ways to view futures in their current state. ]]></description><guid isPermaLink="false">98e8bcf7-00d1-4f6d-ba28-ea41f2d7b705</guid><pubDate>Tue, 18 Jun 2019 00:00:00 +0000</pubDate><dc:creator>j</dc:creator></item><item><title>On Memoization in Rust</title><link>https://medium.com/swlh/on-memoization-291fd1dd924</link><description><![CDATA[A detailed walk through how to memoize function calls in Rust.]]></description><guid isPermaLink="false">b26fcca3-2a79-4340-88fd-80c6f70c95d1</guid><pubDate>Mon, 17 Jun 2019 12:30:14 +0000</pubDate><dc:creator>Andrew Pritchard</dc:creator></item><item><title>Amethyst 0.11.0 has been released!</title><link>https://amethyst.rs/posts/release-0-11</link><description><![CDATA[Amethyst 0.11.0 comes packed with the Rendy integration & many small additions throughout the engine.]]></description><guid isPermaLink="false">13cf6e76-809f-4987-997d-4cb45a26114d</guid><pubDate>Mon, 17 Jun 2019 00:31:00 +0000</pubDate><dc:creator>Thomas Schaller</dc:creator></item><item><title>Rust for OOP - Enums &amp; Pattern Matching - Part 1</title><link>https://oribenshir.github.io/afternoon_rusting/blog/enum-and-pattern-matching-part-1</link><description><![CDATA[We continue our series “Rust for OOP” with Enums & Pattern Matching, one of my preferred features of Rust. I didn’t hear about it before getting into the language, yet immediately fell in love with it. Enums are simple, expressive, reducing code bloat, enable encapsulation, easy to understand, and reason with. It also enables many useful design pattern. ]]></description><guid isPermaLink="false">e7bf2504-b854-4a1d-b946-38075e83e97a</guid><pubDate>Mon, 17 Jun 2019 00:00:00 +0000</pubDate><dc:creator>Ori Ben-Shir</dc:creator></item><item><title>Makepad, a live Rust authoring tool for 2D vector design, shaders and animation</title><link>https://github.com/makepad/makepad</link><description><![CDATA[The vision is to build a livecoding / design hybrid program, where procedural design and code are fused in one environment. If you have missed 'learnable programming' please check this out: http://worrydream.com/LearnableProgramming/ Makepad aims to fulfill (some) of these ideas using a completely from-scratch renderstack built on the GPU and Rust. It will be like an IDE meets a vector designtool, and had offspring. Direct manipulation of the vectors modifies the code, the code modifies the vectors.

However before we can make this awesome application, we need to build a UI stack. The aim of this toolkit is to be our stepping stone into building a livecoding IDE and designtools that don't suck or fall to pieces along the way.]]></description><guid isPermaLink="false">87146592-5c10-431e-8655-5272eec53ed9</guid><pubDate>Mon, 17 Jun 2019 00:00:00 +0000</pubDate><dc:creator>makepad</dc:creator></item><item><title>Rust on the ESP and how to get started</title><link>https://dentrassi.de/2019/06/16/rust-on-the-esp-and-how-to-get-started/?pk_campaign=twitter</link><description><![CDATA[Read about a simple quickstart with Rust on the ESP, using a ready-to-run container setup that should make this as easy as possible.]]></description><guid isPermaLink="false">38752604-badd-4d11-a3e3-92b6091d2153</guid><pubDate>Sun, 16 Jun 2019 14:18:55 +0000</pubDate><dc:creator>Jens Reimann</dc:creator></item><item><title>A simple plugin interface for the Rust FFI</title><link>http://kmdouglass.github.io/posts/a-simple-plugin-interface-for-the-rust-ffi/</link><description><![CDATA[I present a straight-forward design of a plugin interface using the Rust FFI.]]></description><guid isPermaLink="false">d0496592-58c8-4e56-8cfb-890df49f7b6c</guid><pubDate>Sun, 16 Jun 2019 07:33:33 +0000</pubDate><dc:creator>Kyle M. Douglass</dc:creator></item></channel></rss>