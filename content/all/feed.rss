<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/"><channel><title>Read Rust - All Posts</title><link>https://readrust.net/</link><description>All Posts posts on Read Rust</description><item><title>PrettySize for rust</title><link>https://neosmart.net/blog/2018/prettysize-for-rust/</link><description><![CDATA[We’ve just published a rust port of our PrettySize.NET library, now available via cargo and github. Like its .NET predecessor, PrettySize-rs aims to provide a comprehensive API for dealing with file sizes, covering both manipulation and human-readable formatting.]]></description><guid isPermaLink="false">02a5f7b7-0114-440d-9be0-d5aaf77bfa65</guid><pubDate>Sat, 11 Aug 2018 20:56:39 +0000</pubDate><dc:creator>Mahmoud Al-Qudsi</dc:creator></item><item><title>Portability benchmark of Dota2 on MacOS</title><link>https://gfx-rs.github.io/2018/08/10/dota2-macos-performance.html</link><description><![CDATA[gfx-rs is a Rust project aiming to make graphics programming more accessible and portable, focusing on exposing a universal Vulkan-like API. It’s a single Rust API with multiple backends that implement it: Direct3D 12/11, Metal, Vulkan, and even OpenGL. We are also building a Vulkan Portability implementation based on it, which allows non-Rust applications using Vulkan to run everywhere. This post is focused on the Metal backend only.]]></description><guid isPermaLink="false">526c879c-7409-4234-a92c-e04b21f37d0d</guid><pubDate>Fri, 10 Aug 2018 00:00:00 +0000</pubDate><dc:creator>gfx-rs</dc:creator></item><item><title>Tower Web — A new web framework for Rust</title><link>https://medium.com/@carllerche/tower-web-a-new-web-framework-for-rust-e2912856851b</link><description><![CDATA[I previously announced Tower and mentioned that a web framework was in the works. It took longer than I had hoped (as it sometimes does with software), but today, I am opening up Tower Web.

Tower Web is an asynchronous HTTP web framework that focuses on removing boilerplate. It is built on top of Tokio, Hyper, and of course Tower. It works today on stable Rust.]]></description><guid isPermaLink="false">ea6c2f82-fb04-49be-be31-307284eedba4</guid><pubDate>Thu,  9 Aug 2018 17:46:17 +0000</pubDate><dc:creator>Carl Lerche</dc:creator></item><item><title>Xori - Custom disassembly framework</title><link>https://sites.google.com/secured.org/malwareunicorn/xori</link><description><![CDATA[Xori is an automation-ready disassembly and static analysis library that consumes shellcode or PE binaries and provides triage analysis data.]]></description><guid isPermaLink="false">31c9d3c0-192b-45f2-922e-5b8d188683bc</guid><pubDate>Thu,  9 Aug 2018 08:23:00 +0000</pubDate><dc:creator>Amanda Rousseau and Rich Seymour</dc:creator></item><item><title>The State of GPGPU in Rust</title><link>https://bheisler.github.io/post/state-of-gpgpu-in-rust/</link><description><![CDATA[At work a few months ago, we started experimenting with GPU-acceleration. My boss asked if I was interested. I didn’t know anything about programming GPUs, so of course I said “Heck yes, I’m interested!“. I needed to learn about GPUs in a hurry, and that led to my GPU Path Tracer series. That was a lot of fun, but it showed me that CUDA support in Rust is pretty poor.]]></description><guid isPermaLink="false">704eb876-5cac-4636-8817-4946659876e1</guid><pubDate>Wed,  8 Aug 2018 20:00:00 -0600</pubDate><dc:creator>Brook Heisler</dc:creator></item><item><title>GSoC wrap-up - Splitting Servo&apos;s script crate</title><link>https://blog.servo.org/2018/08/09/gsoc-generic-servo/</link><description><![CDATA[I am Peter Hrvola (retep007) Twitter Github. During my Google Summer of Code (GSoC) project, I have been working on investigating the monolithic nature of Servo’s script crate and prototyping separation to smaller crates. My goal was to improve the use of resources during compilation. Current debug build consumes over 5GB of memory and takes 347s.]]></description><guid isPermaLink="false">e141f480-7f0d-4b15-82b6-44d0f807f09c</guid><pubDate>Thu,  9 Aug 2018 00:00:00 +0000</pubDate><dc:creator>Peter Hrvola</dc:creator></item><item><title>Literate Programming in Rust</title><link>https://damien.codes/posts/literate-rust/</link><description><![CDATA[In which we explore how cargo and rustdoc make it possible to write documentation and unit tests at once, resulting in code that is explained and tested from the POV of a public API.]]></description><guid isPermaLink="false">9a82c540-b8ab-4635-a68b-82754b5fe8a1</guid><pubDate>Thu,  9 Aug 2018 00:00:00 +0000</pubDate><dc:creator>Damien</dc:creator></item><item><title>RSoC: FAT32 Filesystem in Redox - 3</title><link>https://www.redox-os.org/news/rsoc-fat32-3/</link><description><![CDATA[The previous blog post discusses how raw disk reads were implemented in the loader stub. The next step was to implement a clean read API which can be used by different filesystem libraries in order to read their respective filesystems. Since the raw reads from the BIOS interrupt had a granularity in terms of sectors(each sector being 512 bytes), the reads had to be translated in order to provide byte level granularity. The clone_from_slice function ensures that a direct call to memcopy is not required. The refined read function is here.]]></description><guid isPermaLink="false">6f2abec2-1096-4a82-90db-b1962a2876f7</guid><pubDate>Thu,  9 Aug 2018 00:00:00 +0000</pubDate><dc:creator>Deepak Sirone</dc:creator></item><item><title>Kickstart - a fast and simple project template bootstrapper</title><link>https://blog.artemix.org/article/show/kickstart</link><description><![CDATA[Ever had some code base that you regularly use to start a new project? Until now, you've probably lost some time refactoring everything to fill out the right project name, title etc. A few tools already exist but either you're lost in feature bloating hell or you're fighting to configure everything in most cases. The following tool is an early-developement, rust-based, template tool made to be more versatile that its closest python counter-part, cookiecutter.]]></description><guid isPermaLink="false">1d84906a-4085-4d87-8f43-786f1d531f44</guid><pubDate>Wed,  8 Aug 2018 23:02:19 +0000</pubDate><dc:creator>Artemis</dc:creator></item><item><title>Proposal: Rust Custom Test Frameworks</title><link>https://blog.jrenner.net/rust/testing/2018/08/06/custom-test-framework-prop.html</link><description><![CDATA[The Rust community recently approved a Custom Test Frameworks eRFC which lays out a series of goals and possible directions of exploration for implementing custom test frameworks. In this post, I present my own proposed fulfillment of the RFC with rationale.]]></description><guid isPermaLink="false">8c27c640-fb7d-42f9-a31f-09e9f5b35c2d</guid><pubDate>Wed,  8 Aug 2018 08:12:00 +0000</pubDate><dc:creator>John Renner</dc:creator></item><item><title>Launching the 2018 State of Rust Survey</title><link>https://blog.rust-lang.org/2018/08/08/survey.html</link><description><![CDATA[It’s that time again! Time for us to take a look at how the Rust project is doing, and what we should plan for the future. The Rust Community Team is pleased to announce our 2018 State of Rust Survey! Whether or not you use Rust today, we want to know your opinions. Your responses will help the project understand its strengths and weaknesses and establish development priorities for the future.

This year, volunteers have also translated the survey into 14 languages!]]></description><guid isPermaLink="false">f0133b81-60d3-416a-b58a-6d6c9c7afe6a</guid><pubDate>Wed,  8 Aug 2018 00:00:00 +0000</pubDate><dc:creator>The Rust Community Team</dc:creator></item><item><title>Ideas for Rust Meetups</title><link>https://llogiq.github.io/2018/08/08/meetup-ideas.html</link><description><![CDATA[Since I’m co-organizing the Rhein-Main Rust meetup (and am probably the main driving force behind it), I tought, it might be useful to share a few ideas we have that we have either already done, or plan doing – perhaps other meetup organizers can benefit from this. Note that our meetups usually run 2-4 hours, but some attendees may have to join late or leave early so the format has to take this into account.]]></description><guid isPermaLink="false">8cf7d62c-c8d9-4116-ae4c-7ac155d015cb</guid><pubDate>Wed,  8 Aug 2018 00:00:00 +0000</pubDate><dc:creator>Llogiq</dc:creator></item><item><title>Journey into rust #1: Conway’s Game</title><link>https://jonathansteyfkens.com/rust/opengl/graphics/2018/08/07/rust-conway-game-of-life.html</link><description><![CDATA[The language rust has been popping up on my twitter feed and my personal life more and more. It’s been promoted and presented as the ultra safe language, so naturally I decided to check it out. The upcoming series of posts “Journey into rust” will describe and document my experiences using rust, hopefully explaining certain concepts that rust does differently. This will all be written from a C++ programmers standpoint that was thought writing Object Oriented code. I encourage you the reader to think critically and correct where necessary.

On to the actual first post! After reading “the Rust Programming Language” I wanted to get my hands dirty and actually write some code. I like graphical applications and using low level graphics API’s so I decided to implement a cellular automation in rust. But just implementing cellular automation isn’t very exciting, is it? What if we could do this on the GPU…And off I went on my journey to create Conway’s game of life in rust.]]></description><guid isPermaLink="false">b7c9c3df-7ecd-41f3-8c89-5c1d35298b7b</guid><pubDate>Tue,  7 Aug 2018 22:30:01 +0000</pubDate><dc:creator>Jonathan Steyfkens</dc:creator></item><item><title>Stacked Borrows: An Aliasing Model For Rust</title><link>https://www.ralfj.de/blog/2018/08/07/stacked-borrows.html</link><description><![CDATA[In this post, I am proposing “Stacked Borrows”: A set of rules defining which kinds of aliasing are allowed in Rust. This is intended to answer the question which pointer may be used when to perform which kinds of memory accesses.]]></description><guid isPermaLink="false">b5f6a958-c0bd-4ea9-a1ae-d8e4f5549719</guid><pubDate>Tue,  7 Aug 2018 00:00:00 +0000</pubDate><dc:creator>Ralf Jung</dc:creator></item><item><title>Clippy&apos;s &quot;cast_lossless&quot; Lint Warning</title><link>https://benjamincongdon.me/blog/2018/08/06/Clippys-cast_lossless-Lint-Warning/</link><description><![CDATA[Recently, I was trying out clippy  — a linting and static analysis tool for Rust, when I ran into a lint warning that wasn’t immediately clear to me: warning: casting u8 to u16 may become silently lossy if types change.]]></description><guid isPermaLink="false">64be78c2-0f4e-413f-ac54-1e6b21215413</guid><pubDate>Mon,  6 Aug 2018 20:28:01 +0000</pubDate><dc:creator>Benjamin Congdon</dc:creator></item><item><title>Rust Modules In Less Than 5 Minutes</title><link>https://medium.com/@erik.tate/rust-modules-in-less-than-5-minutes-9bff7f617798</link><description><![CDATA[When I started learning Rust, the module system did not at first seem to be a shining beacon of intuitive design. The Rust documentation is phenomenal, but there are definitely some areas that I found difficult to follow; this being one such topic. So I thought I might take a stab at writing up a guide that I think would have helped me through the awkward growing pains a bit quicker.]]></description><guid isPermaLink="false">7d6c2d9c-16c8-42be-93d5-d61cc9dac117</guid><pubDate>Sun,  5 Aug 2018 23:49:43 +0000</pubDate><dc:creator>Erik Tate</dc:creator></item><item><title>RSoC: Porting Redox to ARM (AArch64) — 0x02</title><link>https://medium.com/@wizofe/rsoc-porting-redox-to-arm-aarch64-0x02-c566ee22f377</link><description><![CDATA[At the time of writing the previous blog the plan was to target the Raspberry Pi 3 (Cortex A53) as a development platform because of its availability, popularity and community. Sadly, it seems that Broadcom went through a lot of shortcuts while implementing this specific design, which means features like GIC are half-there or completely missing, like in this case.

After a discussion with @microcolonel, he proposed and kindly sent me a HiKey960 reference SoC from the awesome Linaro 96Boards initiative. The quality of this board is definitely a lot better than the Raspberry Pi and the documentation is detailed and open. Great stuff.]]></description><guid isPermaLink="false">382f988d-9fe3-4525-9b21-0c6cb4373303</guid><pubDate>Sun,  5 Aug 2018 22:39:42 +0000</pubDate><dc:creator>ioannis valasakis</dc:creator></item><item><title>A small custom Bool Type in Diesel</title><link>https://noyez.gitlab.io/post/2018-08-05-a-small-custom-bool-type-in-diesel/</link><description><![CDATA[I’ve been working with diesel and serde. I use diesel for my postgres datastore, and serde for serializing/deserializing data to the web. Recently I came across a situation where I needed to define my type in diesel as well as implement deserialize in serde. The example below is a fairly simple so it makes for a good example to share so others can learn (and so I can remember how all this works next time I need it).]]></description><guid isPermaLink="false">2182c554-41eb-4ee7-a1de-11eb90a8223d</guid><pubDate>Sun,  5 Aug 2018 00:00:00 +0000</pubDate><dc:creator>Noyez</dc:creator></item><item><title>Amethyst 0.8 has been released!</title><link>https://www.amethyst.rs/blog/release-0-8/</link><description><![CDATA[With a brand new tutorial and a ton of new features, including prefabs, controller support, MP3 audio, localisation and an even better ergonomics!]]></description><guid isPermaLink="false">b5717efe-ad7b-4b02-8554-aba801aff909</guid><pubDate>Sun,  5 Aug 2018 00:00:00 +0000</pubDate><dc:creator>Moxinilian (Théo Degioanni)</dc:creator></item><item><title>Easily Analyzing Your S3 Buckets</title><link>http://whitfin.io/analyzing-your-buckets-with-s3-meta/</link><description><![CDATA[mazon S3 is a storage solution used by pretty much everyone these days. Due to this there are naturally a bunch of tools for doing almost everything you can think of with S3. This post is about a tool I wrote to retrieve metadata about S3 buckets. If you don't care for the post, feel free to skip straight to the repo.]]></description><guid isPermaLink="false">1bc929f4-2800-466c-bd70-fb73f7b70ef8</guid><pubDate>Sat,  4 Aug 2018 17:44:06 +0000</pubDate><dc:creator>Isaac Whitfield</dc:creator></item><item><title>Working on the Embedded Rust Book</title><link>https://jamesmunns.com/blog/working-on-the-book/</link><description><![CDATA[TL;DR: Up to now, I haven't had as much time or motivation as I would have like to contribute to the Embedded Rust Book. However, I am excited to see the initial version of the book launch with the 2018 edition of Rust (which will ship with stable support for embedded)!, so I will be committing to write one chapter per two weeks, until the end of the year.

Read below for my plan, and how you can help!]]></description><guid isPermaLink="false">e20d8f7a-53c3-45c8-b16e-ac25a20ff548</guid><pubDate>Sat,  4 Aug 2018 00:00:00 +0000</pubDate><dc:creator>James Munns</dc:creator></item><item><title>Rust and the Case of the Redundant Comparison</title><link>https://blog.dend.ro/rust-and-the-case-of-the-redundant-comparison/</link><description><![CDATA[A couple of days ago I landed my second pull request in the Rust Programming Language repository. This is the story of how that went. This post is inspired by other posts about improving the Rust compiler.]]></description><guid isPermaLink="false">58e93b1c-f7b4-440f-88fb-fa5ab900f1c6</guid><pubDate>Sat,  4 Aug 2018 00:00:00 +0000</pubDate><dc:creator>dend</dc:creator></item><item><title>Some Slight Improvements</title><link>https://llogiq.github.io/2018/08/04/improve.html</link><description><![CDATA[Today I want to talk about two Rust PRs I recently wrote. The PRs in question are #52942 and #52997. Both are relatively small changes to Rust’s internally used data structures that improve performance and readability. Both have some basic benchmarks (the first one already had them and I wrote them for the second one), although it’s rather hard to gauge whether they really impacted compile times (as perf.rust-lang.org puts all changes of the specific day together). But that’s not the point I want to make right now.]]></description><guid isPermaLink="false">02647906-fc14-42ea-87ec-19fc717cb3d7</guid><pubDate>Sat,  4 Aug 2018 00:00:00 +0000</pubDate><dc:creator>Llogiq</dc:creator></item><item><title>Gutenberg 0.4.0: custom taxonomies, image processing and more</title><link>https://www.vincentprouillet.com/blog/releasing-gutenberg-0-4-0/</link><description><![CDATA[Gutenberg 0.4.0 is out with custom taxonomies, image processing, improved shortcodes and more.]]></description><guid isPermaLink="false">c1718910-2677-4da4-a45f-a8bd055fe075</guid><pubDate>Sat,  4 Aug 2018 00:00:00 +0000</pubDate><dc:creator>Vincent Prouillet</dc:creator></item><item><title>How to run Rust in OpenFaaS</title><link>https://booyaa.wtf/2018/run-rust-in-openfaas/</link><description><![CDATA[OpenFaaS is an open source implementation of Function as a Service (Serverless Functions, microservices) that you can self host. Rather than list all the various offerings in this space, I'll refer you to the Cloud Native Computing Foundation, in particular the interactive Landscape.

You can either deploy existing functions or create new ones. If you create new ones, there's a big list of officially supported languages. Alternative you could turn a CLI into function.

Once I'd given Python and Ruby a go as an introduction, I wanted to see how easy it would be to create a Rust template.]]></description><guid isPermaLink="false">924567bd-54c7-429d-84a6-db7b8b9221f1</guid><pubDate>Sat,  4 Aug 2018 00:00:00 +0000</pubDate><dc:creator>Mark Sta Ana</dc:creator></item><item><title>intl_pluralrules: A Rust Crate for Handling Plural Forms with CLDR Plural Rules</title><link>https://blog.mozilla.org/l10n/2018/08/03/intl_pluralrules-a-rust-crate-for-handling-plural-forms-with-cldr-plural-rules/</link><description><![CDATA[intl_pluralrules is a Rust crate, built to handle pluralization. Pluralization is the foundation for all localization and many internationalization APIs. With the addition of intl_pluralrules, any locale-aware date-, time- or unit-formatting (“1 second” vs “2 seconds”) and many other pluralization-dependent APIs can be added to Rust.]]></description><guid isPermaLink="false">577e9c57-0455-41c6-9711-be71bf55e550</guid><pubDate>Fri,  3 Aug 2018 23:30:19 +0000</pubDate><dc:creator>Kekoa Riggin</dc:creator></item><item><title>Solving the Generalized Streaming Iterator Problem without GATs</title><link>http://lukaskalbertodt.github.io/2018/08/03/solving-the-generalized-streaming-iterator-problem-without-gats.html</link><description><![CDATA[Generic Associated Types (GATs for short) are a long awaited extension to Rust’s type system. They offer a way to work with higher kinded types – a necessity in a couple of situations. A common example is the streaming iterator: an iterator able to return items borrowing from self (the iterator itself). Unfortunately, GATs haven’t even landed in nightly yet. So while are waiting, we can try tackling the streaming iterator problem without GATs. In this post we explore three possible workarounds for situations where an associated type depends on the lifetime of a &self receiver.]]></description><guid isPermaLink="false">2cc12b2e-22fb-461a-be01-ffeab54caa9f</guid><pubDate>Fri,  3 Aug 2018 00:00:00 +0000</pubDate><dc:creator>Lukas Kalbertodt</dc:creator></item><item><title>CLion IDE Rust plugin update: language support improvements, new quick-fixes, improved debugger and more</title><link>https://blog.jetbrains.com/clion/2018/08/intellij-rust-update-2018_2/</link><description><![CDATA[CLion 2018.2 was released just recently. Along with the release, the Rust plugin has had an update! In this blog post, we’d like to highlight some of the main improvements in the plugin.]]></description><guid isPermaLink="false">18d063ca-b781-400f-9e5f-1534b5b90630</guid><pubDate>Thu,  2 Aug 2018 11:01:28 +0000</pubDate><dc:creator>Anastasia Kazakova</dc:creator></item><item><title>Announcing Rust 1.28</title><link>https://blog.rust-lang.org/2018/08/02/Rust-1.28.html</link><description><![CDATA[The Rust team is happy to announce a new version of Rust. This release includes the global_allocator attribute to customise the allocator, improved error messages for format strings, and a number of number related stabilisations.]]></description><guid isPermaLink="false">44372b96-a1e4-44ee-af79-4496c4f629e6</guid><pubDate>Thu,  2 Aug 2018 00:00:00 +0000</pubDate><dc:creator>The Rust Core Team</dc:creator></item><item><title>Why I Ripped The Same CD 300 Times</title><link>https://john-millikin.com/%F0%9F%A4%94/why-i-ripped-the-same-cd-300-times</link><description><![CDATA[The piano arrangement album 帰るべき城 by Altneuland was published in 2005. I discovered it in 2008 (probably on YouTube), downloaded the best copy I could find, and filed it away in the TODO list. Recent advances in international parcel forwarding technology let me buy a used copy last year, but when it arrived none of my CD drives could read track #3. This sort of thing is common when buying used CDs, especially if they need to transit a USPS international shipping center. I shelved it and kept on the lookout for another copy, which I located last month. It arrived on Friday, I immediately tried to rip it, and hit the exact same error. This didn’t seem to be an issue of wear or damage…]]></description><guid isPermaLink="false">bf6d4501-afb3-40dc-aa8a-bef247e2e77b</guid><pubDate>Thu,  2 Aug 2018 00:00:00 +0000</pubDate><dc:creator>John Millikin</dc:creator></item><item><title>Accelerating Edwards Curve Arithmetic with Parallel Formulas</title><link>https://medium.com/@hdevalence/accelerating-edwards-curve-arithmetic-with-parallel-formulas-ac12cf5015be</link><description><![CDATA[The fastest formulas for elliptic curve operations were published by Hisil, Wong, Carter, and Dawson in their 2008 paper Twisted Edwards Curves Revisited. Their paper also describes a parallel version of their formulas, designed to execute four streams of instructions on four independent processors. Until now, these parallel formulas don’t seem to have been implemented in software. But a closer look reveals that slightly modifying the formulas allows the expensive instructions to be executed in uniform, making a vectorized SIMD implementation possible.

I implemented this strategy in Rust, targeting 256-bit wide AVX2 operations. The resulting implementation performs double-base scalar multiplication faster than other Ed25519 implementations I tested, and is even faster than FourQ without endomorphisms]]></description><guid isPermaLink="false">8a924e9f-d803-4e85-b2e8-92b5909c7695</guid><pubDate>Wed,  1 Aug 2018 17:41:42 +0000</pubDate><dc:creator>Henry de Valence</dc:creator></item><item><title>Sequoia, a new OpenPGP implementation</title><link>https://www.reddit.com/r/rust/comments/93mng5/ann_sequoia_a_new_openpgp_implementation/</link><description><![CDATA[This past fall, three former GnuPG developers began working on a new OpenPGP implementation in Rust called Sequoia. As it’s starting to shape up and become useful, I feel now is a good time to announce the project to the larger Rust community, and hopefully get some feedback before our first release.]]></description><guid isPermaLink="false">81096070-a563-47a0-8f09-2e5fb3c1b984</guid><pubDate>Wed,  1 Aug 2018 16:50:12 +1000</pubDate><dc:creator>/u/nwalfield</dc:creator></item><item><title>warp</title><link>http://seanmonstar.com/post/176530511587/warp</link><description><![CDATA[Over the past several months, I’ve been working a web framework in Rust. I wanted to make use of the new hyper 0.12 changes, so the framework is just as fast, is asynchronous, and benefits from all the improvements found powering Linkerd. More importantly, I wanted there to be a reason for making a new framework; it couldn’t just be yet another framework with the only difference being I’ve written it. Instead, the way this framework is used is quite different than many that exist. In doing so, it expresses a strong opinion, which might not match your previous experiences, but I believe it manages to do something really special.

I’m super excited to reveal warp, a joint project with @carllerche.]]></description><guid isPermaLink="false">55adde79-edfa-433f-8c4f-40f2baee7cd9</guid><pubDate>Wed,  1 Aug 2018 00:00:00 +0000</pubDate><dc:creator>Sean McArthur</dc:creator></item><item><title>Announcing Vagga 0.8.1 – PaulColomiets</title><link>https://medium.com/@paulcolomiets/announcing-vagga-0-8-1-5e1fd44ee6fa</link><description><![CDATA[We are excited to announce the next version of vagga, the containerization tool that makes setting up development environments easy and fun. This release brings local overrides for vagga commands, support of ubuntu bionic, better CI support, space reuse between multiple projects, and more.]]></description><guid isPermaLink="false">14507477-073a-4055-a2de-b0e4c4fd2ad5</guid><pubDate>Tue, 31 Jul 2018 19:39:25 +0000</pubDate><dc:creator>PaulColomiets</dc:creator></item><item><title>#[derive(Debug)] on serde steroids</title><link>https://rreverser.com/derive-serdebug/</link><description><![CDATA[In this post I'd like to introduce a serdebug helper which is a drop-in replacement for #[derive(Debug)] with some of the advanced features that serde can provide.]]></description><guid isPermaLink="false">0a171d26-74e1-491c-befd-e02ac528c1ff</guid><pubDate>Tue, 31 Jul 2018 16:00:45 +0000</pubDate><dc:creator>Ingvar Stepanyan</dc:creator></item><item><title>BetaFPV F3 Drone Flight Controller - Board Support Crate</title><link>https://www.joshmcguigan.com/blog/betafpv-drone-flight-controller-board-support-crate/</link><description><![CDATA[In a previous blog post I described how to get a very simple Rust program compiling for and running on the BetaFPV F3 drone flight controller. Since that time I’ve been working to create a board support crate to provide a high level API for the board.]]></description><guid isPermaLink="false">5473f9e8-40a8-43fe-956e-e84678267c90</guid><pubDate>Tue, 31 Jul 2018 00:00:00 +0000</pubDate><dc:creator>Josh Mcguigan</dc:creator></item><item><title>Writing a front-end WebAssembly framework in Rust: lessons learned</title><link>https://medium.com/@robert.balicki_2494/writing-a-front-end-webassembly-framework-in-rust-lessons-learned-7cc48ed27d96</link><description><![CDATA[Over the past few months, I’ve been writing Smithy, a very work-in-progress front-end WebAssembly framework written in Rust.

My goal for Smithy is to enable you to use idiomatic Rust to write front-end code. This has costs: for example worrying about lifetimes and using Rc<RefCell<State>> to share state. But this also has the potential to give you the safety guarantees that the Rust compiler provides when writing browser code!]]></description><guid isPermaLink="false">7f8cf89b-0cca-43c6-a660-3780bd2cdf72</guid><pubDate>Mon, 30 Jul 2018 12:46:05 +0000</pubDate><dc:creator>Robert Balicki</dc:creator></item><item><title>Streaming UTF-8 in Haskell and Rust</title><link>https://www.fpcomplete.com/blog/2018/07/streaming-utf8-haskell-rust</link><description><![CDATA[An investigation into getting Haskell-like error handling ergonomics into a Rust application dealing with streaming UTF-8 encoding and decoding.]]></description><guid isPermaLink="false">8f26eb1d-8d0c-4785-a7fb-85c8cf5c6f27</guid><pubDate>Mon, 30 Jul 2018 09:00:00 +0000</pubDate><dc:creator>Michael Snoyman</dc:creator></item><item><title>That weekend I wasted on newtyped indices</title><link>https://exphp.github.io/2018/07/30/that-weekend-i-wasted-on-newtyped-indices.html</link><description><![CDATA[Today, ajyne posted a thread on users.rust-lang.org asking: What have been the drawbacks of static typing for you? Kornel was quick to reply with a variety of points, but this one in particular stands out to me, "With powerful type systems there’s no end to how far you can go to guarantee things about your program, but you might create a complex monster". As I see it, there is no truer answer. The type system can be a seductive beast, often promising correctness and performance at the low-low, one-time cost of your soul. I personally can name a number of examples from my own code base where I tried to abstract over something too big and failed. I call these my wasted weekends.]]></description><guid isPermaLink="false">4f9e9645-78dc-4c18-a504-653e96a0c960</guid><pubDate>Mon, 30 Jul 2018 00:00:00 +0000</pubDate><dc:creator>Michael Lamparski</dc:creator></item><item><title>Rust: controlling side effects from the test</title><link>https://blog.cyplo.net/posts/2018/07/rust-injection.html</link><description><![CDATA[Imagine you want to write a timestamping repository of some sorts, that will associate the timestamp of when the storage operation was invoked with the stored value. How to write it in Rust ? And more importantly - how to test it ? I would like to share a solution I found and talk a bit about how it works.]]></description><guid isPermaLink="false">3b874195-0df6-40ca-8667-067d3440061b</guid><pubDate>Mon, 30 Jul 2018 00:00:00 +0000</pubDate><dc:creator>Cyryl Płotnicki</dc:creator></item><item><title>Futures 0.3.0-alpha.2</title><link>https://rust-lang-nursery.github.io/futures-rs/blog/2018/07/30/futures-0.3.0-alpha.2.html</link><description><![CDATA[Several new changes while working towards 0.3.]]></description><guid isPermaLink="false">e29e550b-7c05-4625-9a81-513b316b5675</guid><pubDate>Mon, 30 Jul 2018 00:00:00 +0000</pubDate><dc:creator>Josef Brandl</dc:creator></item><item><title>Using C libraries in Rust: make a sys crate</title><link>https://kornel.ski/rust-sys-crate</link><description><![CDATA[Using C libraries in a portable way involves a bit of work: finding the library on the system or building it if it's not available, checking if it is compatible, finding C headers and converting them to Rust modules, and giving Cargo correct linking instructions. Often every step of this is tricky, because operating systems, package managers and libraries have their unique quirks that need special handling.

Fortunately, all this work can be done once in a build script, and published as a <insert library name>-sys Rust crate. This way other Rust programmers will be able to use the C library without having to re-invent the build script themselves.]]></description><guid isPermaLink="false">e0622344-66a9-4b93-a59f-1b5250ba8c98</guid><pubDate>Mon, 30 Jul 2018 00:00:00 +0000</pubDate><dc:creator>Kornel</dc:creator></item><item><title>nphysics: 2D and 3D real-time physics engine</title><link>http://nphysics.org/</link><description><![CDATA[I’m excited to announce the brand new website/user-guide for the nphysics2d and nphysics3d crates: pure-rust 2D and 3D real-time physics engines with rigid bodies and joints! Online wasm-based demos are also provided (see for example the Multibody joints 34 demo).]]></description><guid isPermaLink="false">a3f0bd42-0a42-4156-9fd6-74aebe5f0465</guid><pubDate>Sun, 29 Jul 2018 03:46:07 +1000</pubDate><dc:creator>Sébastien Crozet</dc:creator></item><item><title>Rust concurrency patterns: Natural Born Pipelines</title><link>https://medium.com/@polyglot_factotum/rust-concurrency-patterns-natural-born-pipelines-4d599e7612fc</link><description><![CDATA[There seems to be demand for a “Rust concurrent pipeline” guide à la https://blog.golang.org/pipelines, so let’s give it a try.]]></description><guid isPermaLink="false">f7eba5d3-ef85-47cb-88ec-345cf3c46ade</guid><pubDate>Sat, 28 Jul 2018 09:12:33 +0000</pubDate><dc:creator>Gregory Terzian</dc:creator></item><item><title>A Snapshot of Rust&apos;s Popularity in July 2018</title><link>http://www.jonathanturner.org/2018/07/snapshot-of-rust-popularity.html</link><description><![CDATA[Talking about a language’s popularity is traditionally a tricky topic. How do you measure popularity? How do you compare one language to another when they’re focused on different styles and different audiences? So, rather than having one or two charts, I’m going to look at a number of “slices” into Rust’s growth to see it front different angles.]]></description><guid isPermaLink="false">2dba28aa-a443-4887-9806-aba84cf787ef</guid><pubDate>Sat, 28 Jul 2018 00:00:00 +0000</pubDate><dc:creator>Jonathan Turner</dc:creator></item><item><title>Recommending books (with Rust)</title><link>https://maciejkula.github.io/2018/07/27/recommending-books-with-rust/</link><description><![CDATA[In this post, we’re going to build a sequence-based recommender system in Rust: a system that accepts a person’s reading history as input, and outputs recommendations on what to read next.]]></description><guid isPermaLink="false">31fd7758-63f6-4e38-8331-bd27fd6324ba</guid><pubDate>Fri, 27 Jul 2018 09:17:00 -0700</pubDate><dc:creator>Maciej Kula</dc:creator></item><item><title>Using a Mac to cross-compile Linux binaries</title><link>http://timryan.org/2018/07/27/cross-compiling-linux-binaries-from-macos.html</link><description><![CDATA[The cycle of development we’re most familiar with is: write code, compile your code, then run this code on the same machine you were writing it on. On most desktop OSes, you pick up a compiler by downloading one from your package manager. Xcode and Visual Studio are toolchains (actually IDEs) that leverage being platform-specific, each including tools tailored around the platform your code will run on and heavily showcasing the parent OS’s design language.]]></description><guid isPermaLink="false">86add592-8587-406b-8233-a06e675452f0</guid><pubDate>Fri, 27 Jul 2018 13:22:00 +0000</pubDate><dc:creator>Tim Ryan</dc:creator></item><item><title>Rust and OpenGL from scratch, a blog post series about building an OpenGL renderer with Rust</title><link>https://www.reddit.com/r/rust/comments/92abkg/rust_and_opengl_from_scratch_a_blog_post_series/</link><description><![CDATA[I titled this post “from scratch”, because I am going to assume little knowledge of Rust and basic knowledge of 3D graphics and OpenGL.

Therefore, this tutorial may teach you basic Rust and how to get Rust working with OpenGL, however for in-depth OpenGL learning you will need another tutorial or book.

“From Scratch” also means that we will try to build abstractions ourselves, so that we get better knowledge of Rust. In addition to that, we will able to follow existing OpenGL tutorials, because we will know exactly what OpenGL functions we are calling.]]></description><guid isPermaLink="false">1220a3b8-605c-4d1d-8c38-163bd5a8f02e</guid><pubDate>Fri, 27 Jul 2018 17:01:38 +1000</pubDate><dc:creator>Nerijus Arlauskas</dc:creator></item><item><title>Programming Servo: How to match</title><link>https://medium.com/programming-servo/programming-servo-how-to-match-b76c43f76fe6</link><description><![CDATA[Today, let’s share some lessons learned from contributing to Servo, which is a great way to learn Rust.]]></description><guid isPermaLink="false">f0e4ab48-bf11-47bf-9267-4da78f78bdcc</guid><pubDate>Fri, 27 Jul 2018 04:37:21 +0000</pubDate><dc:creator>Gregory Terzian</dc:creator></item><item><title>What is Rust 2018?</title><link>https://blog.rust-lang.org/2018/07/27/what-is-rust-2018.html</link><description><![CDATA[The release of Rust 1.31.0 on December 6th will be the first release of “Rust 2018.” This marks a culmination of the last three years of Rust’s development, and brings it together in one neat package. For example, there will be a 2018 edition of the book that incorporates features stabilized since the print edition was considered finalized.]]></description><guid isPermaLink="false">2c62015d-b849-4ab6-bbc9-e62255ca3473</guid><pubDate>Fri, 27 Jul 2018 00:00:00 +0000</pubDate><dc:creator>The Rust Core Team</dc:creator></item><item><title>Bringing Rust to Ledger hardware wallets</title><link>https://medium.com/@roosmaa/bringing-rust-to-ledger-hardware-wallet-ccf1356a7de1</link><description><![CDATA[Beginning of this year I wanted to experiment with some embedded development. I ended up looking into Ledger cryptocurrency hardware wallet application development. I wouldn’t actually consider this true embedded development as a lot of the heavy lifting has been done and abstracted away by Ledger, but it’s still writing software for a very constrained environment. Ledger applications only get 4KB of RAM to utilise and most of the embedded development practices still apply (no heap allocations for instance).]]></description><guid isPermaLink="false">41e44eb5-79db-4f16-83c2-a126c4d43286</guid><pubDate>Thu, 26 Jul 2018 12:01:48 +0000</pubDate><dc:creator>Mart Roosmaa</dc:creator></item><item><title>Is WebAssembly the return of Java Applets &amp; Flash?</title><link>https://words.steveklabnik.com/is-webassembly-the-return-of-java-applets-flash</link><description><![CDATA[For this post, I’m going to make three comparisons: to Flash, to Java Applets, and occasionally to PNaCL. Secondly, this post is going to focus on the web use-case for WebAssembly, even though the previous post was about non-web uses. We’ll make that comparison in the next post. Finally, this post is kind of like eating tapas, there’s a bunch of little sections.]]></description><guid isPermaLink="false">6204efce-b9b3-4225-ae6b-5fc74f441d5f</guid><pubDate>Thu, 26 Jul 2018 00:03:00 +0000</pubDate><dc:creator>Steve Klabnik</dc:creator></item><item><title>Announcing the js-sys crate!</title><link>https://rustwasm.github.io/2018/07/26/announcing-the-js-sys-crate.html</link><description><![CDATA[The js-sys crate contains raw #[wasm_bindgen] bindings to all the global APIs guaranteed to exist in every JavaScript environment by the ECMAScript standard. It does not contain bindings to any Web- or Node-specific APIs. With the js-sys crate, we can work with Objects, Arrays, Functions, Maps, Sets, etc… without writing the #[wasm_bindgen] imports by hand.]]></description><guid isPermaLink="false">95c003ee-6a87-45cb-abd3-491bd965d65c</guid><pubDate>Thu, 26 Jul 2018 00:00:00 +0000</pubDate><dc:creator>rustwasm</dc:creator></item><item><title>Pax: A fast dev time JavaScript bundler</title><link>https://pax.js.org/</link><description><![CDATA[Don’t waste time waiting for your bundler to do its thing. Use Pax while you’re developing, and iterate to your heart’s content. Use your super-cool, magical, slow-as-molasses bundler for releases, when you don’t care how long it takes to run.]]></description><guid isPermaLink="false">7161b1be-54de-4776-857e-3ef78df24125</guid><pubDate>Wed, 25 Jul 2018 12:59:16 +0000</pubDate><dc:creator>Nathan</dc:creator></item><item><title>Version selection in Cargo</title><link>http://aturon.github.io/2018/07/25/cargo-version-selection/</link><description><![CDATA[When there are multiple ways to resolve dependencies, Cargo generally chooses the newest possible version. The goal of this post is to explain why Cargo works this way, and how that rationale relates to several recent discussions, including:]]></description><guid isPermaLink="false">d0dc161e-3fcc-4fc7-9032-f9847bf4f3b8</guid><pubDate>Wed, 25 Jul 2018 00:00:00 +0000</pubDate><dc:creator>Aaron Turon</dc:creator></item><item><title>Where next for the Monotron</title><link>http://railwayelectronics.blogspot.com/2018/07/where-next-for-monotron.html?m=1</link><description><![CDATA[It's a couple of months on from my talk at RustFest on Monotron, so I thought it was worth a quick catch up on where we're going next. As a recap, Monotron currently generates an 800 x 600 VGA signal at 60 Hz (with a pixel clock of 40 MHz). It does this using three synchronised SPI peripherals, a timer generating the horizontal-sync pulse and a GPIO pin for the vertical-sync. With the CPU running at a clock speed of 80 MHz, the SPI peripherals are clocked at 20 MHz producing 400 horizontal pixels per line. This is half the nominal 800 pixels, but we needed to sacrifice resolution to double the amount of CPU time we have to 4 clocks per pixel (i.e. 32 clocks per 8-bit character column).]]></description><guid isPermaLink="false">669e3447-5dac-4fe9-a87a-0b315ae3062d</guid><pubDate>Tue, 24 Jul 2018 22:40:00 +0100</pubDate><dc:creator>theJPster</dc:creator></item><item><title>My experience with the Rust 2018 preview</title><link>https://boats.gitlab.io/blog/post/my-experience-with-rust-2018/</link><description><![CDATA[Recently, I wrote a little a side project to sign git commits without gpg. When I did this, I decided to use the Rust 2018 edition. I also transitioned an existing library from Rust 2015 to Rust 2018 to see how that tooling worked. I thought I’d write a blog post about my experience using the Rust 2018 preview and the state of things right now.]]></description><guid isPermaLink="false">a243dc7d-5708-4a3d-bae8-20ccc3de53d0</guid><pubDate>Tue, 24 Jul 2018 00:00:00 +0000</pubDate><dc:creator>boats</dc:creator></item><item><title>Pointers Are Complicated, or: What&apos;s in a Byte?</title><link>https://www.ralfj.de/blog/2018/07/24/pointers-and-bytes.html</link><description><![CDATA[This summer, I am again working on Rust full-time, and again I will work (amongst other things) on a “memory model” for Rust/MIR. However, before I can talk about the ideas I have for this year, I have to finally take the time and dispel the myth that “pointers are simple: they are just integers”. Both parts of this statement are false, at least in languages with unsafe features like Rust or C: Pointers are neither simple nor (just) integers.

I also want to define a piece of the memory model that has to be fixed before we can even talk about some of the more complex parts: Just what is the data that is stored in memory? It is organized in bytes, the minimal addressable unit and the smallest piece that can be accessed (at least on most platforms), but what are the possible values of a byte? Again, it turns out “it’s just an 8-bit integer” does not actually work as the answer.

I hope that by the end of this post, you will agree with me on both of these statements. :)]]></description><guid isPermaLink="false">b4133437-b69d-4491-a40f-a368a8847627</guid><pubDate>Tue, 24 Jul 2018 00:00:00 +0000</pubDate><dc:creator>Ralf Jung</dc:creator></item><item><title>Building Readable Tests with Fluent Testing APIs</title><link>https://leotindall.com/tutorial/building-readable-tests-with-fluent-testing-apis/</link><description><![CDATA[One of the biggest challenges in software testing is defining the input for code under test in a way that is expressive and powerful enough to test complex situations but doesn’t distract from the intent of the test or clutter the test code to a degree that makes it difficult to read.

Many dynamic languages have testing APIs which take advantage of their looser and later type checking to provide easy mocking and stubbing, but strict, statically typed languages can make it difficult to build up suitable instances of the types needed in the test.]]></description><guid isPermaLink="false">96eb15b8-5f51-403c-a699-805553293c16</guid><pubDate>Mon, 23 Jul 2018 09:56:24 -0500</pubDate><dc:creator>Leo Tindall</dc:creator></item><item><title>On impl blocks, injection and surjection in Rust</title><link>https://phaazon.net/blog/on-rust-impl-block</link><description><![CDATA[Rust has this cool feature called impl block. An impl block is just a scope that introduces a way to augment a type with methods – do not confuse impl blocks with trait impls, used to implement a given trait.]]></description><guid isPermaLink="false">4a0e6748-9562-4507-bbfe-3cdf49b6292b</guid><pubDate>Sun, 22 Jul 2018 22:05:00 +0000</pubDate><dc:creator>Dimitri Sabadie</dc:creator></item><item><title>A static web app in Rust</title><link>https://bluejekyll.github.io/blog/rust/2018/07/22/static-web-app-rust.html</link><description><![CDATA[A three day tour of Yew and WASM with Rust]]></description><guid isPermaLink="false">b3d696eb-a5d0-4118-a7b0-328623d35555</guid><pubDate>Sun, 22 Jul 2018 07:00:00 +0000</pubDate><dc:creator>Benjamin Fry</dc:creator></item><item><title>Writing a GPU-Accelerated Path Tracer in Rust - Part 3</title><link>https://bheisler.github.io/post/writing-gpu-accelerated-path-tracer-part-3/</link><description><![CDATA[Hello! Welcome to my third and final post on my GPU-accelerated Path Tracer in Rust. In the last post, we implemented all of the logic necessary to build a true path tracer. Problem is, even on the GPU it’s terrifically slow. This post is (mostly) about fixing that.

But first, we need to fix a bug or two, because I goofed. *sad trombone*

Step -1: Fixing Bugs /u/anderslanglands on Reddit pointed out that, since I’m using Cosine-weighted Importance Sampling, I need to do some extra math to avoid biasing the results.]]></description><guid isPermaLink="false">0b53c7ea-570b-4595-b8eb-2f62d8e9cb96</guid><pubDate>Thu, 19 Jul 2018 18:30:00 -0600</pubDate><dc:creator>Brook Heisler</dc:creator></item><item><title>glitchcat — Creating CLI apps in Rust is super easy</title><link>https://blog.kuviman.com/2018/07/20/glitchcat.html</link><description><![CDATA[glitchcat is a cat-like program with glitch animation.]]></description><guid isPermaLink="false">1e54b1bb-953c-4149-b09c-9d1d3f7046cf</guid><pubDate>Fri, 20 Jul 2018 00:00:00 +0000</pubDate><dc:creator>kuviman</dc:creator></item><item><title>Announcing Rust 1.27.2</title><link>https://blog.rust-lang.org/2018/07/20/Rust-1.27.2.html</link><description><![CDATA[The Rust team is happy to announce a new version of Rust, 1.27.2.]]></description><guid isPermaLink="false">2d302e67-f458-4d07-b1f4-78cb9ed02914</guid><pubDate>Fri, 20 Jul 2018 00:00:00 +0000</pubDate><dc:creator>The Rust Core Team</dc:creator></item><item><title>Futures 0.3.0-alpha.1</title><link>https://rust-lang-nursery.github.io/futures-rs/blog/2018/07/19/futures-0.3.0-alpha.1.html</link><description><![CDATA[Welcome to the inaugural post of the new futures-rs blog!

After several months of work, we’re happy to announce an alpha release of the new edition of future-rs, version 0.3. The immediate goal of this work is to support async/await notation (with borrowing) in Rust itself, which has entailed significant changes to the futures crate.]]></description><guid isPermaLink="false">2a8864ba-0872-45d2-89f4-87e9f368374b</guid><pubDate>Thu, 19 Jul 2018 17:00:00 +0000</pubDate><dc:creator>Aaron Turon</dc:creator></item><item><title>Encrusted: An interpreter for Infocom-era interactive fiction games like Zork</title><link>https://sterlingdemille.com/encrusted/</link><description><![CDATA[A modern z-machine for the classics. Encrusted is an interpreter for Infocom-era interactive fiction games like Zork. Run the web interface here ↑, or get it for your terminal.]]></description><guid isPermaLink="false">dd4398c4-2ad7-4f13-a900-2d78fa78bd0c</guid><pubDate>Thu, 19 Jul 2018 04:41:01 +0000</pubDate><dc:creator>Sterling DeMille</dc:creator></item><item><title>Auditing popular Rust crates: how a one-line unsafe has nearly ruined everything</title><link>https://medium.com/@shnatsel/auditing-popular-rust-crates-how-a-one-line-unsafe-has-nearly-ruined-everything-fab2d837ebb1</link><description><![CDATA[Following the actix-web incident (which is fixed now, at least mostly) I decided to poke other popular Rust libraries and see what comes of it.

The good news is I’ve poked at 6 popular crates now, and I’ve got not a single actually exploitable vulnerability. I am impressed. When I poked popular C libraries a few years ago it quickly ended in tears. The bad news is I’ve found one instance that was not a security vulnerability by sheer luck, plus a whole slew of denial-of-service bugs. And I can’t fix all of them by myself. Read on to find out how I did it, and how you can help!]]></description><guid isPermaLink="false">80a9211d-dd65-4da8-b8d6-5d4223ee278d</guid><pubDate>Thu, 19 Jul 2018 01:38:11 +0000</pubDate><dc:creator>Sergey &quot;Shnatsel&quot; Davidoff</dc:creator></item><item><title>Exploring inband lifetimes by converting librustc_mir</title><link>https://mark-simulacrum.github.io/2018/07/19/inband-lifetimes.html</link><description><![CDATA[Inband lifetimes is a limited change, and does not feel like it greatly enhances code. However, it also doesn’t hurt much and feels slightly better in many cases.

However, there are numerous edge cases and slight pain points, many having to do with a lack of known standard ways to do things. As such, many of the edge cases are likely to fall away as we develop after stabilization and come up with standard methods to work with the new feature.

The primary work to migrate is essentially just deleting ~all lifetime headers (<'a, 'b, 'c>) across impls and functions. More intensive migration would involve replacing untied/single-use lifetimes with '_ in all cases. This is quite hard to do from a person perspective (though compiler can likely do so fairly easily).]]></description><guid isPermaLink="false">ea8d1190-c763-4f38-8181-1fc86193bfe4</guid><pubDate>Thu, 19 Jul 2018 00:00:00 +0000</pubDate><dc:creator>Mark Rousskov</dc:creator></item><item><title>Thoughts on Compile-Time Function Evaluation and Type Systems</title><link>https://www.ralfj.de/blog/2018/07/19/const.html</link><description><![CDATA[For some time now (since the 1.26 release, to be precise), Rust has a very powerful machinery for CTFE, or compile-time function evaluation. Since then, there have been various discussions about which operations should be allowed during CTFE, which checks the compiler should do, how this all relates to promotion and which kinds of guarantees we should be able to expect around CTFE. This post is my take on those topics, and it should not be surprising that I am going to take a very type-system centric view. Expect something like a structured brain dump, so there are some unanswered questions towards the end as well.]]></description><guid isPermaLink="false">7e963a31-6451-4f7d-9817-1e8c33c4973d</guid><pubDate>Thu, 19 Jul 2018 00:00:00 +0000</pubDate><dc:creator>Ralf Jung</dc:creator></item><item><title>#[test] in 2018</title><link>https://blog.jrenner.net/rust/testing/2018/07/19/test-in-2018.html</link><description><![CDATA[Lately, I’ve been working implementing the Custom Test Frameworks eRFC for Rust. While exploring the compiler codebase, I’ve learned about the internals of testing in Rust and figured it would be interesting to share.]]></description><guid isPermaLink="false">f4903839-c307-4209-b760-15176676663f</guid><pubDate>Thu, 19 Jul 2018 00:00:00 +0000</pubDate><dc:creator>John Renner</dc:creator></item><item><title>RustSec Advisory Database</title><link>https://rustsec.org/</link><description><![CDATA[Security advisory database for Rust crates published through https://crates.io.]]></description><guid isPermaLink="false">db3cdc15-004b-4a41-9649-6ade4a8407eb</guid><pubDate>Thu, 19 Jul 2018 00:00:00 +0000</pubDate><dc:creator>Rust Project Developers</dc:creator></item><item><title>Wayland-rs 0.21: Pure Rust implementation</title><link>https://smithay.github.io/wayland-rs-v-0-21.html</link><description><![CDATA[wayland-rs is a set of crates providing generic APIs to manipulate the Wayland protocol, successor of X11 for linux windowing.

Here I am finally, after having hinted at the possibility and finally taken the time to write and merge quite an epic pull request, I can finally say it: wayland-rs is now a pure rust implementation of the protocol, rather than a crate of bindings to the wayland system C libraries.]]></description><guid isPermaLink="false">e5caa9df-4d3f-46be-a8ce-79369f0cad32</guid><pubDate>Wed, 18 Jul 2018 22:00:00 +0200</pubDate><dc:creator>Victor Berger</dc:creator></item><item><title>Let&apos;s code with the Roguelike tutorial - Part 7 - Enhancing the UI</title><link>https://www.yosenspace.com/posts/lets-code-roguelike-tutorial-part7-enhancing-ui.html</link><description><![CDATA[Up to now, all the rendering code has been in the game loop in the main function. The rendering code is simple and straightforward, so, while it should have been extracted into its own function, there wasn't a pressing need to do so. Now that I'm going to enhance the UI, the rendering needs to be extracted.]]></description><guid isPermaLink="false">92d89e3b-be0d-4f75-b335-79e26b2373e5</guid><pubDate>Wed, 18 Jul 2018 08:50:00 +0000</pubDate><dc:creator>Yosen</dc:creator></item><item><title>Let&apos;s code with the Roguelike tutorial - Part 6 - Combat engine</title><link>https://www.yosenspace.com/posts/lets-code-roguelike-tutorial-part6-combat-engine.html</link><description><![CDATA[ I now have a map, and a bunch of monsters on the map, able to attack and be attacked by the player. To provide for different kinds of monsters, I needed to add stats like combat strength and HP.]]></description><guid isPermaLink="false">6744150e-efec-40e9-a978-ed41e314d64a</guid><pubDate>Wed, 18 Jul 2018 07:28:00 +0000</pubDate><dc:creator>Yosen</dc:creator></item><item><title>cargo-generate: create a new Rust project from a template </title><link>https://github.com/ashleygwilliams/cargo-generate</link><description><![CDATA[cargo-generate is a developer tool to help you get up and running quickly with a new Rust project by leveraging a pre-existing git repository as a template.]]></description><guid isPermaLink="false">9ceafb2d-9937-48c9-9deb-ff9d1ebd19d3</guid><pubDate>Wed, 18 Jul 2018 06:59:00 +0000</pubDate><dc:creator>Ashley Williams</dc:creator></item><item><title>How to help test the 2018 edition</title><link>https://www.ncameron.org/blog/how-to-help-test-the-2018-edition/</link><description><![CDATA[An edition brings together the features that have landed into a clear package, with fully updated documentation and tooling. By the end of the year we are planning to release the 2018 edition, our first since the Rust 1.0 release. You can currently opt-in to a preview of the 2018 edition to try it out and help test it.

In fact, we really need help testing it out! Once you’ve turned it on and seen its wonderful new features, what then? Here we’ve got some specific things we’d like you to test.]]></description><guid isPermaLink="false">a81b111b-b3d6-4515-81bc-00d00bf62fb9</guid><pubDate>Wed, 18 Jul 2018 03:08:04 +0000</pubDate><dc:creator>Nick Cameron</dc:creator></item><item><title>Deploying Rust with Docker and Kubernetes</title><link>https://www.fpcomplete.com/blog/2018/07/deploying-rust-with-docker-and-kubernetes</link><description><![CDATA[Using a tiny Rust app to demonstrate deploying Rust with Docker and Kubernetes.]]></description><guid isPermaLink="false">f53d06d7-6b22-4cb8-95f1-66f8ae0bdb8f</guid><pubDate>Tue, 17 Jul 2018 21:36:08 +0000</pubDate><dc:creator>Chris Allen</dc:creator></item><item><title>So You Want to Build a Language VM - Part 00</title><link>https://blog.subnetzero.io/post/building-language-vm-part-00/</link><description><![CDATA[A Brief Course in Computer Hardware. This is the prelude to a series of posts to detailing how to build a language VM. If you are familiar with terms like registers, program counter, and assembly, feel free to skip this post. If not, read on.]]></description><guid isPermaLink="false">c7f57579-ce36-4d54-86a4-9aa4a6c1cadd</guid><pubDate>Mon, 16 Jul 2018 00:00:00 +0000</pubDate><dc:creator>Fletcher Haynes</dc:creator></item><item><title>Hello Content-o-Tron</title><link>http://blog.community.rs/content-team/2018/07/16/hello-content-o-tron.html</link><description><![CDATA[Content-o-Tron is a project to help amplify the lesser heard voices in the Rust community.

We are able to do this by providing editorial assistance and technical reviews of draft blog posts.

Once your blog post is ready to publish, we will ensure it is disseminated through various channels such as Read Rust, MozHacks, social networks and of course the Rust Community’s own blog on community.rs.]]></description><guid isPermaLink="false">fbdc0364-12e8-49f4-914f-b3c4f17d43f0</guid><pubDate>Mon, 16 Jul 2018 00:00:00 +0000</pubDate><dc:creator>Mark Sta Ana</dc:creator></item><item><title>How Rust made me rethink my view about compilers</title><link>https://defphil.com/post/2018/07/15/staying-rusty/</link><description><![CDATA[It's funny how universe aligns things, just few days ago I stumbled upon Rust koans. Already familiar way of learning and exercising, patented by Ruby programmers, where you correct tests and make them work. Also whole method of learning was similar to reading 'Little Schemer' fairly popular book among fellow Lispers. So I'll use this blog post to summarize few early impressions about Rust, and let me tell you straight away, I am loving it so far!]]></description><guid isPermaLink="false">d6b87789-dd86-49e2-91b6-692607e32f67</guid><pubDate>Sun, 15 Jul 2018 00:00:00 +0000</pubDate><dc:creator>Filip Miletic</dc:creator></item><item><title>Flocking in Rust with Piston</title><link>https://blog.shine.rocks/posts/flocking-in-rust-with-piston/</link><description><![CDATA[Wikipedia states that flocking is a behavior exhibited when a group of birds, called a flock, are foraging or in flight. Flocking simulation are basically softwares which simulate this flocking behavior of birds. The original algorithm is developed by Craig Reynolds in 1986.]]></description><guid isPermaLink="false">a65d9a08-fc44-4976-b2ad-82b934b7961f</guid><pubDate>Sun, 15 Jul 2018 00:00:00 +0000</pubDate><dc:creator>Htet Aung Shine</dc:creator></item><item><title>How we built a Visual Studio Code extension for IoT prototyping</title><link>https://cultivatehq.com/posts/how-we-built-a-visual-studio-code-extension-for-iot-prototyping/</link><description><![CDATA[We recently had the opportunity to make a Visual Studio Code extension that needed to communicate with an embedded device. This post explains the architecture we chose to achieve that and the decisions that led to it.]]></description><guid isPermaLink="false">a9a551b0-07a6-48a2-944f-b956438fecc0</guid><pubDate>Fri, 13 Jul 2018 22:39:00 +0000</pubDate><dc:creator>Dan Munckton</dc:creator></item><item><title>Electrosmog trapping with CC1101</title><link>https://dsvensson.github.io/posts/2018-07-13-Electrosmog-trapping-with-CC1101.html</link><description><![CDATA[A couple of months ago I moved to a house, and the need to monitor-all-the-things guided me towards the affordable IKEA Sparsnäs energy display. Sparsnäs is made up of two parts, one being the transmitter that is attached to your electricity meter, and the other; the display that stores usage, and presents a variety of graphs. The downside is that there is no way of getting the data out of the display so you have to accept how it’s presented, and that it may get lost, or build something on your own. Thankfully the protocol has been thoroughly reverse engineered and documented in a very elaborate manner.]]></description><guid isPermaLink="false">c5d017d6-de45-4099-9272-19fe01441fdc</guid><pubDate>Fri, 13 Jul 2018 20:06:53 +0000</pubDate><dc:creator>Daniel Svensson</dc:creator></item><item><title>Multi target Rust builds with auto deployment in Travis-CI</title><link>https://medium.com/@tyrf/multi-target-rust-builds-with-auto-deployment-in-travis-ci-ab5214fb73ba</link><description><![CDATA[This is just a small build script to automatically compile and create Rust binaries for your i86 32 and 64 bit machine and your Raspberry Pi(ARM) with Travis-CI. On the right side I added a little explanation of the following script.]]></description><guid isPermaLink="false">fbdcd657-aab5-4d28-aa3a-ab04294f49eb</guid><pubDate>Fri, 13 Jul 2018 18:44:17 +0000</pubDate><dc:creator>Hendrik Teuber</dc:creator></item><item><title>Linux Container Internals (Part II)</title><link>https://rabbitstack.github.io/operating%20systems/containers/linux-container-internals-part-ii/</link><description><![CDATA[Containers are moving the world. Each passing day more and more organizations are embracing containers as first-class citizens for distribution and deployment of software components. Containers represent the core of the cloud native paradigm.]]></description><guid isPermaLink="false">5f84b8db-7379-4c08-9cae-d2a901caaab1</guid><pubDate>Fri, 13 Jul 2018 18:10:04 +0200</pubDate><dc:creator>Nedim Šabić</dc:creator></item><item><title>Rust vs. Go</title><link>http://julio.meroh.net/2018/07/rust-vs-go.html</link><description><![CDATA[Welcome to the Rust Review’s bonus post, which I had promised from the very beginning. I’m here to cover the big elephant in the room: Rust vs. Go. Which one is better?

There is no good answer to this question because this comparison is unfounded. I think people tend to bundle the two languages together because they were released at about the same time and the release of Rust felt like a response to the release of Go. Moreover, both languages are supposed to focus on systems software. But they are vastly different, and even as they both target systems software, they target different kinds of such software.]]></description><guid isPermaLink="false">40055859-95cc-47a0-89e3-fd3c8a000fba</guid><pubDate>Fri, 13 Jul 2018 10:45:00 +0200</pubDate><dc:creator>Julio Merino</dc:creator></item><item><title>Writing a GPU-Accelerated Path Tracer in Rust - Part 2</title><link>https://bheisler.github.io/post/writing-gpu-accelerated-path-tracer-part-2/</link><description><![CDATA[Hello, and welcome to part two of my series on writing a GPU-accelerated path tracer in Rust. I’d meant to have this post up sooner, but nothing ruins my productivity quite like Games Done Quick. I’m back now, though, so it’s time to turn the GPU ray-tracer from the last post into a real path tracer.

Tracing Paths As mentioned last time, Path Tracing is an extension to Ray Tracing which attempts to simulate global illumination.]]></description><guid isPermaLink="false">289bc607-7039-4931-838e-0451ee67e488</guid><pubDate>Thu, 12 Jul 2018 19:00:00 -0600</pubDate><dc:creator>Brook Heisler</dc:creator></item><item><title>The Tale of a Bug in Arc: Synchronization and Data Races</title><link>https://www.ralfj.de/blog/2018/07/13/arc-synchronization.html</link><description><![CDATA[While I was busy doing Rust-unrelated research, RustBelt continues to move and recently found another bug (after a missing impl !Sync that we found previously): It turns out that Arc::get_mut did not perform sufficient synchronization, leading to a data race.]]></description><guid isPermaLink="false">b2fbac94-27b1-4c37-8c21-ead67edecf43</guid><pubDate>Fri, 13 Jul 2018 00:00:00 +0000</pubDate><dc:creator>Ralf Jung</dc:creator></item><item><title>Physical Computing With Rust On Raspberry Pi</title><link>https://medium.com/@rahulthakoor/physical-computing-with-rust-on-raspberry-pi-a7b6f34261a6</link><description><![CDATA[A couple of months ago I released the rust_gpiozero¹ crate. It is a port of the GPIO Zero² library by the Raspberry Pi Foundation. The library provides a simple interface to control GPIO devices with a Raspberry Pi. Following this, recently ported the Raspberry Pi Foundation’s Physical Computing with Python³ guide for Rust.]]></description><guid isPermaLink="false">34fa3257-4ea8-4ade-8cad-353aa02239d3</guid><pubDate>Thu, 12 Jul 2018 14:52:13 +0000</pubDate><dc:creator>Rahul Thakoor</dc:creator></item><item><title>Ownership in Rust, Part 2</title><link>https://medium.com/@thomascountz/ownership-in-rust-part-2-c3e1da89956e</link><description><![CDATA[It’s still not problem.]]></description><guid isPermaLink="false">62456010-4ef4-4f1d-87f0-6e0c64929d82</guid><pubDate>Wed, 11 Jul 2018 16:55:03 +0000</pubDate><dc:creator>Thomas Countz</dc:creator></item><item><title>Let&apos;s code with the Roguelike tutorial - Part 5 - Setting up enemies</title><link>https://www.yosenspace.com/posts/lets-code-roguelike-tutorial-part5-setting-up-enemies.html</link><description><![CDATA[I now have the game up to the point where the player has a random dungeon to explore. It's time to make it more interesting by adding some threats - namely, some monsters.]]></description><guid isPermaLink="false">9ba882d4-cadd-4708-906b-2ec25fe72941</guid><pubDate>Wed, 11 Jul 2018 04:57:00 +0000</pubDate><dc:creator>Yosen</dc:creator></item><item><title>Let&apos;s code with the Roguelike tutorial - Part 4 - Field of view and exploration</title><link>https://www.yosenspace.com/posts/lets-code-roguelike-tutorial-part4-field-view-exploration.html</link><description><![CDATA[In the current implementation, the player can see the entire layout of the dungeon from the beginning. The next step is to change the game to start off with the dungeon hidden, so the player will actually have some rooms to explore.]]></description><guid isPermaLink="false">1e1fcc0e-6af2-4223-8689-4cab5a34222f</guid><pubDate>Wed, 11 Jul 2018 04:57:00 +0000</pubDate><dc:creator>Yosen</dc:creator></item><item><title>BetaFPV F3 Drone Flight Controller - Hello Rust</title><link>https://www.joshmcguigan.com/blog/betafpv-drone-flight-controller-hello-rust/</link><description><![CDATA[One of the most exciting areas of hobbyist embedded programming, in my opinion, is flight controllers for remote controlled aircraft. In the particular case of a multi-rotor drone, the flight controller is responsible for converting the UP command from the transmitter into specific outputs for each of the motors. Maintaining the stability of a drone involves carefully adjusting the output of each motor thousands of times per second based on feedback from on-board sensors.

There are several great C-based open source drone flight controller firmware projects, but as far as I can see there are none written in Rust. The good news is that most drone flight controllers are based on STM32 MCUs, which Rust has strong support for. Robust flight controller firmware is quite complex, and there are a number of challenges to be solved before even getting the rotors spinning. The first of those challenges is building a Rust project for a particular flight controller board, and flashing the board with the compiled code. A single blinking LED is our goal for today.]]></description><guid isPermaLink="false">133f5906-759e-4a83-b188-fc18eda31cc0</guid><pubDate>Wed, 11 Jul 2018 00:00:00 +0000</pubDate><dc:creator>Josh Mcguigan</dc:creator></item><item><title>Enforcing style in CI for Rust Projects</title><link>https://medium.com/@ag_dubs/enforcing-style-in-ci-for-rust-projects-18f6b09ec69d</link><description><![CDATA[This article will attempt to help you avoid the debate entirely, at least in your Rust projects, by explaining how you can use the rustfmt tool to enforce style guidelines using CI. We’ll start with a brief introduction to rustfmt, so feel free to skip the next section if you are already familiar.]]></description><guid isPermaLink="false">59c63ab5-9b88-498e-a6ce-989f77bcdffe</guid><pubDate>Tue, 10 Jul 2018 22:03:24 +0000</pubDate><dc:creator>Ashley Williams</dc:creator></item><item><title>Ownership in Rust, Part 1</title><link>https://medium.com/@thomascountz/ownership-in-rust-part-1-112036b1126b</link><description><![CDATA[It’s not my problem.]]></description><guid isPermaLink="false">c0f25118-a040-4f57-bd18-1594ce4e72f6</guid><pubDate>Mon,  9 Jul 2018 20:58:44 +0000</pubDate><dc:creator>Thomas Countz</dc:creator></item><item><title>Rust + actix-web power Atlas Weekend music festival</title><link>https://www.reddit.com/r/rust/comments/8xdsx5/rust_actixweb_in_the_on_of_the_biggest_music/</link><description><![CDATA[We've just finished music festival Atlas Weekend which took place in Kyiv, Ukraine. This year there were for about 450,000 visitors during 6 days. I'm glad to announce that Rust and actix-web are used as a backend for main technical purposes of festival.]]></description><guid isPermaLink="false">a95c25cb-0553-42ee-a81a-4a9cedce53e8</guid><pubDate>Tue, 10 Jul 2018 03:16:52 +1000</pubDate><dc:creator>/u/maxfrai</dc:creator></item><item><title>Introducing PrrrStack, Pt. 2</title><link>https://medium.com/@ccrsh/introducing-prrrstack-pt-2-24704b5763b2</link><description><![CDATA[In the first article of this series, we created a RestAPI for our application using Postgres, Rust, and Rocket. For the second half, we’ll be using React to create the front end.]]></description><guid isPermaLink="false">85ab7e93-7bbc-43ef-be5f-5decca1b4651</guid><pubDate>Mon,  9 Jul 2018 12:35:32 +0000</pubDate><dc:creator>Crash Springfield</dc:creator></item><item><title>The Cheddar shading language</title><link>https://phaazon.net/blog/cheddar-0.1</link><description><![CDATA[Cheddar is a GLSL superset language. What it means is that most of the GLSL constructs and syntax you’re used to is valid in Cheddar – not all of it; most of it. Cheddar adds a set of features that I think are lacking to GLSL. Among them: Some non-valid GLSL constructions made valid in Cheddar to ease the writing of certain shader stages; A more functional approach to programming shaders on the GPU; Structures, types and GLSL-specific constructs sharing; Imports and modules with live reloading and transitive dependencies.]]></description><guid isPermaLink="false">5579acfe-3441-4097-9476-863e348858f5</guid><pubDate>Mon,  9 Jul 2018 01:00:00 +0000</pubDate><dc:creator>Dimitri Sabadie</dc:creator></item><item><title>Rustberry 0.1.0 has been released, and I need more testers!</title><link>https://www.reddit.com/r/rust/comments/8x1ayd/calling_all_raspberry_pi_owners_rustberry_010_has/</link><description><![CDATA[After many laborious hours of reading and interpreting the various online references, I've published the first release of my latest project, a crate to safely abstract Raspberry Pi's platform-specific features in Rust. I've (very creatively) named it Rustberry, and it's finally stable and clean enough that I'm able to publish it and receive initial feedback.]]></description><guid isPermaLink="false">54c6e230-51fa-42c2-bcab-26b75e699bb3</guid><pubDate>Sun,  8 Jul 2018 23:06:00 +1000</pubDate><dc:creator>/u/ninja_tokumei</dc:creator></item><item><title>Learning Rust 02: an ls clone</title><link>https://routley.io/tech/2018/07/08/learning-rust-02.html</link><description><![CDATA[In this post, I’m building an ls clone. It’s pretty similar to the last post’s pwd clone. It’s called rls.]]></description><guid isPermaLink="false">078a2508-9729-477b-915e-3a72fb6f66e9</guid><pubDate>Sun,  8 Jul 2018 00:00:00 +0100</pubDate><dc:creator> James Routley</dc:creator></item></channel></rss>