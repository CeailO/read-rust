<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/"><channel><title>Read Rust - All Posts</title><link>https://readrust.net/</link><description>All Posts posts on Read Rust</description><item><title>Wait-Free Per-Object Thread-Local Storage</title><link>https://bzim.gitlab.io/blog/posts/wait-free-per-object-thread-local-storage.html</link><description><![CDATA[In this post, I present a wait-free thread-local storage using the Rust language.]]></description><guid isPermaLink="false">3c9dc7f2-978e-4663-900e-8a49c10bf57f</guid><pubDate>Sun, 18 Nov 2018 00:00:00 +0000</pubDate><dc:creator>Bruno Corrêa Zimmermann</dc:creator></item><item><title>Compile Time Feature Flags in Rust</title><link>https://www.worthe-it.co.za/programming/2018/11/18/compile-time-feature-flags-in-rust.html</link><description><![CDATA[Toggling feature flags when you compile for zero runtime cost]]></description><guid isPermaLink="false">24375765-7fa7-4729-8b69-734c409c47fb</guid><pubDate>Sun, 18 Nov 2018 00:00:00 +0000</pubDate><dc:creator>Justin Worthe</dc:creator></item><item><title>Introducing pest into glsl and hindsight about nom vs. pest (part 2)</title><link>https://phaazon.net/blog/glsl-pest-part-2</link><description><![CDATA[This is the second article about my experience at supporting pest in my glsl crate – without, for now, removing the nom parser.]]></description><guid isPermaLink="false">84353bd7-6977-4894-883f-b917ccef0b45</guid><pubDate>Sat, 17 Nov 2018 20:40:00 +0000</pubDate><dc:creator>Dimitri Sabadie</dc:creator></item><item><title>Synthesizing Structures with immense</title><link>https://paytonturnage.com/writing/2018-11-17-synthesizing-structures-with-immense/</link><description><![CDATA[I wrote a nightly Rust library called immense for synthesizing 3D structures with simple composable rules, inspired by Structure Synth. In the docs I cover the basics, and in this article I’ll go over making a mesh from start to finish.]]></description><guid isPermaLink="false">04284ee3-1ace-4204-bb2f-e2d27249c8c2</guid><pubDate>Sat, 17 Nov 2018 12:09:00 +0000</pubDate><dc:creator>Payton Turnage</dc:creator></item><item><title>Introducing pest into glsl and hindsight about nom vs. pest (part 1)</title><link>https://phaazon.net/blog/glsl-pest-part-1</link><description><![CDATA[This is the first article out of a (I guess?!) series of upcoming articles about… parsing. More specifically, I’ve been writing the glsl crate for a while now and the current, in-use parser is backed with nom. nom is a parser combinator crate written originally by @geal and there has been a lot of fuzz around nom vs. pest lately.

Soooooooooooo. Because glsl is written with nom in its third iteration and because nom is now at version 4, I decided it was time to update the parser code of glsl. I heard about the comparison between pest and nom and decided to write an implementation with pest.

This is the first article of a series about how writing a pest looks like is fun compared to writing the nom parser. I’ll post several articles as I advance and see interesting matter to discuss and share.]]></description><guid isPermaLink="false">2a3a85cf-b4ac-49ff-9a27-4d377cd3d0cb</guid><pubDate>Sat, 17 Nov 2018 05:00:00 +0000</pubDate><dc:creator>Dimitri Sabadie</dc:creator></item><item><title>Build Your Own Shell using Rust</title><link>https://www.joshmcguigan.com/blog/build-your-own-shell-rust/</link><description><![CDATA[This is a tutorial on building your own shell using Rust, in the spirit of the build-your-own-x list. Creating a shell is a great way to understand how the shell, terminal emulator, and OS work together.]]></description><guid isPermaLink="false">5527d11f-6f5e-47f4-b208-c90499764f04</guid><pubDate>Sat, 17 Nov 2018 00:00:00 +0000</pubDate><dc:creator>Josh Mcguigan</dc:creator></item><item><title>Can you Drop it?</title><link>http://optimistictypes.com/can-you-drop-it/</link><description><![CDATA[Resource allocation & the implementation of drop logic in Rust.]]></description><guid isPermaLink="false">18ce3041-0f7a-4bf8-8e5a-ccea2a6c8053</guid><pubDate>Sat, 17 Nov 2018 00:00:00 +0000</pubDate><dc:creator>J Haigh</dc:creator></item><item><title>Gutenberg is out, Zola 0.5.0 is in</title><link>https://www.vincentprouillet.com/blog/releasing-zola-0-5-0/</link><description><![CDATA[Gutenberg changes name to Zola and gets a big release to celebrate.]]></description><guid isPermaLink="false">6b8f2916-9634-4d6b-ae64-02d565c58659</guid><pubDate>Sat, 17 Nov 2018 00:00:00 +0000</pubDate><dc:creator>Vincent Prouillet</dc:creator></item><item><title>Bringing Elm’s architecture to Rust and Webassembly</title><link>https://sindrejohansen.no/blog/willow/rust/elm/2018/11/16/willow-elm-in-rust.html</link><description><![CDATA[I really like Elm. It is a delightful language with an amazing ecosystem. It has an interesting architecture called TEA, The Elm Architecture. Another language I like is Rust. On paper, Rust is completely different from Elm, but in using them both, I have seen some resemblance. Having used both Elm and Rust I had something I wanted to try. Would it be possible to create The Elm Architecture in Rust?]]></description><guid isPermaLink="false">ad136bed-3540-4ced-8a77-448b94426ba3</guid><pubDate>Fri, 16 Nov 2018 16:35:22 +0000</pubDate><dc:creator>Sindre</dc:creator></item><item><title>Programming Servo: A background-hang-monitor</title><link>https://medium.com/programming-servo/programming-servo-a-background-hang-monitor-73e89185ce1</link><description><![CDATA[Let’s say you’re contributing to a system in Rust consisting of a bunch of different components, running in their own threads or processes, for example an engine to make the Web run.

When one of those components seemingly hangs on something, how can you find out what it is hanging on? Maybe a backtrace of what that component is doing at that time would be useful?

That’s easy, for that we have thebacktrace-rs crate, right?

Well, there’s a catch: how do we call Backtrace::new() from a thread that is hanging?]]></description><guid isPermaLink="false">40ed3562-277a-453f-84a6-29ab5314ed0c</guid><pubDate>Fri, 16 Nov 2018 12:30:06 +0000</pubDate><dc:creator>Gregory Terzian</dc:creator></item><item><title>Stacked Borrows Implemented</title><link>https://www.ralfj.de/blog/2018/11/16/stacked-borrows-implementation.html</link><description><![CDATA[Three months ago, I proposed Stacked Borrows as a model for defining what kinds of aliasing are allowed in Rust, and the idea of a validity invariant that has to be maintained by all code at all times. Since then I have been busy implementing both of these, and developed Stacked Borrows further in doing so. This post describes the latest version of Stacked Borrows, and reports my findings from the implementation phase: What worked, what did not, and what remains to be done. There will also be an opportunity for you to help the effort!]]></description><guid isPermaLink="false">4d211c62-3ab3-4db5-a900-94731f798765</guid><pubDate>Fri, 16 Nov 2018 00:00:00 +0000</pubDate><dc:creator>Ralf Jung</dc:creator></item><item><title>Program Synthesis is Possible in Rust</title><link>http://fitzgeraldnick.com/2018/11/15/program-synthesis-is-possible-in-rust.html</link><description><![CDATA[Program synthesis is the act of automatically constructing a program thatfulfills a given specification. I recently stumbled across Adrian Sampson’s Program Synthesis is Possible blog post. Adrian describes and implements minisynth, a toy program synthesizer that generates constants for holes in a template program when given a specification. What fun! As a way to learn more about program synthesis myself, I ported minisynth to Rust.]]></description><guid isPermaLink="false">e8b911ca-d007-441e-93e3-d8f1f1b89a00</guid><pubDate>Thu, 15 Nov 2018 00:00:00 -0800</pubDate><dc:creator>Nick Fitzgerald</dc:creator></item><item><title>Rust And Game Development</title><link>https://alexene.github.io/2018/11/15/Rust-and-game-development.html</link><description><![CDATA[Rust is excellent for performance crucial applications that run on multi-processor architectures and these two aspects are also critical for game development. Rust has already seen a bunch of interest from games developers like Chucklefish, Embark Studios, Ready at Dawn, etc. - but in order to really excel I’d love to organize some structured efforts to improve the ecosystem and I think it would be great if the 2019 roadmap will include game development.]]></description><guid isPermaLink="false">dabab963-1e9e-4b55-bb85-d0173a1db54a</guid><pubDate>Thu, 15 Nov 2018 00:00:00 +0000</pubDate><dc:creator>Alexandru Ene</dc:creator></item><item><title>Rust, MongoDB &amp; Wither 0.6</title><link>https://medium.com/docql/https-medium-com-docql-rust-mongodb-wither-13e803c9ae72</link><description><![CDATA[Hello everyone! I would like to share an update on an open source project which I have been developing for a little while now. It is a Rust project called Wither which attempts to “provide a simple, sane & predictable interface into MongoDB, based on data models”. This post is about the 0.6 release of this crate, and I would like to dive into some of the aspects of developing this release which I really enjoyed or which I found interesting.]]></description><guid isPermaLink="false">b21ca2e0-5670-4a7b-af11-3a6c1312d5e2</guid><pubDate>Wed, 14 Nov 2018 18:33:12 +0000</pubDate><dc:creator>Anthony Dodd</dc:creator></item><item><title>This Year in Embedded Rust</title><link>https://rust-embedded.github.io/blog/2018-11-14-this-year-in-embedded-rust/</link><description><![CDATA[This year the Embedded WG set out to build the solid foundation that the embedded Rust ecosystem requires to thrive. As we approach the date of the 2018 edition release we reflect on our progress and share our achievements with you in this post.]]></description><guid isPermaLink="false">68074e79-2747-4170-970f-0e56b936578c</guid><pubDate>Wed, 14 Nov 2018 00:00:00 +0000</pubDate><dc:creator>The Embedded Working Group</dc:creator></item><item><title>Running Rust natively in AWS Lambda and testing it locally</title><link>https://medium.com/@bernardo.belchior1/running-rust-natively-in-aws-lambda-and-testing-it-locally-57080421426d</link><description><![CDATA[Abusing Go runtime in AWS to run Rust binaries]]></description><guid isPermaLink="false">97715a00-432f-4cfa-9c11-92f0d74ff60e</guid><pubDate>Mon, 12 Nov 2018 14:23:33 +0000</pubDate><dc:creator>Bernardo Belchior</dc:creator></item><item><title>Things Rust doesn’t let you do</title><link>https://medium.com/@GolDDranks/things-rust-doesnt-let-you-do-draft-f596a3c740a5</link><description><![CDATA[A survey of things that Rust doesn’t let you do although arguably safe.]]></description><guid isPermaLink="false">858249f6-6979-48c9-a138-1b7fd2fc9502</guid><pubDate>Mon, 12 Nov 2018 01:34:25 +0000</pubDate><dc:creator>Pyry Kontio</dc:creator></item><item><title>Rust Flow: Function and Method Sequences in Rust</title><link>https://myrrlyn.net/blog/misc/rust-flow</link><description><![CDATA[Rust allows for a very functional style of value “flow” without sacrificing the performance of a more traditionally imperative sequence. Furthermore, the functional flow may offer more clarity about value lifetimes and error handling that the imperative sequence might obscure.]]></description><guid isPermaLink="false">d435191e-e40d-477d-a5ee-908808ee5eee</guid><pubDate>Sun, 11 Nov 2018 14:44:00 +0000</pubDate><dc:creator>Alexander Payne</dc:creator></item><item><title>Truly Zero Cost</title><link>https://vorner.github.io/2018/11/11/truly-zero-cost.html</link><description><![CDATA[I know it is claimed how Rust has zero cost abstractions and such and that all these levels of abstractions will just go away in a release build. But there’s a difference in hearing the theory and seeing it really happen in practice. And I don’t appreciate it because I’d consider it magic, but more because I understand how that is being done and it still looks cool.]]></description><guid isPermaLink="false">c6c90807-5108-434e-9dc0-c5ba8135420d</guid><pubDate>Sun, 11 Nov 2018 00:00:00 +0000</pubDate><dc:creator>Michal &apos;vorner&apos; Vaner</dc:creator></item><item><title>Serve archived static files over HTTP</title><link>https://deterministic.space/serve-archived-static-files-over-http.html</link><description><![CDATA[Say you want to store a huge number of very small filesthat you will only access over HTTP.For example:You are using rustdoc to render the documentation of a library.Without much work you’ll end up with about 100k HTML filesthat are about 10kB each.As it turns out,this number of small files is very annoying for any kind of file system performance.Best case: making copies/backups is slow.Worst case: You’re using an anti virus software and it takes ages.]]></description><guid isPermaLink="false">b2687a6e-55b3-4d3b-a025-fc9e7c592e8e</guid><pubDate>Sun, 11 Nov 2018 00:00:00 +0100</pubDate><dc:creator>Pascal Hertleif</dc:creator></item><item><title>Monadic do notation in Rust: Part I</title><link>https://varkor.github.io/blog/2018/11/10/monadic-do-notation-in-rust-part-i.html</link><description><![CDATA[Following last time, where we saw that, given parameterision over traits (rather than just types), we could implement functors and monads in Rust that supported existing “monad-like” traits like Iterator and Future, I thought it would be interesting to tackle another one of the arguments against monads in Rust.]]></description><guid isPermaLink="false">364d5469-2447-49c8-ab4c-e0b82da96f27</guid><pubDate>Sat, 10 Nov 2018 20:10:56 +0000</pubDate><dc:creator>varkor</dc:creator></item><item><title>After NLL: Moving from borrowed data and the sentinel pattern</title><link>http://smallcultfollowing.com/babysteps/blog/2018/11/10/after-nll-moving-from-borrowed-data-and-the-sentinel-pattern/</link><description><![CDATA[Continuing on with my “After NLL” series, I want to look at another common error that I see and its solution: today’s choice is about moves from borrowed data and the Sentinel Pattern that can be used to enable them.]]></description><guid isPermaLink="false">9dae526e-703d-4726-b68c-92f847e3c85f</guid><pubDate>Sat, 10 Nov 2018 00:00:00 -0500</pubDate><dc:creator>Niko Matsakis</dc:creator></item><item><title>proc_macro_attribute Revisited</title><link>https://llogiq.github.io/2018/11/10/proc-macro.html</link><description><![CDATA[Recently, the procedural macro interface was somewhat stabilized. OK, there’s still the unstable proc_macro_hygiene feature you have to activate, but at least the registrar and rustc_private are no longer needed.]]></description><guid isPermaLink="false">190265bb-a65b-4acd-99e9-3d6f8a06969c</guid><pubDate>Sat, 10 Nov 2018 00:00:00 +0000</pubDate><dc:creator>Llogiq</dc:creator></item><item><title>How to get the size of Rust types with -Zprint-type-sizes</title><link>https://blog.mozilla.org/nnethercote/2018/11/09/how-to-get-the-size-of-rust-types-with-zprint-type-sizes/</link><description><![CDATA[When optimizing Rust code it’s sometimes useful to know how big a type is, i.e. how many bytes it takes up in memory. std::mem::size_of can tell you, but often you want to know the exact layout as well. For example, an enum might be surprisingly big, in which case you probably will want to know if, for example, there is one variant that is much bigger than the others.]]></description><guid isPermaLink="false">4ace2654-b6a1-4a4a-9917-07f9e12c1ec2</guid><pubDate>Fri,  9 Nov 2018 03:42:40 +0000</pubDate><dc:creator>Nicholas Nethercote</dc:creator></item><item><title>Exploring a shipping puzzle, part 2</title><link>https://kevinlynagh.com/notes/shipping-puzzle/part-2/</link><description><![CDATA[A friend recently told me about a puzzle, which is a great excuse to explore programming craft. My Rust solution was a simple port of my second Clojure solution. The only major difference is that it takes advantage of mutability (which is idiomatic in Rust, unlike in Clojure). The Rust solution runs in about 4.22 ± 0.05 ms, or about 5x faster than the fast Clojure solution.]]></description><guid isPermaLink="false">93922af4-e454-4bfd-a0f2-64c481a6263c</guid><pubDate>Fri,  9 Nov 2018 00:00:00 +0000</pubDate><dc:creator>Kevin Lynagh</dc:creator></item><item><title>Making progress in await syntax</title><link>https://boats.gitlab.io/blog/post/await-syntax/</link><description><![CDATA[One thing we’ve left as an unresolved question so far in the matter of async/await syntax is the exact final syntax for the await operation. In the current implementation, awaits are written using a compiler plugin:

async fn foo() {
await!(bar());
}

This is not because of any technical limitation: the reason we have done this is that we have not decided on the precise, final syntax for the await operation.]]></description><guid isPermaLink="false">89cf760b-0385-4e81-ad78-45b7eb3b2aa2</guid><pubDate>Thu,  8 Nov 2018 00:00:00 +0000</pubDate><dc:creator>withoutboats</dc:creator></item><item><title>Middleware in Tide</title><link>https://rust-lang-nursery.github.io/wg-net/2018/11/07/tide-middleware.html</link><description><![CDATA[After the positive response to the routing and extraction proposal in Tide, I’m pleased to say that an initial implementation is available on GitHub! As a testament to the strong foundation that Rust’s ecosystem provides, the basic framework implementation took only about 1,000 lines of code.]]></description><guid isPermaLink="false">b8931a7e-08d1-406b-b751-6bd27a9d4d67</guid><pubDate>Wed,  7 Nov 2018 00:00:00 +0000</pubDate><dc:creator>Aaron Turon</dc:creator></item><item><title>Learning a new language for more than 2 months (feat. Exercism)</title><link>https://cslai.coolsilon.com/2018/11/06/learning-a-new-language-for-more-than-2-months-feat-exercism/</link><description><![CDATA[Usually I take about a week to learn a new language so I can start doing some real work with it. After all a programming language (at least the high level and dynamic ones) is just assignment, calculation, branching, looping and reuse (and in certain cases, concurrency/parallelism, not gonna dive deep in defining the difference though). Well, that was true until I started learning Rust, partly for my own leisure. I still don’t feel comfortable writing a complete Rust code. Though I really like the language.]]></description><guid isPermaLink="false">09e9a0eb-339f-496e-8477-911e89774938</guid><pubDate>Tue,  6 Nov 2018 11:18:35 +0000</pubDate><dc:creator>Jeffrey04</dc:creator></item><item><title>How to speed up the Rust compiler in 2018: NLL edition</title><link>https://blog.mozilla.org/nnethercote/2018/11/06/how-to-speed-up-the-rust-compiler-in-2018-nll-edition/</link><description><![CDATA[Niko Matsakis recently blogged about the Rust compiler’s new borrow checker, which implements non-lexical lifetimes (NLL). The new borrow checker is a really nice improvement to Rust, because it accepts many sound programs that the old borrow checker rejected.]]></description><guid isPermaLink="false">14df2f8d-908b-4836-966f-b307f763319d</guid><pubDate>Tue,  6 Nov 2018 00:09:41 +0000</pubDate><dc:creator>Nicholas Nethercote</dc:creator></item><item><title>Introducing Mundane, a new cryptography library for Rust</title><link>https://joshlf.com/post/2018/11/06/introducing-mundane/</link><description><![CDATA[Mundane is a cryptography library written in Rust and backed by BoringSSL. It aims to be difficult to misuse, ergonomic, and performant (in that order). It was originally created to serve the cryptography needs of Fuchsia, but we’ve decided to split it off as a general-purpose crate.]]></description><guid isPermaLink="false">b612b468-7306-4f7b-a09a-2b4f0bac5b55</guid><pubDate>Tue,  6 Nov 2018 00:00:00 +0000</pubDate><dc:creator>Joshua Liebow-Feeser</dc:creator></item><item><title>A hammer you can only hold by the handle</title><link>https://blog.systems.ethz.ch/blog/2018/a-hammer-you-can-only-hold-by-the-handle.html</link><description><![CDATA[Today we’re looking at the rust borrow checker from a different perspective. As you may know, the borrow checker is designed to safely handle memory allocation and ownership, preventing accessess to invalid memory and ensuring data-race freedom. This is a form of resource management: the borrow checker is tracking who’s in charge of a chunk of memory, and who is currently allowed to read or write to it. In this post, we’ll see how these facilities can be used to enforce higher-level API constraints in your libraries and software. Once you’re familiar with these techniques, we’ll cover how the same principles apply to advanced memory management and handling of other more abstract resources.]]></description><guid isPermaLink="false">495a9412-287b-4baf-af46-007603eff49a</guid><pubDate>Mon,  5 Nov 2018 00:00:00 +0000</pubDate><dc:creator>Andrea Lattuada</dc:creator></item><item><title>A New Way of Thinking</title><link>https://boakye.yiadom.org/rust/new/</link><description><![CDATA[Rust was my language of the year. You know, that thing where programmers set out to learn a new programming language every year. Usually not to be productive at it but to familiarize themselves with current trends in language design, implementation, and paradigms. I had heard a lot of good stuff about Rust and decided late last year to make it my 2018 language. I’m only a few days in but I’ve been smacked by some of what I consider the best ideas in programming I’ve encountered yet.]]></description><guid isPermaLink="false">6e6bbbca-9a60-4c29-a050-1d34f08192ea</guid><pubDate>Sun,  4 Nov 2018 23:59:50 +0000</pubDate><dc:creator>Yaw Boakye</dc:creator></item><item><title>Monotron at Rust Belt Rust</title><link>https://railwayelectronics.blogspot.com/2018/11/monotron-at-rust-belt-rust.html</link><description><![CDATA[So now @rustbeltrust is over, I thought it was worth writing down a few details about what Monotron can do. It's had a few upgrades since @RustFest Paris! I tried to keep them under wraps to avoid spoilers but I can share them now. This is an un-roll and re-edit of my Twitter thread, and the features listed here are in no particular order.]]></description><guid isPermaLink="false">e8029bd5-78ca-4797-bf1b-9f909f132a4b</guid><pubDate>Sun,  4 Nov 2018 20:49:00 +0000</pubDate><dc:creator>Jonathan Pallant</dc:creator></item><item><title>On dealing with owning and borrowing in public interfaces</title><link>https://phaazon.net/blog/on-owning-borrowing-pub-interface</link><description><![CDATA[I’ve been writing on a few examples code lately to add to documentations of some crates of mine. I write a lot of code that creates new objects that need other objects in order to be built. Most of the APIs you can see around tend to love the borrow principle – and I do.]]></description><guid isPermaLink="false">dd822196-d8f4-4764-9727-6096581c035a</guid><pubDate>Sun,  4 Nov 2018 01:30:00 +0000</pubDate><dc:creator>Dimitri Sabadie</dc:creator></item><item><title>Optional Arguments in Rust</title><link>https://hoverbear.org/2018/11/04/optional-arguments/</link><description><![CDATA[When designing an API for your crate one topic which can come is how to handle optional arguments. Let’s explore our Options in Rust!]]></description><guid isPermaLink="false">125dced7-207a-4c36-904b-3d17c903c508</guid><pubDate>Sun,  4 Nov 2018 00:00:00 +0000</pubDate><dc:creator>Andrew Hobden</dc:creator></item><item><title>Higher-Order Functions in Rust</title><link>https://dev.to/deciduously/higher-order-functions-in-rust-287h</link><description><![CDATA[Rust is an imperative language but it provides many tools in the standard library which adhere to a more functional style, like the Iterator trait and its methods like map, for_each, and filter. This is a quick run-down of how to define your own higher-order functions in Rust which can both take closures as parameters and return closures in such a way that you can use the two together.]]></description><guid isPermaLink="false">bfe6aa2d-0dbd-4966-81cc-eebed27ca28d</guid><pubDate>Sat,  3 Nov 2018 00:00:00 +0000</pubDate><dc:creator>Ben Lovy</dc:creator></item><item><title>eyeoh: My first Rust library</title><link>https://sts10.github.io//2018/11/02/eyeoh-rust-library.html</link><description><![CDATA[I realized I kept copy and pasting (or re-writing) functions to take user input or read simple files into Rust variables. So I’ve been working on a Rust library that attempts to make these tasks easier.]]></description><guid isPermaLink="false">db47620d-045e-42dc-bc1a-6aedaed9d948</guid><pubDate>Fri,  2 Nov 2018 22:18:50 +0000</pubDate><dc:creator>Sam Schlinkert</dc:creator></item><item><title>Anchored and Uniform Paths</title><link>https://boats.gitlab.io/blog/post/anchored-uniform/</link><description><![CDATA[Rust 2018 is almost out the door, but there is one big decision the language team has yet to make. It has to do with the modules and paths system, so of course it is a very easy decision that no one has a strong opinion about. ;-)
In Rust 2018, we’ll be making some big changes to how paths work to try to create a more consistent experience. The “lodestar” (if you will) of these changes is an idea we call “1path:” the idea no matter where you are in your project, whether in a use statement or normal code, a path is interpreted the same way.]]></description><guid isPermaLink="false">7be81fee-ef29-448f-9e03-9be0fc63fbb7</guid><pubDate>Fri,  2 Nov 2018 00:00:00 +0000</pubDate><dc:creator>withoutboats</dc:creator></item><item><title>After NLL: Interprocedural conflicts</title><link>http://smallcultfollowing.com/babysteps/blog/2018/11/01/after-nll-interprocedural-conflicts/</link><description><![CDATA[In my previous post on the status of NLL, I promised to talk about “What is next?” for ownership and borrowing in Rust. I want to lay out the various limitat...]]></description><guid isPermaLink="false">bfd4f2e7-3e44-4383-a144-ae5da7c664fa</guid><pubDate>Thu,  1 Nov 2018 00:00:00 -0400</pubDate><dc:creator>Niko Matsakis</dc:creator></item><item><title>Rust Nightly, Travis CI and Code Coverage</title><link>https://baptiste.gelez.xyz/~/Rust/rust-nightly-travis-ci-and-code-coverage/</link><description><![CDATA[How to setup test a Rust Nightly project with a workspace in Travis CI and collect coverage information with kcov and Codecov.]]></description><guid isPermaLink="false">b49cc876-bb7e-4861-a0d6-34b4396b3600</guid><pubDate>Thu,  1 Nov 2018 00:00:00 +0000</pubDate><dc:creator>Baptiste Gelez</dc:creator></item><item><title>MIR-based borrowck is almost here</title><link>http://smallcultfollowing.com/babysteps/blog/2018/10/31/mir-based-borrowck-is-almost-here/</link><description><![CDATA[Now that the final Rust 2018 Release Candidate has shipped, I thought it would be a good idea to do another update on the state of the MIR-based borrow check (aka NLL). Let’s get the highlights out of the way. Most importantly, Rust 2018 crates will use NLL by default. Once the Rust 2018 release candidate becomes stable, we plan to switch Rust 2015 crates to use NLL as well, but we’re holding off until we have some more experience with people using it in the wild.]]></description><guid isPermaLink="false">3c73e50b-c4cd-43ea-9214-49f711bf3058</guid><pubDate>Wed, 31 Oct 2018 00:00:00 -0400</pubDate><dc:creator>Niko Matsakis</dc:creator></item><item><title>Shifgrethor IV: Tracing</title><link>https://boats.gitlab.io/blog/post/shifgrethor-iv/</link><description><![CDATA[The post before this one covered how shifgrethor handles rooting: how we track for the garbage collector that this object is alive. That isn’t sufficient for implementing a tracing garbage collector though: the idea of a tracing garbage collector is that we can trace from rooted objects through all of the objects they reference. That way, instead of having to root everything you use, you can only root a few objects from which all of the live objects can be traced.]]></description><guid isPermaLink="false">57fd5a7a-0eb0-43fd-bf99-5b8a6a0e782c</guid><pubDate>Wed, 31 Oct 2018 00:00:00 +0000</pubDate><dc:creator>withoutboats</dc:creator></item><item><title>Serverless Rust</title><link>https://medium.com/@softprops/serverless-rust-318732a3596</link><description><![CDATA[This is going to be the first post ( and hopefully not last ) in a series of posts about writing (and thinking about) serverless applications in Rust. Stay tuned…]]></description><guid isPermaLink="false">4b5e36d0-0775-48da-a6f9-ab19ce9a5aae</guid><pubDate>Tue, 30 Oct 2018 02:08:22 +0000</pubDate><dc:creator>Doug Tangren</dc:creator></item><item><title>Pyro - A fast, small and documented Entity Component System</title><link>https://maikklein.github.io/pyro-ecs/</link><description><![CDATA[In contrast to many other ECS, iteration in Pyro is fully linear. Different combinations of components always live in the same storage. The advantage is that iteration is always fully linear and no cache is wasted. The storage behind the scene is a SoA storage.]]></description><guid isPermaLink="false">092a372d-fa4a-48e7-8382-c85069e9a425</guid><pubDate>Tue, 30 Oct 2018 00:00:00 +0000</pubDate><dc:creator>Maik Klein</dc:creator></item><item><title>Qt applications with Cargo</title><link>https://www.vandenoever.info/blog/2018/10/30/building_qt_apps_with_cargo.html</link><description><![CDATA[This blog shows how Qt applications can be built with Cargo. The goal is to make compiling them as simple as installing Qt and running cargo build.]]></description><guid isPermaLink="false">d8946b80-5782-44b2-80d9-9ac2e18eb5d0</guid><pubDate>Tue, 30 Oct 2018 00:00:00 +0000</pubDate><dc:creator>Jos van den Oever</dc:creator></item><item><title>Announcing Gotham 0.3</title><link>https://gotham.rs/blog/release/2018/10/29/gotham-0.3.html</link><description><![CDATA[First of all, hello there! This is the first announcement after the call for maintainers back in summer, and includes the efforts of several new faces: @whitfin, @nyarly, @colinbankier. Together, as well as input from the original authors @bradleybeddoes and @smangelsdorf, we are the new maintainers of the Gotham project. Today we’re excited to announce the release of Gotham 0.3, which follows the evolution of the broader Rust ecosystem.]]></description><guid isPermaLink="false">77d7a663-c11c-476c-a180-a84d0edf2975</guid><pubDate>Mon, 29 Oct 2018 15:31:00 +0000</pubDate><dc:creator>@whitfin, @nyarly, @colinbankier</dc:creator></item><item><title>From Rust to beyond: The PHP galaxy</title><link>https://mnt.io/2018/10/29/from-rust-to-beyond-the-php-galaxy/</link><description><![CDATA[This blog post is part of a series explaining how to send Rust beyond earth, into many different galaxies. The galaxy we will explore today is the PHP galaxy. This post will explain what PHP is, how to compile any Rust program to C and then to a PHP native extension.]]></description><guid isPermaLink="false">6bf46601-8824-4e8e-b625-f3b6f9d074da</guid><pubDate>Mon, 29 Oct 2018 10:17:12 +0000</pubDate><dc:creator>Ivan Enderlin</dc:creator></item><item><title>Finding and fixing memory leaks in a Hyper application or &apos;How I Learned to Stop Worrying and Love the Allocator&apos;</title><link>https://blog.1aim.com/2018/10/finding-and-fixing-memory-leaks-in-a-hyper-application-or-how-i-learned-to-stop-worrying-and-love-the-allocator/</link><description><![CDATA[I was doing some initial load testing of the next version our application, so that performance regressions can be tracked, when I noticed something. After only a few seconds of throwing wrk at it, our backend was using 1.3GB of memory, growing at around 50MB/s. Yikes.]]></description><guid isPermaLink="false">1f6655e8-89c4-4e30-91e6-776449b88293</guid><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><dc:creator>Ferdia McKeogh</dc:creator></item><item><title>Auth Web Microservice with rust using Actix-Web - Part 2</title><link>https://hgill.io/posts/auth-microservice-rust-actix-web-diesel-complete-tutorial-part-2/</link><description><![CDATA[Picking up from part one, we now have as server that takes an email address from a request and spits out a JSON response with an invitation object. In part one I said that we will send an email to the user, after some thought and feedback, we will be skipping this part now (look out for part 3). For now we will use the http response from the server to verify the email so to speak.]]></description><guid isPermaLink="false">268e1717-7988-4cb0-83e4-f4c902a969a8</guid><pubDate>Sun, 28 Oct 2018 13:02:37 +0100</pubDate><dc:creator>Harry Gill</dc:creator></item><item><title>The Embedded Working Group Newsletter - Embedded on Stable!</title><link>https://rust-embedded.github.io/blog/2018-10-28-newsletter-14/</link><description><![CDATA[This is a special "spotlight" edition of the newsletter, where we look at a few topics in a bit more detail: Embedded Rust Applications on Stable, Cortex-A team, shared-bus, and more.]]></description><guid isPermaLink="false">13502f64-39c2-4eae-9825-b68c2056bc66</guid><pubDate>Sun, 28 Oct 2018 00:00:00 +0000</pubDate><dc:creator>The Embedded Working Group</dc:creator></item><item><title>My release checklist for Rust programs</title><link>https://dev.to/sharkdp/my-release-checklist-for-rust-programs-1m33</link><description><![CDATA[After some practice with three of my Rust projects (fd, hyperfine and bat), my workflow has converged to something that works quite well and avoids many pitfalls that I have walked into in the past. My hope in writing this post is that this process can be useful for others as well. The following is my release checklist for fd, but I have very similar lists for other projects.]]></description><guid isPermaLink="false">e5f786a1-6dd9-427f-8202-03b5a38a7ace</guid><pubDate>Sun, 28 Oct 2018 00:00:00 +0000</pubDate><dc:creator>David Peter</dc:creator></item><item><title>2d graphics in Rust discussion - A look at GPU memory management</title><link>https://nical.github.io/posts/rust-2d-graphics-02.html</link><description><![CDATA[In this post I'll write about an piece of the low level details of an hypothetical rust 2d graphics crate built on top of gfx-hal. Gfx provides a vulkan-like interface implemented on top of vulkan, d3d12, metal or flavors of OpenGL. just like the previous post this is in the context of recent discussions about a 2d graphics crate in rust.]]></description><guid isPermaLink="false">7141c453-0f38-4d85-a3bd-f01abc08ad77</guid><pubDate>Sun, 28 Oct 2018 00:00:00 +0200</pubDate><dc:creator>Nical</dc:creator></item><item><title>Improving ndarray-csv: Goodbye failure, Hello Extension Traits</title><link>https://paulkernfeld.com/2018/10/27/improving-ndarray-csv.html</link><description><![CDATA[Two weeks ago, I wrote a blog post explaining some design decisions that I made for the ndarray-csv crate. Based on some excellent Reddit comments and GitHub issues from dtolnay, I have amended some of these decisions.]]></description><guid isPermaLink="false">427d9cb0-4562-45c7-b6f0-3defc4df172b</guid><pubDate>Sat, 27 Oct 2018 00:00:00 +0000</pubDate><dc:creator>Paul Kernfeld</dc:creator></item><item><title>Problems Scaling A Large Multi-Crate Rust Project</title><link>https://robert.ocallahan.org/2018/10/problems-scaling-large-multi-crate-rust.html?m=1</link><description><![CDATA[We have 85K lines of Rust code implementing the backend of our Pernosco debugger. To impose some modularity constraints and to reduce build times, from the beginning we organized our code as a large set of crates in a single Cargo workspace in a single Gitlab repository. Currently we have 48 crates. This has mostly worked pretty well but as the number of our crates keeps increasing, we have hit some serious scalability problems.]]></description><guid isPermaLink="false">e64df9c0-3056-4720-837e-670543317c59</guid><pubDate>Thu, 25 Oct 2018 00:00:00 +0000</pubDate><dc:creator>Robert O&apos;Callahan</dc:creator></item><item><title>10x Your JavaScript With WASM And Rust</title><link>https://blog.x5ff.xyz/blog/azure-functions-wasm-rust-ai/</link><description><![CDATA[This is part four in a series of Rust on Azure Functions. The other parts are about performance comparisons (part 1 and part 2), and explaining the PMX algorithm (part 3). If you want to learn more about Genetic Algorithms be sure to read part 3 first).]]></description><guid isPermaLink="false">8c9a2022-1124-47da-94c4-a85e808a257c</guid><pubDate>Thu, 25 Oct 2018 00:00:00 +0000</pubDate><dc:creator>Claus</dc:creator></item><item><title>The Case For Macros</title><link>https://llogiq.github.io/2018/10/25/macros.html</link><description><![CDATA[I know a few Rustaceans who are wary of macros. One privately admitted to hating them with a passion. They are right; macros can make code harder to understand (both for humans and computers, for example many clippy lints have an explicit check to only lint outside of macros), so they should be used with some caution.]]></description><guid isPermaLink="false">451e814b-f0e1-4d88-bdda-9862ab107902</guid><pubDate>Thu, 25 Oct 2018 00:00:00 +0000</pubDate><dc:creator>Llogiq</dc:creator></item><item><title>Parsing logs 230x faster with Rust</title><link>https://andre.arko.net/2018/10/25/parsing-logs-230x-faster-with-rust/</link><description><![CDATA[Perhaps surprisingly, one of the most challenging things about operating RubyGems.org is the logs. A single day of request logs is usually around 500 gigabytes on disk. So every day, we generate about 500 files that are 85MB on disk, and contain about a million streaming JSON objects that take up 1GB when uncompressed. What we want out of those files is incredibly tiny—a few thousand integers, labelled with names and version numbers. Without any real idea of how to get those counts out of S3, I started by writing a proof of concept Ruby script that could parse one of the 500 log files and print out stats from it. Even on my super-fast laptop, my prototype script would take more than 16 hours to parse 24 hours worth of logs.]]></description><guid isPermaLink="false">80d71718-3acf-49d1-ad47-3e05c5da17a2</guid><pubDate>Thu, 25 Oct 2018 00:00:00 +0000</pubDate><dc:creator>Andre Arko</dc:creator></item><item><title>Announcing Rust 1.30</title><link>https://blog.rust-lang.org/2018/10/25/Rust-1.30.0.html</link><description><![CDATA[The Rust team is happy to announce a new version of Rust, 1.30.0. Rust 1.30 is an exciting release with a number of features: Procedural Macros, Module system improvements, Raw Identifiers, and more.]]></description><guid isPermaLink="false">3db4746e-d5ac-46c7-af24-a25e2db1b7d2</guid><pubDate>Thu, 25 Oct 2018 00:00:00 +0000</pubDate><dc:creator>The Rust Core Team</dc:creator></item><item><title>Summer School With The Rust Compiler</title><link>http://patshaughnessy.net/2018/10/24/summer-school-with-the-rust-compiler</link><description><![CDATA[Learning Rust is hard for everyone, but it’s even worse for me because I’ve been working with Ruby during past ten years. Switching to Rust from Ruby is leaving an anything-goes hippie commune to a summer school for delinquent programmers run by a sadistic and unforgiving teacher. Why would anyone use a compiler like this? The answer is simple: to learn how to write better code.]]></description><guid isPermaLink="false">a758c495-92fa-476d-9758-a916dc50c2f9</guid><pubDate>Wed, 24 Oct 2018 03:00:00 +0000</pubDate><dc:creator>Pat Shaughnessy</dc:creator></item><item><title>Shifgrethor III: Rooting</title><link>https://boats.gitlab.io/blog/post/shifgrethor-iii/</link><description><![CDATA[After the digression in the previous post, it’s time to get back to what I promised in the first post: a look at how shifgrethor handles rooting. Shifgrethor’s solution is somewhat novel and takes advantage of some of Rust’s specific features, so I want to start by looking briefly at some of the other options.]]></description><guid isPermaLink="false">88e3b29b-1f9a-41a2-bb8a-9f73310c0352</guid><pubDate>Wed, 24 Oct 2018 00:00:00 +0000</pubDate><dc:creator>withoutboats</dc:creator></item><item><title>Multithreading Rust and Wasm</title><link>https://rustwasm.github.io/2018/10/24/multithreading-rust-and-wasm.html</link><description><![CDATA[When WebAssembly was first shipped it was an MVP which, while minimal, has spawned a huge number of exciting projects which work today across all major browsers. Rust has capitalized on the wasm MVP’s success as well with tools like wasm-bindgen and wasm-pack by making the MVP feel less minimal. WebAssembly is yet more ambitious, though! Since inception it’s always been intended to extend the WebAssembly specification with new features and functionality.]]></description><guid isPermaLink="false">1025ea91-d834-4f58-97cc-dabcee3b86df</guid><pubDate>Wed, 24 Oct 2018 00:00:00 +0000</pubDate><dc:creator>Alex Crichton</dc:creator></item><item><title>Plumbing the Deps of the Crate: Caching Rust Docker Builds</title><link>https://mgattozzi.com/caching-rust-docker-builds/</link><description><![CDATA[Learn how to cache your Docker builds with Rust better so you don't keep downloading and building your deps over and over and over again!]]></description><guid isPermaLink="false">96f12355-f732-45f5-9ca2-d2e68bc741ab</guid><pubDate>Tue, 23 Oct 2018 03:32:10 +0000</pubDate><dc:creator>Michael Gattozzi</dc:creator></item><item><title>korq: Kubernetes Dynamic Log Tailing Utility</title><link>https://vertexclique.github.io/korq/</link><description><![CDATA[K∅RQ is used for tailing pod logs concurrently and following groups at once. It was basically a need to follow logs during deployment and see how instances behave during and after deployment. This is the main motive behind K∅RQ.]]></description><guid isPermaLink="false">fac60173-70f5-4682-a698-716cf05306ce</guid><pubDate>Tue, 23 Oct 2018 00:00:00 +0000</pubDate><dc:creator>Mahmut Bulut</dc:creator></item><item><title>Hardware Interrupts | Writing an OS in Rust</title><link>https://os.phil-opp.com/hardware-interrupts/</link><description><![CDATA[In this post we set up the programmable interrupt controller to correctly forward hardware interrupts to the CPU. To handle these interrupts we add new entries to our interrupt descriptor table, just like we did for our exception handlers. We will learn how to get periodic timer interrupts and how to get input from the keyboard.]]></description><guid isPermaLink="false">97757259-e11d-4a4f-88cb-2653ca3cb977</guid><pubDate>Tue, 23 Oct 2018 00:00:00 +0000</pubDate><dc:creator>Philipp Oppermann</dc:creator></item><item><title>Rust can be difficult to learn and frustrating, but it’s also the most exciting thing in software development in a long time</title><link>https://www.influxdata.com/blog/rust-can-be-difficult-to-learn-and-frustrating-but-its-also-the-most-exciting-thing-in-software-development-in-a-long-time/</link><description><![CDATA[I recently decided to put serious effort into learning the Rust programming language. I saw it coming up frequently in interesting projects (e.g. ripgrep) and kept hearing good things about it. My hesitation to picking up Rust since its 1.0 release in 2015 came from two fronts. First, I’m completely invested in Go because of InfluxDB. Second, I heard that it was not the easiest thing to learn. While I don’t normally shy away from difficult tasks, I was hesitant because I believe that many developer tools that take off do so because they are easy to use or give developers significant productivity gains. More often than not, I want to invest my time in tools that I think have longevity that will get some critical mass in the market.]]></description><guid isPermaLink="false">fae7cb69-a7bf-4cb1-9d1d-f5e703312ef7</guid><pubDate>Mon, 22 Oct 2018 18:45:16 +0000</pubDate><dc:creator>Paul Dix</dc:creator></item><item><title>My Experience With Learning Rust</title><link>https://medium.com/@nathanielbarragan/my-experience-with-learning-rust-bbcb6b7c1063</link><description><![CDATA[Although I didn’t start writing this blog when I started writing in Rust, I remember clearly why I started writing in Rust. From what I had been doing in C#, none of it utilized multiple threads. Multi-threaded programming had always been a sore topic for me. Things like thread synchronization and message passing never really made sense to me. I learned Rust mainly due to its promises for ease of programming for multiple threads. Once hearing that things like parts of Firefox were written using it, and the Mozilla themselves were very strongly invested in Rust, I had more reason to start writing in it. I’d assume that if Mozilla were to invest so much in a programming language, it must have some sort of benefits over your usual C and C++ programming languages. Even further than that, I’ve heard of some game studios adopting Rust in their games and I was pretty much hooked at that point.]]></description><guid isPermaLink="false">60825132-c54b-4297-9f81-936601b76f64</guid><pubDate>Mon, 22 Oct 2018 02:29:02 +0000</pubDate><dc:creator>Nathaniel Barragan</dc:creator></item><item><title>Release of glsl-quasiquote-0.2 with support for GLSL pragmas</title><link>https://phaazon.net/blog/glsl-quasiquote-0.2</link><description><![CDATA[glsl-quasiquote-0.2 was released early this morning. This new version provides a more stable public API. Two major changes: The glsl_str! proc-macro would have only survived the 0.1 version. It’s now deprecated and will be removed soon. The glsl! proc-macro now supports GLSL pragmas (both #version and #extension).]]></description><guid isPermaLink="false">0367445a-ecf2-4c7a-9829-1b38d731036c</guid><pubDate>Mon, 22 Oct 2018 02:00:00 +0000</pubDate><dc:creator>Dimitri Sabadie</dc:creator></item><item><title>Rust&apos;s Orphan Rule Is Good, Actually</title><link>https://davidlegare.ghost.io/rusts-orphan-rule/</link><description><![CDATA[The orphan trait rule in Rust is interesting and works impressively well for what it intends to do. While I'm often frustrated by the limitations it imposes, it absolutely succeeds at removing ambiguity in whether or not a trait will be implemented for a type.]]></description><guid isPermaLink="false">c2e61957-0d95-43e3-af09-3173307bf95c</guid><pubDate>Sat, 20 Oct 2018 05:42:04 +0000</pubDate><dc:creator>David LeGare</dc:creator></item><item><title>Rust Mesh Optimizer</title><link>https://www.wihlidal.com/blog/pipeline/2018-10-20-rust-mesh-optimizer/</link><description><![CDATA[When triangle meshes are rendered by a GPU, there are pipeline stages that need to load and process vertex and index data. The efficiency of this process will depend on the layout of the data, and how the GPU is designed. There is an excellent library from Arseny Kapoulkine called meshoptimizer, which provides a variety of algorithms for optimizing geometry for the GPU.]]></description><guid isPermaLink="false">ec7874f9-e0a0-453b-b723-bdcb56e8ad09</guid><pubDate>Sat, 20 Oct 2018 00:00:00 +0000</pubDate><dc:creator>Graham Wihlidal</dc:creator></item><item><title>Towards fearless SIMD</title><link>https://raphlinus.github.io/rust/simd/2018/10/19/fearless-simd.html</link><description><![CDATA[SIMD is a powerful performance technique, and is especially valuable in signal and image processing applications. I will be using it very extensively in my synthesizer, and also it’s increasingly used in xi-editor to optimize string comparisons and similar primitives.]]></description><guid isPermaLink="false">4f32d4ec-419f-4025-b508-3c486ffb059e</guid><pubDate>Fri, 19 Oct 2018 17:03:42 +0000</pubDate><dc:creator>Raph Levien</dc:creator></item><item><title>Rust RwLock and Mutex Performance Oddities</title><link>https://fy.blackhats.net.au/blog/html/2018/10/19/rust_rwlock_and_mutex_performance_oddities.html</link><description><![CDATA[Recently I have been working on Rust datastructures once again. In the process I wanted to test how my work performed compared to a standard library RwLock and Mutex. On my home laptop the RwLock was 5 times faster, the Mutex 2 times faster than my work.

So checking out my code on my workplace workstation and running my bench marks I noticed the Mutex was the same - 2 times faster. However, the RwLock was 4000 times slower.]]></description><guid isPermaLink="false">8157d765-72cb-40a0-b59f-6b4ae2ae173d</guid><pubDate>Fri, 19 Oct 2018 00:00:00 +0000</pubDate><dc:creator>firstyear</dc:creator></item><item><title>Is Rust functional?</title><link>https://www.fpcomplete.com/blog/2018/10/is-rust-functional</link><description><![CDATA[Rust is an imperative systems programming language. Why does it have so much attention from functional programming advocates? Is it hiding a functional nature?]]></description><guid isPermaLink="false">b39581e7-2147-4b4a-bfdf-b19141e80d89</guid><pubDate>Thu, 18 Oct 2018 03:02:08 +0000</pubDate><dc:creator>Michael Snoyman</dc:creator></item><item><title>Rust has higher kinded types already... sort of</title><link>https://joshlf.com/post/2018/10/18/rust-higher-kinded-types-already/</link><description><![CDATA[In Rust, a type which takes type parameters (Rc<T>, Vec<T>, HashMap<K, V>, etc) is only a valid type when all type parameters are specified. In other words, Rc, Vec, and HashMap<K> are not types. You can’t have a variable of type Rc. You can’t pass Rc as a parameter to other types. The ability to have such things be actual types is a feature called higher kinded types (HKT).]]></description><guid isPermaLink="false">4c54199d-d367-4525-8202-cba2c82afa3d</guid><pubDate>Thu, 18 Oct 2018 00:00:00 +0000</pubDate><dc:creator>Joshua Liebow-Feeser</dc:creator></item><item><title>Serverless Rust with AWS Lambda and WebAssembly</title><link>https://blog.scottlogic.com/2018/10/18/serverless-rust.html</link><description><![CDATA[In this post, I look at how WebAssembly can be used to create serverless functions and demonstrate an AWS Lambda function written entirely in Rust.]]></description><guid isPermaLink="false">c1a9ce3b-fd19-4285-b465-ab7607792297</guid><pubDate>Thu, 18 Oct 2018 00:00:00 +0000</pubDate><dc:creator>Colin Eberhardt</dc:creator></item><item><title>Serverless Rust with Cloudflare Workers</title><link>https://blog.cloudflare.com/cloudflare-workers-as-a-serverless-rust-platform/</link><description><![CDATA[It's exciting times for Rust developers. Cloudflare's Serverless Platform, Cloudflare Workers, allows you to compile your code to WASM, upload to 150+ data centers and invoke those functions just as easily as if they were JavaScript functions. Today I'm going to convert my lipsum generator to use Rust and explore the developer experience (hint: it's already pretty nice).]]></description><guid isPermaLink="false">0c92d9d7-26ba-4152-9820-08ef1011689d</guid><pubDate>Tue, 16 Oct 2018 12:00:00 +0000</pubDate><dc:creator>Steven Pack</dc:creator></item><item><title>Configuration envy</title><link>https://medium.com/@softprops/configuration-envy-a09584386705</link><description><![CDATA[For many of my use cases for running Rust applications, storing configuration in file format is less attractive as I’m typically running Rust inside docker containers and container orchestrators typically encourage the use of standard interfaces like the env for configuration. So I pondered 🤔, “What if I could treat my program’s env parameterization with the same level of typing I treat my functions and enclosing types with while getting everything one get’s from using serde for free?” That would be the bee’s knees 🐝 . Enter: envy.]]></description><guid isPermaLink="false">2e4df02b-88e0-4510-851a-d1dce6014568</guid><pubDate>Tue, 16 Oct 2018 04:17:18 +0000</pubDate><dc:creator>Doug Tangren</dc:creator></item><item><title>Routing and extraction in Tide: a first sketch</title><link>https://rust-lang-nursery.github.io/wg-net/2018/10/16/tide-routing.html</link><description><![CDATA[This post continues the series on Tide, sketching a possible design for routing and extraction that combines some of the best ideas from frameworks like Rocket, Actix, and Gotham.]]></description><guid isPermaLink="false">7141f981-74d7-4df6-9ce2-b857fff58557</guid><pubDate>Tue, 16 Oct 2018 00:00:00 +0000</pubDate><dc:creator>Aaron Turon</dc:creator></item><item><title>Shifgrethor I: Garbage collection as a Rust library</title><link>https://boats.gitlab.io/blog/post/shifgrethor-i/</link><description><![CDATA[I’m really excited to share with you an experiment that I’ve been working on for the past 5 or 6 weeks. It’s a Rust library called shifgrethor. shifgrethor implements a garbage collector in Rust with an API I believe to be properly memory safe.
I’ll be going through all of the technical details in future blog posts, so I want to kick this series off with a high level overview of the project’s purpose and design decisions.]]></description><guid isPermaLink="false">b138af7a-2e74-44c1-b362-03af475f050b</guid><pubDate>Tue, 16 Oct 2018 00:00:00 +0000</pubDate><dc:creator>withoutboats</dc:creator></item><item><title>Pi-hole: Announcing Our RESTful API</title><link>https://pi-hole.net/2018/10/15/announcing-our-restful-api-contributions-welcome/</link><description><![CDATA[The API is written in Rust, a language new to the Pi-hole project. Rust is a safe and fast language which matches well with our goals for the API. It is statically typed and prevents whole categories of errors while being productive and extendable.]]></description><guid isPermaLink="false">0c44f78b-c47a-4be2-9e30-4fa129304a9c</guid><pubDate>Mon, 15 Oct 2018 13:00:33 +0000</pubDate><dc:creator>Pi-hole</dc:creator></item><item><title>Const-fn compile-time SUBLEQ interpreter</title><link>https://www.reddit.com/r/rust/comments/9o6vzo/constfn_compiletime_subleq_interpreter/</link><description><![CDATA[With the minimal subset of const fn becoming stable soon (in the second next Rust version), I wanted to give const fns a try and test what is possible with them. We implemented a compile-time SUBLEQ interpreter which only uses const-fns, which you can find on the playground. Let's walk through the process of building this abomination :)]]></description><guid isPermaLink="false">e7b5dffe-46bb-42a8-a17c-2ede829080ff</guid><pubDate>Mon, 15 Oct 2018 09:10:49 +1100</pubDate><dc:creator>u/oberien</dc:creator></item><item><title>ruplacer: find and replace text in source files</title><link>https://dmerej.info/blog/post/ruplacer/</link><description><![CDATA[Today I’d like to talk about a command-line tool I’ve been working on. It’s called ruplacer and as the name suggest, it’s rually cool and written in Rust. Basically, it finds and replaces text in source files.]]></description><guid isPermaLink="false">2657be5e-f98f-48a7-9e0a-c4ad2c183cba</guid><pubDate>Sun, 14 Oct 2018 12:34:43 +0000</pubDate><dc:creator>Dimitri Merejkowsky</dc:creator></item><item><title>Amethyst is growing; news on ongoing projects</title><link>https://www.amethyst.rs/blog/dev-news-10-2018/</link><description><![CDATA[We want to share some of the progress being made on Amethyst! As we've had a lot of expansion, we've also revamped the way we manage the project and we have some very interesting new features being worked on.]]></description><guid isPermaLink="false">7abf3b08-b87f-4bd1-a4f4-4d79f4216413</guid><pubDate>Sun, 14 Oct 2018 00:00:00 +0000</pubDate><dc:creator>Moxinilian (Théo Degioanni)</dc:creator></item><item><title>Rust and features discoverability</title><link>https://phaazon.net/blog/rust-features-documentation</link><description><![CDATA[Whatever the project you work on, you should must document your code. There are several situations – let’s call this the First Hypothesis]]></description><guid isPermaLink="false">476c5ab3-1148-4507-b294-8e4c06a188fd</guid><pubDate>Sat, 13 Oct 2018 23:37:00 +0000</pubDate><dc:creator>Dimitri Sabadie</dc:creator></item><item><title>Following up on the 2d graphics in Rust discussion</title><link>https://nical.github.io/posts/rust-2d-graphics-01.html</link><description><![CDATA[Ralph Levien recently published A crate I want: 2d graphics on his blog, which started some interesting discussions on reddit. At the same time there is a nascent discussion on the draw2d repository (which doesn't have any code at this point) about a potential 2d graphics crate.]]></description><guid isPermaLink="false">3d3a61ed-ff74-4407-b508-0c7405b8c653</guid><pubDate>Sun, 14 Oct 2018 00:00:00 +0200</pubDate><dc:creator>Nical</dc:creator></item><item><title>Reflections on Implementing the ndarray-csv Crate</title><link>https://paulkernfeld.com/2018/10/13/ndarray-csv-reflections.html</link><description><![CDATA[Recently, I wrote ndarray-csv, a Rust crate for converting between CSV files and 2D arrays. There are already crates for CSV and arrays, so how exciting could this possibly be? Actually, there was a lot more to it than I had thought: although it started out as a two-hour project, I ended up rewriting the entire thing three times!]]></description><guid isPermaLink="false">11700b19-9b9f-44c3-9708-2c4cd7f0d721</guid><pubDate>Sat, 13 Oct 2018 00:00:00 +0000</pubDate><dc:creator>Paul Kernfeld</dc:creator></item><item><title>Building a command-line todo app in Rust</title><link>https://medium.com/@devashishdxt/building-a-command-line-todo-app-in-rust-a89bb7af91c3</link><description><![CDATA[In this tutorial, we are going to create a simple command-line todo app. By the end of this tutorial, you should have a basic understanding of Rust programming language, building command-line apps in Rust, and performing file-system operations in Rust.]]></description><guid isPermaLink="false">ceb7c2a6-d905-4b13-8f42-4aa42cd9b3e3</guid><pubDate>Fri, 12 Oct 2018 13:14:56 +0000</pubDate><dc:creator>Devashish Dixit</dc:creator></item><item><title>A crate I want: 2d graphics</title><link>https://raphlinus.github.io/rust/graphics/2018/10/11/2d-graphics.html</link><description><![CDATA[The Rust ecosystem has lot of excellent crates, and many more new ones being published. I believe one is missing, though, and I’d really like to see it happen: a cross-platform abstraction for 2D graphics. In this post I will set out what I want.]]></description><guid isPermaLink="false">63fef91b-3a2c-4b05-9fad-bc5a80bd1733</guid><pubDate>Thu, 11 Oct 2018 22:44:03 +0000</pubDate><dc:creator>Raph Levien</dc:creator></item><item><title>Rust Programming with Dynamsoft Barcode Reader</title><link>https://medium.com/@yushulx/rust-programming-with-dynamsoft-barcode-reader-3d1e83004bba</link><description><![CDATA[A few days ago, I accepted a new challenge of creating a simple command line barcode reader using Rust and Dynamsoft Barcode Reader SDK. Rust is a system programming language similar to C++. The learning process did not go through smoothly as I expected. It is not as easy as learning other high-level programming languages such as Java and Python. In this article, I share my experience of learning and using Rust.]]></description><guid isPermaLink="false">cb2bfe24-75a2-43d6-bebc-b8f8ac610c95</guid><pubDate>Thu, 11 Oct 2018 00:26:20 +0000</pubDate><dc:creator>Xiao Ling</dc:creator></item><item><title>Game Dev From Zero - Part 1: Hello</title><link>https://hashnode.com/post/game-dev-from-zero-part-1-hello-rust-lang-cjn3brwto001jv7s2e533bdfc</link><description><![CDATA[With this article, I want to introduce you to game development. I want to give you a little tour of where to start, how to explore possibilities and revive my journey a little bit at the same time. I will try to construct different games from the ground up while writing this article, so you can experience game-dev live.]]></description><guid isPermaLink="false">9a9651de-466e-411e-9449-c1d6878ffba0</guid><pubDate>Thu, 11 Oct 2018 00:00:00 +0000</pubDate><dc:creator>Marco Alka</dc:creator></item><item><title>imag: Call for Participation (1)</title><link>https://imag-pim.org/blog/2018/10/10/call-for-participation-1/</link><description><![CDATA[This is the first call for participation for the imag project. I have no experience writing such calls for participation, so please bear with me!

Right now, the imag ecosystem has some tools available which are already usable and in rather good shape. There is a contact manager, a diary and a notes tool, a habit tracker and a time tracker are there as well, though those are not extensively tested by now.]]></description><guid isPermaLink="false">2b068be3-88b7-4d60-ad38-cfd40019cf5f</guid><pubDate>Wed, 10 Oct 2018 08:42:06 +0000</pubDate><dc:creator>imag</dc:creator></item><item><title>Fixing a Clippy crash</title><link>https://phansch.net/2018/10/10/fixing-a-clippy-crash/</link><description><![CDATA[3 weeks ago I set out to fix a crash in Clippy, this is what I learned along the way. I hope this blog post will be useful for other people diving into Clippy and maybe serve as motivation if things get difficult.]]></description><guid isPermaLink="false">08336620-497d-49b2-9e77-eeb36d26f512</guid><pubDate>Wed, 10 Oct 2018 00:00:00 +0000</pubDate><dc:creator>Philipp Hansch</dc:creator></item><item><title>Rust has a static garbage collector</title><link>https://words.steveklabnik.com/borrow-checking-escape-analysis-and-the-generational-hypothesis</link><description><![CDATA[I’ve often seen people make statements like this one, from the Rust subreddit this morning, "Manual memory management requires more work than garbage collected. Its a trade off of course to be more performant or use lower resources. When and where should Rust be used or not used according to you?". While I don’t completely disagree with this sentiment, it’s also never quite sat right with me. Yes, Rust is a bit harder at the start, but once you get over a hump, I don’t generally find writing Rust to be significantly harder than using a GC’d language. I’ve been trying to figure out why that is.]]></description><guid isPermaLink="false">a3b6b34c-174b-4738-9c06-c9ab251718c4</guid><pubDate>Wed, 10 Oct 2018 00:00:00 +0000</pubDate><dc:creator>Steve Klabnik</dc:creator></item><item><title>Rust SGX SDK v1.0.4 Released</title><link>https://medium.com/baiduxlab/rust-sgx-sdk-v1-0-4-released-9c7d9056a888</link><description><![CDATA[Rust SGX SDK, maintained by Baidu X-Lab, is a convenient framework to develop secure trusted computing applications for Intel SGX enclaves. Based on it, developers can easily build trusted SGX enclaves with memory safety guarantees. This adds an extra strong (and strongest ever) security layer over the SGX isolation, further keeping attackers away from the secrets in enclave even if they compromised the privileged software environment (operating system, hypervisor, etc.). Rust SGX SDK thus means a lot to privacy protection and trusted computing on public cloud platforms and blockchains.]]></description><guid isPermaLink="false">620115c2-e4f9-4c5c-953a-d891cc636b01</guid><pubDate>Tue,  9 Oct 2018 17:50:10 +0000</pubDate><dc:creator>Baidu X-Lab</dc:creator></item><item><title>Remacs continues to improve</title><link>http://db48x.net/rust-remacs-2018/</link><description><![CDATA[As you doubtless know, Emacs has an embedded Lisp environment that provides a large number of intersting Lisp functions that the user can call. Many of these are implemented in C for speed, and we've been rewriting them in Rust. So far we've ported 394 individual Lisp functions from C to Rust, of which 207 were ported in this last year. This is about a third of the total, as you can see by this graph. We've actually completely ported several whole C files now.]]></description><guid isPermaLink="false">49cace2a-ebaf-4aec-b41b-8fb7aa67acc8</guid><pubDate>Tue,  9 Oct 2018 12:35:00 +0000</pubDate><dc:creator>db48x</dc:creator></item><item><title>Noria: dynamic, partially-stateful data-flow for high-performance web applications</title><link>https://www.usenix.org/conference/osdi18/presentation/gjengset</link><description><![CDATA[We introduce partially-stateful data-flow, a new streaming data-flow model that supports eviction and reconstruction of data-flow state on demand. By avoiding state explosion and supporting live changes to the data-flow graph, this model makes data-flow viable for building long-lived, low-latency applications, such as web applications. Our implementation, Noria, simplifies the backend infrastructure for read-heavy web applications while improving their performance.

A Noria application supplies a relational schema and a set of parameterized queries, which Noria compiles into a data-flow program that pre-computes results for reads and incrementally applies writes. Noria makes it easy to write high-performance applications without manual performance tuning or complex-to-maintain caching layers. Partial statefulness helps Noria limit its in-memory state without prior data-flow systems’ restriction to windowed state, and helps Noria adapt its data-flow to schema and query changes while on-line. Unlike prior data-flow systems, Noria also shares state and computation across related queries, eliminating duplicate work.

On a real web application’s queries, our prototype scales to 5× higher load than a hand-optimized MySQL baseline. Noria also outperforms a typical MySQL/memcached stack and the materialized views of a commercial database. It scales to tens of millions of reads and millions of writes per second over multiple servers, outperforming a state-of-the-art streaming data-flow system.]]></description><guid isPermaLink="false">b2cb0409-6147-4d84-8261-734f17fda39c</guid><pubDate>Tue,  9 Oct 2018 11:14:00 +0000</pubDate><dc:creator>Jon Gjengset, Malte Schwarzkopf, Jonathan Behrens, and Lara Timbó Araújo</dc:creator></item><item><title>Rust and the Three Laws of Informatics</title><link>https://medium.com/@schemouil/rust-and-the-three-laws-of-informatics-4324062b322b</link><description><![CDATA[What are the most important properties of programs, and how much do existing languages help? How is Rust different?]]></description><guid isPermaLink="false">0f56caac-74c9-414c-89d5-fe1cb9a74424</guid><pubDate>Tue,  9 Oct 2018 07:42:09 +0000</pubDate><dc:creator>Simon Chemouil</dc:creator></item><item><title>Gfx-hal Tutorial part 2: Vertex buffers</title><link>https://falseidolfactory.com/2018/10/09/gfx-hal-part-2-vertex-buffers.html</link><description><![CDATA[For the last two parts of this tutorial, all we’ve had to look at on-screen is a single blueish triangle. In this part, we want to display a more complex shape, with more variation in color. To do this, we’ll have to stop hard-coding our triangle mesh in the vertex shader. (And start hard-coding it in the source code!)]]></description><guid isPermaLink="false">1ac9419e-3a15-4c2e-961d-20160f9ef6e9</guid><pubDate>Tue,  9 Oct 2018 00:00:00 +0000</pubDate><dc:creator>Mistodon</dc:creator></item><item><title>New crate: pin-cell</title><link>https://boats.gitlab.io/blog/post/pin-cell/</link><description><![CDATA[Today I realized a new crate called pin-cell. This crate contains a type called PinCell, which is a kind of cell that is similar to RefCell, but only can allow pinned mutable references into its interior. Right now, the crate is nightly only and no-std compatible.
How is the API of PinCell different from RefCell? When you call borrow_mut on a RefCell, you get a type back that implements DerefMut, allowing you to mutate the interior value.]]></description><guid isPermaLink="false">9ed3a1ea-2c0d-4508-a2d7-69e9bb07557a</guid><pubDate>Tue,  9 Oct 2018 00:00:00 +0000</pubDate><dc:creator>withoutboats</dc:creator></item><item><title>Notes on Type Layouts and ABIs in Rust</title><link>https://gankro.github.io/blah/rust-layouts-and-abis/</link><description><![CDATA[Over the years I've found myself with a weird amount of knowledge about how types and ABIs in Rust work, and I wanted to write it all down in one place so that... it's written down in one place. Much of this information can or should be found in the Rust Language Reference and the Rustonomicon.]]></description><guid isPermaLink="false">492f5ab9-f95c-480b-8377-dc2f06e836b8</guid><pubDate>Tue,  9 Oct 2018 00:00:00 +0000</pubDate><dc:creator>Alexis Beingessner</dc:creator></item><item><title>Porting C (minimp3) To Rust</title><link>https://wiki.alopex.li/PortingCToRust</link><description><![CDATA[So because it seemed like a good idea at the time, I decided to port the minimp3 library from C to Rust. I want a pure Rust MP3 decoder crate to exist under a permissive license, I wanted to learn a few things about the MP3 file format, and it seemed small enough to do in a single weekend. (In reality it was largely done in about a week.) I’m quite good at Rust, and I’m okay at C (but rusty; hah!), and I know nothing at all about MP3 decoding. So, it was a fun learning experience. It was very interesting seeing how C and Rust’s different feature set changed how the programs were written. minimp3 turned out to be a good choice for this, since it is standalone, pretty well-written C as far as I can tell, does nothing that needs to be unsafe, and small but not trivial. This article is an attempt to organize my thoughts, notes and observations as I went about the project, in the hopes that it will be useful or at least interesting to someone else.]]></description><guid isPermaLink="false">ab2b9642-16a3-4d28-9f8b-5f6938964600</guid><pubDate>Mon,  8 Oct 2018 19:53:10 +0000</pubDate><dc:creator>Simon Heath</dc:creator></item></channel></rss>