<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/"><channel><title>Read Rust - All Posts</title><link>https://readrust.net/</link><description>All Posts posts on Read Rust</description><item><title>Riker - a framework for building modern, concurrent and resilient systems using the Rust language using the actor model</title><link>https://riker.rs/</link><description><![CDATA[Riker is a framework for building modern, concurrent and resilient systems using the Rust language. Riker aims to make working with state and behavior in concurrent systems as easy and scalable as possible. The Actor Model has been chosen to realize this because of the familiar and inherent simplicity it provides while also providing strong guarantees that are easy to reason about. The Actor Model also provides a firm foundation for resilient systems through the use of the actor hierarchy and actor supervision.]]></description><guid isPermaLink="false">3fc0a35d-5eab-4143-98d5-7325738364e4</guid><pubDate>Tue,  8 Oct 2019 00:00:00 +0000</pubDate><dc:creator>Riker</dc:creator></item><item><title>Announcing Bastion 0.2.0!</title><link>https://www.reddit.com/r/rust/comments/day85g/announcing_bastion_020/</link><description><![CDATA[Bastion is a fault-tolerant runtime for Rust applications. After receiving plenty of good feedback from the community and a long-running development stage, now Bastion is 0.2.0!]]></description><guid isPermaLink="false">b2b15138-1280-44d7-95a0-9e5954a14b9a</guid><pubDate>Sun,  6 Oct 2019 04:16:30 +0000</pubDate><dc:creator>Mahmut Bulut</dc:creator></item><item><title>The &quot;Inside Rust&quot; Blog</title><link>https://blog.rust-lang.org/inside-rust/</link><description><![CDATA[This is the "Inside Rust" blog. This blog is aimed at those who wish to follow along with Rust development. The various Rust teams and working groups use this blog to post status updates, calls for help, and other similar announcements.]]></description><guid isPermaLink="false">55e7a635-29bd-4a2d-aaac-b0d599006ff7</guid><pubDate>Fri,  4 Oct 2019 01:18:00 +0000</pubDate><dc:creator>Niko Matsakis</dc:creator></item><item><title>The Embedded Working Group Newsletter - 19</title><link>https://rust-embedded.github.io/blog/newsletter-19/</link><description><![CDATA[This is the 19th newsletter of the Embedded WG where we highlight new progress, celebrate cool projects, thank the community, and advertise projects that need help!]]></description><guid isPermaLink="false">230003fc-89e8-4108-97d1-45f2d8b30dd8</guid><pubDate>Thu,  3 Oct 2019 00:00:00 +0000</pubDate><dc:creator>The Embedded Working Group</dc:creator></item><item><title>Roguelike Tutorial: Up-to-date and Literate</title><link>https://aimlesslygoingforward.com/blog/2019/10/02/roguelike-tutorial-up-to-date-and-literate/</link><description><![CDATA[This tutorial will show you how to write a roguelike in the Rust programming language and the libtcod library. In this update the Asciidoctor documents were changed to allow generating the final source files at the end of each chapter directly from the tutorial text.]]></description><guid isPermaLink="false">e3c786d5-955b-422a-b426-fcc3639d92c3</guid><pubDate>Wed,  2 Oct 2019 00:00:00 +0000</pubDate><dc:creator>Tomas Sedovic</dc:creator></item><item><title>Static Assertions 1.0</title><link>https://nikolaivazquez.com/posts/programming/rust-static-assertions-1_0/</link><description><![CDATA[static_assertions is a library designed to enable users to perform various checks at compile-time. It allows for finding errors quickly and early when it comes to ensuring certain features or aspects of a codebase. The macros it provides are especially important when exposing a public API that requires types to be the same size or implement certain traits.]]></description><guid isPermaLink="false">e2d3a9d7-cc8b-4cd5-8d5b-3bb986487601</guid><pubDate>Wed,  2 Oct 2019 00:00:00 +0000</pubDate><dc:creator>Nikolai Vazquez</dc:creator></item><item><title>Happy First Birthday, Ferrous!</title><link>https://ferrous-systems.com/blog/happy-birthday-ferrous/</link><description><![CDATA[Ferrous Systems GmbH was fully incorporated in Berlin, on October 1st, 2018; which makes today Ferrous' first birthday! It's been a busy year (or really more than a year) for us, full of ups, downs, growth, challenges, stress, and opportunities, and it finally feels like the right time to write a bit more about it from a personal perspective.]]></description><guid isPermaLink="false">b909cef2-cf3b-4db8-b567-c230036a7adf</guid><pubDate>Tue,  1 Oct 2019 00:00:00 +0000</pubDate><dc:creator>James Munns</dc:creator></item><item><title>Project update</title><link>https://gfx-rs.github.io/2019/10/01/update.html</link><description><![CDATA[gfx-rs is a Rust project aiming to make low-level GPU programming portable with low overhead. It’s a single Vulkan-like Rust API with multiple backends that implement it: Direct3D 12/11, Metal, Vulkan, and even OpenGL. wgpu-rs is a Rust project on top of gfx-rs that provides safety, accessibility, and even stronger portability. This is an update that is not aligned to any dates or releases. We just want to share about some of the exciting work that landed recently, which will make it to the next release cycle.]]></description><guid isPermaLink="false">17460b05-a9d9-4c79-801c-2a2e54c5132f</guid><pubDate>Tue,  1 Oct 2019 00:00:00 +0000</pubDate><dc:creator>gfx-rs</dc:creator></item><item><title>Building the Azure IoT Edge Security Daemon in Rust</title><link>https://msrc-blog.microsoft.com/2019/09/30/building-the-azure-iot-edge-security-daemon-in-rust/</link><description><![CDATA[Azure IoT Edge is an open source, cross platform software project from the Azure IoT team at Microsoft that seeks to solve the problem of managing distribution of compute to the edge of your on-premise network from the cloud. This post explains some of the rationale behind our choice of Rust as the implementation programming language for the Security Daemon component in the product.]]></description><guid isPermaLink="false">f7d6bffe-ea86-4fbc-9aa6-4ba15b3929a5</guid><pubDate>Mon, 30 Sep 2019 16:45:48 +0000</pubDate><dc:creator>Microsoft Security Response Center</dc:creator></item><item><title>Plugins in Rust</title><link>http://adventures.michaelfbryan.com/posts/plugins-in-rust/</link><description><![CDATA[Imagine you are implementing a calculator application and want users to be able to extend the application with their own functionality. For example, imagine a user wants to provide a random() function that generates true random numbers using random.org instead of the pseudo-random numbers that a crate like rand would provide.

The Rust language gives you a lot of really powerful tools for adding flexibility and extensibility to your applications (e.g. traits, enums, macros), but all of these happen at compile time. Unfortunately, to get the flexibility that we’re looking we’ll need to be able to add new functionalty at runtime. This can be achieved using a technique called Dynamic Loading.]]></description><guid isPermaLink="false">7a86a452-ec34-4489-b209-f91aecdd6d98</guid><pubDate>Mon, 30 Sep 2019 22:04:58 +0800</pubDate><dc:creator>Michael-F-Bryan</dc:creator></item><item><title>Async-await hits beta!</title><link>https://blog.rust-lang.org/2019/09/30/Async-await-hits-beta.html</link><description><![CDATA[Big news! As of this writing, syntactic support for async-await is available in the Rust beta channel! It will be available in the 1.39 release, which is expected to be released on November 7th, 2019. Once async-await hits stable, that will mark the culmination of a multi-year effort to enable efficient and ergonomic asynchronous I/O in Rust. It will not, however, mark the end of the road: there is still more work to do, both in terms of polish (some of the error messages we get today are, um, not great) and in terms of feature set (async fn in traits, anyone?).]]></description><guid isPermaLink="false">fbf09d15-52c8-4ab6-a6bf-22c0b238aedb</guid><pubDate>Mon, 30 Sep 2019 00:00:00 +0000</pubDate><dc:creator>Niko Matsakis</dc:creator></item><item><title>Figthting The Async Fragmentation</title><link>https://vorner.github.io/2019/09/29/figthting-the-async-fragmentation.html</link><description><![CDATA[Sometimes, I get this nudging feeling that something is not exactly right and that I have to go out and save the world and fix it (even though it’s usually something minor or doesn’t need fixing at all). I guess everyone has days like these. It’s part what drives me to invest my free time to writing software.

This is about some dead ends when trying to fix the problem of Rust’s async networking fragmentation. I haven’t been successful, but I can at least share what I tried and discovered, maybe someone else is having the same bugging feeling so they don’t have to repeat them. Or just maybe some of the approaches would work for some other problems. And because we have a bunch of success stories out there, having some failure stories to balance it doesn’t hurt.]]></description><guid isPermaLink="false">51a1a155-fccb-426f-b0e5-f4670be28e9d</guid><pubDate>Sun, 29 Sep 2019 00:00:00 +0000</pubDate><dc:creator>Michal &apos;vorner&apos; Vaner</dc:creator></item><item><title>Binary Format Shootout</title><link>https://speice.io/2019/09/binary-format-shootout.html</link><description><![CDATA[Cap'n Proto vs. Flatbuffers vs. Simple Binary Encoding]]></description><guid isPermaLink="false">87600fb3-40d3-403e-87b7-25a3a2eacdcf</guid><pubDate>Sat, 28 Sep 2019 00:00:00 +0000</pubDate><dc:creator>Bradlee Speice</dc:creator></item><item><title>Sample REST API in Rust and Go</title><link>https://jmmv.dev/2019/09/rest-api-rust-go.html</link><description><![CDATA[Over the summer, I prototyped a bunch of web apps whose ideas had been floating in my mind for a long time. I spent quite a bit of time learning about REST APIs and, as part of these exercises, implemented skeletons of REST servers in both Go and Rust. The app prototypes have gone nowhere but I thought of sharing the skeletons I built if only to serve as templates for myself in future work. Thus, in this post, I will cover these skeleton demos and I will compare them.]]></description><guid isPermaLink="false">dcbe1901-b9b1-4eec-a44e-d6be0dcdd958</guid><pubDate>Fri, 27 Sep 2019 06:45:40 +0500</pubDate><dc:creator>Julio Merino</dc:creator></item><item><title>Announcing Rust 1.38.0</title><link>https://blog.rust-lang.org/2019/09/26/Rust-1.38.0.html</link><description><![CDATA[The highlight of this release is pipelined compilation. The release also includes linting of some incorrect uses of mem::{uninitialized, zeroed}, #[deprecated] macros, std::any::type_name, and more.]]></description><guid isPermaLink="false">d9b796b1-aacb-4a2f-ad7b-05ce22cc3ec1</guid><pubDate>Thu, 26 Sep 2019 00:00:00 +0000</pubDate><dc:creator>The Rust Release Team</dc:creator></item><item><title>Nushell 0.3.0</title><link>http://www.jonathanturner.org/2019/09/nushell_0_3_0.html</link><description><![CDATA[Nushell, or Nu for short, is a new shell that takes a modern, structured approach to your commandline. It works seamlessly with the data from your filesystem, operating system, and a growing number of file formats to make it easy to build powerful commandline pipelines. We’re happy to announce that today we’re releasing Nushell 0.3.0. Nu has seen numerous bugfixes, performance improvements, and features added since its initial public release (which was only a few weeks ago!)]]></description><guid isPermaLink="false">f449d35d-98c7-4460-9d42-d6641415e542</guid><pubDate>Tue, 24 Sep 2019 00:00:00 +0000</pubDate><dc:creator>Jonathan Turner</dc:creator></item><item><title>Build an NB-IoT GPS Tracker on STM32 L476 with Apache Mynewt and Embedded Rust</title><link>https://medium.com/@ly.lee/build-an-nb-iot-gps-tracker-on-stm32-l476-with-apache-mynewt-and-embedded-rust-8c095a925546</link><description><![CDATA[Let’s build an NB-IoT GPS Tracker! A simple gadget that determines its current location based on received GPS signals… And transmits the location to a server via NB-IoT. We shall take an existing Apache Mynewt Embedded OS + Embedded Rust project from the article “Rust Rocks NB-IoT! STM32 Blue Pill with Quectel BC95-G on Apache Mynewt”… And extend it with a GPS module: Quectel L70-R.]]></description><guid isPermaLink="false">c793ec07-09a1-4b5d-b3e6-f8b146178fbc</guid><pubDate>Sun, 22 Sep 2019 12:24:41 +0000</pubDate><dc:creator>Lup Yuen Lee</dc:creator></item><item><title>Async Builders</title><link>https://blog.yoshuawuyts.com/async-finalizers/</link><description><![CDATA[Last month we introduced Surf, an async cross-platform streaming HTTP client for Rust. It was met with a great reception, and people generally seem to be really enjoying it. A common piece of feedback we've gotten is how much people enjoy the interface, in particular how little code it requires to create HTTP requests. In this post we'll cover a pattern at the heart of Surf's ergonomics stjepang came up with: the "async finalizer".]]></description><guid isPermaLink="false">258e95ec-03a2-47b2-b577-cf45ad96924e</guid><pubDate>Sat, 21 Sep 2019 00:00:00 +0000</pubDate><dc:creator>Yoshua Wuyts</dc:creator></item><item><title>Of bitpacking, with or without SSE3</title><link>https://fulmicoton.com/posts/bitpacking/</link><description><![CDATA[This blog post might interest three type of readers: people interested in tantivy: You’ll learn how tantivy uses SIMD instructions to decode posting lists, and what happens on platform where the relevant instruction set is not available.  rustaceans who would like to hear a good SIMD in rust story. lucene core devs (yeah it is a very select club) who might be interested in a possible (unconfirmed) optimization opportunity.]]></description><guid isPermaLink="false">d7a12b5f-ab52-4e4b-b752-7d857e9f86bf</guid><pubDate>Fri, 20 Sep 2019 00:00:00 +0000</pubDate><dc:creator>Paul Masurel</dc:creator></item><item><title>Rust on the ESP32</title><link>https://mabez.dev/blog/posts/esp32-rust/</link><description><![CDATA[In March of 2019, Espressif released their first run at an llvm fork to support the xtensa architecure. Shortly after I got to work bootstrapping Rust to use this newly created fork. Prior to this project, I'd had no experience with the compiler, fortunately I came across the RISCV PR which gave me a rough idea of what was required. After many build attempts I finally got it working; I was now able to generate xtensa assembly from Rust source code!]]></description><guid isPermaLink="false">abac05ba-47c5-4454-8363-2f823ff9c573</guid><pubDate>Tue, 10 Sep 2019 00:00:00 +0000</pubDate><dc:creator>Scott Mabin</dc:creator></item><item><title>Writing Linux Kernel Module in Rust</title><link>https://github.com/lizhuohua/linux-kernel-module-rust</link><description><![CDATA[We designed a framework to help developers to quickly build device drivers in Rust. We also utilized Rust’s security features to provide several useful infrastructures for developers so that they can easily handle kernel memory allocation and concurrency management, at the same time, some common bugs (e.g. use-after-free) can be alleviated.

We demonstrate the generality of our framework by implementing a real-world device driver on Raspberry Pi 3, and our evaluation shows that device drivers generated by our framework have acceptable binary size for canonical embedded systems and the runtime overhead is negligible.]]></description><guid isPermaLink="false">8ae2d3d4-bbd0-4e9b-8bb8-f1ff4703b0cf</guid><pubDate>Mon,  9 Sep 2019 06:31:16 +0000</pubDate><dc:creator>Li Zhuohua</dc:creator></item><item><title>Improvement to the compile time of a crate</title><link>http://antoyo.ml/compilation-time-dependencies</link><description><![CDATA[For one of my projects, I need to use LLVM so I tried this cool inkwell crate that provides a mostly safe wrapper over LLVM. To my dismay, though, compiling this crate takes… a lot of time: Debug build: 1m 05s Release build: 3m 34s. By the way, I write this article for the sole purpose of trying to fix some problems there is in the crate ecosystem and by no mean I want to incriminate the author of this crate (or any other). I’ve been guilty of doing the same mistakes, but I learned from them and want other people to learn from them as well.]]></description><guid isPermaLink="false">a8b46d95-5e16-4348-abfe-b54bc46da590</guid><pubDate>Sat,  7 Sep 2019 00:00:00 +0000</pubDate><dc:creator>Antoni Boucher</dc:creator></item><item><title>Linux.Fe2O3: a Rust virus</title><link>https://www.guitmz.com/linux-fe2o3-rust-virus/</link><description><![CDATA[Everytime I try to learn a new programming language, I try by port my prependers (Linux.Zariche, Linux.Liora, Linux.Cephei). Despite the code simplicity , it gives me the chance to understand very useful things in a language, like error handling, file i/o, encryption, memory and a few of its core libraries.

This time, Rust is the language and I must say that I was impressed by its compiler and error handling, but the syntax is still not 100% clear to me (as you can see from my rudimentar code in Linux.Fe2O3) and I wish it had a built-in random library too. This code was written in less than 2 days, of course its not pretty, has lots of .unwrap() (already got great input from some people on Reddit to help me with that, will be addressed) so I apologise in advance.]]></description><guid isPermaLink="false">5e44948a-fa5d-4dbb-a7e7-7e4838fbaa80</guid><pubDate>Fri,  6 Sep 2019 13:35:51 +0000</pubDate><dc:creator>Guilherme Thomazi</dc:creator></item><item><title>We want smaller, faster, more secure native apps</title><link>https://medium.com/tauri-apps/we-want-smaller-faster-more-secure-native-apps-77222f590c64</link><description><![CDATA[Introducing Tauri-Apps, an open-source project to help you make native apps with any framework with the power of Rust.]]></description><guid isPermaLink="false">e2f780ad-41db-499a-999c-321f0e8f556e</guid><pubDate>Thu,  5 Sep 2019 20:57:20 +0000</pubDate><dc:creator>nothingismagick</dc:creator></item><item><title>Low Power NB-IoT on STM32 Blue Pill with Apache Mynewt and Embedded Rust</title><link>https://medium.com/@ly.lee/low-power-nb-iot-on-stm32-blue-pill-with-apache-mynewt-and-embedded-rust-cef5a3ecdd90</link><description><![CDATA[In this article we’ll learn to optimise the power consumption of the NB-IoT Sensor Application in the previous tutorial from this jagged power-hungry mess… To these well-disciplined bars… It’s a simple application (coded in Embedded Rust) that polls Blue Pill’s internal temperature sensor and transmits the sensor data to a server over NB-IoT.]]></description><guid isPermaLink="false">695ee455-42ad-432f-88a0-00deb73361d3</guid><pubDate>Wed,  4 Sep 2019 01:25:15 +0000</pubDate><dc:creator>Lup Yuen Lee</dc:creator></item><item><title>Futures Concurrency</title><link>https://blog.yoshuawuyts.com/futures-concurrency/</link><description><![CDATA[In a previous post we've looked at Rust streams. In this post we're going to discuss another problem in the async space: futures concurrency combinators. We're going to cover the different forms of concurrency that can be expressed with Futures, and cover both fallible and infallible variants.]]></description><guid isPermaLink="false">d821223f-0e0c-4bbf-a248-7191d0c0c1da</guid><pubDate>Mon,  2 Sep 2019 00:00:00 +0000</pubDate><dc:creator>Yoshua Wuyts</dc:creator></item><item><title>How Rust optimizes async/await II: Program analysis</title><link>https://tmandry.gitlab.io/blog/posts/optimizing-await-2/</link><description><![CDATA[In Part 1, we covered how async fns in Rust are compiled to state machines. We saw that the internal compiler implementation uses generators and the yield statement to facilitate this transformation. In this post, we'll go over some subtleties that the compiler implementation must consider when optimizing generators. We'll look at two different kinds of analysis, liveness analysis and storage conflict detection.]]></description><guid isPermaLink="false">7304ebe7-ee28-48a9-b88c-dd03e2605a10</guid><pubDate>Mon,  2 Sep 2019 00:00:00 +0000</pubDate><dc:creator>Tyler Mandry</dc:creator></item><item><title>Announcing actix-raft: Raft distributed consensus implemented using Actix</title><link>https://railgun-rs.github.io/actix-raft/overview.html</link><description><![CDATA[An implementation of the Raft distributed consensus protocol using the Actix actor framework. Blazing fast Rust, a modern consensus protocol, an outstanding actor framework. This project intends to provide a backbone for the next generation of distributed data storage systems (SQL, NoSQL, KV, Streaming &c) built with Rust.]]></description><guid isPermaLink="false">8e664490-3dfb-419b-8281-61ea737dd762</guid><pubDate>Wed, 28 Aug 2019 00:00:00 +0000</pubDate><dc:creator>Anthony Dodd</dc:creator></item><item><title>How to use routers in Rust Frontend</title><link>https://www.steadylearner.com/blog/read/How-to-use-routers-in-Rust-Frontend</link><description><![CDATA[In the previous post How to use a modal in Rust, we learnt how to write a simple image modal with Rust frontend. We could find that we can build components visible only in specific conditions. In this post, we will learn how to use routers in Rust frontend with Yew. You will find that it is easy with an example.]]></description><guid isPermaLink="false">4da678ba-45e7-444f-b5da-20e2893bb4d6</guid><pubDate>Tue, 27 Aug 2019 23:46:31 +0000</pubDate><dc:creator>Steadylearner</dc:creator></item><item><title>Async Stack Traces in Rust</title><link>http://fitzgeraldnick.com/2019/08/27/async-stacks-in-rust.html</link><description><![CDATA[One neat result of Rust’s futures and async/await design is that all of the async callers are on the stack below the async callees. In most other languages, only the youngest async callee is on the stack, and none of the async callers. Because the youngest frame is most often not where a bug’s root cause lies, this extra context makes debugging async code easier in Rust.]]></description><guid isPermaLink="false">518da2d7-644e-4028-95a2-388b2cb5fc0f</guid><pubDate>Tue, 27 Aug 2019 00:00:00 -0700</pubDate><dc:creator>Nick Fitzgerald</dc:creator></item><item><title>rx — a minimalist and extensible pixel editor</title><link>http://cloudhead.io/rx/</link><description><![CDATA[rx is an extensible, modern and minimalist pixel editor implemented in Rust. It's designed to have as little UI as possible, and instead takes inspiration from vi's modal nature and command mode. Compared to other pixel editors, rx aims to be smaller, yet more configurable and extendable. `rx` takes a different approach when it comes to animation as well, which is done with *strips*.]]></description><guid isPermaLink="false">ce52dbf1-c1be-4db1-bdb9-c2ac79ed9b1d</guid><pubDate>Mon, 26 Aug 2019 20:08:25 +0000</pubDate><dc:creator>Alexis Sellier</dc:creator></item><item><title>Picking Rust for web</title><link>https://abe-winter.github.io/wisdom/2019/08/26/rust-for-web.html</link><description><![CDATA[I’ve been staring at this energy efficiency across programming languages table for days. It can’t be right (why is typescript so much worse than javascript?) but a lot of it tracks with things I’ve observed from using these languages IRL. Also this web framework benchmarks project. Bottom line: I’m thinking about using rust as the backend for a small one-person web project. Here’s everything I said to myself while researching reasons not to.]]></description><guid isPermaLink="false">5d8d151f-18fd-4aa2-8a3d-eb5620394f36</guid><pubDate>Mon, 26 Aug 2019 00:00:00 +0000</pubDate><dc:creator>Abe Winter</dc:creator></item><item><title>pastel - A command-line tool to generate, analyze, convert and manipulate colors</title><link>https://github.com/sharkdp/pastel</link><description><![CDATA[pastel is a command-line tool to generate, analyze, convert and manipulate colors. It supports many different color formats and color spaces like RGB, HSL, CIELAB, CIELCh as well as ANSI 8-bit and 24-bit representations.]]></description><guid isPermaLink="false">315ad655-56d7-48d4-b68a-434cbabf710a</guid><pubDate>Mon, 26 Aug 2019 00:00:00 +0000</pubDate><dc:creator>David Peter</dc:creator></item><item><title>Actually Using Crev, Or, The Problem Of Trusting Software Dependencies</title><link>https://wiki.alopex.li/ActuallyUsingCrev</link><description><![CDATA[Currently the only implementation of crev is cargo-crev, which ties into the Rust language package manager, cargo. However, none of this is Rust-specific apart from the implementation, the basic concept and code review format should work for any language or package system. Code reviews (“proofs”) are just YAML files, and they can be shared around however you feel like – the method currently seems to be by putting proofs in git repositories, and cargo-crev has support for this. crev already has a pretty good getting started guide that covers much of the same ground as this, but I wanted to write something similar that comes from a random user, not the system’s creator.]]></description><guid isPermaLink="false">5ab7b4e5-a7ab-470c-be66-ec1a8354a782</guid><pubDate>Sun, 25 Aug 2019 00:00:00 +0000</pubDate><dc:creator>Simon Heath</dc:creator></item><item><title>Wrapping Unsafe C Libraries in Rust</title><link>https://medium.com/dwelo-r-d/wrapping-unsafe-c-libraries-in-rust-d75aeb283c65</link><description><![CDATA[In this article, we will explore how to wrap those functions and make them safe for normal use. We’ll go over how to define a wrapper struct that handles initialization and cleanup, and describe some traits that describe how application developers can safely use your library with threads. We’ll also talk a bit about how to turn a function’s random integer return into an ergonomic, type-checked Result, how to translate strings and arrays to and from the world of C, and how to turn raw pointers returned from C into scoped objects with inherited lifetimes.

The overall goal of this step is to dig into the C library’s documentation and make each function’s internal assumptions explicit.]]></description><guid isPermaLink="false">eb9194f2-85b1-412c-aa0b-0218529bf163</guid><pubDate>Sat, 24 Aug 2019 07:09:28 +0000</pubDate><dc:creator>Jeff Hiner</dc:creator></item><item><title>Is This Magic!? Ferris Explores Rustc!</title><link>https://quietmisdreavus.net/code/2019/08/23/is-this-magic-ferris-explores-rustc/</link><description><![CDATA[A companion to the RustConf 2019 talk with the same name; an introduction to making your first contribution to the Rust compiler.]]></description><guid isPermaLink="false">63fb93a7-e179-491f-83b9-84a7e284fe48</guid><pubDate>Fri, 23 Aug 2019 11:00:00 -0500</pubDate><dc:creator>QuietMisdreavus</dc:creator></item><item><title>Join Your Threads</title><link>https://matklad.github.io/2019/08/23/join-your-threads.html</link><description><![CDATA[This is a note on how to make multithreaded programs more robust. It’s not really specific to Rust, but I get to advertise my new jod-thread micro-crate :)]]></description><guid isPermaLink="false">c50ebb87-7e8f-4d08-bc8c-ebe51377faf4</guid><pubDate>Fri, 23 Aug 2019 00:00:00 +0000</pubDate><dc:creator>Aleksey Kladov</dc:creator></item><item><title>Introduction to C2Rust</title><link>https://immunant.com/blog/2019/08/introduction-to-c2rust/</link><description><![CDATA[Our goal is to build useful tools that make it easier to take existing Rust code and get up and running with Rust. We aim to automate much of the translation and rewriting process so that migrating legacy systems is practical and scalable with minimal manual effort.

We’re excited to announce that a milestone long in the making is finally here! You can now install C2Rust from crates.io with a simple cargo install on Linux and OS X. We’ve been hard at work improving C2Rust, so go install and give it a spin! You can find the necessary prerequisites in the C2Rust README.]]></description><guid isPermaLink="false">0df32177-8f6b-48ec-a896-5555337110fa</guid><pubDate>Fri, 23 Aug 2019 00:00:00 +0000</pubDate><dc:creator>Immunant, Inc</dc:creator></item><item><title>Introducing nushell</title><link>http://www.jonathanturner.org/2019/08/introducing-nushell.html</link><description><![CDATA[Today, we’re introducing a new shell, written in Rust. It draws inspiration from the classic Unix philosophy of pipelines, the structured data approach of PowerShell, functional programming, systems programming, and more.]]></description><guid isPermaLink="false">adf5ec47-1ec7-4b47-9d89-122b4efdd8f9</guid><pubDate>Fri, 23 Aug 2019 00:00:00 +0000</pubDate><dc:creator>Jonathan Turner, Yehuda Katz, and Andrés Robalino, with contributions from Odin Dutton</dc:creator></item><item><title>Artichoke is a Ruby made with Rust</title><link>https://github.com/artichoke/artichoke</link><description><![CDATA[Artichoke is a platform for building MRI-compatible Ruby implementations. Artichoke provides a Ruby runtime implemented in Rust that can be loaded into many VM backends.]]></description><guid isPermaLink="false">1e20c763-7a28-429e-9d68-e3628dcc2edd</guid><pubDate>Fri, 23 Aug 2019 00:00:00 +0000</pubDate><dc:creator>Ryan Lopopolo</dc:creator></item><item><title>Thoughts on Rust bloat</title><link>https://raphlinus.github.io/rust/2019/08/21/rust-bloat.html</link><description><![CDATA[I’m about to accept a PR that will increase druid’s compile time about 3x and its executable size almost 2x. In this case, I think the tradeoff is worth it (without localization, a GUI toolkit is strictly a toy), but the bloat makes me unhappy and I think there is room for improvement in the Rust ecosystem.]]></description><guid isPermaLink="false">5b9044be-428f-48ff-b1f3-b9f0e6b63732</guid><pubDate>Wed, 21 Aug 2019 17:17:42 +0000</pubDate><dc:creator>Raph Levien</dc:creator></item><item><title>Building with async/await in Rust</title><link>https://ragona.com/posts/clobber_async_await</link><description><![CDATA[As you might have heard, async/await is coming to Rust soon. This is a big deal. Rust has already has popular crates (tokio, actix) that provide asynchronous concurrency, but the async syntax coming to stable in 1.39 is much, much more approachable. My experience has been that you can produce and reason about application flow much more easily, which has made me significantly more productive when dealing with highly concurrent systems. To kick the tires of this new syntax I dug into the nightly branch, and built a high-performance TCP client called clobber. In this post I'll talk about why I think async/await in Rust is a big deal, and walk you some of the code in clobber.]]></description><guid isPermaLink="false">b577a6bb-429a-454b-8d2b-77175dba68c8</guid><pubDate>Wed, 21 Aug 2019 00:00:00 +0000</pubDate><dc:creator>Ryan Ragona</dc:creator></item><item><title>6 months of game development in Rust</title><link>https://iolivia.me/posts/6-months-of-rust-game-dev/</link><description><![CDATA[If you made it here you might have already read my previous post 24 hours of game development in Rust, but if you haven't, it was basically a short summary of how I started learning rust and decided to make a game with it. I started with a classical OOP/trait architecture that was taking me nowhere really fast, so I switched to ECS and got a minimal prototype working. Fast forward 6 months, I wanted to catch you folks up on where I am and what I've learnt so far.]]></description><guid isPermaLink="false">c5ced679-f825-47f6-b97e-11199ed40973</guid><pubDate>Wed, 21 Aug 2019 00:00:00 +0000</pubDate><dc:creator>Olivia Ifrim</dc:creator></item><item><title>Visual Embedded Rust Programming with Visual Studio Code</title><link>https://medium.com/@ly.lee/visual-embedded-rust-programming-with-visual-studio-code-1bc1262e398c</link><description><![CDATA[Create and edit Embedded Rust programs for STM32 Blue Pill and Apache Mynewt… By dragging and dropping blocks!]]></description><guid isPermaLink="false">05f496a4-b42b-43f3-b0f8-90edcdb52bee</guid><pubDate>Mon, 19 Aug 2019 00:08:33 +0000</pubDate><dc:creator>Lup Yuen Lee</dc:creator></item><item><title>Introduction</title><link>https://rust-lang.github.io/compiler-team/</link><description><![CDATA[A home for compiler team planning documents, meeting minutes, and other such things. If you’re interested in learning about how rustc works – as well as advice on building the compiler, preparing a PR, and other similar topics – check out the rustc-guide.]]></description><guid isPermaLink="false">6f824da5-4033-40da-994f-581a7909e50e</guid><pubDate>Sun, 18 Aug 2019 04:30:25 +0000</pubDate><dc:creator>Rust Lang Compiler Team</dc:creator></item><item><title>Rsoc: Improving Ion&apos;s UX, week 5 and 6</title><link>https://www.redox-os.org/news/rsoc-ion-ux-4-5/</link><description><![CDATA[The Redox official website]]></description><guid isPermaLink="false">a14dd34c-7e7d-4040-9b8f-e8708df5447d</guid><pubDate>Sun, 18 Aug 2019 00:00:00 +0000</pubDate><dc:creator>AdminXVII</dc:creator></item><item><title>Introducing the Rust Game Development Working Group</title><link>https://rust-gamedev.github.io/2019/08/18/introducing-the-rust-game-development-working-group</link><description><![CDATA[Rust’s combination of low-level control, excellent performance and modern build tools makes it an exciting choice for game developers. The idea of a working group to support this burgeoning community has been proposed many times over the years, and we’re excited to announce that a group has finally been formed!]]></description><guid isPermaLink="false">01b4afb8-222b-4d4f-ad09-443d48231e3f</guid><pubDate>Sun, 18 Aug 2019 00:00:00 +0000</pubDate><dc:creator>Rust GameDev</dc:creator></item><item><title>How Rust optimizes async/await: Part 1</title><link>https://tmandry.gitlab.io/blog/posts/optimizing-await-1/</link><description><![CDATA[The issue to stabilize an initial version of async/await in Rust has left final comment period. The feature looks slated to stabilize in an upcoming release, most likely 1.39. One of the blockers mentioned in the RFC is the size of the state machines emitted by async fn. I’ve spent the last few months tackling this problem, and wanted to give people a window into the process of writing these optimizations, with all the intricacies involved.]]></description><guid isPermaLink="false">c0401410-c335-43a2-a9f3-342909efdb3f</guid><pubDate>Sun, 18 Aug 2019 00:00:00 +0000</pubDate><dc:creator>Tyler Mandry</dc:creator></item><item><title>Using C Libraries in Rust</title><link>https://medium.com/dwelo-r-d/using-c-libraries-in-rust-13961948c72a</link><description><![CDATA[Today I want to dig into one of the difficulties we ran into while trying to rewrite our IoT Python code in Rust: specifically FFI, or the “Foreign Function Interface” — the bit that allows Rust to interact with other languages. When I tried to write Rust code to integrate with C libraries a year ago, the existing documents and guides often gave conflicting advice, and I had to stumble through the process on my own. This guide is intended to help future Rustaceans work through the process of porting C libraries to Rust, and familiarize the reader with the most common problems we encountered while doing the same.]]></description><guid isPermaLink="false">86fe455b-cfd7-472b-860b-2d969a8cd5ba</guid><pubDate>Sat, 17 Aug 2019 00:22:36 +0000</pubDate><dc:creator>Jeff Hiner</dc:creator></item><item><title>The New Firmware Manager: Updating firmware across Linux distributions</title><link>https://blog.system76.com/post/187072707563/the-new-firmware-manager-updating-firmware-across</link><description><![CDATA[Over the past few months, System76 has been developing a simple, easy-to-use tool for updating firmware on Pop!_OS and System76 hardware. Today, we’re excited to announce that you can now check and update firmware through Settings on Pop!_OS, and through the firmware manager GTK application on System76 hardware running other Debian-based distributions.]]></description><guid isPermaLink="false">9e2dbb14-ceba-4562-a577-a218c1e652f8</guid><pubDate>Sat, 17 Aug 2019 00:00:00 +0000</pubDate><dc:creator>System76</dc:creator></item><item><title>Announcing async-std</title><link>https://async.rs/blog/announcing-async-std/</link><description><![CDATA[We are excited to announce a beta release of async-std with the intent to publish version 1.0 by September 26th, 2019. async-std is a library that looks and feels like the Rust standard library, except everything in it is made to work with async/await exactly as you would expect it to. The library comes with a book and polished API documentation, and will soon provide a stable interface to base your async libraries and applications on. While we don't promise API stability before our 1.0 release, we also don't expect to make any breaking changes.]]></description><guid isPermaLink="false">5b6c323e-57a0-4281-86ee-67c3a4bf6173</guid><pubDate>Fri, 16 Aug 2019 00:00:00 +0000</pubDate><dc:creator>Stjepan Glavin</dc:creator></item><item><title>Understanding Futures in Rust -- Part 2</title><link>https://www.viget.com/articles/understanding-futures-is-rust-part-2/</link><description><![CDATA[If you're familiar with promises in JavaScript and followed the last blog post you may have been confused about where the familiar combinators (then, catch, and finally) were in the previous post. You will find their equivalents in this post, and, by the end, the following code will compile. You will also gain an understanding of the types, traits, and underling concepts that make futures work.]]></description><guid isPermaLink="false">4bf39b49-7652-4132-8a42-c12c7d922ab9</guid><pubDate>Thu, 15 Aug 2019 00:00:00 +0000</pubDate><dc:creator>Joe Jackson</dc:creator></item><item><title>Announcing Rust 1.37.0</title><link>https://blog.rust-lang.org/2019/08/15/Rust-1.37.0.html</link><description><![CDATA[The highlights of Rust 1.37.0 include referring to enum variants through type aliases, built-in cargo vendor, unnamed const items, profile-guided optimization, a default-run key in Cargo, and #[repr(align(N))] on enums. Read on for a few highlights, or see the detailed release notes for additional information.]]></description><guid isPermaLink="false">76cefd5b-2344-4629-84fb-5bf5c45c0ce0</guid><pubDate>Thu, 15 Aug 2019 00:00:00 +0000</pubDate><dc:creator>The Rust Release Team</dc:creator></item><item><title>Diagnostics with Tracing</title><link>https://tokio.rs/blog/2019-08-tracing/</link><description><![CDATA[Effectively developing systems and operating them in production requires visibility into their behavior at runtime. While conventional logging can provide some of this visibility, asynchronous software &mdash; like applications using the Tokio runtime &mdash; introduces new challenges.

tracing is a collection of libraries that provide a framework for instrumenting Rust programs to collect structured, context-aware, event driven diagnostics. Note that tracing was originally released under the name tokio-trace; the name was changed to reflect that, although it is part of the Tokio project, the tokio runtime is not required to use tracing.]]></description><guid isPermaLink="false">c7b37ead-766f-4ca9-b816-eb99a0c01b33</guid><pubDate>Wed, 14 Aug 2019 00:00:00 +0000</pubDate><dc:creator>Eliza Weisman</dc:creator></item><item><title>surf</title><link>https://blog.yoshuawuyts.com/surf/</link><description><![CDATA[Today we're happy to announce Surf, an asynchronous cross-platform streaming HTTP client for Rust. This project was a collaboration between Kat Marchán (Entropic / Microsoft), Stjepan Glavina (Ferrous Systems), and myself (Yoshua Wuyts). Surf is a friendly HTTP client built for casual Rustaceans and veterans alike. ]]></description><guid isPermaLink="false">2d8f15c2-34f2-4bc2-a1b2-aef6744a9691</guid><pubDate>Wed, 14 Aug 2019 00:00:00 +0000</pubDate><dc:creator>Yoshua Wuyts</dc:creator></item><item><title>Updating to Async/Await</title><link>https://leshow.github.io/post/async_await/</link><description><![CDATA[We’re pleased to announce the release of the first Tokio alpha with async & await support. This includes updating all of the Tokio crates to use std::future instead of futures 0.1. It also includes adding async fn versions of the APIs.]]></description><guid isPermaLink="false">dac15914-213c-4397-8485-eb2156b0e88b</guid><pubDate>Mon, 12 Aug 2019 09:30:08 -0400</pubDate><dc:creator>Evan Cameron</dc:creator></item><item><title>Learning Rust: Working with threads</title><link>https://www.codegram.com/blog/learning-rust-threads/</link><description><![CDATA[I used to live in the single-thread JavaScript happy-land where the closest thing to working with threads I ever did was communicating between a website and a Chrome extension. So when people talked about the difficulties of parallelism and concurrency, I never truly got what the fuss was about.

As you may have read before, I started learning Rust a few weeks ago, re-writing a text-based game I previously made with Vue. It's a survival game in which you must gather and craft items to eat and drink. It has no winning condition other than trying to survive as many days as possible. I managed to get most of the game features working, but there was an annoying bug: if the user left the game idle for hours, it didn't check for the stats until the user interacted again. You could live for hundreds of days without doing nothing!

I knew this could be solved with threads, so I finally gathered the courage and read the chapter Fearless Concurrency of The Rust Programming Language.]]></description><guid isPermaLink="false">16a7b9b5-ad78-4644-93f1-fb81e3f6419b</guid><pubDate>Mon, 12 Aug 2019 00:00:00 +0000</pubDate><dc:creator>Núria Soriano</dc:creator></item><item><title>Runtime Configuration Reloading</title><link>https://vorner.github.io/2019/08/11/runtime-configuration-reloading.html</link><description><![CDATA[A lot of programs need to read some kind of configuration at startup. But the challenge doesn’t end here. Some programs ‒ certainly not all, but some ‒ are long running. For these, restarting them to change configuration isn’t something you’d want to do. The unix daemon convention is to send a SIGHUP signal to the process.]]></description><guid isPermaLink="false">2938c850-88bc-4bec-b0fb-f2561f4a0b17</guid><pubDate>Sun, 11 Aug 2019 00:00:00 +0000</pubDate><dc:creator>Michal &apos;vorner&apos; Vaner</dc:creator></item><item><title>Photo mosaics with Rust</title><link>https://willdady.com/photo-mosaics-with-rust/</link><description><![CDATA[As I've been learning the Rust programming language lately I thought creating a photo-mosaic generator could be a fun project. I knew a generator like this would require a large set of tile images to sample from. The original plan was for it to only create mosaics from emoji which is how it got it's name emosaic (emoji + mosaic = emosaic) but as I progressed it made more sense to keep in generic and let the user provide their own pool of tile images.]]></description><guid isPermaLink="false">0b1d562c-94e0-49fd-be04-15ea918ed05d</guid><pubDate>Sat, 10 Aug 2019 00:00:00 +0000</pubDate><dc:creator>Will Dady</dc:creator></item><item><title>Amethyst game engine activity Report - July 2019</title><link>https://amethyst.rs/posts/activity-report-july-2019</link><description><![CDATA[If you’re new to Amethyst, now is a great time to get better acquainted with our project, developed by a global collective numbering in the double digits. The engine is settling into more frequent releases, making it easier for gamedevs to keep up with our incremental improvements. We’ve added a second showcase game to teach by example whilst demonstrating what Amethyst is currently capable of. And best of all for the newcomers, we’ve introduced the “2D quickstarter”, a simple game template that gets you up and running with a working Amethyst game as quickly as possible.]]></description><guid isPermaLink="false">60559491-c207-46d3-8ca1-0f9b1615975f</guid><pubDate>Sat, 10 Aug 2019 00:00:00 +0000</pubDate><dc:creator>Erlend Sogge Heggen</dc:creator></item><item><title>Rustacean Terminal Chat App in Rust</title><link>https://www.pubnub.com/blog/build-realtime-rust-chat-app-cursive-tui/</link><description><![CDATA[Build a basic chat app with the Rust Programming Language.]]></description><guid isPermaLink="false">e21ad158-7d23-47c3-82a4-0f76f651c6d9</guid><pubDate>Fri,  9 Aug 2019 17:31:52 +0000</pubDate><dc:creator>Samba Diallo</dc:creator></item><item><title>Follow-up to Method on Emulating Higher-Kinded Types (HKTs) in Rust</title><link>https://gist.github.com/edmundsmith/e09d5f473172066c0023ef84ee830cad</link><description><![CDATA[First off, thanks for all the comments and kind words on the original writeup; I've been meaning to follow up on some of the suggestions and write about the different ways to represent monads (and functors, HKTs, etc) that now exist, but a month of being busy has kind of gotten in the way (mainly with three new kittens!).

And for sure, I do not expect (nor do I want) this to become the norm for production-level Rust: rather, I hope that this can contribute to the foundations of programming with higher-level abstractions in Rust, somewhat like how early template metaprogramming in C++ and typeclass-constraint-unification metaprogramming in Haskell have contributed, perhaps indirectly, to later innovations in their respective languages and ecosystems that were much more reasoned, sound and usable.]]></description><guid isPermaLink="false">2a87f758-3eaf-4971-a00f-02f3175d0db5</guid><pubDate>Thu,  8 Aug 2019 11:44:35 +0000</pubDate><dc:creator>Edmund Smith</dc:creator></item><item><title>Await a minute, why bother?</title><link>https://docs.rs/dtolnay/0.0.5/dtolnay/macro._01__await_a_minute.html</link><description><![CDATA[Recently I have been retooling some core Rust libraries at $work to play nicely with native async/await syntax. This note covers my thoughts on why this feature is so important to our async codebase if it's "just" syntax sugar for a job that could just be done using raw Futures instead.]]></description><guid isPermaLink="false">902d33e4-a66a-479e-8758-f543083da639</guid><pubDate>Thu,  8 Aug 2019 00:00:00 +0000</pubDate><dc:creator>David Tolnay</dc:creator></item><item><title>Tokio alpha release with async &amp; await</title><link>https://tokio.rs/blog/2019-08-alphas/</link><description><![CDATA[We’re pleased to announce the release of the first Tokio alpha with async & await support. This includes updating all of the Tokio crates to use std::future instead of futures 0.1. It also includes adding async fn versions of the APIs.]]></description><guid isPermaLink="false">b958f8b9-38f2-42e9-8cb9-9b7c59f7b875</guid><pubDate>Thu,  8 Aug 2019 00:00:00 +0000</pubDate><dc:creator>Tokio</dc:creator></item><item><title>My First Three Months With Rust</title><link>https://blog.aclysma.com/my-first-three-months-with-rust/</link><description><![CDATA[I’ve used C++ professionally in games and simulations for over 10 years, and in the past few years I’ve also used C# to build distributed backend systems. Lately, I’ve been exploring Rust.]]></description><guid isPermaLink="false">27ce3b2b-a0fc-4cf2-ade4-1d4bcd1dabf7</guid><pubDate>Wed,  7 Aug 2019 19:13:41 +0000</pubDate><dc:creator>Philip Degarmo</dc:creator></item><item><title>Using Tree-sitter Parsers in Rust</title><link>https://rfdonnelly.github.io/posts/using-tree-sitter-parsers-in-rust/</link><description><![CDATA[Tree-sitter is a parser generator tool and parsing library. It generates portable parsers that can be used in several languages including Rust. Tree-sitter grammars are available for several languages. This is a game changer because it lowers the barrier to entry for writing language tooling. You no longer need to write your own parser. With Tree-sitter, you can now simply use an existing parser.]]></description><guid isPermaLink="false">a998ed84-202b-48ad-b8ca-829ae5f387ef</guid><pubDate>Wed,  7 Aug 2019 11:20:33 -0700</pubDate><dc:creator>Rob Donnelly</dc:creator></item><item><title>Rust Rocks NB-IoT! STM32 Blue Pill with Quectel BC95-G on Apache Mynewt</title><link>https://medium.com/@ly.lee/rust-rocks-nb-iot-stm32-blue-pill-with-quectel-bc95-g-on-apache-mynewt-ef62a7e28f7e</link><description><![CDATA[We’re back in 2019… Hardly anyone writes embedded programs in Rust for microcontrollers (like STM32 Blue Pill), we all use C. But we really should switch to Rust! Moon Base One has given us 2 key reasons…]]></description><guid isPermaLink="false">2e787744-947c-488d-a7b0-06f5e8ed34f3</guid><pubDate>Wed,  7 Aug 2019 04:44:39 +0000</pubDate><dc:creator>Lup Yuen Lee</dc:creator></item><item><title>Implementing Lempel-Ziv Jaccard Distance (LZJD) in Rust</title><link>https://tweedegolf.nl/blog/33/implementing-lempel-ziv-jaccard-distance-lzjd-in-rust</link><description><![CDATA[One of our clients helps companies in becoming GDPR-compliant. A goal is to recognize sensitive pieces of user data in a big pile of registrations, receipts, emails, and transcripts, and mark them to be checked out later. As more and more data is collected by companies, finding and eliminating sensitive data becomes harder and harder, to the point where it is no longer possible for mere human employees to keep up without assistance.]]></description><guid isPermaLink="false">f0cc3e18-ac97-474b-b8f1-416a9e11aadc</guid><pubDate>Tue,  6 Aug 2019 00:00:00 +0000</pubDate><dc:creator>Henk Dieter</dc:creator></item><item><title>Practical Networked Applications in Rust, Part 2: Networked Key-Value Store</title><link>https://arveknudsen.com/posts/practical-networked-applications-in-rust/module-2/</link><description><![CDATA[Welcome to the second installation in my series on taking the Practical Networked Applications in Rust course, kindly provided by the PingCAP company, where you develop a networked and multithreaded/asynchronous key-value store in the amazing Rust language. In the previous, and initial, post I implemented the course module of making the fundamental key-value store functionality, based around the Bitcask algorithm, which would only allow for local usage on your own computer. In the second module of my course work, I add networking functionality, dividing the application into a client/server architecture so that clients can connect to servers across the network.]]></description><guid isPermaLink="false">09df4bbd-96fe-49af-8811-407f98c3108e</guid><pubDate>Sun,  4 Aug 2019 01:00:00 +0200</pubDate><dc:creator>Arve Knudsen</dc:creator></item><item><title>My Thoughts on Rust&apos;s Future: A Positive Outlook</title><link>https://cprimozic.net/blog/my-thoughts-on-rusts-future/</link><description><![CDATA[I'm feeling really positive about Rust's prospects of popularity and wide-spread adoption in the future. I've been a part of the Rust community for three years now, and it feels like the stars are starting to align in order to let Rust jump into a position of dominance in the programming language world. There are several different, wide-spread, and mostly unrelated trends that I've noticed are all coming together with positive implications for Rust.]]></description><guid isPermaLink="false">ac36b146-f880-46e7-9f3f-819ab9daefa8</guid><pubDate>Sat,  3 Aug 2019 00:00:00 +0000</pubDate><dc:creator>Casey Primozic</dc:creator></item><item><title>Low-level TCP server in Rust with MIO</title><link>https://sergey-melnychuk.github.io/2019/08/01/rust-mio-tcp-server/</link><description><![CDATA[It is time to get acquainted with Metal IO, low-level cross-platform abstraction over epoll/kqueue written in Rust. In this article I will show and explain how to write simple single-threaded asynchronous TCP server, then teach it to mock HTTP protocol, and then benchmark it with ab/wrk. The results are about to be impressive.]]></description><guid isPermaLink="false">94dd1a96-2b38-4556-bb32-5064f803e5b6</guid><pubDate>Thu,  1 Aug 2019 22:25:42 +0000</pubDate><dc:creator>Sergey Melnychuk</dc:creator></item><item><title>This month in rustsim #7 (June − July 2019)</title><link>https://www.rustsim.org/blog/2019/08/01/this-month-in-rustsim/</link><description><![CDATA[Welcome to the seventh edition of _This month in rustsim_! This monthly newsletter will provide you with a]]></description><guid isPermaLink="false">9ce993e1-4fda-4f75-9d26-9b15c084d07c</guid><pubDate>Thu,  1 Aug 2019 00:00:00 +0000</pubDate><dc:creator>Sébastien Crozet</dc:creator></item><item><title>Understanding Rust Through AVL Trees</title><link>https://francismurillo.github.io/2019-07-31-Understanding-Rust-Through-AVL-Trees/</link><description><![CDATA[From<Elixir>, Into<Rust>. I loved learning the Elixir language and how its pragmatic supervision trees and process model taught me the value fault tolerance as a quality of code than of infrastructure. Having safety and failure recovery as an idiomatic culture and mindset of the language made me a better thinker and developer. As a personal preference then in selecting new languages to learn, I look for potentially new perspectives and insights that it ascribes to its pilgrims. In general, a good learning curve is a good indicator since it has much to teach.]]></description><guid isPermaLink="false">a4736472-659a-4d2a-9dc4-d4d12d342963</guid><pubDate>Wed, 31 Jul 2019 00:00:00 +0000</pubDate><dc:creator>Francis Murillo</dc:creator></item><item><title>Animate code with awoo!</title><link>https://phaazon.net/blog/introducing-awoo</link><description><![CDATA[Lately, I’ve been wanting to re-write demoscene-like applications. Not in the same mood and way as I usually did, though. Instead, I want to build small things for people to play with. A bit like small and easy to use audiovisual experiences (it can be seen as small video games for instance, but focused on the artistic expression as some games do).

The thing is, the kind of program we want generates its own inputs based on, mostly, the speed at which the hardware it’s running on is able to render a complete frame. The faster the more accurate we sample from that continuous function. That is actually quite logical: more FPS means, literally, more images to sample. The difference between two images will get less and less noticeable as the number of FPS rises. That gives you smooth images.

The “challenge” here is to write code to schedule those images. Instead of taking a parameter like the time on the command-line and rendering the corresponding image, we will generate a stream of images and will do different things at different times. Especially in demoscene productions, we want to synchronize what’s on the screen with what’s playing on the audio device.]]></description><guid isPermaLink="false">f40bd89a-d036-4bfd-819a-9f7c128707d9</guid><pubDate>Sun, 28 Jul 2019 11:00:00 +0000</pubDate><dc:creator>Dimitri Sabadie</dc:creator></item><item><title>RSoC: Improving Ion&apos;s UX, week 4 - Autocompleting under 1ms</title><link>https://www.redox-os.org/news/rsoc-ion-ux-3/</link><description><![CDATA[The Redox official website]]></description><guid isPermaLink="false">0045c68b-1c6b-4aee-9704-5471d5dd9758</guid><pubDate>Sun, 28 Jul 2019 00:00:00 +0000</pubDate><dc:creator>AdminXVII</dc:creator></item><item><title>Rust vs GUI</title><link>https://turbomack.github.io/posts/2019-07-28-rust-vs-gui.html</link><description><![CDATA[Implications of Rust's borrow checking and memory ownership on GUI development (simple case)]]></description><guid isPermaLink="false">1a249517-dab9-4195-abad-c76c79fd0560</guid><pubDate>Sun, 28 Jul 2019 00:00:00 +0000</pubDate><dc:creator>Marek Fajkus</dc:creator></item><item><title>Rust: safe and unsafe as theorems and axioms</title><link>https://iandouglasscott.com/2019/07/26/rust-safe-and-unsafe-as-theorems-and-axioms/</link><description><![CDATA[There is a fair amount of confusion about what unsafe means in Rust, as well as debate about how one should think about it. Recently I’ve seen several blog posts like What is Rust’s unsafe?, The Temptation of Unsafe and Unsafe as a Human-Assisted Type System. I’m not really attempting to explain what is considered unsafe in Rust, which is explained by the reference. Nor am I going to try to answer the question of precisely when unsafe should be used and how often. My basic suggestion: we can think of unsafe in terms of mathematical axioms and theorems. This understanding is somewhere in between actual mathematical rigour and an analogy.]]></description><guid isPermaLink="false">398562a1-3ec5-4277-8a7c-5c3388fed5ba</guid><pubDate>Fri, 26 Jul 2019 15:37:00 -0700</pubDate><dc:creator>Ian Douglas Scott</dc:creator></item><item><title>The Rust compiler is still getting faster</title><link>https://blog.mozilla.org/nnethercote/2019/07/25/the-rust-compiler-is-still-getting-faster/</link><description><![CDATA[I previously wrote about one period of improvement in Rust compiler speed. How are things going in 2019?]]></description><guid isPermaLink="false">771ffeb1-3f31-43b3-9f4b-17b114e326c2</guid><pubDate>Thu, 25 Jul 2019 03:56:24 +0000</pubDate><dc:creator>Nicholas Nethercote</dc:creator></item><item><title>Unsafe as a Human-Assisted Type System</title><link>https://matklad.github.io/2019/07/25/unsafe-as-a-type-system.html</link><description><![CDATA[This is a short note about yet another way to look at Rust’s unsafe. Today, an interesting bug was found in rustc, which made me aware just how useful unsafe is for making code maintainable. The story begins a couple of months ago, when I was casually browsing through recent pull requests for rust-lang/rust. I was probably waiting for my code to compile at that moment :] Anyway, a pull request caught my attention, and, while I was reading the diff, I noticed a usage of unsafe.]]></description><guid isPermaLink="false">98583b20-bd88-4cad-8a18-5e375c6c369f</guid><pubDate>Thu, 25 Jul 2019 00:00:00 +0300</pubDate><dc:creator>Aleksey Kladov</dc:creator></item><item><title>A little Rust program for the C major scale</title><link>https://chilimatic.hashnode.dev/a-little-rust-program-for-the-c-major-scale-cjyhc96hv001kvcs1heos8grg</link><description><![CDATA[Well I am a professional programmer for over a decade now, so my brain is trained to remember algorithmic thinking. But it's not trained to retain music theory. Which leads me to my beginning life-hack of music theory .... write a music theory shell application in rust to help me understanding the underlying mathematical structures by implementing them. I will try to make this an ongoing regular exercise to combine of my two currently favorite things: Rust and Guitar playing / Music.]]></description><guid isPermaLink="false">c4f23f51-7f72-4671-aec3-de6849639309</guid><pubDate>Wed, 24 Jul 2019 14:23:00 +0000</pubDate><dc:creator>j</dc:creator></item><item><title>Baseball Coding with Rust – Part 2</title><link>https://tht.fangraphs.com/baseball-coding-with-rust-part-2/</link><description><![CDATA[In Part 1, we introduced Rust and built a little program that allowed us to get all the GameDay links for a particular day. Today, we’ll dive right into code and begin the process of building out a complete game from the xml files. As much as possible, I’ll try to explain important concepts along the way as we build out the application. My goal is to deliver a crash course into baseball-centric programming in Rust, complete with code, theory and practical use, without getting too much into the weeds.]]></description><guid isPermaLink="false">1f02eefe-da84-472d-8df4-039766538e7f</guid><pubDate>Wed, 24 Jul 2019 00:00:00 +0000</pubDate><dc:creator>Eli Ben-Porat</dc:creator></item><item><title>Practical Networked Applications in Rust, Part 1: Non-Networked Key-Value Store</title><link>https://arveknudsen.com/posts/practical-networked-applications-in-rust/module-1/</link><description><![CDATA[The PingCAP company, makers of the TiDB NewSQL database and the TiKV key-value store, have kindly made publicly available, as well as open-sourced, a set of training courses that they call the "PingCAP Talent Plan". These courses train programmers in writing distributed systems in the Go and Rust languages. They are originally intended by PingCAP to train students, new employees and new contributors to TiDB and TiKV and focus as such on subjects relevant to those projects, but are still appropriate to anyone with an interest in learning to make distributed systems in Go and/or Rust.]]></description><guid isPermaLink="false">faca5f20-8895-4d5b-850c-d2a8b4149876</guid><pubDate>Tue, 23 Jul 2019 13:00:00 +0200</pubDate><dc:creator>Arve Knudsen</dc:creator></item><item><title>Baseball Coding with Rust – Intro</title><link>https://tht.fangraphs.com/baseball-coding-with-rust-intro/</link><description><![CDATA[From time to time, major league teams will post job offers on FanGraphs. Most of these postings, if not all of them, ask for a level of proficiency in Python or R. While these languages have built up tremendous ecosystems, especially for data science, they are limited in the amount of data they can handle.

This is not a flaw in either language, rather a design choice. Without getting into the weeds too much about language theory, each language plants itself somewhere on the performance/ease-of-use spectrum. Nothing in today’s piece should be construed as a critique of Python or R. Quite the contrary. Python and R are the bedrock languages of the data science worlds.

Today, I would like to introduce you to Rust, a modern systems programming language that aims to be, in their words, “A language empowering everyone to build reliable and efficient software.” I can personally attest to this being the case.]]></description><guid isPermaLink="false">48855ece-4f3a-44aa-80a1-b86a03cc9538</guid><pubDate>Tue, 23 Jul 2019 10:00:52 +0000</pubDate><dc:creator>Eli Ben-Porat</dc:creator></item><item><title>Why Rust for safe systems programming</title><link>https://msrc-blog.microsoft.com/2019/07/22/why-rust-for-safe-systems-programming/</link><description><![CDATA[In this series, we have explored the need for proactive measures to eliminate a class of vulnerabilities and walked through some examples of memory safety issues we’ve found in Microsoft code that could have been avoided with a different language. Now we’ll peek at why we think that Rust represents the best alternative to C and C++ currently available.]]></description><guid isPermaLink="false">153bc34f-6b3a-4103-8fed-55ed99da9e36</guid><pubDate>Mon, 22 Jul 2019 19:19:19 +0000</pubDate><dc:creator>Ryan Levick</dc:creator></item><item><title>cHTTP 0.5 and the Journey Ahead</title><link>https://stephencoakley.com/2019/07/22/chttp-0.5-and-the-journey-ahead</link><description><![CDATA[One of my more recent projects that I have been putting a lot of effort into is a Rust HTTP client called cHTTP, which I introduced on this blog over 18 months ago. Here I want to share an update on the direction of the project, and also give some detail on what months of late evenings and weekends produced in version 0.5 just published today.]]></description><guid isPermaLink="false">14ef4b09-79cc-424c-88bd-97a5d40ec957</guid><pubDate>Mon, 22 Jul 2019 05:00:00 +0000</pubDate><dc:creator>Stephen Coakley</dc:creator></item><item><title>How to write Full Stack Rust code</title><link>https://www.steadylearner.com/blog/read/How-to-write-Full-Stack-Rust-code</link><description><![CDATA[In the previous post How to modulize your Rust Frontend, we learnt how to use impl, functions and Yew components. They help you to find errors and organize your Rust frontend project. In this post, we will include server side code with ws-rs. It will help us to build complete Rust Full Stack chat app similar to what we made at How to start Rust Chat App.]]></description><guid isPermaLink="false">ca7ab50b-0ea0-4d8f-9f38-74945bc33900</guid><pubDate>Mon, 22 Jul 2019 00:00:00 +0000</pubDate><dc:creator>Steadylearner</dc:creator></item><item><title>RSoC: Implementing ptrace for Redox OS - part 5</title><link>https://www.redox-os.org/news/rsoc-ptrace-5/</link><description><![CDATA[This week I’ve decided to skip trying to get GDB working for now (there are so many issues it’ll take forever to solve them), and instead decided to finally give focus to the final concerns I had about ptrace. Most changes this week was related to getting decent behavior of child processes, although the design feels… suboptimal, somehow (not sure why), so I feel I must be able to improve it better later.

Another change was security: Tracers running as a non-root user can now in addition to only tracing processes running as the same user, only trace processes that are directly or indirectly children of the tracer. In the future this can easily be allowed with some kind of capability, but currently in Redox there isn’t a capability-like system other than the simple (but really powerful) namespacing system which sadly I don’t think can be used for this.]]></description><guid isPermaLink="false">94badc73-4b58-487c-88de-ce68562f9f19</guid><pubDate>Mon, 22 Jul 2019 00:00:00 +0000</pubDate><dc:creator>jD91mZM2</dc:creator></item><item><title>Fuzz rising: how fuzz testing is making memory unsafe languages untenable</title><link>https://www.cloudatomiclab.com/fuzz/</link><description><![CDATA[Go and read the excellent blog post from Cloudflare on their recent outage if you haven’t already. I am not going to talk about most of it, just a few small points that especially interest me right now, which are definitely not the most important things from the outage point of view. This post got a bit long so I split it up, so this is part one.]]></description><guid isPermaLink="false">cc336a90-bbf5-49c3-94b7-e3c4454cbc53</guid><pubDate>Sun, 21 Jul 2019 20:52:00 +0000</pubDate><dc:creator>Justin Cormack</dc:creator></item><item><title>Localizing the Rust Website to Traditional Chinese</title><link>https://medium.com/coding-neutrino-blog/localize-the-rust-website-to-traditional-chinese-473413f44d21</link><description><![CDATA[I am glad to announce that the Traditional Chinese (正體中文) version of the Rust official website has been launched. Thanks to all contributors in the community. This article records our experience to achieve the work.]]></description><guid isPermaLink="false">52f43349-8161-4996-95ad-138528adcf21</guid><pubDate>Fri, 19 Jul 2019 16:38:55 +0000</pubDate><dc:creator>Liu An Chi (tigercosmos)</dc:creator></item><item><title>How to use Torch in Rust with tch-rs</title><link>http://vegapit.com/article/how-to-use-torch-in-rust-with-tch-rs</link><description><![CDATA[Thanks to the diligent work of Laurent Mazare on his tch-rs crate, the Rust community can now enjoy an easy access to the powerful Torch neural net framework. Being personally an avid user of both Rust and Torch, stumbling on this repo has been nothing but a belated birthday present. In this post, I would like to dive into two examples to present its most fundamental functionalities.]]></description><guid isPermaLink="false">4f959a60-5f69-4997-b6d8-6cf6e8311e1f</guid><pubDate>Fri, 19 Jul 2019 13:18:00 +0100</pubDate><dc:creator>Vegapit</dc:creator></item><item><title>HOWTO: Replace mem::uninitialized with mem::MaybeUninit</title><link>https://www.reddit.com/r/rust/comments/cefgec/howto_replace_memuninitialized_with_memmaybeuninit/</link><description><![CDATA[The recent 1.36.0 release of Rust has brought a mem::MaybeUninit union that allows safer handling of possibly uninitialized data. MaybeUninit is a replacement of mem::uninitialized. Why? Because using mem::uninitialized it is damn easy to shoot yourself in the foot.]]></description><guid isPermaLink="false">ab2b1d95-83c2-4541-9f2d-bb5224d0b713</guid><pubDate>Fri, 19 Jul 2019 10:59:18 +0000</pubDate><dc:creator>Roman Proskuryakov</dc:creator></item><item><title>Rust for OOP - Closures</title><link>https://oribenshir.github.io/afternoon_rusting/blog/closures</link><description><![CDATA[Turning functions into first-class citizens in our programming languages is one of the major changes of the decade. Well, kind of. The concept, also known as lambda, is far from new. Functional programming languages had it from the very start, during the late ’50s. Even some of the object-oriented languages like Python had it quite early, back in 1994. However it became an official part of C++ only in 2011, and Java brought it even later in 2014. And with those two languages and many others, it became the norm, even for non-functional programming. As first-class citizens, functions can be saved as variables or transfer as arguments to functions easily.]]></description><guid isPermaLink="false">fd4779eb-f9f4-4c63-98c9-d7fe21fb6bac</guid><pubDate>Fri, 19 Jul 2019 00:00:00 +0000</pubDate><dc:creator>Ori Ben-Shir</dc:creator></item><item><title>Bit vectors and variable-length encoding</title><link>https://christianpoveda.github.io/blog/bit-vectors/</link><description><![CDATA[This is the first post on what is supposed to be an small series about writing compression algoritms in Rust, please take into account that I am no expert in compression so this is the perspective of a learner, if you think there is some improvements or corrections to be done, let me know.

You might be wondering why bit vectors are relevant for compression and so was I until I started reading a little bit about it. So, let's talk about compression.]]></description><guid isPermaLink="false">4e8c0915-f401-40a1-b6b6-6120583484d1</guid><pubDate>Fri, 19 Jul 2019 00:00:00 +0000</pubDate><dc:creator>Christian Poveda</dc:creator></item><item><title>How to modulize your Rust Frontend</title><link>https://www.steadylearner.com/blog/read/How-to-modulize-your-Rust-Frontend</link><description><![CDATA[In the previous post How to use markdown with Rust Frontend, we learnt how to render markdown in Rust frontend and include CSS files from your previous frontend project. You can use a text, image, video, markdown or any HTML elements you want for your Rust frontend. In this post, we will learn how to modulize your Rust Yew frontend app. It will be easy after you learn how to use impl, function, and components for that.]]></description><guid isPermaLink="false">5784cd2f-f28c-4746-8c85-c39ee718c4a0</guid><pubDate>Fri, 19 Jul 2019 00:00:00 +0000</pubDate><dc:creator>Steadylearner</dc:creator></item><item><title>C vs Rust vs Go: performance analysis</title><link>https://medium.com/@marek.michalik/c-vs-rust-vs-go-performance-analysis-945ab749056c</link><description><![CDATA[In one of my previous jobs I got a task: “For given image find popular colors in that image, so users can browse images by it’s colors”. This is where three languages comes to play. I have implemented histogram algorithm in C, Rust and Go.]]></description><guid isPermaLink="false">13003d78-0993-49fe-ae7e-0b0263a77353</guid><pubDate>Thu, 18 Jul 2019 20:54:01 +0000</pubDate><dc:creator>Marek Michalik</dc:creator></item><item><title>Introducing Abscissa: iqlusion&apos;s security-oriented Rust application framework</title><link>https://iqlusion.blog/introducing-abscissa-rust-application-framework</link><description><![CDATA[Earlier this month we released Abscissa: our security-oriented Rust application framework. After releasing v0.1, we’ve spent the past few weeks further polishing it up in tandem with this blog post, and just released a follow-up v0.2.]]></description><guid isPermaLink="false">9ec74f93-14a2-47ec-8572-24b9efe51a62</guid><pubDate>Thu, 18 Jul 2019 07:00:51 -0700</pubDate><dc:creator>Tony Arcieri</dc:creator></item><item><title>Codenano, a tool for designing DNA nanostructures</title><link>https://dna.hamilton.ie/2019-07-18-codenano.html</link><description><![CDATA[We are proud to announce the release of our software codenano, available at https://dna.hamilton.ie/codenano/. Here, we give an introduction to what codenano can and can not do. The source code for codenano is hosted on a github repository: https://github.com/thenlevy/codenano, along with a short tutorial.

Codenano allows one to design and visualise DNA nanostructures specified using code, all in your browser. Codenano also has the ability to compute some simple interactions between DNA bases in order to help the user design DNA nanostructures that are feasible according to some simple criteria. ]]></description><guid isPermaLink="false">2439dd44-0bd5-437e-bb60-f7b24b4f02f2</guid><pubDate>Thu, 18 Jul 2019 00:00:00 +0000</pubDate><dc:creator>Nicolas Levy, Pierre-Étienne Meunier and Damien Woods</dc:creator></item><item><title>The Temptation of Unsafe</title><link>https://inejge.github.io/blog/2019/07/18/The-Temptation-of-Unsafe.html</link><description><![CDATA[Recently, another round of discussion concerning the use of Rust’s unsafe features in the Actix web framework happened, or rather erupted, on Reddit, even more heated and acrimonious than the first time around. (I am not linking to any of the threads, as I believe that they don’t need any more exposure. Use your favorite search engine.) This proves, if more proof is needed, that people hold passionate beliefs about the matter.]]></description><guid isPermaLink="false">a0f3d2bb-e52e-440b-809f-169497494769</guid><pubDate>Thu, 18 Jul 2019 00:00:00 +0000</pubDate><dc:creator>inejge</dc:creator></item><item><title>How to speed up the Rust compiler in 2019</title><link>https://blog.mozilla.org/nnethercote/2019/07/17/how-to-speed-up-the-rust-compiler-in-2019/</link><description><![CDATA[I have written previously about my efforts to speed up the Rust compiler in 2016 (part 1, part 2) and 2018 (part 1, part 2, NLL edition). It’s time for an update on the first half of 2019.]]></description><guid isPermaLink="false">688a7c2c-4cb7-4da6-a9d5-3cf4d5f7571a</guid><pubDate>Wed, 17 Jul 2019 02:54:57 +0000</pubDate><dc:creator>Nicholas Nethercote</dc:creator></item><item><title>Announcing heim: async library for system information fetching</title><link>https://svartalf.info/posts/2019-07-17-announcing-heim-project/</link><description><![CDATA[If you are familiar with Python ecosystem, probably you had heard about psutil package — a cross-platform library for retrieving information about system processes and system utilization (CPU, memory, disks, network and so on). It is very popular and actively used package, which has analogs in other languages: gopsutil for Golang, oshi for Java, you name it. Rust, of course, is not an exception here: we do have psutil, sysinfo, sys-info and systemstat crates.

Now, despite the tremendous work that had been done already by the authors of these crates, I’m excited to announce what I’ve been working on for the past three months: “heim” project — library for system information fetching.]]></description><guid isPermaLink="false">c91d6ec8-c734-495e-89ad-e63da5825eb0</guid><pubDate>Wed, 17 Jul 2019 00:00:00 +0000</pubDate><dc:creator>Nikita Kuznetsov</dc:creator></item></channel></rss>