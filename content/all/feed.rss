<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/"><channel><title>Read Rust - All Posts</title><link>https://readrust.net/</link><description>All Posts posts on Read Rust</description><item><title>Organizational Debt</title><link>https://boats.gitlab.io/blog/post/rust-2019/</link><description><![CDATA[We all know that classic aphorism: Year comes to an end, Rust blog post press send. This is mine.

There are lots of cool technical improvements to Rust that I want the project to achieve this year, and a few in particular that I’m definitely going to be putting a lot of time into. But this blog post is going to talk about none of them. Instead, I want to talk about organizational debt, and how badly the Rust project needs to deal with it in 2019.]]></description><guid isPermaLink="false">f0adf24b-6589-4306-a580-6cef894ad3b7</guid><pubDate>Mon, 16 Dec 2019 00:00:00 +0000</pubDate><dc:creator>withoutboats</dc:creator></item><item><title>Sonic: Fast, lightweight &amp; schema-less search backend</title><link>https://github.com/valeriansaliou/sonic</link><description><![CDATA[Sonic is a fast, lightweight and schema-less search backend. It ingests search texts and identifier tuples that can then be queried against in a microsecond's time.]]></description><guid isPermaLink="false">0dbd06f7-147e-404c-81ce-360e61e087e5</guid><pubDate>Sun, 24 Mar 2019 00:00:00 +0000</pubDate><dc:creator>Valerian Saliou</dc:creator></item><item><title>Redox OS 0.5.0</title><link>https://www.redox-os.org/news/release-0.5.0/</link><description><![CDATA[It has been one year and four days since the last release of Redox OS! In this time, we have been hard at work improving the Redox ecosystem. Much of this work was related to relibc, a new C library written in Rust and maintained by the Redox OS project, and adding new packages to the cookbook. We are proud to report that we have now far exceeded the capabilities of newlib, which we were using as our system C library before. We have added many important libraries and programs, which you can see listed below.]]></description><guid isPermaLink="false">c3e2f0b2-713e-4ab5-9126-103233acb271</guid><pubDate>Sun, 24 Mar 2019 00:00:00 +0000</pubDate><dc:creator>Jeremy Soller</dc:creator></item><item><title>My First 3 Weeks of Professional Rust</title><link>https://www.wezm.net/technical/2019/03/first-3-weeks-of-professional-rust/</link><description><![CDATA[For the last 15 years as a professional programmer I have worked mostly with dynamic languages. First Perl, then Python, and for the last 10 years or so, Ruby. I’ve also been writing Rust on the side for personal projects for nearly four years. Recently I started a new job and for the first time I’m writing Rust professionally. Rust represents quite a shift in language features, development process and tooling. I thought it would be interesting to reflect on that experience so far.]]></description><guid isPermaLink="false">98e50b2b-889a-49d1-9973-f1d39c9cc389</guid><pubDate>Sat, 23 Mar 2019 22:45:00 +0000</pubDate><dc:creator>Wesley Moore</dc:creator></item><item><title>Rust + Gtk = Wow</title><link>https://dorianpula.ca/2019/03/22/rust-gtk-wow/</link><description><![CDATA[As I’ve been experimenting with writing Rust apps, I attempted to create a small little GUI application. At first I attempted to setup everything with Qt, but C++/Qt interoperability with Rust is painful. Very, very painful. I experimented with some more radical UI frameworks such as Azul and Conrad. These have a lot of promise going forward. However for the here and now, I recommend looking at gtk-rs, Rust binding for Gtk.]]></description><guid isPermaLink="false">da7566eb-9da3-4f88-9c13-743fd67037a3</guid><pubDate>Fri, 22 Mar 2019 21:54:08 +0000</pubDate><dc:creator>Dorian Pula</dc:creator></item><item><title>Are we Database Yet?</title><link>https://www.reddit.com/r/rust/comments/b463rg/are_we_database_yet/</link><description><![CDATA[I'm giving a talk next month at our Rust Meetup about using Rust in production. I've been reflecting on my last few months using Rust after learning the language about a year ago. One of my most frustrating experiences tends to always be around the futures ecosystem, as that's where I oft-fruitless labour for hours before giving up on what I'm doing.

I do data engineering and software development work professionally, and these 2 areas are where I often find a lot of pain with using the language.

A few weeks ago I wanted to write something that takes csv files and writes them to a database. I used Apache Arrow's Rust library (which I've started contributing to this year) to do that. The idea was simple, Arrow has a CSV reader that can infer schema, so I map the schema's data types to a database's types, and then I sequentially write records in batches to the database.

I found the exercise quite painful, so I'd like to talk about databases and Rust.]]></description><guid isPermaLink="false">ea9c3fbe-c681-4b42-a0ef-3699a1612972</guid><pubDate>Sat, 23 Mar 2019 02:02:56 +1100</pubDate><dc:creator>nevi-me</dc:creator></item><item><title>Hands-on IoT applications with OpenWhisk and Rust</title><link>https://medium.com/the-theam-journey/hands-on-iot-applications-with-openwhisk-and-rust-acb9ef5bc166</link><description><![CDATA[In this article, we’ll explore Apache OpenWhisk (which we’ll refer to simply as OpenWhisk), an open-source, distributed serverless platform that allows us to execute functions in response to events. OpenWhisk supports a lot of languages out of the box and can be extended to use other languages. In our case, we are going to use Rust as our main primary language.]]></description><guid isPermaLink="false">784ce8bf-55af-48fc-9893-23f28a38c999</guid><pubDate>Fri, 22 Mar 2019 13:41:31 +0000</pubDate><dc:creator>Roberto Díaz</dc:creator></item><item><title>Rust All Hands 2019: Array iterators, Rayon, and more</title><link>https://developers.redhat.com/blog/2019/03/22/rust-all-hands-2019-array-iterators-rayon-and-more/</link><description><![CDATA[A few weeks ago, I had the pleasure of attending the second annual Rust All Hands meeting, hosted by Mozilla at their Berlin office. The attendees were a mix of volunteers and corporate employees covering the full range of Rust development, including the compiler, language, libraries, docs, tools, operations, and community. Although I’m sure there will be an official summary of the meeting (like last year’s), in this article, I’ll cover a few things I was directly involved in. First, I’ll look at a feature many developers have wanted for a long time…]]></description><guid isPermaLink="false">6450a97d-c96a-47df-b999-a865defe34ae</guid><pubDate>Fri, 22 Mar 2019 07:05:51 +0000</pubDate><dc:creator>Josh Stone</dc:creator></item><item><title>Helix: Improve the Performance of Rails with Rust</title><link>https://headway.io/blog/helix-improve-the-performance-of-rails-with-rust/</link><description><![CDATA[With Rust, you can do low-level number-crunching and bit-by-bit processing, while enjoying memory safety and concurrency features. With Helix, you can use your Rust code inside of a Rails project.]]></description><guid isPermaLink="false">1f1562d2-b784-4bda-84d4-a0dc68178793</guid><pubDate>Fri, 22 Mar 2019 00:00:00 +0000</pubDate><dc:creator>Raphael Spencer</dc:creator></item><item><title>Portability benchmark of Dolphin Emulator on MacOS</title><link>https://gfx-rs.github.io/2019/03/22/dolphin-macos-performance.html</link><description><![CDATA[gfx-rs is a Rust project aiming to make graphics programming more accessible and portable, focusing on exposing a universal Vulkan-like API. It’s a single Rust API with multiple backends that implement it: Direct3D 12/11, Metal, Vulkan, and even OpenGL. We are also building a Vulkan Portability implementation based on it, which allows non-Rust applications using Vulkan to run everywhere. This post is focused on the Metal backend only.

Previously, we benchmarked Dota2 and were able to run many other applications and engines successfully, including Dolphin Emulator. For Dolphin, we previously focused on visual correctness. After games appeared to render correctly, we shifted our focus to performance to ensure they also render quickly.]]></description><guid isPermaLink="false">0b65aa06-68c5-4d0b-9160-6edb0ca35f34</guid><pubDate>Fri, 22 Mar 2019 00:00:00 +0000</pubDate><dc:creator>gfx-rs</dc:creator></item><item><title>The Embedded Working Group Newsletter - 17</title><link>https://rust-embedded.github.io/blog/newsletter-17/</link><description><![CDATA[This week's highlights: The Embedded Rust Showcase, Oxidize speakers announced, docs on interrupts, and Life before Main!]]></description><guid isPermaLink="false">d226973e-f9e9-46e7-8395-d63272cd6f61</guid><pubDate>Fri, 22 Mar 2019 00:00:00 +0000</pubDate><dc:creator>The Embedded Working Group</dc:creator></item><item><title>Learning Rust With Entirely Too Many Linked Lists</title><link>https://rust-unofficial.github.io/too-many-lists/</link><description><![CDATA[I fairly frequently get asked how to implement a linked list in Rust. The answer honestly depends on what your requirements are, and it's obviously not super easy to answer the question on the spot. As such I've decided to write this book to comprehensively answer the question once and for all. In this series I will teach you basic and advanced Rust programming entirely by having you implement 6 linked lists.]]></description><guid isPermaLink="false">34dfeb70-4900-4ef3-b6d5-674d3caf376d</guid><pubDate>Fri, 22 Mar 2019 00:00:00 +0000</pubDate><dc:creator>Alexis Beingessner</dc:creator></item><item><title>barrel.rs: a powerful schema migration builder&apos;s 0.5.0 release</title><link>https://rust-db.github.io/barrel/blog/releasing-050/</link><description><![CDATA[barrel makes writing migrations for different databases as easy as possible. It provides you with a common API over SQL, with certain features only provided for database specific implementations. This way you can focus on your Rust code, and stop worrying about SQL.]]></description><guid isPermaLink="false">554b2733-697f-41c7-b91b-0261acc1aa24</guid><pubDate>Thu, 21 Mar 2019 00:00:00 +0000</pubDate><dc:creator>Squirrel People</dc:creator></item><item><title>Chaining Functions Without Returning Self</title><link>https://randompoison.github.io/posts/returning-self/</link><description><![CDATA[It’s a common pattern in the Rust ecosystem to have a function return self at the end in order to enable method chaining. This approach is often used in combination with the builder pattern, though it can also be applied to a wide variety of other situations. The example demonstrates the most straightforward of these cases (i.e. initializing and modifying an object in a single statement), but, as I’m going to demonstrate, this approach quickly breaks down when applied to a wider variety of use cases.]]></description><guid isPermaLink="false">88233a0c-3917-4ec2-b2c5-bcfd322a9662</guid><pubDate>Thu, 21 Mar 2019 00:00:00 +0000</pubDate><dc:creator>David LeGare</dc:creator></item><item><title>Rust: The Hard Parts - Part One: References and borrowing</title><link>https://naftuli.wtf/2019/03/20/rust-the-hard-parts/</link><description><![CDATA[Rust has a perception of being a very difficult language to learn. I had a similar experience, but just as I was told, there is a point where things start to get a lot easier. This post aims to describe the hard parts that I had to get through in order to start being productive with Rust in the belief that this may help others get over the hill to that sweet spot of infinite bliss and productivity. In this post, I’m going to cover references and borrowing.]]></description><guid isPermaLink="false">dad7fd3a-4891-4ddc-bf77-81668ffd5ea7</guid><pubDate>Wed, 20 Mar 2019 00:00:00 +0000</pubDate><dc:creator>Naftuli Kay</dc:creator></item><item><title>Why Hashbrown Does A Double-Lookup</title><link>https://gankro.github.io/blah/hashbrown-insert/</link><description><![CDATA[I recently finished a detailed review of hashbrown, which will likely become the new implementation for rust's std::collections::HashMap. One of the most surprising things I found was in the implementation of insert. It was doing something that was so offensive to people who care about collection performance that we had designed an entire API to help people avoid it: it did two lookups in the map. However, after some more discussion and review, I concluded that this implementation was reasonable. This post will try to cover why that is.]]></description><guid isPermaLink="false">38a15a60-b3e5-49c5-9036-3af3d6bc43ff</guid><pubDate>Wed, 20 Mar 2019 00:00:00 +0000</pubDate><dc:creator>Alexis Beingessner</dc:creator></item><item><title>Web Development with Rust: Deploy your first App</title><link>https://dev.to/gruberb/web-programming-in-rust-02x-deploy-your-first-app-1k05</link><description><![CDATA[If you learn something new, always have an updated version of your project in production. It keeps you motivated. We cover the most common options of how to do this in and with Rust.]]></description><guid isPermaLink="false">6d82f826-46bb-4cb3-ba49-3a18c736f5ab</guid><pubDate>Tue, 19 Mar 2019 20:13:00 +0000</pubDate><dc:creator>Bastian Gruber</dc:creator></item><item><title>Refactoring Varisat: 3. Conflict Driven Clause Learning</title><link>https://jix.one/refactoring-varisat-3-cdcl/</link><description><![CDATA[This is the third post in my series about refactoring varisat. In this post the new code base turns into a working SAT solver. While you can use the command line tool or the library to solve some small and easy SAT problems now, there is still a lot ahead to gain feature and performance parity with varisat 0.1.

In the last post we saw how unit propagation is implemented. When some variables are known, unit propagation allows us to derive the values of new variables or finds a clause that cannot be satisfied. Unit propagation alone isn’t enough though, as there is no guarantee to make progress. To continue the search for a satisfying solution after propagating all assignments, it is necessary to make a guess. A natural way to handle this would be recursion and backtracking. This would give us a variant of the DPLL algorithm from which conflict driven clause learning evolved.]]></description><guid isPermaLink="false">da916659-e0c2-4c4c-a793-b4f7273dcd1f</guid><pubDate>Mon, 18 Mar 2019 20:00:53 +0100</pubDate><dc:creator>Jannis Harder</dc:creator></item><item><title>Governance Working Group announcement</title><link>https://internals.rust-lang.org/t/governance-working-group-announcement/9637</link><description><![CDATA[I’m very excited to announce the formation of the Governance working group, an offspring of the Core team. The high-level goal of the group is making the workings of the Rust project more predictable and transparent. The working group will examine, document, and propose improvements to some of the policies and procedures that we use to run the project. To that end, the Governance WG will take multiple viewpoints and investigate our current modes of working under the perspective of community members and project members alike. Our aim is to make the project more transparent and also make it easier for interested community members to give effective feedback and stay close to the project.]]></description><guid isPermaLink="false">dc9cf1b6-7814-4a3a-9e3e-adcd17835a81</guid><pubDate>Mon, 18 Mar 2019 16:01:23 +0000</pubDate><dc:creator>Florian Gilcher</dc:creator></item><item><title>Implementing a NES Emulator in Rust</title><link>http://www.michaelburge.us/2019/03/18/nes-design.html</link><description><![CDATA[Recently, I made an emulator for the Nintendo Entertainment Console(NES) - a game console first released in 1983. In this article, I’ll talk about how I used Rust to develop the emulator. I’ll cover questions like: What features does the emulator support? What games can it play? How did I approach the problem of emulating the NES? Did Rust’s type system or borrow checker interfere? Were there performance issues?]]></description><guid isPermaLink="false">54f59df5-bf2f-46e5-a817-0a31878f7cda</guid><pubDate>Mon, 18 Mar 2019 13:34:00 +0000</pubDate><dc:creator>Michael Burge</dc:creator></item><item><title>Building and augmenting libraries by calling Rust from JavaScript</title><link>https://opensource.com/article/19/3/calling-rust-javascript</link><description><![CDATA[Explore how to use WebAssembly (Wasm) to embed Rust inside JavaScript.]]></description><guid isPermaLink="false">208250d2-7529-4548-b658-0b76353e05de</guid><pubDate>Mon, 18 Mar 2019 03:02:00 -0400</pubDate><dc:creator>Ryan Levick</dc:creator></item><item><title>Introducing cargo-instruments: zero-hassle profiling on macOS</title><link>https://www.reddit.com/r/rust/comments/b20eca/introducing_cargoinstruments_zerohassle_profiling/</link><description><![CDATA[cargo-instruments (github) is a cargo plugin that makes it easy to profile rust binaries on macOS.  tl;dr: cargo-instruments is a shim between cargo and Xcode's very powerful dtrace-backed diagnostic suite, Instruments. Out of the box, this lets you track cpu / thread usage, allocations, context switches, and a bunch of other stuff.]]></description><guid isPermaLink="false">b1715412-8fc8-4882-9230-71e2b95c4b55</guid><pubDate>Sun, 17 Mar 2019 13:18:32 +1100</pubDate><dc:creator>cmyr</dc:creator></item><item><title>Procedural macro in Rust 101</title><link>https://dev.to/naufraghi/procedural-macro-in-rust-101-k3f</link><description><![CDATA[How to pick a function and make it a macro with added superpowers.]]></description><guid isPermaLink="false">d10fac5d-46ac-49b4-a8e0-517cb3cdfcba</guid><pubDate>Sun, 17 Mar 2019 00:00:00 +0000</pubDate><dc:creator>Matteo Bertini</dc:creator></item><item><title>Implementing a Hidden Markov Model in Rust</title><link>https://paulkernfeld.com/2019/03/17/hmmm.html</link><description><![CDATA[Over the past few months, I’ve implemented hmmm, a Rust library for Hidden Markov Models (HMMs). HMMs are a well-established statistical machine learning technique for modeling sequences of data. They have been applied to problems like speech recognition and bioinformatics. They are called “hidden” because each discrete time step is associated with a hidden state. Below, I’ll briefly discuss some challenges that I ran into while implementing this library.]]></description><guid isPermaLink="false">187cf7df-3448-4699-86f6-28e90a1a025f</guid><pubDate>Sun, 17 Mar 2019 00:00:00 +0000</pubDate><dc:creator>Paul Kernfeld</dc:creator></item><item><title>Programming GPIO Interrupts in Rust</title><link>https://flowdsp.io/blog/stm32f3-01-interrupts/</link><description><![CDATA[Using Embedded Rust to configure and service a hardware interrupt on the STM32F3 Discovery board.]]></description><guid isPermaLink="false">4ba1b199-045c-4ba4-80e2-6741bc648f06</guid><pubDate>Sun, 17 Mar 2019 00:00:00 +0000</pubDate><dc:creator>Antoine van Gelder</dc:creator></item><item><title>Packaging up a Rust Binary for Linux</title><link>https://dorianpula.ca/2019/03/15/packaging-up-a-rust-binary-for-linux/</link><description><![CDATA[How does one package a Rust app? I would check out creating a snap package (https://t.co/UYibrbPN7c). It worked alright for me, even though the format encourages sandboxing of apps which takes a bit to wrap your mind a bit. Or create a deb using cargo-deb and use the alien utility to transform that to a rpm.]]></description><guid isPermaLink="false">9082061f-b4a4-4aed-81e6-71a0c7e49b1a</guid><pubDate>Fri, 15 Mar 2019 21:48:17 +0000</pubDate><dc:creator>Dorian Pula</dc:creator></item><item><title>A Rust API for librsvg</title><link>https://people.gnome.org/~federico/blog/a-rust-api-for-librsvg.html</link><description><![CDATA[After the librsvg team finished the rustification of librsvg's main library, I wanted to start porting the high-level test suite to Rust. This is mainly to be able to run tests in parallel, which cargo test does automatically in order to reduce test times. However, this meant that librsvg needed a Rust API that would exercise the same code paths as the C entry points. At the same time, I wanted the Rust API to make it impossible to misuse the library.]]></description><guid isPermaLink="false">04f2e112-c86d-4468-9b75-d74f84429d69</guid><pubDate>Fri, 15 Mar 2019 13:36:47 -0600</pubDate><dc:creator>Federico Mena Quintero</dc:creator></item><item><title>Pulldown_cmark 0.3 release announcement</title><link>https://fullyfaithful.eu/pulldown-cmark/</link><description><![CDATA[pulldown_cmark, a fast pull parser for the CommonMark markdown standard written in Rust, has just seen its 0.3 release. It marks a milestone for renewed CommonMark test compliance and performance. In this blog post, we'll have a quick look at the goals of the rewrite, how they were achieved and what's next for the crate.]]></description><guid isPermaLink="false">ad1ab029-a374-4fde-8f62-6100bf699da2</guid><pubDate>Fri, 15 Mar 2019 08:19:00 +0000</pubDate><dc:creator>Marcus Klaas de Vries</dc:creator></item><item><title>Persy: an attempt to write a transactional storage engine in Rust</title><link>http://persy.rs/posts/persy-0.4.html</link><description><![CDATA[Persy is a single file storage engine, all the data, referencing structures and logs are kept in a single file. Persy support read-committed transactions, using copy on write to guarantee high concurrency and isolation, the data consistency is guaranteed by a transaction log that recover the operations in case of crash. Persy provide segments to organize records of different kinds and allow the scan on a single segment. Persy provide index implementation that can be used to associate any simple value to another value or a record reference. In Persy a record is a simple Vec<u8>, the content of the record is ignored by Persy, is just stored and retrieved on request.]]></description><guid isPermaLink="false">c3575790-8873-4860-bc2a-15ba5f636a42</guid><pubDate>Fri, 15 Mar 2019 00:00:00 +0000</pubDate><dc:creator>tglman</dc:creator></item><item><title>Fast, Bump-Allocated Virtual DOMs with Rust and Wasm</title><link>https://hacks.mozilla.org/2019/03/fast-bump-allocated-virtual-doms-with-rust-and-wasm/</link><description><![CDATA[Dodrio is a virtual DOM library written in Rust and WebAssembly. It takes advantage of both Wasm’s linear memory and Rust’s low-level control by designing virtual DOM rendering around bump allocation. Preliminary benchmark results suggest it has best-in-class performance.]]></description><guid isPermaLink="false">23efff3a-8be9-443e-bc32-9de200d2e173</guid><pubDate>Thu, 14 Mar 2019 16:54:44 +0000</pubDate><dc:creator>Nick Fitzgerald</dc:creator></item><item><title>Implementing a static stack usage analysis tool</title><link>https://blog.japaric.io/stack-analysis/</link><description><![CDATA[This blog covers the implementation details of cargo-call-stack v0.1.2. So, why would you ever want to analyze the stack usage of your program at compile time? The obvious answer is when you want to know if your application can stack overflow at runtime without actually running your program. This is important for embedded applications where stack overflows can corrupt memory, and it’s actually a hard requirement for certifying the functional safety of embedded applications.]]></description><guid isPermaLink="false">349a5a06-2dd8-475d-9911-4d777ca6250f</guid><pubDate>Wed, 13 Mar 2019 00:00:00 +0000</pubDate><dc:creator>Jorge Aparicio</dc:creator></item><item><title>ActivityWatch automatic time-tracking software switches to Rust</title><link>https://forum.activitywatch.net/t/development-update-march-2019/189</link><description><![CDATA[While Python is a great language to quickly build new features in, it’s not great for performance or deploying to multiple platforms (especially Android). So @johan-bjareholt took on the tremendous task of reimplementing aw-server in the highly performant and secure programming language Rust. Since Rust compiles to Android we have built a library for use on Android, letting us avoid reimplement all of ActivityWatch to Android devices specifically (and vastly decreases the time to port future features like sync to Android).]]></description><guid isPermaLink="false">ec8871ce-7c85-42a8-bd0c-e85c09a2f04d</guid><pubDate>Tue, 12 Mar 2019 12:06:19 +0000</pubDate><dc:creator>Erik Bjäreholt</dc:creator></item><item><title>A Coding Retreat and Getting Embedded Rust Running on a SensorTag</title><link>https://www.wezm.net/technical/2019/03/sensortag-embedded-rust-coding-retreat/</link><description><![CDATA[This past long weekend some friends on I went on a coding retreat inspired by John Carmack doing similar in 2018. During the weekend I worked on adding support for the Texas Instruments SensorTag to the embedded Rust ecosystem. This post is a summary of the weekend and what I was able to achieve code wise.]]></description><guid isPermaLink="false">0febede4-eee9-43df-bd74-dd2a44dcb4fb</guid><pubDate>Tue, 12 Mar 2019 08:45:00 +0000</pubDate><dc:creator>Wesley Moore</dc:creator></item><item><title>Scientific computing: a Rust adventure [Part 1 - Zero-cost abstractions]</title><link>https://www.lpalmieri.com/posts/2019-03-12-scientific-computing-a-rust-adventure-part-1-zero-cost-abstractions/</link><description><![CDATA[We left, at the end of the previous episode, with an intuitive understanding of Rust’s ownership system: we worked with vectors of integers, Vec<i32>, and we came up with a naive - but surprisingly fast! - scalar product implementation followed by a very simple sort function using the bubble sort algorithm.

In this episode we will implement a generic version of the same scalar product routine. This will require the introduction of several key concepts concerning Rust’s type system: generics, traits, operators, associated types, Copy.]]></description><guid isPermaLink="false">e448a9b1-396d-4b48-8cba-40419fc3cce6</guid><pubDate>Tue, 12 Mar 2019 00:00:00 +0000</pubDate><dc:creator>Luca Palmieri</dc:creator></item><item><title>Remote Development and Debugging of Rust with CLion</title><link>https://medium.com/nearprotocol/remote-development-and-debugging-of-rust-with-clion-39c38ced7cc1</link><description><![CDATA[Most in our team use CLion for Rust development which is especially great for local debugging, alas it is not free. Since we are developing a blockchain it requires careful orchestration of the nodes running on separate machines, and occasionally we need to debug some corner case on a remotely running node. CLion and other JetBrains products have great support of the remote development and debugging. However, unfortunately, Rust is not a primary language of CLion which makes configuration tricky. In this post we walk through the configuration of CLion for remote Rust development and debugging.]]></description><guid isPermaLink="false">0c70dd5f-51e6-4f07-8707-6783ca471d0c</guid><pubDate>Mon, 11 Mar 2019 01:18:15 +0000</pubDate><dc:creator>Maksym Zavershynskyi</dc:creator></item><item><title>Building the virtualization stack of the future with rust-vmm</title><link>https://opensource.com/article/19/3/rust-virtual-machine</link><description><![CDATA[rust-vmm facilitates sharing core virtualization components between Rust Virtual Machine Monitors.]]></description><guid isPermaLink="false">d3f4b805-773f-499e-84c8-b79fcb40631f</guid><pubDate>Mon, 11 Mar 2019 00:00:00 +0000</pubDate><dc:creator>Andreea Florescu</dc:creator></item><item><title>Hardware Debugging a Raspberry Pi using JTAG</title><link>https://github.com/rust-embedded/rust-raspi3-OS-tutorials/tree/master/0B_hw_debug_JTAG</link><description><![CDATA[Functionally, this tutorial is the same as the previous one, where we reset or power down the RPi. Around that, we add infrastructure for JTAG debugging.]]></description><guid isPermaLink="false">ae65ad4b-c966-483f-a57a-965ab7ba7d28</guid><pubDate>Sun, 10 Mar 2019 13:59:01 +0000</pubDate><dc:creator>Andre Richter</dc:creator></item><item><title>Intro to web programming in Rust for NodeJS developers</title><link>https://medium.com/@gruberbastian/intro-to-web-programming-in-rust-for-nodejs-developers-1a9c048c4de1</link><description><![CDATA[Rust is different. You can pick up Python or Ruby over the weekend, create a first CRUD application and be happy with the results. With Rust… with Rust you will struggle to pass a String to a different method, change and return it. You then will order the Rust book, see its size, *sigh* and get started. After a few weeks fighting through the book after work, you give up and wait until someone else creates an easy-to-follow tutorial. Here is your “easy” tutorial.]]></description><guid isPermaLink="false">58a0a3ec-5b93-4e53-bcd0-d8df56d02848</guid><pubDate>Sun, 10 Mar 2019 10:53:02 +0000</pubDate><dc:creator>Bastian Gruber</dc:creator></item><item><title>In nightly Rust, &apos;await!&apos; may never return (dropping futures)</title><link>http://www.randomhacks.net/2019/03/09/in-nightly-rust-await-may-never-return/</link><description><![CDATA[I've been using the proposed await! and Future features in nightly Rust, and overall, I really like the design. But I did run into one surprise: await! may never return, and this has consequences I didn't fully understand. Let's take a look.]]></description><guid isPermaLink="false">eed8a936-e3c7-45b5-bc50-3e1b95ffb767</guid><pubDate>Sat,  9 Mar 2019 15:11:20 -0500</pubDate><dc:creator>Eric Kidd</dc:creator></item><item><title>WASP, a Lisp dialect for performant, concise Web Assembly modules</title><link>https://medium.com/@nbaltunian/wasp-a-lisp-dialect-for-performant-concise-web-assembly-modules-29f5f7282b6a</link><description><![CDATA[WASP is ‘a LISP programming language for extremely performant and concise web assembly modules.’ That means that you can use WASP to generate WASM modules.]]></description><guid isPermaLink="false">356cc6f0-1e2a-4060-8b81-df1d1d6cd911</guid><pubDate>Sat,  9 Mar 2019 04:24:29 +0000</pubDate><dc:creator>Noah</dc:creator></item><item><title>Resize images from S3 with AWS Lambda and Rust</title><link>https://matsimitsu.com/blog/2019-03-09-resize-images-from-s3-with-aws-lambda-and-rust/</link><description><![CDATA[Using Rust and AWS Lambda to thumbnail images, cheaply, relablity, and quickly.]]></description><guid isPermaLink="false">3ad2e4d8-ffb5-4dcc-870e-e5c8dae3ca2a</guid><pubDate>Sat,  9 Mar 2019 00:00:00 +0000</pubDate><dc:creator>Robert Beekman</dc:creator></item><item><title>Should Rust channels panic on send if nobody&apos;s listening?</title><link>http://www.randomhacks.net/2019/03/08/should-rust-channels-panic-on-send/</link><description><![CDATA[Lately, I've been working on several real-world systems using Rust's async and tokio. As you can see on the areweasyncyet.rs site, this requires using nightly Rust and the experimental tokio-async-await library. I hope to talk more about these experiences soon! But today, I want to talk about channel APIs in Rust. A question was raised by @matklad on GitHub, "I've migrated rust-analyzer to crossbeam-channel 0.3, and the thing I've noticed is that every .send is followed by .unwrap. Perhaps we should make this unwrapping behavior the default, and introduce a separate checked_send which returns a Result?".]]></description><guid isPermaLink="false">09e6b7ba-69f9-4256-9ce5-c75ea253c3ec</guid><pubDate>Fri,  8 Mar 2019 16:42:27 -0500</pubDate><dc:creator>Eric Kidd</dc:creator></item><item><title>How productive is Rust?</title><link>https://medium.com/@woutergeraedts/how-productive-is-rust-e2260db28f09</link><description><![CDATA[We often get the question how productive working with Rust is. “We know that it is awesome, but isn’t it hard to learn? Don’t you struggle with the borrow checker?”. Well, we put it to the test in Google’s Hash Code 2019 programming competition.]]></description><guid isPermaLink="false">23fcf66c-3fff-4894-836d-32a880171b46</guid><pubDate>Fri,  8 Mar 2019 12:59:39 +0000</pubDate><dc:creator>Wouter Geraedts</dc:creator></item><item><title>Torchbear - a fast and complete interpreter for the new Speakeasy langauge</title><link>https://github.com/foundpatterns/torchbear</link><description><![CDATA[Torchbear is a new programming environment currently available for Windows, Android, MacOS, and Linux. With it, you get Rust's great library ecosystem, but you don't need to recompile with each change to how you use those libraries. Since you express your domain logic in a higher level scripting language and your system logic in Rust's language, you get the best of both worlds!]]></description><guid isPermaLink="false">977952df-eb7d-43eb-82e2-3e53b7e00a72</guid><pubDate>Wed,  6 Mar 2019 13:17:44 +1100</pubDate><dc:creator>Mitchell Tannenbaum</dc:creator></item><item><title>The rise of wgpu: Native WebGPU implementation based on gfx-hal</title><link>https://gfx-rs.github.io/2019/03/06/wgpu.html</link><description><![CDATA[WebGPU is a new graphics/compute API developed by the browser vendors (and Intel) within W3C: The goal is to design a new Web API that exposes these modern technologies in a performant, powerful and safe manner.

Don’t be confused by the “Web” part here - both us (gfx-rs team) and Google are trying to make it feasible to run on native platforms as well. Typically, the Web as a platform has different priorities from native: a lot of focus is placed on the security and portability (in a wider and stronger sense). Coincidentally, these are qualities we are currently missing in the gfx-rs ecosystem: security means safety (in the Rust sense), and portability means that people can use it and run everywhere, without worrying about thousands of potential configurations at run-time, or diverging behavior between platforms due to timing differences or loosely defined behavior.

With these goals in mind, we’d like to announce our new project: wgpu-rs.]]></description><guid isPermaLink="false">861a769a-5c77-4afb-bb9d-b0e05cd3855e</guid><pubDate>Wed,  6 Mar 2019 00:00:00 +0000</pubDate><dc:creator>gfx-rs</dc:creator></item><item><title>The Embedded Working Group Newsletter - 16</title><link>https://rust-embedded.github.io/blog/newsletter-16/</link><description><![CDATA[This is the sixteenth newsletter of the Embedded WG where we highlight new progress, celebrate cool projects, thank the community, and advertise projects that need help!]]></description><guid isPermaLink="false">c2a5636f-d083-4e22-94d7-5b26df1b173d</guid><pubDate>Wed,  6 Mar 2019 00:00:00 +0000</pubDate><dc:creator>The Embedded Working Group</dc:creator></item><item><title>Embedded Graphics 0.4.7 and TinyBMP 0.1.0</title><link>https://wapl.es/rust/2019/03/04/embedded-graphics-0.4.7-bmp-support.html</link><description><![CDATA[Embedded graphics 0.4.7 has been released, along with a new sister crate, tinybmp! TinyBMP aims to parse BMP-format image data using no dynamic allocations. It targets embedded environments but can be used in any place a small BMP parser is required. Thanks to TinyBMP, Embedded Graphics now supports loading this simple image format. The header photo was made using Embedded Graphics and the SSD1331 driver in pure Rust. In this post, I’ll talk through how the BMP file is parsed in no_std environments with nom and how to get BMP images working with embedded_graphics.]]></description><guid isPermaLink="false">25b303a5-4e11-416b-a5a5-db8f7d35db8c</guid><pubDate>Tue,  5 Mar 2019 08:51:11 +0000</pubDate><dc:creator>James Waples</dc:creator></item><item><title>From 48s to 5s - optimizing a 350 line pathtracer in Rust</title><link>https://medium.com/@cfsamson/from-48s-to-5s-optimizing-a-350-line-pathtracer-in-rust-191ab4a1a412</link><description><![CDATA[In this post I’ll talk about how to port a short raytracer written in C#/C++ codebase to Rust, then applying some simple optimizations by leveraging some features in Rust.]]></description><guid isPermaLink="false">ca80053b-f874-4631-9f13-c8ffaf6dabd6</guid><pubDate>Mon,  4 Mar 2019 23:03:25 +0000</pubDate><dc:creator>Carl Fredrik Samson</dc:creator></item><item><title>Building fast interpreters in Rust</title><link>https://blog.cloudflare.com/building-fast-interpreters-in-rust/</link><description><![CDATA[we created a configurable Rust library for writing and executing Wireshark®-like filters in different parts of our stack written in Go, Lua, C, C++ and JavaScript Workers. We have now open-sourced this library under our Github account: https://github.com/cloudflare/wirefilter. This post will dive into its design, explain why we didn’t use a parser generator and how our execution engine balances security, runtime performance and compilation cost for the generated filters.]]></description><guid isPermaLink="false">7fa900ce-52d1-494e-b770-ed5ef64aea61</guid><pubDate>Mon,  4 Mar 2019 16:00:00 +0000</pubDate><dc:creator>Ingvar Stepanyan</dc:creator></item><item><title>Enjoy Compile time function evaluation using &apos;const fn&apos; in Rust</title><link>https://blog.knoldus.com/no-more-run-time-enjoy-compile-time-function-evaluation-using-const-fn-in-rust/</link><description><![CDATA[A few days ago, I was exploring Rust’s Unstable Book and found pretty much same feature in Rust, which is const_fn. I started exploring this feature more after the recent Rust release 1.33.0, in which Rust team has announced major improvements in const fn. The idea of using const fn is to compute result at compile time so that time can be saved when code is run.]]></description><guid isPermaLink="false">48cd5e22-48f6-4711-a1d2-e9ce7338ef0d</guid><pubDate>Mon,  4 Mar 2019 15:26:43 +0000</pubDate><dc:creator>Ayush Mishra</dc:creator></item><item><title>Safe Way to access private fields in Rust</title><link>https://blog.knoldus.com/safe-way-to-access-private-fields-in-rust/</link><description><![CDATA[Do you want your fields to be private but got stuck in accessing them from other module. Then this blog let you know the ways to access the private fields as well as which one is safer way.]]></description><guid isPermaLink="false">b72bfa37-94f9-4758-9028-225ce6f93877</guid><pubDate>Mon,  4 Mar 2019 06:04:58 +0000</pubDate><dc:creator>Amita Yadav</dc:creator></item><item><title>Oxide: The Essence of Rust</title><link>https://arxiv.org/abs/1903.00982</link><description><![CDATA[Rust is a major advancement in industrial programming languages due in large part to its success in bridging the gap between low-level systems programming and high-level application programming. This success has ultimately empowered programmers to more easily build reliable and efficient software, and at its heart lies a novel approach to ownership that balances type system expressivity with usability.

In this work, we set out to capture the essence of this model of ownership by developing a type systems account of Rust's borrow checker. To that end, we present Oxide, a formalized programming language close to source-level Rust (but with fully-annotated types). This presentation takes a new view of lifetimes as approximate provenances of references, and our type system is able to automatically compute this information through a flow-sensitive substructural typing judgment for which we prove syntactic type safety using progress and preservation. The result is a simpler formulation of borrow checking - including recent features such as non-lexical lifetimes - that we hope researchers will be able to use as the basis for work on Rust.]]></description><guid isPermaLink="false">eac014e1-98a8-4913-9050-5e7a073b8611</guid><pubDate>Sun,  3 Mar 2019 20:22:37 +0000</pubDate><dc:creator>Aaron Weiss, Daniel Patterson, Nicholas D. Matsakis, Amal Ahmed</dc:creator></item><item><title>luster: An experimental Lua VM implemented in pure Rust</title><link>https://www.reddit.com/r/rust/comments/awx9cy/github_kyrenluster_an_experimental_lua_vm/</link><description><![CDATA[ What I want to talk about though (and what I will eventually write a blog post about) is the technique that I'm using in luster for safe garbage collection. Inside luster are two libraries called "gc-arena" and "gc-sequence", and they represent a new (I believe novel?) system for safe garbage collection in Rust. There have been several attempts here before such as rust-gc and shifgrethor, and this represents another attempt with... different? limitations more appropriate for implementing language runtimes like Lua.]]></description><guid isPermaLink="false">17e95b5e-6cd8-4f98-8030-c923e69897cb</guid><pubDate>Mon,  4 Mar 2019 06:26:29 +1100</pubDate><dc:creator>Catherine West</dc:creator></item><item><title>Starling, the Binary Indexed Merkle Tree (Or Merkle-BIT)</title><link>https://www.reddit.com/r/rust/comments/aww097/starling_the_binary_indexed_merkle_tree_or/</link><description><![CDATA[Hey rustaceans! With a little help from your feedback just a few hours ago, I'm proud to present to you all Starling, a Binary Indexed Merkle tree! I've been working on this data structure for the last few months, and I think it is ready now for the community to have a look. Let me explain what it is and why it might be useful for your project.]]></description><guid isPermaLink="false">ce110dd7-46c1-4f12-880f-1c0bbf3a6726</guid><pubDate>Mon,  4 Mar 2019 04:12:50 +1100</pubDate><dc:creator>ChosunOne</dc:creator></item><item><title>Entity component system (ECS) explained with tennis players and courts</title><link>http://iolivia.me/posts/entity-component-system-explained/</link><description><![CDATA[In the last post  I talked about a small game I built in Rust and roughly how far I got in 24 hours. One of the biggest challenges I had was…]]></description><guid isPermaLink="false">df193fd9-bd7c-45bc-bc27-27ba8dee5bbb</guid><pubDate>Sun,  3 Mar 2019 00:00:00 +0000</pubDate><dc:creator>Olivia Ifrim</dc:creator></item><item><title>Pedal to the metal: dynamic templates with Ramhorns</title><link>https://maciej.codes/2019-03-03-ramhorns.html</link><description><![CDATA[I have a problem. I don't know what to call it, but there is this itch I have when I find something that can obviously be made more efficient. The way I get about scratching that itch these days is by writing some Rust. I just got such an itch when looking at static site generators for this blog, Hugo (written in Go) is pretty much state-of-the art. In Rust land we have Zola, which is feature-rich, mature (for v0.5), and definitely fast enough for most users, and yet it is not as fast as it could be. Being written in Rust is, by itself, not a guarantee of top performance. The implementation matters. After some looking around I've narrowed down a problem I want to tackle (for now) to one area: template engines.]]></description><guid isPermaLink="false">a540ae81-ddbb-4279-a507-b7faf43e5b19</guid><pubDate>Sun,  3 Mar 2019 00:00:00 +0000</pubDate><dc:creator>Maciej Hirsz</dc:creator></item><item><title>rust-audit: Know exact library versions used to build your Rust executable</title><link>https://github.com/Shnatsel/rust-audit</link><description><![CDATA[Know exact library versions used to build your Rust executable. Audit binaries for known bugs or security vulnerabilities in production, at scale, with zero bookkeeping.]]></description><guid isPermaLink="false">e2a2559d-5bf2-45b6-ba62-a3af84913c3a</guid><pubDate>Sat,  2 Mar 2019 20:02:25 +0000</pubDate><dc:creator>Sergey &quot;Shnatsel&quot; Davidoff</dc:creator></item><item><title>Refactoring Varisat: 2. Clause Storage and Unit Propagation</title><link>https://jix.one/refactoring-varisat-2-clause-storage-and-unit-propagation/</link><description><![CDATA[This is the second post in my series about refactoring varisat. Since the last post I started implementing some of the core data structures and algorithms of a CDCL based SAT solver: clause storage and unit propagation. In this post I will explain how the these parts work and the rationale behind some of the decisions I made.]]></description><guid isPermaLink="false">31d81292-5ae5-4462-8f26-ca156d625f40</guid><pubDate>Sat,  2 Mar 2019 18:18:04 +0100</pubDate><dc:creator>Jannis Harder</dc:creator></item><item><title>Proposal: New channels for Rust’s standard library</title><link>https://stjepang.github.io/2019/03/02/new-channels.html</link><description><![CDATA[In this blog post, I’m proposing we also replace the guts of mpsc with crossbeam-channel for some more performance wins. However, unlike with mutexes and hash maps, this change will also enable oft-requested new features that make it tempting to deprecate mpsc altogether and introduce better channels designed from scratch.]]></description><guid isPermaLink="false">4a9fd96a-fd25-48dd-a97e-511e023b35f8</guid><pubDate>Sat,  2 Mar 2019 00:00:00 +0000</pubDate><dc:creator>Stjepan Glavina</dc:creator></item><item><title>Async-await status report</title><link>http://smallcultfollowing.com/babysteps/blog/2019/03/01/async-await-status-report/</link><description><![CDATA[I wanted to post a quick update on the status of the async-await effort. The short version is that we’re in the home stretch for some kind of stabilization, but there remain some significant questions to overcome.]]></description><guid isPermaLink="false">c838f89e-80f8-4146-b26e-622020ff2653</guid><pubDate>Fri,  1 Mar 2019 00:00:00 -0500</pubDate><dc:creator>Niko Matsakis</dc:creator></item><item><title>The last two months in rustsim #4 (January - February 2019)</title><link>https://www.rustsim.org/blog/2019/03/01/this-month-in-rustsim/</link><description><![CDATA[Welcome to the fourth edition of This month in rustsim. This monthly newsletter will provide you with a summary of important update that occurred within the rustsim community. This includes in particular updates about the nphysics, ncollide, nalgebra, and alga crate.]]></description><guid isPermaLink="false">677c24c1-719c-4744-acb3-46eb5e21f991</guid><pubDate>Fri,  1 Mar 2019 00:00:00 +0000</pubDate><dc:creator>Sébastien Crozet</dc:creator></item><item><title>24 hours of game development in Rust</title><link>http://iolivia.me/posts/24-hours-of-rust-game-dev/</link><description><![CDATA[In this post I'll talk about a small game I've been developing in about 24 hours in total (mostly in a few hour blocks during evenings or weekends). The game is far from finished, but I thought I'd write up about my experience so far, what I've learnt and some interesting observations about building a game from scratch-ish and doing it in Rust.]]></description><guid isPermaLink="false">38d6b47d-bd95-4566-af44-c30769c1e149</guid><pubDate>Fri,  1 Mar 2019 00:00:00 +0000</pubDate><dc:creator>Olivia Ifrim</dc:creator></item><item><title>Implications of Rewriting a Browser Component in Rust</title><link>https://hacks.mozilla.org/2019/02/rewriting-a-browser-component-in-rust/</link><description><![CDATA[Since our first release in 2002, there have been 69 security bugs in Firefox’s style component. If we'd had a time machine and could have written this component in Rust from the start, 51% wouldn't have happened. That said, Rust is not foolproof. Developers still need to be aware of correctness bugs and data leakage attacks.]]></description><guid isPermaLink="false">1ffc5388-6476-4542-90c1-398c561a2c43</guid><pubDate>Thu, 28 Feb 2019 14:10:27 +0000</pubDate><dc:creator>Diane Hosfelt</dc:creator></item><item><title>This Week in Pop!_OS 1</title><link>https://pop-planet.info/2019/02/this-week-in-pop/</link><description><![CDATA[This will be the first in a series of weekly updates on progress made in the development of Pop!_OS. Thus, this will only contain content pertaining specifically to Pop!_OS, though at times there may be some overlap with the hardware side of System76.]]></description><guid isPermaLink="false">c8769017-9667-4bad-82c6-e43ec7391182</guid><pubDate>Thu, 28 Feb 2019 00:20:54 +0000</pubDate><dc:creator>Michael Murphy</dc:creator></item><item><title>JavaFX UI in Rust</title><link>https://astonbitecode.github.io/blog/post/rust-javafx/</link><description><![CDATA[In this post, I would like to share the way how we can implement a Rust application that has a User Interface written in JavaFX.]]></description><guid isPermaLink="false">28f6c857-f8f6-4ff3-8a21-12c894a7dbb8</guid><pubDate>Thu, 28 Feb 2019 00:05:58 +0000</pubDate><dc:creator>Aston</dc:creator></item><item><title>Azure Pipelines for Rust Projects</title><link>https://nbsoftsolutions.com/blog/azure-pipelines-for-rust-projects</link><description><![CDATA[In this post I will detail why I believe that Azure Pipelines can be a great CI / CD platform for open source Rust projects on Github. The catch is that there are some rough spots on Azure Pipelines and in the rust ecosystem, but everything can be worked around. In writing this post, I hope to detail examples one can copy and paste into their projects.]]></description><guid isPermaLink="false">5288ae7c-b0a5-4e98-b6ad-512af05f04e4</guid><pubDate>Thu, 28 Feb 2019 00:00:00 +0000</pubDate><dc:creator>Nick Babcock</dc:creator></item><item><title>Announcing Rust 1.33.0</title><link>https://blog.rust-lang.org/2019/02/28/Rust-1.33.0.html</link><description><![CDATA[The Rust team is happy to announce a new version of Rust, 1.33.0. The two largest features in this release are significant improvements to const fns, and the stabilization of a new concept: "pinning."]]></description><guid isPermaLink="false">e6376cd5-713f-4a8e-8792-2329772feee5</guid><pubDate>Thu, 28 Feb 2019 00:00:00 +0000</pubDate><dc:creator>The Rust Release Team</dc:creator></item><item><title>Low level text layout kickoff</title><link>https://raphlinus.github.io/rust/skribo/text/2019/02/27/text-layout-kickoff.html</link><description><![CDATA[This post is to announce a new Rust library for low-level text layout, called “skribo” (the Esperanto word for “writing”). This has been a major gap in the Rust ecosystem, and I hope the new crate can improve text handling across the board.]]></description><guid isPermaLink="false">70a94e2b-dbd2-4f66-ada8-5886b5c51fab</guid><pubDate>Wed, 27 Feb 2019 18:16:42 +0000</pubDate><dc:creator>Raph Levien</dc:creator></item><item><title>Rust build scripts vs. Meson</title><link>https://people.gnome.org/~federico/blog/rust-build-scripts.html</link><description><![CDATA[One of the pain points in trying to make the Meson build system work with Rust and Cargo is Cargo's use of build scripts, i.e. the build.rs that many Rust programs use for doing things before the main build. This post is about my exploration of what build.rs does.]]></description><guid isPermaLink="false">f93cc38e-4380-4174-8f53-b5c6674772da</guid><pubDate>Wed, 27 Feb 2019 12:14:12 -0600</pubDate><dc:creator>Federico Mena Quintero</dc:creator></item><item><title>Releasing rust_gpiozero v0.2.0</title><link>https://rahul-thakoor.github.io/releasing-rust_gpiozero-v0.2.0/</link><description><![CDATA[A new version packed with new features and improvements: Blink leds without blocking main thread and adjust brightness. ⚙️ Work with servo motors and adjust motor speed. 〜 Work with software PWM.]]></description><guid isPermaLink="false">e0caaf97-6980-4421-afbe-3fca31872c73</guid><pubDate>Wed, 27 Feb 2019 17:43:48 +0400</pubDate><dc:creator>Rahul Thakoor</dc:creator></item><item><title>Forge: A scripting language for Rust gamedev inspired by JS, Rust and Python</title><link>https://github.com/zesterer/forge</link><description><![CDATA[Forge is a dynamically-typed language written in Rust. It is inspired by JavaScript, Rust, Python and Rhai. In the future, you'll be able to use Forge as a general-purpose lightweight scripting language in your applications.]]></description><guid isPermaLink="false">a1899a77-1a12-49f3-92e2-5e353491c8ae</guid><pubDate>Wed, 27 Feb 2019 04:21:00 +0000</pubDate><dc:creator>Joshua Barretto</dc:creator></item><item><title>Rust Case Study: Community makes Rust an easy choice for npm [pdf]</title><link>https://www.rust-lang.org/static/pdfs/Rust-npm-Whitepaper.pdf</link><description><![CDATA[Learn how npm uses Rust]]></description><guid isPermaLink="false">b149b575-39a9-4136-8749-29e04c5cf0b3</guid><pubDate>Wed, 27 Feb 2019 03:26:00 +0000</pubDate><dc:creator>The Rust Core Team</dc:creator></item><item><title>Working with Command Line Arguments in Rust</title><link>https://blog.knoldus.com/working-with-command-line-arguments-in-rust/</link><description><![CDATA[Command Line Arguments are used to control program from outside instead of hard-coding those values inside the code and supplied to program when it is invoked. In this blog, I’ll demystify you how to use Command Line Arguments in the Rust Programming Language.]]></description><guid isPermaLink="false">12b9edfa-c917-436a-b001-76305b65eb0d</guid><pubDate>Tue, 26 Feb 2019 07:05:40 +0000</pubDate><dc:creator>Pawan Bisht</dc:creator></item><item><title>Bid adieu to tarpaulin, HTML reports are here for Rust</title><link>https://blog.knoldus.com/bid-adieu-to-tarpaulin-html-reports-are-here-for-rust/</link><description><![CDATA[Kcov is a code coverage tool for Binaries, Shell scripts as well as Python scripts. It generates an HTML file for most of the languages. But we will focus mainly on Rust language.]]></description><guid isPermaLink="false">a6483426-5600-4cf0-a514-c532946abda3</guid><pubDate>Tue, 26 Feb 2019 06:41:19 +0000</pubDate><dc:creator>Mudit Chhabra</dc:creator></item><item><title>Firmware examples that make use of the jnet embedded TCP/IP crate</title><link>https://github.com/japaric/jnet/tree/master/firmware</link><description><![CDATA[[Experiment] JNeT: japaric's network thingies.]]></description><guid isPermaLink="false">34d09d33-17ae-4799-9026-f41fc6d95fe4</guid><pubDate>Tue, 26 Feb 2019 04:35:00 +0000</pubDate><dc:creator>Jorge Aparicio</dc:creator></item><item><title>100x improvement on startup time in Wasmer 0.2.0</title><link>https://medium.com/wasmer/running-webassembly-100x-faster-%EF%B8%8F-a8237e9a372d</link><description><![CDATA[We’ve been working steadily to get Wasmer to execute WebAssembly modules on the server-side as fast as possible. TL;DR — We got 100x improvement on startup time on Wasmer 0.2.0.]]></description><guid isPermaLink="false">fe2180a3-53fb-4b12-b6b2-722c19587b39</guid><pubDate>Mon, 25 Feb 2019 22:04:55 +0000</pubDate><dc:creator>Syrus Akbary</dc:creator></item><item><title>New cargo subcommand: sync-readme</title><link>https://phaazon.net/blog/cargo-sync-readme</link><description><![CDATA[cargo sync-readme synchronizes your README (the file specified by the readme key in your Cargo.toml, or just README.md by default) with the entrypoint of your library or binary crate (by default, lib.rs or main.rs, or what is defined at the path key in your manifest).]]></description><guid isPermaLink="false">806cf62c-14c8-4a7e-afa8-f99843d634f2</guid><pubDate>Mon, 25 Feb 2019 18:50:00 +0000</pubDate><dc:creator>Dimitri Sabadie</dc:creator></item><item><title>Up and Running with React + Rust + Wasm</title><link>https://prestonrichey.com/blog/react-rust-wasm/</link><description><![CDATA[I’m super excited about WebAssembly! It’s fast, (can be) small, and extremely portable. In fact, I wouldn’t be surprised if in the near future most web developers write code that eventually gets compiled to Wasm.

But currently there’s not a huge selection of resources showing how to get started with WebAssembly, and I couldn’t find any tutorials that worked with create-react-app. Most focus on writing and compiling a module, but rush over the details of actually using Wasm code. What follows is a basic setup for a React app using WebAssembly that should serve as a good foundation for more complex applications.]]></description><guid isPermaLink="false">7da6de6b-bbf8-4587-ab48-615ee988d899</guid><pubDate>Mon, 25 Feb 2019 00:00:00 +0000</pubDate><dc:creator>Preston Richey</dc:creator></item><item><title>Part 4: Line IDs in toy version control system, oji</title><link>https://jneem.github.io/ids/</link><description><![CDATA[I’ve written quite a bit about the theory of patches and merging, but nothing yet about how to actually implement anything efficiently. That will be the subject of this post, and probably some future posts too.]]></description><guid isPermaLink="false">aa9ed2af-2308-4ae8-a009-caf772f96e3b</guid><pubDate>Mon, 25 Feb 2019 00:00:00 +0000</pubDate><dc:creator>Joe Neeman</dc:creator></item><item><title>Introducing battery crate</title><link>https://svartalf.info/posts/2019-02-25-introducing-battery-crate/</link><description><![CDATA[My new pet project for reading batteries information in Rust.]]></description><guid isPermaLink="false">e513ef63-5727-4db5-8830-08606838d1e3</guid><pubDate>Mon, 25 Feb 2019 00:00:00 +0000</pubDate><dc:creator>Nikita Kuznetsov</dc:creator></item><item><title>Rust 2019: Rust Audio</title><link>https://www.reddit.com/r/rust/comments/aua2tb/rust_2019_rust_audio/?st=JSJEXJDY&amp;sh=497b171c</link><description><![CDATA[Howdy y'all. This is a super late 2019 goal post but I drank too much coffee this morning and wanted to get some thoughts out. I'd love to see 2019 be a great year for progressing the environment for developing audio applications in Rust. I'm not saying that there aren't already some good libraries out there, but in comparison with the defacto C++ offerings, we have a long way to go. Basically, I'd love to see an alternative to JUCE in Rust, and that is very ambitious because JUCE is an amazing library!]]></description><guid isPermaLink="false">dfa770cf-7919-4344-b9ef-6ad7b5e0a084</guid><pubDate>Mon, 25 Feb 2019 04:21:15 +1100</pubDate><dc:creator>u/engid</dc:creator></item><item><title>Fearless concurrency: how Clojure, Rust, Pony, Erlang and Dart let you achieve that</title><link>https://sites.google.com/a/athaydes.com/renato-athaydes/posts/fearlessconcurrencyhowclojurerustponyerlanganddartletyouachievethat</link><description><![CDATA[several models that make it easier to reason about concurrent programs have been envisioned over time. In this article, we'll have a quick look at a few of them, from new to not-so-new languages. I don't intend to give an extensive analysis of each solution, or make a formal comparison between them. My intention is to simply explain the basics of each solution and how they can be used in practice (with code samples that show off what the result of using the models might look like), so that other developers may have an easier time understanding them and deciding which solution, or language, might be better applicable to their particular problems.]]></description><guid isPermaLink="false">938a7c8a-5c3d-4adb-82e0-caf416396075</guid><pubDate>Sun, 24 Feb 2019 09:13:00 +0000</pubDate><dc:creator>Renato Athaydes</dc:creator></item><item><title>Zero knowledge proofs using Bulletproofs</title><link>https://medium.com/coinmonks/zero-knowledge-proofs-using-bulletproofs-4a8e2579fc82</link><description><![CDATA[I will show how to create various zero knowledge proofs using the Bulletproofs implementation from dalek-cryptography. The examples will be i) proving knowledge of factors of a given number without revealing the factors, ii) a range proof, i.e. prove that you know a value x such that a ≤ x ≤ b without revealing x, iii) prove that the value you have is non-zero without revealing it (without using above range proof), iv) Set membership, i.e given a set S, prove that you know an element contained in the set without revealing the element, v) Similarly, set non-membership without revealing the value of the absent element. The examples can be adapted with little effort such that they can be used in ZK-SNARK implementations like libsnark or bellman.]]></description><guid isPermaLink="false">fae48adb-0406-4124-b06d-6b9d7a667d85</guid><pubDate>Sat, 23 Feb 2019 20:38:04 +0000</pubDate><dc:creator>Lovesh Harchandani</dc:creator></item><item><title>Combine Results for Improved Rust Validation Logic</title><link>https://www.joshmcguigan.com/blog/multi-try-improved-validation-logic-rust/</link><description><![CDATA[The error handling features within Rust are some of my favorite things about the language. This system works great when you are in a function which returns a Result and you want to exit at the first error you come to. However, it can be challenging if your goal is to try a few failure-prone things and return each of the errors, rather than just the first error. This is the problem multi_try attempts to solve. ]]></description><guid isPermaLink="false">03e057c7-1da0-4468-b0f8-3aaedde6b241</guid><pubDate>Sat, 23 Feb 2019 00:00:00 +0000</pubDate><dc:creator>Josh Mcguigan</dc:creator></item><item><title>Scientific computing: a Rust adventure [Part 0 - Vectors]</title><link>https://www.lpalmieri.com/posts/2019-02-23-scientific-computing-a-rust-adventure-part-0-vectors/</link><description><![CDATA[My daily work revolves around building Machine Learning applications, while a lot of my evenings have been spent experimenting with Rust, getting more and more fascinated and in love with the language.

It couldn’t be helped: I started to have a look at what the Rust ecosystem had to offer for Machine Learning, Big Data and scientific computing at large. I quickly found out that there is a lot to be done and a lot of potential (see here or here). It got me really fired up 🔥]]></description><guid isPermaLink="false">8d4c090f-e6e3-4975-abe7-385479579cfa</guid><pubDate>Sat, 23 Feb 2019 00:00:00 +0000</pubDate><dc:creator>Luca Palmieri</dc:creator></item><item><title>Our first Rust crate: decrypting ansible vaults</title><link>https://medium.com/@woutergeraedts/our-first-rust-crate-decrypting-ansible-vaults-25f2f3a9a674</link><description><![CDATA[We encrypt these secrets in so-called ansible vaults. Kuberwave also has the need to access these secrets. Because our staff is already comfortable with using these vaults, we’ve decided to also employ them for our Kubernetes setup. For this I created ansible-vault-rs, a library that can decrypt ansible vaults. Note that it can not create or edit vaults, because I have no need (yet) for this functionality.]]></description><guid isPermaLink="false">2c0b32cc-51a7-4e6f-a729-92c6cedcd7b1</guid><pubDate>Fri, 22 Feb 2019 08:12:26 +0000</pubDate><dc:creator>Wouter Geraedts</dc:creator></item><item><title>Rust lang team working groups</title><link>http://smallcultfollowing.com/babysteps/blog/2019/02/22/rust-lang-team-working-groups/</link><description><![CDATA[Now that the Rust 2018 edition has shipped, the language design team has been thinking a lot about what to do in 2019 and over the next few years. I think we’ve got a lot of exciting stuff on the horizon, and I wanted to write about it.]]></description><guid isPermaLink="false">0d3ca45d-85aa-40ab-95f0-40ec5abaa75f</guid><pubDate>Fri, 22 Feb 2019 00:00:00 -0500</pubDate><dc:creator>Niko Matsakis</dc:creator></item><item><title>Changes in the core team</title><link>https://blog.rust-lang.org/2019/02/22/Core-team-changes.html</link><description><![CDATA[Just a quick update: You may have noticed that, in the last month or so, a number of Rust core team members have changed their jobs and/or their roles in the project.]]></description><guid isPermaLink="false">2471466d-74a1-4d19-82d7-6909e10178cd</guid><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><dc:creator>The Rust Core Team</dc:creator></item><item><title>git req | switch branches, not context</title><link>https://arusahni.github.io/git-req/</link><description><![CDATA[Check out git branches by their pull (or merge) request ID]]></description><guid isPermaLink="false">3a45d462-3f13-451b-8b15-03d07069c3f3</guid><pubDate>Thu, 21 Feb 2019 10:16:00 +0000</pubDate><dc:creator>Aru Sahni</dc:creator></item><item><title>How to document Rust&apos;s macro invocation</title><link>https://amanjeev.com/blog/rust-document-macro-invocations/</link><description><![CDATA[You can easily document your Rust items like functions by putting three slashes ///. However, if you want to document each separate invocation of your amazing! macro, it is not that straightfoward.]]></description><guid isPermaLink="false">6cab1c1c-68f3-4f20-b239-85009d4d563a</guid><pubDate>Thu, 21 Feb 2019 00:00:00 +0000</pubDate><dc:creator>Amanjeev Sethi</dc:creator></item><item><title>New Gtk-rs release finally happened!</title><link>https://gtk-rs.org/blog/2019/02/21/new-release.html</link><description><![CDATA[It’s time for a new release! Main adds/changes this time are: We added the generation of the Atk crate. We now generate functions taking callback as parameters. We improved the channels handling in GLib. The whole new GString type! The minimum Rust version supported is now the 1.31. The minimum version of all libraries has been changed to GNOME 3.14. The maximum version of all libraries has been upgraded to GNOME 3.30. Added subclassing support in GLib. Even more bindings generated. Let’s see those in details.]]></description><guid isPermaLink="false">7a149bc9-7e87-40cb-b3ef-da277059f897</guid><pubDate>Thu, 21 Feb 2019 00:00:00 +0000</pubDate><dc:creator>Gtk-rs</dc:creator></item><item><title>Procedural Generation with Wave Function Collapse</title><link>https://gridbugs.org/wave-function-collapse/</link><description><![CDATA[Wave Function Collapse is a procedural generation algorithm which produces images by arranging a collection of tiles according to rules about which tiles may be adjacent to each other tile, and relatively how frequently each tile should appear. The algorithm maintains, for each pixel of the output image, a probability distribution of the tiles which may be placed there. It repeatedly chooses a pixel to “collapse” - choosing a tile to use for that pixel based on its distribution. WFC gets its name from quantum physics. The goal of this post is to build an intuition for how and why the WFC algorithm works.]]></description><guid isPermaLink="false">2c967b7c-6987-45ae-96b1-776ee6c51011</guid><pubDate>Thu, 21 Feb 2019 00:00:00 +0000</pubDate><dc:creator>Stephen Sherratt</dc:creator></item><item><title>Updates about my work on native-Rust GUI, text layout, splines, markdown parsing, and more</title><link>https://raphlinus.github.io/personal/2019/02/20/more-small-updates.html</link><description><![CDATA[This post is actually a collection of updates about pretty big things, but the writeup is small. Several will be expanded into larger blog posts - if there are any that you are especially eager to see, please tweet at me and I’ll give the topic priority.]]></description><guid isPermaLink="false">ea353a56-0b7b-4025-a410-0e479c39950a</guid><pubDate>Wed, 20 Feb 2019 17:02:42 +0000</pubDate><dc:creator>Raph Levien</dc:creator></item><item><title>DOS: the final frontier...</title><link>https://www.reddit.com/r/rust/comments/ask2v5/dos_the_final_frontier/</link><description><![CDATA[In our crusade to oxidize platform after platform, I've been working to bring Rust to yet another target: MS-DOS. I don't know if this has been done before, but I couldn't find any information about it on the web, so I had to rely on information about using GCC to compile MS-DOS programs (not all of which carried over), and it took quite a bit of fiddling with the target specification to get things just right. In the end, I've managed to produce COM executables that can call DOS interrupts and interface with hardware such as the PC speaker, and presumably the rest of the hardware, given the right code.]]></description><guid isPermaLink="false">7c13bc47-79a3-408a-bfc0-d67639f4f359</guid><pubDate>Wed, 20 Feb 2019 15:47:21 +1100</pubDate><dc:creator>u/serentty</dc:creator></item><item><title>Introducing embedded-sdmmc - a pure-Rust #[no_std] SD card and FAT16/FAT32 library</title><link>https://www.reddit.com/r/rust/comments/ascvls/introducing_embeddedsdmmc_a_purerust_no_std_sd/</link><description><![CDATA[161 votes and 6 comments so far on Reddit]]></description><guid isPermaLink="false">fe990782-d611-46a2-a6c1-4048707e61df</guid><pubDate>Wed, 20 Feb 2019 04:32:00 +0000</pubDate><dc:creator>Jonathan Pallant</dc:creator></item><item><title>The Embedded Working Group Newsletter - 15</title><link>https://rust-embedded.github.io/blog/newsletter-15/</link><description><![CDATA[This is the fifteenth newsletter of the Embedded WG where we highlight new progress, celebrate cool projects, thank the community, and advertise projects that need help!]]></description><guid isPermaLink="false">e7d75d4a-b84d-41fd-a164-016bb9e9d99c</guid><pubDate>Wed, 20 Feb 2019 00:00:00 +0000</pubDate><dc:creator>The Embedded Working Group</dc:creator></item><item><title>My experience with Rust</title><link>http://subhojit777.in/rust-language-experience/</link><description><![CDATA[I started learning Rust in 2018. I completed my work in an open source project and was thinking about learning a new programming language. My motive was to learn a language that allows you to control the lower level of a high-level programming language. I considered learning Golang, but, in most of the online articles I learned that Rust (being a system programming language) gives you more control than Go, however, the learning curve is far steeper than Go. I had no worries about deadlines or time, therefore I chose Rust.]]></description><guid isPermaLink="false">fb473ea5-9d84-4c2d-9926-282c55dcbf18</guid><pubDate>Wed, 20 Feb 2019 00:00:00 +0000</pubDate><dc:creator>Subhojit Paul</dc:creator></item><item><title>rustdoc in 2019</title><link>https://quietmisdreavus.net/code/2019/02/19/rustdoc-in-2019/</link><description><![CDATA[A recap of the 2019 Rust All-Hands from a rustdoc perspective; and the 2019 roadmap for the Rustdoc Team.]]></description><guid isPermaLink="false">5afc518c-63b7-4b76-96f2-659de41359d9</guid><pubDate>Tue, 19 Feb 2019 12:00:00 -0600</pubDate><dc:creator>QuietMisdreavus</dc:creator></item><item><title>Part 3: Graggles can have cycles</title><link>https://jneem.github.io/cycles/</link><description><![CDATA[Almost two years ago, I promised a series of three posts about version control. The first two (here and here) introduced a new (at the time) framework for version control. The third post, which I never finished, was going to talk about the datastructures and algorithms used in pijul, a version control system built around that new framework. The problem is that pijul is a complex piece of software, and so I had lots of trouble wrapping my head around it.

Two years later, I’m finally ready to continue with this series of posts (but having learned from my earlier mistakes, I’m not going to predict the total number of posts ahead of time). In the meantime, I’ve written my own toy version control system (VCS) to help me understand what’s going on. It’s called ojo, and it’s extremely primitive: to start with, it can only track a single file. However, it is (just barely) sophisticated enough to demonstrate the important ideas. I’m also doing my best to make the code is clear and well-documented.]]></description><guid isPermaLink="false">53d60351-cb50-4f9f-83d7-e6c8d94ab025</guid><pubDate>Tue, 19 Feb 2019 00:00:00 +0000</pubDate><dc:creator>Joe Neeman</dc:creator></item><item><title>Cross-compiling Rust code to Minix</title><link>https://iandouglasscott.com/2019/02/18/cross-compiling-rust-code-to-minix/</link><description><![CDATA[I’ve decided to take a look at Minix, which is an interesting microkernel OS. Naturally after building Minix from git, the first thing I decided to try was porting Rust’s std to Minix so I could cross-compile Rust programs from Linux to run under Minix. Okay, I suppose I could have started with something else, but porting Rust software and modifying the platform-depending part of std is something I have experience with from working on Redox OS. And Rust really isn’t that hard to port.]]></description><guid isPermaLink="false">2c73855c-6079-427a-b075-4c07ed3cec23</guid><pubDate>Mon, 18 Feb 2019 13:00:00 -0800</pubDate><dc:creator>Ian Douglas Scott</dc:creator></item></channel></rss>