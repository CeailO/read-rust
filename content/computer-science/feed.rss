<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/"><channel><title>Read Rust - Computer Science</title><link>https://readrust.net/</link><description>Computer Science posts on Read Rust</description><item><title>Fast Search Through Metric Spaces with Rust and BK Trees</title><link>https://www.innoq.com/en/blog/looks-the-same-to-me/</link><description>In the previous post, pHash helped us to summarize our photo album. Now it’s time to employ BK-trees and efficiently search through the metric space of perceptual hashes. Let’s roll up the sleeves; more Rust awaits!</description><guid isPermaLink="false">d377bc0d-a127-456d-81fa-926fe634de0f</guid><pubDate>Thu,  1 Mar 2018 00:00:00 +0100</pubDate><dc:creator>Jan Stępień</dc:creator></item><item><title>Reasoning with Types in Rust</title><link>https://aaronweiss.us/posts/2018-02-26-reasoning-with-types-in-rust.html</link><description>Rust is a modern programming language which is marketed primarily on the basis of its very nice type system, and I’d like to tell you about how you can use this type system to reason about your programs in interesting ways. Most of the time when its type system is discussed, the focus is on its guarantee of data race freedom and ability to enable so-called fearless concurrency (and rightfully so—this is a place where Rust truly shines!). Today, I have a different focus in mind, characterized perhaps most succinctly as follows:</description><guid isPermaLink="false">5e572868-98d0-4944-b897-14cca13a39a4</guid><pubDate>Mon, 26 Feb 2018 00:00:00 +0000</pubDate><dc:creator>Aaron Weiss</dc:creator></item><item><title>Combine 3 - Partial parsing in Rust</title><link>https://marwes.github.io/2018/02/08/combine-3.html</link><description>Combine is a parser combinator library for the Rust programming language. I first announced version 3 of Combine back in August and back then I definitely expected to have a stable version by now. However other projects (cough gluon cough) got in the way and Combine fell to the wayside. It didn’t help that I didn’t have a killer feature for 3.0 either, user-defined error types make it possible to define parsers usable in #[no_std] crates which is great when you need it but it is still a fairly niche use-case.</description><guid isPermaLink="false">29eb1ede-d551-4b8d-aeec-c673aafb7e8f</guid><pubDate>Thu,  8 Feb 2018 00:00:00 +0000</pubDate><dc:creator>Markus Westerlind</dc:creator></item><item><title>Memory Safety in Rust: A Case Study with C</title><link>http://willcrichton.net/notes/rust-memory-safety/</link><description>To demonstrate the value of Rust&apos;s memory safety rules, I contrast the implementation of a simple vector library in C and Rust, highlighting where and how Rust&apos;s static analysis can prevent tricky memory errors.</description><guid isPermaLink="false">d2fc34d4-c1ec-4c3d-8e39-b420b8f20fe8</guid><pubDate>Fri,  2 Feb 2018 00:00:00 +0000</pubDate><dc:creator>Will Crichton</dc:creator></item></channel></rss>