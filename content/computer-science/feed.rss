<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/"><channel><title>Read Rust - Computer Science</title><link>https://readrust.net/</link><description>Computer Science posts on Read Rust</description><item><title>Modern Parser Generator</title><link>https://matklad.github.io/2018/06/06/modern-parser-generator.html</link><description><![CDATA[During the last couple of years, I’ve spent a lot of time writing parsers and parser generators, and I want to write down my thoughts about this topic. Specifically, I want to describe some properties of a parser generator that I would enjoy using. Note that this is not an “introduction to parsing” blog post, some prior knowledge is assumed.]]></description><guid isPermaLink="false">6f104d56-9b00-4748-a04f-0c77ec89a1d2</guid><pubDate>Wed,  6 Jun 2018 16:03:25 +0000</pubDate><dc:creator>Aleksey Kladov</dc:creator></item><item><title>TensorScript Type Inference: Hindley-Milner in Rust</title><link>http://rickyhan.com/jekyll/update/2018/05/26/hindley-milner-tutorial-rust.html</link><description><![CDATA[Type-inferred gradually typed languages are a joy to use: easy to write, analyze, and refactor. In this blog post, I will showcase to the other dozen of programmers who are interested in the obscure art of programming language type inference.]]></description><guid isPermaLink="false">bfb80762-37e6-4337-83c9-52f371839e60</guid><pubDate>Sat, 26 May 2018 04:00:00 +0000</pubDate><dc:creator>Ricky Han</dc:creator></item><item><title>Implement Raft in Rust</title><link>https://pingcap.com/blog/implement-raft-in-rust/</link><description><![CDATA[Consensus is one of the most important challenges in designing and building distributed systems–how to make sure multiple nodes (or agents, processes, threads, tasks, participants, etc.) in a group agree on a specific value proposed by at least one of the nodes. As an open-source distributed scalable HTAP database, TiDB uses the Raft Consensus Algorithm in its distributed transactional key-value storage engine, TiKV, to ensure data consistency, auto-failover, and fault tolerance.]]></description><guid isPermaLink="false">91a4f766-391d-43fc-a2ce-66354ac78bd4</guid><pubDate>Tue, 22 May 2018 00:00:00 +0000</pubDate><dc:creator>Siddon Tang</dc:creator></item><item><title>Oblix: An Efficient Oblivious Search Index [pdf]</title><link>https://people.eecs.berkeley.edu/~raluca/oblix.pdf</link><description><![CDATA[Abstract—Search indices are fundamental building blocks of many systems, and there is great interest in running them on encrypted data. Unfortunately, many known schemes that enable search queries on encrypted data achieve efficiency at the expense of security, as they reveal access patterns to the encrypted data.  In this paper we present Oblix, a search index for encrypted data that is oblivious (provably hides access patterns), is dynamic (supports inserts and deletes), and has good efficiency.  Oblix relies on a combination of novel oblivious-access tech- niques and recent hardware enclave platforms (e.g., Intel SGX).  In particular, a key technical contribution is the design and implementation of doubly-oblivious data structures, in which the client’s accesses to its internal memory are oblivious, in addition to accesses to its external memory at the server. These algorithms are motivated by hardware enclaves like SGX, which leak access patterns to both internal and external memory.  We demonstrate the usefulness of Oblix in several applications: private contact discovery for Signal, private retrieval of public keys for Key Transparency, and searchable encryption that hides access patterns and result sizes.]]></description><guid isPermaLink="false">e2724828-a6e9-4383-9614-bea31e743784</guid><pubDate>Mon, 21 May 2018 00:00:00 +0000</pubDate><dc:creator>Pratyush Mishra, Rishabh Poddar, Jerry Chen, Alessandro Chiesa, Raluca Ada Popa</dc:creator></item><item><title>Cannoli: A Python Compiler Written in Rust [pdf]</title><link>https://github.com/joncatanio/cannoli/raw/master/resources/papers/cannoli-thesis-paper.pdf</link><description><![CDATA[I just finished my Master's Thesis and part of it was writing a Python compiler in Rust. The goal of the thesis was to evaluate language features of Python that were hypothesized to cause performance issues. Quantifying the cost of these features could be valuable to language designers moving forward. Some interesting results were observed when implementing compiler optimizations for Python. An average speedup of 51% was achieved across a number of benchmarks.]]></description><guid isPermaLink="false">c7a4923a-2a12-4f88-82fc-4b99b94080e9</guid><pubDate>Thu, 17 May 2018 16:00:59 +0000</pubDate><dc:creator>Jonathan Catanio</dc:creator></item><item><title>Bulletproof Multi-Party Computation in Rust with Session Types</title><link>https://blog.chain.com/bulletproof-multi-party-computation-in-rust-with-session-types-b3da6e928d5d</link><description><![CDATA[In Rust, objects are either owned or borrowed. While there can be multiple borrows of the same object, each object has a unique owner. When objects are passed by value, ownership is transferred to the new scope, and the old scope can no longer access it. This makes it possible to implement “consuming” methods which take self by value, and therefore can only be called once. In the party and dealer types, such methods consume the previous state and return the next state in the protocol.]]></description><guid isPermaLink="false">0308ada3-604c-4240-8e94-2f9d23bc2934</guid><pubDate>Fri, 11 May 2018 22:25:19 +0000</pubDate><dc:creator>Cathie Yun</dc:creator></item><item><title>KRust: A Formal Executable Semantics of Rust</title><link>https://arxiv.org/abs/1804.10806</link><description><![CDATA[Rust is a new and promising high-level system programming language. It provides both memory safety and thread safety through its novel mechanisms such as ownership, moves and borrows. Ownership system ensures that at any point there is only one owner of any given resource. The ownership of a resource can be moved or borrowed according to the lifetimes. The ownership system establishes a clear lifetime for each value and hence does not necessarily need garbage collection. These novel features bring Rust high performance, fine low-level control of C and C++, and unnecessity in garbage collection, which differ Rust from other existing prevalent languages. For formal analysis of Rust programs and helping programmers learn its new mechanisms and features, a formal semantics of Rust is desired and useful as a fundament for developing related tools. In this paper, we present a formal executable operational semantics of a realistic subset of Rust, called KRust. The semantics is defined in K, a rewriting-based executable semantic framework for programming languages. The executable semantics yields automatically a formal interpreter and verification tools for Rust programs. KRust has been thoroughly validated by testing with hundreds of tests, including the official Rust test suite.]]></description><guid isPermaLink="false">0c0d7114-9e80-4e4f-868d-51de6778bed1</guid><pubDate>Sat, 28 Apr 2018 00:00:00 +0000</pubDate><dc:creator>Feng Wang, Fu Song, Min Zhang, Xiaoran Zhu, Jun Zhang</dc:creator></item><item><title>QCGPU - Hardware Accelerated Quantum Computer Simulation</title><link>https://qcgpu.github.io/</link><description><![CDATA[A software library for high performance and hardware accelerated simulation of Quantum Computers and Algorithms. Written with Rust and OpenCL.]]></description><guid isPermaLink="false">ed19c2a7-fe9d-465b-b41a-71480e6b978a</guid><pubDate>Wed, 11 Apr 2018 06:47:00 +1000</pubDate><dc:creator>QCGPU</dc:creator></item><item><title>Safe Intrusive Collections with Pinning</title><link>https://www.ralfj.de/blog/2018/04/10/safe-intrusive-collections-with-pinning.html</link><description><![CDATA[In my last post, I talked about the new “pinned references” which guarantee that the data at the memory it points to will not, ever, be moved elsewhere. I explained how they enable giving a safe API to code that could previously only be exposed with unsafe, and how one could go about proving such a thing. This post is about another application of pinned references—another API whose safety relies on the pinning guarantees: Intrusive collections. It turns out that pinned references can almost be used for this, but not quite. However, this can be fixed by extending the guarantees provided by pinned references, as suggested by @cramertj.]]></description><guid isPermaLink="false">68ff8b22-500f-4674-b9f0-b70414db12d8</guid><pubDate>Tue, 10 Apr 2018 00:00:00 +0000</pubDate><dc:creator>Ralf Jung</dc:creator></item><item><title>Writing a recursive ascent parser by hand</title><link>https://www.abubalay.com/blog/2018/04/08/recursive-ascent</link><description><![CDATA[I’ve been exploring various ways to write parsers. For a long time, I’ve used hand-written recursive descent for its straightforwardness, flexibility, and performance. There is another way—parser generators like Menhir, LALRPOP, or the venerable Bison use the bottom-up LR algorithm. I decided I would try an experiment: write an LR parser by hand, and see how readable I could make it.]]></description><guid isPermaLink="false">66851aee-1bf3-4b18-b1aa-50f79ce773f4</guid><pubDate>Sun,  8 Apr 2018 00:00:00 +0000</pubDate><dc:creator>Russell Johnston</dc:creator></item><item><title>im - Immutable Data Structures for Rust</title><link>https://docs.rs/im/10.0.0/im/</link><description><![CDATA[This library implements several of the more commonly useful immutable data structures for Rust. They rely on structural sharing to keep most operations fast without needing to mutate the underlying data store, leading to more predictable code without necessarily sacrificing performance.]]></description><guid isPermaLink="false">318f9d08-d86a-4799-ac08-75014d089475</guid><pubDate>Fri,  6 Apr 2018 21:06:00 +0000</pubDate><dc:creator>Bodil Stokke</dc:creator></item><item><title>Sound and ergonomic specialization for Rust</title><link>http://aturon.github.io/2018/04/05/sound-specialization/</link><description><![CDATA[Specialization holds the dubious honor of being among the oldest post-1.0 features remaining in unstable limbo. That’s for good reason, though: until recently, we did not know how to make it sound.]]></description><guid isPermaLink="false">e01d9c09-e66d-4fea-94e3-95db24137dd6</guid><pubDate>Thu,  5 Apr 2018 00:00:00 +0000</pubDate><dc:creator>Aaron Turon</dc:creator></item><item><title>Writing the Perfect &apos;Collect&apos; Trait</title><link>https://mtak-blog.github.io/the_perfect_collect_trait</link><description><![CDATA[I’ve been spending some time thinking about garbage collection in rust. I know, shame on me, it’s a systems language, we hate garbage collection, but… even in a systems programming language, garbage collection is still pretty damn useful.]]></description><guid isPermaLink="false">4812042b-1d2a-4171-9a77-d2f0a0c44b91</guid><pubDate>Thu,  5 Apr 2018 00:00:00 +0000</pubDate><dc:creator>mtak-blog</dc:creator></item><item><title>Number Theory using Rust&apos;s type system</title><link>https://shingtaklam1324.github.io/number-theory-rust/</link><description><![CDATA[Rust does not have dependent types, or GADTs like Haskell, but with a few tricks, we can use Rust's type system to emulate an Idris-like number system.]]></description><guid isPermaLink="false">465a729e-a243-4cd7-bee8-e0c7d5d09fbd</guid><pubDate>Sun, 18 Mar 2018 00:00:00 +1100</pubDate><dc:creator>shingtaklam1324</dc:creator></item><item><title>stencil; abstract stencil calculation</title><link>https://dev.to/termoshtt/stencil-abstract-stencil-calculation-i2m</link><description><![CDATA[I am developing a library for stencil calculation in Rust.]]></description><guid isPermaLink="false">17b6e878-388f-40c5-93a0-cf3da64a1078</guid><pubDate>Sat, 17 Mar 2018 00:00:00 +0000</pubDate><dc:creator>termoshtt</dc:creator></item><item><title>Fast Search Through Metric Spaces with Rust and BK Trees</title><link>https://www.innoq.com/en/blog/looks-the-same-to-me/</link><description><![CDATA[In the previous post, pHash helped us to summarize our photo album. Now it’s time to employ BK-trees and efficiently search through the metric space of perceptual hashes. Let’s roll up the sleeves; more Rust awaits!]]></description><guid isPermaLink="false">d377bc0d-a127-456d-81fa-926fe634de0f</guid><pubDate>Thu,  1 Mar 2018 00:00:00 +0100</pubDate><dc:creator>Jan Stępień</dc:creator></item><item><title>Reasoning with Types in Rust</title><link>https://aaronweiss.us/posts/2018-02-26-reasoning-with-types-in-rust.html</link><description><![CDATA[Rust is a modern programming language which is marketed primarily on the basis of its very nice type system, and I’d like to tell you about how you can use this type system to reason about your programs in interesting ways. Most of the time when its type system is discussed, the focus is on its guarantee of data race freedom and ability to enable so-called fearless concurrency (and rightfully so—this is a place where Rust truly shines!). Today, I have a different focus in mind, characterized perhaps most succinctly as follows:]]></description><guid isPermaLink="false">5e572868-98d0-4944-b897-14cca13a39a4</guid><pubDate>Mon, 26 Feb 2018 00:00:00 +0000</pubDate><dc:creator>Aaron Weiss</dc:creator></item><item><title>Combine 3 - Partial parsing in Rust</title><link>https://marwes.github.io/2018/02/08/combine-3.html</link><description><![CDATA[Combine is a parser combinator library for the Rust programming language. I first announced version 3 of Combine back in August and back then I definitely expected to have a stable version by now. However other projects (cough gluon cough) got in the way and Combine fell to the wayside. It didn’t help that I didn’t have a killer feature for 3.0 either, user-defined error types make it possible to define parsers usable in #[no_std] crates which is great when you need it but it is still a fairly niche use-case.]]></description><guid isPermaLink="false">29eb1ede-d551-4b8d-aeec-c673aafb7e8f</guid><pubDate>Thu,  8 Feb 2018 00:00:00 +0000</pubDate><dc:creator>Markus Westerlind</dc:creator></item><item><title>Memory Safety in Rust: A Case Study with C</title><link>http://willcrichton.net/notes/rust-memory-safety/</link><description><![CDATA[To demonstrate the value of Rust's memory safety rules, I contrast the implementation of a simple vector library in C and Rust, highlighting where and how Rust's static analysis can prevent tricky memory errors.]]></description><guid isPermaLink="false">d2fc34d4-c1ec-4c3d-8e39-b420b8f20fe8</guid><pubDate>Fri,  2 Feb 2018 00:00:00 +0000</pubDate><dc:creator>Will Crichton</dc:creator></item></channel></rss>