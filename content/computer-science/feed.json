{
  "version": "https://jsonfeed.org/version/1",
  "title": "Read Rust - Computer Science",
  "home_page_url": "https://readrust.net/",
  "feed_url": "https://readrust.net/computer-science/feed.json",
  "description": "Computer Science posts on Read Rust",
  "author": {
    "name": "Wesley Moore",
    "url": "http://www.wezm.net/"
  },
  "items": [
    {
      "id": "ab3d6484-4107-4555-a9b0-0f1aa6ae9a18",
      "title": "How Usable are Rust Cryptography APIs?",
      "content_text": "Poor usability of cryptographic APIs is a severe source of vulnerabilities. Aim: We wanted to find out what kind of cryptographic libraries are present in Rust and how usable they are. Method: We explored Rust's cryptographic libraries through a systematic search, conducted an exploratory study on the major libraries and a controlled experiment on two of these libraries with 28 student participants. Results: Only half of the major libraries explicitly focus on usability and misuse resistance, which is reflected in their current APIs. We found that participants were more successful using rust-crypto which we considered less usable than ring before the experiment. Conclusion: We discuss API design insights and make recommendations for the design of crypto libraries in Rust regarding the detail and structure of the documentation, higher-level APIs as wrappers for the existing low-level libraries, and selected, good-quality example code to improve the emerging cryptographic libraries of Rust.",
      "url": "https://arxiv.org/abs/1806.04929",
      "date_published": "2018-06-26T00:00:00+00:00",
      "author": {
        "name": "Kai Mindermann, Philipp Keck, Stefan Wagner",
        "url": "https://arxiv.org/"
      },
      "tags": [
        "Computer Science"
      ]
    },
    {
      "id": "16b43079-6e0d-4c7e-9ea3-00cf0405bf49",
      "title": "Genetic Algorithms in Rust for Autonomous Agents: An Introduction",
      "content_text": "This article discusses a possible genetic algorithm implementation in Rust applied to the travelling salesman problem.",
      "url": "https://medium.com/coinmonks/genetic-algorithms-in-rust-for-autonomous-agents-an-introduction-ac182de32aee",
      "date_published": "2018-06-30T14:09:48.725+00:00",
      "author": {
        "name": "Mithi",
        "url": "https://medium.com/@mithi"
      },
      "tags": [
        "Computer Science"
      ]
    },
    {
      "id": "04445b84-5c91-467e-840c-45df1765c4e6",
      "title": "[1807.00067] Josephine: Using JavaScript to safely manage the lifetimes of Rust data",
      "content_text": "This paper is about the interface between languages which use a garbage collector and those which use fancy types for safe manual memory management. Garbage collection is the traditional memory management scheme for functional languages, whereas type systems are now used for memory safety in imperative languages. We use existing techniques for linear capabilities to provide safe access to copyable references, but the application to languages with a tracing garbage collector, and to data with explicit lifetimes is new. This work is related to mixed linear/non-linear programming, but the languages being mixed are Rust and JavaScript.",
      "url": "https://arxiv.org/abs/1807.00067",
      "date_published": "2018-06-29T00:00:00+00:00",
      "author": {
        "name": "Alan Jeffrey",
        "url": "http://asaj.org/"
      },
      "tags": [
        "Computer Science"
      ]
    },
    {
      "id": "b63f8372-7dbc-4bf5-9ab3-e13a95a011be",
      "title": "Logistic Regression in Rust",
      "content_text": "This weekend, I implemented logistic regression in Rust. For me, the most interesting parts were learning how to implement a stopping condition and how to automatically set a step size.",
      "url": "http://paulkernfeld.com/2018/07/01/logistic-regression-in-rust.html",
      "date_published": "2018-07-01T00:00:00+00:00",
      "author": {
        "name": "Paul Kernfeld",
        "url": "http://paulkernfeld.com/"
      },
      "tags": [
        "Computer Science"
      ]
    },
    {
      "id": "6c71975e-3550-410a-99e7-2ee9635fb0e6",
      "title": "Generic associated types in iterators",
      "content_text": "In this article, I want to explain the term Generic Associated Types through a concrete example. I noticed that people (especially in video games development) need some tools to iterate in various manners mutably, efficiently and safely. I tried to write some convenient iterators over vectors and slices that solve those problems, but finally, I understood that some tools cannot be written with std::iter::Iterator. Doing so led me to the comprehension of generic associated types that I will abbreviate as GATs in this article. I will explain here what GATs are and why they are needed.",
      "url": "https://boiethios.gitlab.io/blog/2018-06-21_GATs_iterators.html",
      "date_published": "2018-06-21T00:00:00+00:00",
      "author": {
        "name": "Boiethios",
        "url": "https://boiethios.gitlab.io/blog/index.html"
      },
      "tags": [
        "Computer Science"
      ]
    },
    {
      "id": "a07d66f5-dfd3-41d4-b2d8-16bf1b0f4886",
      "title": "Rust Distilled: An Expressive Tower of Languages",
      "content_text": "Rust represents a major advancement in production programming languages because of its success in bridging the gap between high-level application programming and low-level systems programming. At the heart of its design lies a novel approach to ownership that remains highly programmable.\n\nIn this talk, we will describe our ongoing work on designing a formal semantics for Rust that captures how programmers can understand ownership and borrowing without trying to grasp the details of lifetime analysis.",
      "url": "https://arxiv.org/abs/1806.02693",
      "date_published": "2018-06-07T00:00:00+00:00",
      "author": {
        "name": "Aaron Weiss, Daniel Patterson, Amal Ahmed",
        "url": "https://arxiv.org/"
      },
      "tags": [
        "Computer Science"
      ]
    },
    {
      "id": "6f104d56-9b00-4748-a04f-0c77ec89a1d2",
      "title": "Modern Parser Generator",
      "content_text": "During the last couple of years, I’ve spent a lot of time writing parsers and parser generators, and I want to write down my thoughts about this topic. Specifically, I want to describe some properties of a parser generator that I would enjoy using. Note that this is not an “introduction to parsing” blog post, some prior knowledge is assumed.",
      "url": "https://matklad.github.io/2018/06/06/modern-parser-generator.html",
      "date_published": "2018-06-06T16:03:25+00:00",
      "author": {
        "name": "Aleksey Kladov",
        "url": "https://matklad.github.io/"
      },
      "tags": [
        "Computer Science"
      ]
    },
    {
      "id": "bfb80762-37e6-4337-83c9-52f371839e60",
      "title": "TensorScript Type Inference: Hindley-Milner in Rust",
      "content_text": "Type-inferred gradually typed languages are a joy to use: easy to write, analyze, and refactor. In this blog post, I will showcase to the other dozen of programmers who are interested in the obscure art of programming language type inference.",
      "url": "http://rickyhan.com/jekyll/update/2018/05/26/hindley-milner-tutorial-rust.html",
      "date_published": "2018-05-26T04:00:00+00:00",
      "author": {
        "name": "Ricky Han",
        "url": "http://rickyhan.com/"
      },
      "tags": [
        "Computer Science"
      ]
    },
    {
      "id": "e2724828-a6e9-4383-9614-bea31e743784",
      "title": "Oblix: An Efficient Oblivious Search Index [pdf]",
      "content_text": "Abstract—Search indices are fundamental building blocks of many systems, and there is great interest in running them on encrypted data. Unfortunately, many known schemes that enable search queries on encrypted data achieve efficiency at the expense of security, as they reveal access patterns to the encrypted data.  In this paper we present Oblix, a search index for encrypted data that is oblivious (provably hides access patterns), is dynamic (supports inserts and deletes), and has good efficiency.  Oblix relies on a combination of novel oblivious-access tech- niques and recent hardware enclave platforms (e.g., Intel SGX).  In particular, a key technical contribution is the design and implementation of doubly-oblivious data structures, in which the client’s accesses to its internal memory are oblivious, in addition to accesses to its external memory at the server. These algorithms are motivated by hardware enclaves like SGX, which leak access patterns to both internal and external memory.  We demonstrate the usefulness of Oblix in several applications: private contact discovery for Signal, private retrieval of public keys for Key Transparency, and searchable encryption that hides access patterns and result sizes.",
      "url": "https://people.eecs.berkeley.edu/~raluca/oblix.pdf",
      "date_published": "2018-05-21T00:00:00+00:00",
      "author": {
        "name": "Pratyush Mishra, Rishabh Poddar, Jerry Chen, Alessandro Chiesa, Raluca Ada Popa",
        "url": "https://rise.cs.berkeley.edu/blog/publication/oblix-an-efficient-oblivious-search-index/"
      },
      "tags": [
        "Computer Science"
      ]
    },
    {
      "id": "91a4f766-391d-43fc-a2ce-66354ac78bd4",
      "title": "Implement Raft in Rust",
      "content_text": "Consensus is one of the most important challenges in designing and building distributed systems–how to make sure multiple nodes (or agents, processes, threads, tasks, participants, etc.) in a group agree on a specific value proposed by at least one of the nodes. As an open-source distributed scalable HTAP database, TiDB uses the Raft Consensus Algorithm in its distributed transactional key-value storage engine, TiKV, to ensure data consistency, auto-failover, and fault tolerance.",
      "url": "https://pingcap.com/blog/implement-raft-in-rust/",
      "date_published": "2018-05-22T00:00:00+00:00",
      "author": {
        "name": "Siddon Tang",
        "url": "https://pingcap.com/blog"
      },
      "tags": [
        "Computer Science"
      ]
    },
    {
      "id": "c7a4923a-2a12-4f88-82fc-4b99b94080e9",
      "title": "Cannoli: A Python Compiler Written in Rust [pdf]",
      "content_text": "I just finished my Master's Thesis and part of it was writing a Python compiler in Rust. The goal of the thesis was to evaluate language features of Python that were hypothesized to cause performance issues. Quantifying the cost of these features could be valuable to language designers moving forward. Some interesting results were observed when implementing compiler optimizations for Python. An average speedup of 51% was achieved across a number of benchmarks.",
      "url": "https://github.com/joncatanio/cannoli/raw/master/resources/papers/cannoli-thesis-paper.pdf",
      "date_published": "2018-05-17T16:00:59+00:00",
      "author": {
        "name": "Jonathan Catanio",
        "url": "https://github.com/joncatanio"
      },
      "tags": [
        "Computer Science"
      ]
    },
    {
      "id": "0308ada3-604c-4240-8e94-2f9d23bc2934",
      "title": "Bulletproof Multi-Party Computation in Rust with Session Types",
      "content_text": "In Rust, objects are either owned or borrowed. While there can be multiple borrows of the same object, each object has a unique owner. When objects are passed by value, ownership is transferred to the new scope, and the old scope can no longer access it. This makes it possible to implement “consuming” methods which take self by value, and therefore can only be called once. In the party and dealer types, such methods consume the previous state and return the next state in the protocol.",
      "url": "https://blog.chain.com/bulletproof-multi-party-computation-in-rust-with-session-types-b3da6e928d5d",
      "date_published": "2018-05-11T22:25:19.221+00:00",
      "author": {
        "name": "Cathie Yun",
        "url": "https://blog.chain.com/@cathieyun"
      },
      "tags": [
        "Computer Science"
      ]
    },
    {
      "id": "0c0d7114-9e80-4e4f-868d-51de6778bed1",
      "title": "KRust: A Formal Executable Semantics of Rust",
      "content_text": "Rust is a new and promising high-level system programming language. It provides both memory safety and thread safety through its novel mechanisms such as ownership, moves and borrows. Ownership system ensures that at any point there is only one owner of any given resource. The ownership of a resource can be moved or borrowed according to the lifetimes. The ownership system establishes a clear lifetime for each value and hence does not necessarily need garbage collection. These novel features bring Rust high performance, fine low-level control of C and C++, and unnecessity in garbage collection, which differ Rust from other existing prevalent languages. For formal analysis of Rust programs and helping programmers learn its new mechanisms and features, a formal semantics of Rust is desired and useful as a fundament for developing related tools. In this paper, we present a formal executable operational semantics of a realistic subset of Rust, called KRust. The semantics is defined in K, a rewriting-based executable semantic framework for programming languages. The executable semantics yields automatically a formal interpreter and verification tools for Rust programs. KRust has been thoroughly validated by testing with hundreds of tests, including the official Rust test suite.",
      "url": "https://arxiv.org/abs/1804.10806",
      "date_published": "2018-04-28T00:00:00+00:00",
      "author": {
        "name": "Feng Wang, Fu Song, Min Zhang, Xiaoran Zhu, Jun Zhang",
        "url": "https://arxiv.org/"
      },
      "tags": [
        "Computer Science"
      ]
    },
    {
      "id": "ed19c2a7-fe9d-465b-b41a-71480e6b978a",
      "title": "QCGPU - Hardware Accelerated Quantum Computer Simulation",
      "content_text": "A software library for high performance and hardware accelerated simulation of Quantum Computers and Algorithms. Written with Rust and OpenCL.",
      "url": "https://qcgpu.github.io/",
      "date_published": "2018-04-11T06:47:00+10:00",
      "author": {
        "name": "QCGPU",
        "url": "https://qcgpu.github.io/"
      },
      "tags": [
        "Computer Science",
        "Tools and Applications"
      ]
    },
    {
      "id": "68ff8b22-500f-4674-b9f0-b70414db12d8",
      "title": "Safe Intrusive Collections with Pinning",
      "content_text": "In my last post, I talked about the new “pinned references” which guarantee that the data at the memory it points to will not, ever, be moved elsewhere. I explained how they enable giving a safe API to code that could previously only be exposed with unsafe, and how one could go about proving such a thing. This post is about another application of pinned references—another API whose safety relies on the pinning guarantees: Intrusive collections. It turns out that pinned references can almost be used for this, but not quite. However, this can be fixed by extending the guarantees provided by pinned references, as suggested by @cramertj.",
      "url": "https://www.ralfj.de/blog/2018/04/10/safe-intrusive-collections-with-pinning.html",
      "date_published": "2018-04-10T00:00:00+00:00",
      "author": {
        "name": "Ralf Jung",
        "url": "https://www.ralfj.de/blog/"
      },
      "tags": [
        "Computer Science"
      ]
    },
    {
      "id": "66851aee-1bf3-4b18-b1aa-50f79ce773f4",
      "title": "Writing a recursive ascent parser by hand",
      "content_text": "I’ve been exploring various ways to write parsers. For a long time, I’ve used hand-written recursive descent for its straightforwardness, flexibility, and performance. There is another way—parser generators like Menhir, LALRPOP, or the venerable Bison use the bottom-up LR algorithm. I decided I would try an experiment: write an LR parser by hand, and see how readable I could make it.",
      "url": "https://www.abubalay.com/blog/2018/04/08/recursive-ascent",
      "date_published": "2018-04-08T00:00:00+00:00",
      "author": {
        "name": "Russell Johnston",
        "url": "https://www.abubalay.com/blog"
      },
      "tags": [
        "Computer Science"
      ]
    },
    {
      "id": "e01d9c09-e66d-4fea-94e3-95db24137dd6",
      "title": "Sound and ergonomic specialization for Rust",
      "content_text": "Specialization holds the dubious honor of being among the oldest post-1.0 features remaining in unstable limbo. That’s for good reason, though: until recently, we did not know how to make it sound.",
      "url": "http://aturon.github.io/2018/04/05/sound-specialization/",
      "date_published": "2018-04-05T00:00:00+00:00",
      "author": {
        "name": "Aaron Turon",
        "url": "http://aturon.github.io/"
      },
      "tags": [
        "Language",
        "Computer Science"
      ]
    },
    {
      "id": "4812042b-1d2a-4171-9a77-d2f0a0c44b91",
      "title": "Writing the Perfect 'Collect' Trait",
      "content_text": "I’ve been spending some time thinking about garbage collection in rust. I know, shame on me, it’s a systems language, we hate garbage collection, but… even in a systems programming language, garbage collection is still pretty damn useful.",
      "url": "https://mtak-blog.github.io/the_perfect_collect_trait",
      "date_published": "2018-04-05T00:00:00+00:00",
      "author": {
        "name": "mtak-blog",
        "url": "https://mtak-blog.github.io/"
      },
      "tags": [
        "Language",
        "Computer Science"
      ]
    },
    {
      "id": "318f9d08-d86a-4799-ac08-75014d089475",
      "title": "im - Immutable Data Structures for Rust",
      "content_text": "This library implements several of the more commonly useful immutable data structures for Rust. They rely on structural sharing to keep most operations fast without needing to mutate the underlying data store, leading to more predictable code without necessarily sacrificing performance.",
      "url": "https://docs.rs/im/10.0.0/im/",
      "date_published": "2018-04-06T21:06:00+00:00",
      "author": {
        "name": "Bodil Stokke",
        "url": "http://immutable.rs/"
      },
      "tags": [
        "Computer Science",
        "Crates"
      ]
    },
    {
      "id": "465a729e-a243-4cd7-bee8-e0c7d5d09fbd",
      "title": "Number Theory using Rust's type system",
      "content_text": "Rust does not have dependent types, or GADTs like Haskell, but with a few tricks, we can use Rust's type system to emulate an Idris-like number system.",
      "url": "https://shingtaklam1324.github.io/number-theory-rust/",
      "date_published": "2018-03-18T00:00:00+11:00",
      "author": {
        "name": "shingtaklam1324",
        "url": "https://shingtaklam1324.github.io/"
      },
      "tags": [
        "Computer Science"
      ]
    },
    {
      "id": "17b6e878-388f-40c5-93a0-cf3da64a1078",
      "title": "stencil; abstract stencil calculation",
      "content_text": "I am developing a library for stencil calculation in Rust.",
      "url": "https://dev.to/termoshtt/stencil-abstract-stencil-calculation-i2m",
      "date_published": "2018-03-17T00:00:00+00:00",
      "author": {
        "name": "termoshtt",
        "url": "https://dev.to/termoshtt"
      },
      "tags": [
        "Computer Science"
      ]
    },
    {
      "id": "d377bc0d-a127-456d-81fa-926fe634de0f",
      "title": "Fast Search Through Metric Spaces with Rust and BK Trees",
      "content_text": "In the previous post, pHash helped us to summarize our photo album. Now it’s time to employ BK-trees and efficiently search through the metric space of perceptual hashes. Let’s roll up the sleeves; more Rust awaits!",
      "url": "https://www.innoq.com/en/blog/looks-the-same-to-me/",
      "date_published": "2018-03-01T00:00:00+01:00",
      "author": {
        "name": "Jan Stępień",
        "url": "https://www.innoq.com/en/staff/jans/"
      },
      "tags": [
        "Computer Science"
      ]
    },
    {
      "id": "5e572868-98d0-4944-b897-14cca13a39a4",
      "title": "Reasoning with Types in Rust",
      "content_text": "Rust is a modern programming language which is marketed primarily on the basis of its very nice type system, and I’d like to tell you about how you can use this type system to reason about your programs in interesting ways. Most of the time when its type system is discussed, the focus is on its guarantee of data race freedom and ability to enable so-called fearless concurrency (and rightfully so—this is a place where Rust truly shines!). Today, I have a different focus in mind, characterized perhaps most succinctly as follows:",
      "url": "https://aaronweiss.us/posts/2018-02-26-reasoning-with-types-in-rust.html",
      "date_published": "2018-02-26T00:00:00+00:00",
      "author": {
        "name": "Aaron Weiss",
        "url": "https://aaronweiss.us/archive.html"
      },
      "tags": [
        "Language",
        "Computer Science"
      ]
    },
    {
      "id": "29eb1ede-d551-4b8d-aeec-c673aafb7e8f",
      "title": "Combine 3 - Partial parsing in Rust",
      "content_text": "Combine is a parser combinator library for the Rust programming language. I first announced version 3 of Combine back in August and back then I definitely expected to have a stable version by now. However other projects (cough gluon cough) got in the way and Combine fell to the wayside. It didn’t help that I didn’t have a killer feature for 3.0 either, user-defined error types make it possible to define parsers usable in #[no_std] crates which is great when you need it but it is still a fairly niche use-case.",
      "url": "https://marwes.github.io/2018/02/08/combine-3.html",
      "date_published": "2018-02-08T00:00:00+00:00",
      "author": {
        "name": "Markus Westerlind",
        "url": "https://marwes.github.io/"
      },
      "tags": [
        "Crates",
        "Computer Science"
      ]
    },
    {
      "id": "d2fc34d4-c1ec-4c3d-8e39-b420b8f20fe8",
      "title": "Memory Safety in Rust: A Case Study with C",
      "content_text": "To demonstrate the value of Rust's memory safety rules, I contrast the implementation of a simple vector library in C and Rust, highlighting where and how Rust's static analysis can prevent tricky memory errors.",
      "url": "http://willcrichton.net/notes/rust-memory-safety/",
      "date_published": "2018-02-02T00:00:00+00:00",
      "author": {
        "name": "Will Crichton",
        "url": "http://willcrichton.net/notes/"
      },
      "tags": [
        "Computer Science"
      ]
    }
  ]
}