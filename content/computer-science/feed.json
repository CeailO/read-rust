{
  "version": "https://jsonfeed.org/version/1",
  "title": "Read Rust - Computer Science",
  "home_page_url": "https://readrust.net/",
  "feed_url": "https://readrust.net/computer-science/feed.json",
  "description": "Computer Science posts on Read Rust",
  "author": {
    "name": "Wesley Moore",
    "url": "http://www.wezm.net/"
  },
  "items": [
    {
      "id": "d10fabc1-ddeb-4ac3-ab03-824bff125807",
      "title": "Face Detection with Tensorflow Rust",
      "content_text": "One of the promises of machine learning is to be able to use it for object recognition in photos. This includes being able to pick out features such as animals, buildings and even faces. This article will step you through using some existing models to accomplish face detection using rust and tensorflow.",
      "url": "https://cetra3.github.io/blog/face-detection-with-tensorflow-rust/",
      "date_published": "2019-03-28T00:00:00+00:00",
      "author": {
        "name": "cetra3",
        "url": "https://github.com/cetra3/"
      },
      "tags": [
        "Computer Science"
      ]
    },
    {
      "id": "b78c276e-61fa-41c0-90db-b706fe5864e3",
      "title": "Generalizing Seqlocks",
      "content_text": "swym is a very performant Software Transactional Memory (STM) library. It uses a variation on the per-object Transactional Locking II algorithm. The paper does an excellent job explaining the algorithm, but it is not required reading for this article. swym is a generalization of seqlocks - one the TL2 paper almost achieves, but does not for whatever reason.",
      "url": "https://mtak-blog.github.io/generalizing-seqlocks",
      "date_published": "2019-03-24T00:00:00+00:00",
      "author": {
        "name": "mtak-",
        "url": "https://github.com/mtak-"
      },
      "tags": [
        "Computer Science"
      ]
    },
    {
      "id": "42678207-257f-4a9c-868a-ab556d18f9d1",
      "title": "Idiomatic monads in Rust",
      "content_text": "A pragmatic new design for high-level abstractions In this post, I’m going to describe a new approach to express monads in Rust. It is the most minimal design I have seen proposed and is, in my eyes, the first plausible design for such abstractions — those commonly known as “higher-kinded types”. This approach depends on a very minimal extension to Rust’s type system. In particular, this approach avoids the need for either higher-kinded types (e.g. as in this design) or full abstraction over traits (e.g. “traits for traits”). Most of the design challenges are tackled directly using existing features.",
      "url": "https://varkor.github.io/blog/2019/03/28/idiomatic-monads-in-rust.html",
      "date_published": "2019-03-28T00:00:28+00:00",
      "author": {
        "name": "varkor",
        "url": "https://varkor.github.io/blog/"
      },
      "tags": [
        "Computer Science"
      ]
    },
    {
      "id": "7f497632-cdeb-48fc-b03b-8abe30f7ac6e",
      "title": "Refactoring Varisat: 4. Heuristics",
      "content_text": "This is the fourth post in my series about refactoring varisat. In the last post we saw how conflict driven clause learning works, in this post we’re going to make it fast. To get there we add several smaller features that were already present in varisat 0.1. While there are still some things missing that varisat 0.1 supports, these are features like proof generation or incremental solving that don’t affect the solving performance.",
      "url": "https://jix.one/refactoring-varisat-4-heuristics/",
      "date_published": "2019-03-21T11:46:30+01:00",
      "author": {
        "name": "Jannis Harder",
        "url": "https://jix.one/"
      },
      "tags": [
        "Computer Science"
      ]
    },
    {
      "id": "da916659-e0c2-4c4c-a793-b4f7273dcd1f",
      "title": "Refactoring Varisat: 3. Conflict Driven Clause Learning",
      "content_text": "This is the third post in my series about refactoring varisat. In this post the new code base turns into a working SAT solver. While you can use the command line tool or the library to solve some small and easy SAT problems now, there is still a lot ahead to gain feature and performance parity with varisat 0.1.\n\nIn the last post we saw how unit propagation is implemented. When some variables are known, unit propagation allows us to derive the values of new variables or finds a clause that cannot be satisfied. Unit propagation alone isn’t enough though, as there is no guarantee to make progress. To continue the search for a satisfying solution after propagating all assignments, it is necessary to make a guess. A natural way to handle this would be recursion and backtracking. This would give us a variant of the DPLL algorithm from which conflict driven clause learning evolved.",
      "url": "https://jix.one/refactoring-varisat-3-cdcl/",
      "date_published": "2019-03-18T20:00:53+01:00",
      "author": {
        "name": "Jannis Harder",
        "url": "https://jix.one/"
      },
      "tags": [
        "Computer Science"
      ]
    },
    {
      "id": "31d81292-5ae5-4462-8f26-ca156d625f40",
      "title": "Refactoring Varisat: 2. Clause Storage and Unit Propagation",
      "content_text": "This is the second post in my series about refactoring varisat. Since the last post I started implementing some of the core data structures and algorithms of a CDCL based SAT solver: clause storage and unit propagation. In this post I will explain how the these parts work and the rationale behind some of the decisions I made.",
      "url": "https://jix.one/refactoring-varisat-2-clause-storage-and-unit-propagation/",
      "date_published": "2019-03-02T18:18:04+01:00",
      "author": {
        "name": "Jannis Harder",
        "url": "https://jix.one/"
      },
      "tags": [
        "Computer Science"
      ]
    },
    {
      "id": "e448a9b1-396d-4b48-8cba-40419fc3cce6",
      "title": "Scientific computing: a Rust adventure [Part 1 - Zero-cost abstractions]",
      "content_text": "We left, at the end of the previous episode, with an intuitive understanding of Rust’s ownership system: we worked with vectors of integers, Vec<i32>, and we came up with a naive - but surprisingly fast! - scalar product implementation followed by a very simple sort function using the bubble sort algorithm.\n\nIn this episode we will implement a generic version of the same scalar product routine. This will require the introduction of several key concepts concerning Rust’s type system: generics, traits, operators, associated types, Copy.",
      "url": "https://www.lpalmieri.com/posts/2019-03-12-scientific-computing-a-rust-adventure-part-1-zero-cost-abstractions/",
      "date_published": "2019-03-12T00:00:00+00:00",
      "author": {
        "name": "Luca Palmieri",
        "url": "https://www.lpalmieri.com/"
      },
      "tags": [
        "Computer Science"
      ]
    },
    {
      "id": "eac014e1-98a8-4913-9050-5e7a073b8611",
      "title": "Oxide: The Essence of Rust",
      "content_text": "Rust is a major advancement in industrial programming languages due in large part to its success in bridging the gap between low-level systems programming and high-level application programming. This success has ultimately empowered programmers to more easily build reliable and efficient software, and at its heart lies a novel approach to ownership that balances type system expressivity with usability.\n\nIn this work, we set out to capture the essence of this model of ownership by developing a type systems account of Rust's borrow checker. To that end, we present Oxide, a formalized programming language close to source-level Rust (but with fully-annotated types). This presentation takes a new view of lifetimes as approximate provenances of references, and our type system is able to automatically compute this information through a flow-sensitive substructural typing judgment for which we prove syntactic type safety using progress and preservation. The result is a simpler formulation of borrow checking - including recent features such as non-lexical lifetimes - that we hope researchers will be able to use as the basis for work on Rust.",
      "url": "https://arxiv.org/abs/1903.00982",
      "date_published": "2019-03-03T20:22:37+00:00",
      "author": {
        "name": "Aaron Weiss, Daniel Patterson, Nicholas D. Matsakis, Amal Ahmed",
        "url": "https://arxiv.org/"
      },
      "tags": [
        "Computer Science"
      ]
    },
    {
      "id": "7fa900ce-52d1-494e-b770-ed5ef64aea61",
      "title": "Building fast interpreters in Rust",
      "content_text": "we created a configurable Rust library for writing and executing Wireshark®-like filters in different parts of our stack written in Go, Lua, C, C++ and JavaScript Workers. We have now open-sourced this library under our Github account: https://github.com/cloudflare/wirefilter. This post will dive into its design, explain why we didn’t use a parser generator and how our execution engine balances security, runtime performance and compilation cost for the generated filters.",
      "url": "https://blog.cloudflare.com/building-fast-interpreters-in-rust/",
      "date_published": "2019-03-04T16:00:00+00:00",
      "author": {
        "name": "Ingvar Stepanyan",
        "url": "https://blog.cloudflare.com/"
      },
      "tags": [
        "Computer Science"
      ]
    },
    {
      "id": "17e95b5e-6cd8-4f98-8030-c923e69897cb",
      "title": "luster: An experimental Lua VM implemented in pure Rust",
      "content_text": " What I want to talk about though (and what I will eventually write a blog post about) is the technique that I'm using in luster for safe garbage collection. Inside luster are two libraries called \"gc-arena\" and \"gc-sequence\", and they represent a new (I believe novel?) system for safe garbage collection in Rust. There have been several attempts here before such as rust-gc and shifgrethor, and this represents another attempt with... different? limitations more appropriate for implementing language runtimes like Lua.",
      "url": "https://www.reddit.com/r/rust/comments/awx9cy/github_kyrenluster_an_experimental_lua_vm/",
      "date_published": "2019-03-04T06:26:29+11:00",
      "author": {
        "name": "Catherine West",
        "url": "https://kyren.github.io/"
      },
      "tags": [
        "Computer Science"
      ]
    },
    {
      "id": "8d4c090f-e6e3-4975-abe7-385479579cfa",
      "title": "Scientific computing: a Rust adventure [Part 0 - Vectors]",
      "content_text": "My daily work revolves around building Machine Learning applications, while a lot of my evenings have been spent experimenting with Rust, getting more and more fascinated and in love with the language.\n\nIt couldn’t be helped: I started to have a look at what the Rust ecosystem had to offer for Machine Learning, Big Data and scientific computing at large. I quickly found out that there is a lot to be done and a lot of potential (see here or here). It got me really fired up 🔥",
      "url": "https://www.lpalmieri.com/posts/2019-02-23-scientific-computing-a-rust-adventure-part-0-vectors/",
      "date_published": "2019-02-23T00:00:00+00:00",
      "author": {
        "name": "Luca Palmieri",
        "url": "https://www.lpalmieri.com/"
      },
      "tags": [
        "Computer Science"
      ]
    },
    {
      "id": "2c967b7c-6987-45ae-96b1-776ee6c51011",
      "title": "Procedural Generation with Wave Function Collapse",
      "content_text": "Wave Function Collapse is a procedural generation algorithm which produces images by arranging a collection of tiles according to rules about which tiles may be adjacent to each other tile, and relatively how frequently each tile should appear. The algorithm maintains, for each pixel of the output image, a probability distribution of the tiles which may be placed there. It repeatedly chooses a pixel to “collapse” - choosing a tile to use for that pixel based on its distribution. WFC gets its name from quantum physics. The goal of this post is to build an intuition for how and why the WFC algorithm works.",
      "url": "https://gridbugs.org/wave-function-collapse/",
      "date_published": "2019-02-21T00:00:00+00:00",
      "author": {
        "name": "Stephen Sherratt",
        "url": "https://gridbugs.org/"
      },
      "tags": [
        "Games and Graphics",
        "Computer Science"
      ]
    },
    {
      "id": "ad9d038f-52e6-4860-a264-61a795428b87",
      "title": "Scannerless parsing of boolean grammars with derivatives in Rust",
      "content_text": "This is yet another library for writing parsers in Rust. What makes this one different is that I've combined some existing academic work in a way that I think is novel. The result is an unusually flexible parsing library while still offering competitive performance and memory usage.",
      "url": "https://github.com/jameysharp/weighted-regexp-rs/blob/master/README.md",
      "date_published": "2019-01-06T00:00:00+00:00",
      "author": {
        "name": "Jamey Sharp",
        "url": "https://github.com/jameysharp"
      },
      "tags": [
        "Crates",
        "Computer Science"
      ]
    },
    {
      "id": "d282adbf-dce7-4fbb-86e5-2d33df229932",
      "title": "Leveraging Rust types for modular specification and verification",
      "content_text": "Rust’s type system ensures memory safety: well-typed Rust programs are guaranteed to not exhibit problems such as dangling pointers, data races, and unexpected side effects through aliased references. Going beyond memory safety, for instance, to guarantee the absence of assertion failures or functional correctness, requires static program verification. Formal verification of system software is notoriously difficult and requires complex specifications and logics to reason about pointers, aliasing, and side effects on mutable state. This complexity is a major obstacle to a more widespread verification of system software.\n\nIn this paper, we present a novel verification technique that leverages Rust’s type system to greatly simplify the specification and verification of Rust programs. We analyse information from the Rust compiler and synthesise a corresponding core proof for the program in a flavour of separation logic tailored to automation. Crucially, our proofs are constructed and checked automatically; users of our work never work with the underlying formal logic. Users can add specifications at the abstraction level of Rust expressions; we show how to interweave these to extend our core proof to prove modularly whether these specifications are correct. We have implemented our technique for a subset of Rust; our initial evaluation on two thousand functions from widely-used Rust crates demonstrates its effectiveness",
      "url": "https://www.research-collection.ethz.ch/handle/20.500.11850/311092",
      "date_published": "2018-12-17T07:00:47+00:00",
      "author": {
        "name": "Astrauskas, Vytautas; Müller, Peter; Poli, Federico; Summers, Alexander",
        "url": "https://www.research-collection.ethz.ch/handle/20.500.11850/22"
      },
      "tags": [
        "Computer Science"
      ]
    },
    {
      "id": "4ea6d02a-6279-4eef-af2f-bd67424d6de8",
      "title": "The Swiss Army Knife of Hashmaps",
      "content_text": "A while back, there was a discussion comparing the performance of using the hashbrown crate (based on Google’s SwissTable implementation) in the Rust compiler. In the last RustFest, Amanieu was experimenting on integrating his crate into stdlib, which turned out to have some really promising results. As a result, it’s being planned to move the crate into stdlib.\n\nWhile the integration is still ongoing, there’s currently no blog post out there explaining SwissTable at the moment. So, I thought I’d dig deeper into the Rust implementation to try and explain how its (almost) identical twin hashbrown::HashMap works.",
      "url": "https://blog.waffles.space/2018/12/07/deep-dive-into-hashbrown/",
      "date_published": "2018-12-07T16:58:46+00:00",
      "author": {
        "name": "Ravi Shankar",
        "url": "https://blog.waffles.space/"
      },
      "tags": [
        "Computer Science",
        "Performance"
      ]
    },
    {
      "id": "57fd5a7a-0eb0-43fd-bf99-5b8a6a0e782c",
      "title": "Shifgrethor IV: Tracing",
      "content_text": "The post before this one covered how shifgrethor handles rooting: how we track for the garbage collector that this object is alive. That isn’t sufficient for implementing a tracing garbage collector though: the idea of a tracing garbage collector is that we can trace from rooted objects through all of the objects they reference. That way, instead of having to root everything you use, you can only root a few objects from which all of the live objects can be traced.",
      "url": "https://boats.gitlab.io/blog/post/shifgrethor-iv/",
      "date_published": "2018-10-31T00:00:00+00:00",
      "author": {
        "name": "withoutboats",
        "url": "https://boats.gitlab.io/blog/"
      },
      "tags": [
        "Computer Science"
      ]
    },
    {
      "id": "88e3b29b-1f9a-41a2-bb8a-9f73310c0352",
      "title": "Shifgrethor III: Rooting",
      "content_text": "After the digression in the previous post, it’s time to get back to what I promised in the first post: a look at how shifgrethor handles rooting. Shifgrethor’s solution is somewhat novel and takes advantage of some of Rust’s specific features, so I want to start by looking briefly at some of the other options.",
      "url": "https://boats.gitlab.io/blog/post/shifgrethor-iii/",
      "date_published": "2018-10-24T00:00:00+00:00",
      "author": {
        "name": "withoutboats",
        "url": "https://boats.gitlab.io/blog/"
      },
      "tags": [
        "Computer Science"
      ]
    },
    {
      "id": "b138af7a-2e74-44c1-b362-03af475f050b",
      "title": "Shifgrethor I: Garbage collection as a Rust library",
      "content_text": "I’m really excited to share with you an experiment that I’ve been working on for the past 5 or 6 weeks. It’s a Rust library called shifgrethor. shifgrethor implements a garbage collector in Rust with an API I believe to be properly memory safe.\nI’ll be going through all of the technical details in future blog posts, so I want to kick this series off with a high level overview of the project’s purpose and design decisions.",
      "url": "https://boats.gitlab.io/blog/post/shifgrethor-i/",
      "date_published": "2018-10-16T00:00:00+00:00",
      "author": {
        "name": "withoutboats",
        "url": "https://boats.gitlab.io/blog/"
      },
      "tags": [
        "Computer Science"
      ]
    },
    {
      "id": "b2cb0409-6147-4d84-8261-734f17fda39c",
      "title": "Noria: dynamic, partially-stateful data-flow for high-performance web applications",
      "content_text": "We introduce partially-stateful data-flow, a new streaming data-flow model that supports eviction and reconstruction of data-flow state on demand. By avoiding state explosion and supporting live changes to the data-flow graph, this model makes data-flow viable for building long-lived, low-latency applications, such as web applications. Our implementation, Noria, simplifies the backend infrastructure for read-heavy web applications while improving their performance.\n\nA Noria application supplies a relational schema and a set of parameterized queries, which Noria compiles into a data-flow program that pre-computes results for reads and incrementally applies writes. Noria makes it easy to write high-performance applications without manual performance tuning or complex-to-maintain caching layers. Partial statefulness helps Noria limit its in-memory state without prior data-flow systems’ restriction to windowed state, and helps Noria adapt its data-flow to schema and query changes while on-line. Unlike prior data-flow systems, Noria also shares state and computation across related queries, eliminating duplicate work.\n\nOn a real web application’s queries, our prototype scales to 5× higher load than a hand-optimized MySQL baseline. Noria also outperforms a typical MySQL/memcached stack and the materialized views of a commercial database. It scales to tens of millions of reads and millions of writes per second over multiple servers, outperforming a state-of-the-art streaming data-flow system.",
      "url": "https://www.usenix.org/conference/osdi18/presentation/gjengset",
      "date_published": "2018-10-09T11:14:00+00:00",
      "author": {
        "name": "Jon Gjengset, Malte Schwarzkopf, Jonathan Behrens, and Lara Timbó Araújo",
        "url": "https://www.usenix.org/conference/osdi18"
      },
      "tags": [
        "Computer Science"
      ]
    },
    {
      "id": "f7523f30-31c4-4699-9071-ec6f7ccd1049",
      "title": "Travel The World Using Partially-Mapped (PMX) Crossover in Rust And JavaScript",
      "content_text": "Implementing a genetic algorithm in JavaScript and Rust.",
      "url": "https://blog.x5ff.xyz/blog/ai-rust-javascript-pmx/",
      "date_published": "2018-08-26T00:00:00+00:00",
      "author": {
        "name": "Claus",
        "url": "https://blog.x5ff.xyz/blog"
      },
      "tags": [
        "Computer Science"
      ]
    },
    {
      "id": "2ff6e0ef-6a4a-4644-bb22-e6e7858955f9",
      "title": "Verifying Rust Programs with SMACK",
      "content_text": "Rust is an emerging systems programming language with guaranteed memory safety and modern language features that has been extensively adopted to build safety-critical software. However, there is currently a lack of automated software verifiers for Rust. In this work, we present our experience extending the SMACK verifier to enable its usage on Rust programs. We evaluate SMACK on a set of Rust programs to demonstrate a wide spectrum of language features it supports.",
      "url": "http://soarlab.org/2018/07/atva2018-bhr/",
      "date_published": "2018-07-30T20:39:49+00:00",
      "author": {
        "name": "Marek Baranowski, Shaobo He, Zvonimir Rakamaric",
        "url": "http://soarlab.org/"
      },
      "tags": [
        "Computer Science"
      ]
    },
    {
      "id": "f025d0a3-cc4c-45c7-9587-71057b3d9cbf",
      "title": "So You Want to Build a Language VM in Rust - Part 00",
      "content_text": "Hi there! This is the prelude to a series of posts to detailing how to build a language VM. If you are familiar with terms like registers, program counter, and assembly, feel free to skip this post. If not, read on. Please note this is nowhere near comprehensive, but enough to understand what we’re building.",
      "url": "https://medium.com/iridium-vm/so-you-want-to-build-a-language-vm-part-0-f9132f611a1b",
      "date_published": "2018-08-17T19:59:12.548+00:00",
      "author": {
        "name": "Fletcher Haynes",
        "url": "https://medium.com/@subnet_zero"
      },
      "tags": [
        "Computer Science"
      ]
    },
    {
      "id": "1af176be-1d98-419b-85d5-dfbf78cb74df",
      "title": "Rust needs BFGS. What is BFGS?",
      "content_text": "There is no general “best” way to minimize a function; different kinds of functions require different strategies. However, Python’s scipy and R’s optim both prominently feature an algorithm called BFGS. I’ll explain what BFGS stands for, the problem that it solves, and how it solves it.",
      "url": "https://paulkernfeld.com/2018/08/06/rust-needs-bfgs.html",
      "date_published": "2018-08-06T00:00:00+00:00",
      "author": {
        "name": "Paul Kernfeld",
        "url": "https://paulkernfeld.com/"
      },
      "tags": [
        "Computer Science"
      ]
    },
    {
      "id": "c7f57579-ce36-4d54-86a4-9aa4a6c1cadd",
      "title": "So You Want to Build a Language VM - Part 00",
      "content_text": "A Brief Course in Computer Hardware. This is the prelude to a series of posts to detailing how to build a language VM. If you are familiar with terms like registers, program counter, and assembly, feel free to skip this post. If not, read on.",
      "url": "https://blog.subnetzero.io/post/building-language-vm-part-00/",
      "date_published": "2018-07-16T00:00:00+00:00",
      "author": {
        "name": "Fletcher Haynes",
        "url": "https://blog.subnetzero.io/"
      },
      "tags": [
        "Computer Science"
      ]
    },
    {
      "id": "ab3d6484-4107-4555-a9b0-0f1aa6ae9a18",
      "title": "How Usable are Rust Cryptography APIs?",
      "content_text": "Poor usability of cryptographic APIs is a severe source of vulnerabilities. Aim: We wanted to find out what kind of cryptographic libraries are present in Rust and how usable they are. Method: We explored Rust's cryptographic libraries through a systematic search, conducted an exploratory study on the major libraries and a controlled experiment on two of these libraries with 28 student participants. Results: Only half of the major libraries explicitly focus on usability and misuse resistance, which is reflected in their current APIs. We found that participants were more successful using rust-crypto which we considered less usable than ring before the experiment. Conclusion: We discuss API design insights and make recommendations for the design of crypto libraries in Rust regarding the detail and structure of the documentation, higher-level APIs as wrappers for the existing low-level libraries, and selected, good-quality example code to improve the emerging cryptographic libraries of Rust.",
      "url": "https://arxiv.org/abs/1806.04929",
      "date_published": "2018-06-26T00:00:00+00:00",
      "author": {
        "name": "Kai Mindermann, Philipp Keck, Stefan Wagner",
        "url": "https://arxiv.org/"
      },
      "tags": [
        "Computer Science"
      ]
    },
    {
      "id": "16b43079-6e0d-4c7e-9ea3-00cf0405bf49",
      "title": "Genetic Algorithms in Rust for Autonomous Agents: An Introduction",
      "content_text": "This article discusses a possible genetic algorithm implementation in Rust applied to the travelling salesman problem.",
      "url": "https://medium.com/coinmonks/genetic-algorithms-in-rust-for-autonomous-agents-an-introduction-ac182de32aee",
      "date_published": "2018-06-30T14:09:48.725+00:00",
      "author": {
        "name": "Mithi",
        "url": "https://medium.com/@mithi"
      },
      "tags": [
        "Computer Science"
      ]
    },
    {
      "id": "04445b84-5c91-467e-840c-45df1765c4e6",
      "title": "[1807.00067] Josephine: Using JavaScript to safely manage the lifetimes of Rust data",
      "content_text": "This paper is about the interface between languages which use a garbage collector and those which use fancy types for safe manual memory management. Garbage collection is the traditional memory management scheme for functional languages, whereas type systems are now used for memory safety in imperative languages. We use existing techniques for linear capabilities to provide safe access to copyable references, but the application to languages with a tracing garbage collector, and to data with explicit lifetimes is new. This work is related to mixed linear/non-linear programming, but the languages being mixed are Rust and JavaScript.",
      "url": "https://arxiv.org/abs/1807.00067",
      "date_published": "2018-06-29T00:00:00+00:00",
      "author": {
        "name": "Alan Jeffrey",
        "url": "http://asaj.org/"
      },
      "tags": [
        "Computer Science"
      ]
    },
    {
      "id": "b63f8372-7dbc-4bf5-9ab3-e13a95a011be",
      "title": "Logistic Regression in Rust",
      "content_text": "This weekend, I implemented logistic regression in Rust. For me, the most interesting parts were learning how to implement a stopping condition and how to automatically set a step size.",
      "url": "http://paulkernfeld.com/2018/07/01/logistic-regression-in-rust.html",
      "date_published": "2018-07-01T00:00:00+00:00",
      "author": {
        "name": "Paul Kernfeld",
        "url": "http://paulkernfeld.com/"
      },
      "tags": [
        "Computer Science"
      ]
    },
    {
      "id": "6c71975e-3550-410a-99e7-2ee9635fb0e6",
      "title": "Generic associated types in iterators",
      "content_text": "In this article, I want to explain the term Generic Associated Types through a concrete example. I noticed that people (especially in video games development) need some tools to iterate in various manners mutably, efficiently and safely. I tried to write some convenient iterators over vectors and slices that solve those problems, but finally, I understood that some tools cannot be written with std::iter::Iterator. Doing so led me to the comprehension of generic associated types that I will abbreviate as GATs in this article. I will explain here what GATs are and why they are needed.",
      "url": "https://boiethios.gitlab.io/blog/2018-06-21_GATs_iterators.html",
      "date_published": "2018-06-21T00:00:00+00:00",
      "author": {
        "name": "Boiethios",
        "url": "https://boiethios.gitlab.io/blog/index.html"
      },
      "tags": [
        "Computer Science"
      ]
    },
    {
      "id": "a07d66f5-dfd3-41d4-b2d8-16bf1b0f4886",
      "title": "Rust Distilled: An Expressive Tower of Languages",
      "content_text": "Rust represents a major advancement in production programming languages because of its success in bridging the gap between high-level application programming and low-level systems programming. At the heart of its design lies a novel approach to ownership that remains highly programmable.\n\nIn this talk, we will describe our ongoing work on designing a formal semantics for Rust that captures how programmers can understand ownership and borrowing without trying to grasp the details of lifetime analysis.",
      "url": "https://arxiv.org/abs/1806.02693",
      "date_published": "2018-06-07T00:00:00+00:00",
      "author": {
        "name": "Aaron Weiss, Daniel Patterson, Amal Ahmed",
        "url": "https://arxiv.org/"
      },
      "tags": [
        "Computer Science"
      ]
    },
    {
      "id": "6f104d56-9b00-4748-a04f-0c77ec89a1d2",
      "title": "Modern Parser Generator",
      "content_text": "During the last couple of years, I’ve spent a lot of time writing parsers and parser generators, and I want to write down my thoughts about this topic. Specifically, I want to describe some properties of a parser generator that I would enjoy using. Note that this is not an “introduction to parsing” blog post, some prior knowledge is assumed.",
      "url": "https://matklad.github.io/2018/06/06/modern-parser-generator.html",
      "date_published": "2018-06-06T16:03:25+00:00",
      "author": {
        "name": "Aleksey Kladov",
        "url": "https://matklad.github.io/"
      },
      "tags": [
        "Computer Science"
      ]
    },
    {
      "id": "bfb80762-37e6-4337-83c9-52f371839e60",
      "title": "TensorScript Type Inference: Hindley-Milner in Rust",
      "content_text": "Type-inferred gradually typed languages are a joy to use: easy to write, analyze, and refactor. In this blog post, I will showcase to the other dozen of programmers who are interested in the obscure art of programming language type inference.",
      "url": "http://rickyhan.com/jekyll/update/2018/05/26/hindley-milner-tutorial-rust.html",
      "date_published": "2018-05-26T04:00:00+00:00",
      "author": {
        "name": "Ricky Han",
        "url": "http://rickyhan.com/"
      },
      "tags": [
        "Computer Science"
      ]
    },
    {
      "id": "e2724828-a6e9-4383-9614-bea31e743784",
      "title": "Oblix: An Efficient Oblivious Search Index [pdf]",
      "content_text": "Abstract—Search indices are fundamental building blocks of many systems, and there is great interest in running them on encrypted data. Unfortunately, many known schemes that enable search queries on encrypted data achieve efficiency at the expense of security, as they reveal access patterns to the encrypted data.  In this paper we present Oblix, a search index for encrypted data that is oblivious (provably hides access patterns), is dynamic (supports inserts and deletes), and has good efficiency.  Oblix relies on a combination of novel oblivious-access tech- niques and recent hardware enclave platforms (e.g., Intel SGX).  In particular, a key technical contribution is the design and implementation of doubly-oblivious data structures, in which the client’s accesses to its internal memory are oblivious, in addition to accesses to its external memory at the server. These algorithms are motivated by hardware enclaves like SGX, which leak access patterns to both internal and external memory.  We demonstrate the usefulness of Oblix in several applications: private contact discovery for Signal, private retrieval of public keys for Key Transparency, and searchable encryption that hides access patterns and result sizes.",
      "url": "https://people.eecs.berkeley.edu/~raluca/oblix.pdf",
      "date_published": "2018-05-21T00:00:00+00:00",
      "author": {
        "name": "Pratyush Mishra, Rishabh Poddar, Jerry Chen, Alessandro Chiesa, Raluca Ada Popa",
        "url": "https://rise.cs.berkeley.edu/blog/publication/oblix-an-efficient-oblivious-search-index/"
      },
      "tags": [
        "Computer Science"
      ]
    },
    {
      "id": "91a4f766-391d-43fc-a2ce-66354ac78bd4",
      "title": "Implement Raft in Rust",
      "content_text": "Consensus is one of the most important challenges in designing and building distributed systems–how to make sure multiple nodes (or agents, processes, threads, tasks, participants, etc.) in a group agree on a specific value proposed by at least one of the nodes. As an open-source distributed scalable HTAP database, TiDB uses the Raft Consensus Algorithm in its distributed transactional key-value storage engine, TiKV, to ensure data consistency, auto-failover, and fault tolerance.",
      "url": "https://pingcap.com/blog/implement-raft-in-rust/",
      "date_published": "2018-05-22T00:00:00+00:00",
      "author": {
        "name": "Siddon Tang",
        "url": "https://pingcap.com/blog"
      },
      "tags": [
        "Computer Science"
      ]
    },
    {
      "id": "c7a4923a-2a12-4f88-82fc-4b99b94080e9",
      "title": "Cannoli: A Python Compiler Written in Rust [pdf]",
      "content_text": "I just finished my Master's Thesis and part of it was writing a Python compiler in Rust. The goal of the thesis was to evaluate language features of Python that were hypothesized to cause performance issues. Quantifying the cost of these features could be valuable to language designers moving forward. Some interesting results were observed when implementing compiler optimizations for Python. An average speedup of 51% was achieved across a number of benchmarks.",
      "url": "https://github.com/joncatanio/cannoli/raw/master/resources/papers/cannoli-thesis-paper.pdf",
      "date_published": "2018-05-17T16:00:59+00:00",
      "author": {
        "name": "Jonathan Catanio",
        "url": "https://github.com/joncatanio"
      },
      "tags": [
        "Computer Science"
      ]
    },
    {
      "id": "0308ada3-604c-4240-8e94-2f9d23bc2934",
      "title": "Bulletproof Multi-Party Computation in Rust with Session Types",
      "content_text": "In Rust, objects are either owned or borrowed. While there can be multiple borrows of the same object, each object has a unique owner. When objects are passed by value, ownership is transferred to the new scope, and the old scope can no longer access it. This makes it possible to implement “consuming” methods which take self by value, and therefore can only be called once. In the party and dealer types, such methods consume the previous state and return the next state in the protocol.",
      "url": "https://blog.chain.com/bulletproof-multi-party-computation-in-rust-with-session-types-b3da6e928d5d",
      "date_published": "2018-05-11T22:25:19.221+00:00",
      "author": {
        "name": "Cathie Yun",
        "url": "https://blog.chain.com/@cathieyun"
      },
      "tags": [
        "Computer Science"
      ]
    },
    {
      "id": "0c0d7114-9e80-4e4f-868d-51de6778bed1",
      "title": "KRust: A Formal Executable Semantics of Rust",
      "content_text": "Rust is a new and promising high-level system programming language. It provides both memory safety and thread safety through its novel mechanisms such as ownership, moves and borrows. Ownership system ensures that at any point there is only one owner of any given resource. The ownership of a resource can be moved or borrowed according to the lifetimes. The ownership system establishes a clear lifetime for each value and hence does not necessarily need garbage collection. These novel features bring Rust high performance, fine low-level control of C and C++, and unnecessity in garbage collection, which differ Rust from other existing prevalent languages. For formal analysis of Rust programs and helping programmers learn its new mechanisms and features, a formal semantics of Rust is desired and useful as a fundament for developing related tools. In this paper, we present a formal executable operational semantics of a realistic subset of Rust, called KRust. The semantics is defined in K, a rewriting-based executable semantic framework for programming languages. The executable semantics yields automatically a formal interpreter and verification tools for Rust programs. KRust has been thoroughly validated by testing with hundreds of tests, including the official Rust test suite.",
      "url": "https://arxiv.org/abs/1804.10806",
      "date_published": "2018-04-28T00:00:00+00:00",
      "author": {
        "name": "Feng Wang, Fu Song, Min Zhang, Xiaoran Zhu, Jun Zhang",
        "url": "https://arxiv.org/"
      },
      "tags": [
        "Computer Science"
      ]
    },
    {
      "id": "ed19c2a7-fe9d-465b-b41a-71480e6b978a",
      "title": "QCGPU - Hardware Accelerated Quantum Computer Simulation",
      "content_text": "A software library for high performance and hardware accelerated simulation of Quantum Computers and Algorithms. Written with Rust and OpenCL.",
      "url": "https://qcgpu.github.io/",
      "date_published": "2018-04-11T06:47:00+10:00",
      "author": {
        "name": "QCGPU",
        "url": "https://qcgpu.github.io/"
      },
      "tags": [
        "Computer Science",
        "Tools and Applications"
      ]
    },
    {
      "id": "68ff8b22-500f-4674-b9f0-b70414db12d8",
      "title": "Safe Intrusive Collections with Pinning",
      "content_text": "In my last post, I talked about the new “pinned references” which guarantee that the data at the memory it points to will not, ever, be moved elsewhere. I explained how they enable giving a safe API to code that could previously only be exposed with unsafe, and how one could go about proving such a thing. This post is about another application of pinned references—another API whose safety relies on the pinning guarantees: Intrusive collections. It turns out that pinned references can almost be used for this, but not quite. However, this can be fixed by extending the guarantees provided by pinned references, as suggested by @cramertj.",
      "url": "https://www.ralfj.de/blog/2018/04/10/safe-intrusive-collections-with-pinning.html",
      "date_published": "2018-04-10T00:00:00+00:00",
      "author": {
        "name": "Ralf Jung",
        "url": "https://www.ralfj.de/blog/"
      },
      "tags": [
        "Computer Science"
      ]
    },
    {
      "id": "66851aee-1bf3-4b18-b1aa-50f79ce773f4",
      "title": "Writing a recursive ascent parser by hand",
      "content_text": "I’ve been exploring various ways to write parsers. For a long time, I’ve used hand-written recursive descent for its straightforwardness, flexibility, and performance. There is another way—parser generators like Menhir, LALRPOP, or the venerable Bison use the bottom-up LR algorithm. I decided I would try an experiment: write an LR parser by hand, and see how readable I could make it.",
      "url": "https://www.abubalay.com/blog/2018/04/08/recursive-ascent",
      "date_published": "2018-04-08T00:00:00+00:00",
      "author": {
        "name": "Russell Johnston",
        "url": "https://www.abubalay.com/blog"
      },
      "tags": [
        "Computer Science"
      ]
    },
    {
      "id": "e01d9c09-e66d-4fea-94e3-95db24137dd6",
      "title": "Sound and ergonomic specialization for Rust",
      "content_text": "Specialization holds the dubious honor of being among the oldest post-1.0 features remaining in unstable limbo. That’s for good reason, though: until recently, we did not know how to make it sound.",
      "url": "http://aturon.github.io/2018/04/05/sound-specialization/",
      "date_published": "2018-04-05T00:00:00+00:00",
      "author": {
        "name": "Aaron Turon",
        "url": "http://aturon.github.io/"
      },
      "tags": [
        "Language",
        "Computer Science"
      ]
    },
    {
      "id": "4812042b-1d2a-4171-9a77-d2f0a0c44b91",
      "title": "Writing the Perfect 'Collect' Trait",
      "content_text": "I’ve been spending some time thinking about garbage collection in rust. I know, shame on me, it’s a systems language, we hate garbage collection, but… even in a systems programming language, garbage collection is still pretty damn useful.",
      "url": "https://mtak-blog.github.io/the_perfect_collect_trait",
      "date_published": "2018-04-05T00:00:00+00:00",
      "author": {
        "name": "mtak-blog",
        "url": "https://mtak-blog.github.io/"
      },
      "tags": [
        "Language",
        "Computer Science"
      ]
    },
    {
      "id": "318f9d08-d86a-4799-ac08-75014d089475",
      "title": "im - Immutable Data Structures for Rust",
      "content_text": "This library implements several of the more commonly useful immutable data structures for Rust. They rely on structural sharing to keep most operations fast without needing to mutate the underlying data store, leading to more predictable code without necessarily sacrificing performance.",
      "url": "https://docs.rs/im/10.0.0/im/",
      "date_published": "2018-04-06T21:06:00+00:00",
      "author": {
        "name": "Bodil Stokke",
        "url": "http://immutable.rs/"
      },
      "tags": [
        "Computer Science",
        "Crates"
      ]
    },
    {
      "id": "465a729e-a243-4cd7-bee8-e0c7d5d09fbd",
      "title": "Number Theory using Rust's type system",
      "content_text": "Rust does not have dependent types, or GADTs like Haskell, but with a few tricks, we can use Rust's type system to emulate an Idris-like number system.",
      "url": "https://shingtaklam1324.github.io/number-theory-rust/",
      "date_published": "2018-03-18T00:00:00+11:00",
      "author": {
        "name": "shingtaklam1324",
        "url": "https://shingtaklam1324.github.io/"
      },
      "tags": [
        "Computer Science"
      ]
    },
    {
      "id": "17b6e878-388f-40c5-93a0-cf3da64a1078",
      "title": "stencil; abstract stencil calculation",
      "content_text": "I am developing a library for stencil calculation in Rust.",
      "url": "https://dev.to/termoshtt/stencil-abstract-stencil-calculation-i2m",
      "date_published": "2018-03-17T00:00:00+00:00",
      "author": {
        "name": "termoshtt",
        "url": "https://dev.to/termoshtt"
      },
      "tags": [
        "Computer Science"
      ]
    },
    {
      "id": "d377bc0d-a127-456d-81fa-926fe634de0f",
      "title": "Fast Search Through Metric Spaces with Rust and BK Trees",
      "content_text": "In the previous post, pHash helped us to summarize our photo album. Now it’s time to employ BK-trees and efficiently search through the metric space of perceptual hashes. Let’s roll up the sleeves; more Rust awaits!",
      "url": "https://www.innoq.com/en/blog/looks-the-same-to-me/",
      "date_published": "2018-03-01T00:00:00+01:00",
      "author": {
        "name": "Jan Stępień",
        "url": "https://www.innoq.com/en/staff/jans/"
      },
      "tags": [
        "Computer Science"
      ]
    },
    {
      "id": "5e572868-98d0-4944-b897-14cca13a39a4",
      "title": "Reasoning with Types in Rust",
      "content_text": "Rust is a modern programming language which is marketed primarily on the basis of its very nice type system, and I’d like to tell you about how you can use this type system to reason about your programs in interesting ways. Most of the time when its type system is discussed, the focus is on its guarantee of data race freedom and ability to enable so-called fearless concurrency (and rightfully so—this is a place where Rust truly shines!). Today, I have a different focus in mind, characterized perhaps most succinctly as follows:",
      "url": "https://aaronweiss.us/posts/2018-02-26-reasoning-with-types-in-rust.html",
      "date_published": "2018-02-26T00:00:00+00:00",
      "author": {
        "name": "Aaron Weiss",
        "url": "https://aaronweiss.us/archive.html"
      },
      "tags": [
        "Language",
        "Computer Science"
      ]
    },
    {
      "id": "29eb1ede-d551-4b8d-aeec-c673aafb7e8f",
      "title": "Combine 3 - Partial parsing in Rust",
      "content_text": "Combine is a parser combinator library for the Rust programming language. I first announced version 3 of Combine back in August and back then I definitely expected to have a stable version by now. However other projects (cough gluon cough) got in the way and Combine fell to the wayside. It didn’t help that I didn’t have a killer feature for 3.0 either, user-defined error types make it possible to define parsers usable in #[no_std] crates which is great when you need it but it is still a fairly niche use-case.",
      "url": "https://marwes.github.io/2018/02/08/combine-3.html",
      "date_published": "2018-02-08T00:00:00+00:00",
      "author": {
        "name": "Markus Westerlind",
        "url": "https://marwes.github.io/"
      },
      "tags": [
        "Crates",
        "Computer Science"
      ]
    },
    {
      "id": "d2fc34d4-c1ec-4c3d-8e39-b420b8f20fe8",
      "title": "Memory Safety in Rust: A Case Study with C",
      "content_text": "To demonstrate the value of Rust's memory safety rules, I contrast the implementation of a simple vector library in C and Rust, highlighting where and how Rust's static analysis can prevent tricky memory errors.",
      "url": "http://willcrichton.net/notes/rust-memory-safety/",
      "date_published": "2018-02-02T00:00:00+00:00",
      "author": {
        "name": "Will Crichton",
        "url": "http://willcrichton.net/notes/"
      },
      "tags": [
        "Computer Science"
      ]
    }
  ]
}