<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/"><channel><title>Read Rust - Language</title><link>https://readrust.net/</link><description>Language posts on Read Rust</description><item><title>Rust Associated Type</title><link>https://medium.com/codechain/rust-associated-type-2281dbf98229</link><description><![CDATA[Associated Types in Rust are similar to Generic Types; however, Associated Types limit the types of things a user can do, which consequently facilitates code management. Among the Generic Types of traits, types that depend on the type of trait implementation can be expressed by using the Associated Type syntax. By comparing the Associated and Generic Types, you can get a better understanding of Associated Types.]]></description><guid isPermaLink="false">001f1e0d-3927-4e39-800e-68324a02887a</guid><pubDate>Thu, 13 Sep 2018 06:50:57 +0000</pubDate><dc:creator>Seung Woo Kim</dc:creator></item><item><title>Parallelizing PNG, part 8: Rust macros for constant specialization</title><link>https://brionv.com/log/2018/09/12/parallelizing-png-part-8-rust-macros-for-constant-specialization/</link><description><![CDATA[In my last posts I covered profiling and some tips for optimizing inner loops in Rust code while working on a multithreaded PNG encoder. Rust’s macro system is another powerful tool for simplifying your code, and sometimes awesomeizing your performance…]]></description><guid isPermaLink="false">bec949a2-4c38-4646-ae0b-1d8638c506a6</guid><pubDate>Wed, 12 Sep 2018 15:26:54 +0000</pubDate><dc:creator>Brion Vibber</dc:creator></item><item><title>How we organize a complex Rust codebase</title><link>https://blog.getseq.net/rust-at-datalust-how-we-organize-a-complex-rust-codebase/</link><description><![CDATA[At Datalust we’ve been busy building Flare: a storage engine for our log server, Seq, written in the Rust programming language. This post is a point-in-time look at how we've approached building this fairly complex piece of software in Rust in 2018. I’d like to share a few]]></description><guid isPermaLink="false">6313ebb2-076c-449b-8fb1-372c9b025168</guid><pubDate>Tue, 11 Sep 2018 22:26:05 +0000</pubDate><dc:creator>Ashley Mannix</dc:creator></item><item><title>From Rust to beyond: The C galaxy</title><link>https://mnt.io/2018/09/11/from-rust-to-beyond-the-c-galaxy/</link><description><![CDATA[This blog post is part of a series explaining how to send Rust beyond earth, into many different galaxies. The galaxy we will explore today is the C galaxy. This post will explain what C is (shortly), how to compile any Rust program in C in theory, and how to do that practically with our Rust parser from the Rust side and the C side. We will also see how to test such a binding.]]></description><guid isPermaLink="false">35458bae-bc62-40d7-ac3d-2dcd8ab1f469</guid><pubDate>Tue, 11 Sep 2018 07:49:07 +0000</pubDate><dc:creator>Ivan Enderlin</dc:creator></item><item><title>Unit Type Params</title><link>https://leshow.github.io/post/unit_type_pattern/</link><description><![CDATA[I always enjoy reading blogs about patterns or tricks people have picked up writing Rust. I’ve seen this a few times but not read about it anywhere.

I’ve been doing class assignments from Operating Systems cs140e. I highly recommend this class if you know a bit of Rust and would like to try writing some lower level code. The class involves building bits of an OS for the raspberry pi.]]></description><guid isPermaLink="false">f712f29b-efed-4c75-a4a0-8523fa0b6d52</guid><pubDate>Mon, 10 Sep 2018 12:28:03 -0400</pubDate><dc:creator>Evan Cameron</dc:creator></item><item><title>The Common Rust Traits</title><link>https://stevedonovan.github.io/rustifications/2018/09/08/common-rust-traits.html</link><description><![CDATA[In Rust, data types - primitives, structs, enums and any other ‘aggregate’ types like tuples and arrays - are dumb. They may have methods but that is just a convenience (they are just functions). Types have no relationship with each other.

Traits are the abstract mechanism for adding functionality to types and establishing relationships between them.]]></description><guid isPermaLink="false">83d6c5ed-e847-4807-8c6c-40e97f66b9d5</guid><pubDate>Sat,  8 Sep 2018 00:00:00 +0200</pubDate><dc:creator>Steve Donovan</dc:creator></item><item><title>Rust pattern: Iterating an over a Rc&lt;Vec&lt;T&gt;&gt;</title><link>http://smallcultfollowing.com/babysteps/blog/2018/09/02/rust-pattern-iterating-an-over-a-rc-vec-t/</link><description><![CDATA[This post examines a particular, seemingly simple problem: given ownership of a Rc<Vec<u32>>, can we write a function that returns an impl Iterator<Item = u32>? It turns out that this is a bit harder than it might at first appear – and, as we’ll see, for good reason. I’ll dig into what’s going on, how you can fix it, and how we might extend the language in the future to try and get past this challenge.]]></description><guid isPermaLink="false">7610bbc1-58a1-413b-a4a3-dad7877ca1bd</guid><pubDate>Sun,  2 Sep 2018 00:00:00 -0400</pubDate><dc:creator>Niko Matsakis</dc:creator></item><item><title>Rust Factory Without Box (Trait Object)</title><link>https://singpolyma.net/2018/09/rust-factory-without-box-trait-object/</link><description><![CDATA[I’ve been playing around a lot with Rust recently and it’s quickly becoming my second-favourite programming language. One of the things I’ve been playing with is some Object Oriented design concepts as they might apply.]]></description><guid isPermaLink="false">c3d8acef-fe90-4a0c-9fc5-9061f0694581</guid><pubDate>Sat,  1 Sep 2018 17:52:00 +0000</pubDate><dc:creator>Stephen Paul Weber</dc:creator></item><item><title>Using RwLock and CondVars in Rust</title><link>https://tutorialedge.net/rust/using-rwlocks-and-condvars-rust/</link><description><![CDATA[Read many, write exclusive locks – RwLock Consider a situation where you have a resource that must be manipulated only a single thread at a time, but is safe to be queried by many—that is, you have many readers and only one writer.

While you could protect this resource with a mutex, the trouble is that the mutex makes no distinction between its lockers; every thread will be forced to wait, no matter what their intentions.]]></description><guid isPermaLink="false">44aebda5-9403-432d-b94e-d81449a1edbf</guid><pubDate>Sat,  1 Sep 2018 15:09:49 +0100</pubDate><dc:creator>Brian L. Troutwine</dc:creator></item><item><title>Primitives in Rust are Weird (and Cool)</title><link>https://speice.io/2018/09/primitives-in-rust-are-weird.html</link><description><![CDATA[I wrote a really small Rust program a while back because I was curious. I was 100% convinced itcouldn’t possibly run. And to my complete befuddlement, it compiled, ran, and produced a completely sensible output.]]></description><guid isPermaLink="false">deb45294-d269-481c-a767-f4fd7c00cf0f</guid><pubDate>Sat,  1 Sep 2018 00:00:00 -0400</pubDate><dc:creator>Bradlee Speice</dc:creator></item><item><title>Rust: Fail Fast and Loudly</title><link>https://blog.shivoa.net/2018/08/rust-fail-fast-and-loudly.html</link><description><![CDATA[To panic or to return a Result: why libraries in Rust must weigh their options rather than accepting a never-panic mandate.]]></description><guid isPermaLink="false">271f4485-7452-487c-a1ee-4043dac3c60e</guid><pubDate>Fri, 31 Aug 2018 02:58:00 +0100</pubDate><dc:creator>Shivoa Birch</dc:creator></item><item><title>Introduction to asynchronous programming in Rust</title><link>https://github.com/nrc/apr-intro</link><description><![CDATA[An alternate introdcution to the APR book. This book aims to be a comprehensive, up-to-date guide on the async story in Rust, appropriate for beginners and old hands alike. We assume you already know Rust fairly well, including having done some multi-threaded programming. If any Rust terms in this guide are unfamiliar, you should check out the Rust book.]]></description><guid isPermaLink="false">09fcee2d-1825-46a0-952f-7035c41b2b32</guid><pubDate>Thu, 30 Aug 2018 10:12:00 +0000</pubDate><dc:creator>Nick Cameron</dc:creator></item><item><title>Debugging an Rc&lt;T&gt; reference leak in Rust</title><link>https://people.gnome.org/~federico/blog/debugging-reference-leak-in-rust.html</link><description><![CDATA[The bug that caused two brown-paper-bag releases in librsvg — because it was leaking all the SVG nodes — has been interesting. Memory leaks in Rust? Isn't it supposed to prevent that? Well, yeah, but the leaks were caused by the C side of things, and by unsafe code in Rust, which does not prevent leaks.]]></description><guid isPermaLink="false">09bd9199-be43-439f-ad36-d22904a73fb1</guid><pubDate>Wed, 29 Aug 2018 16:47:13 -0500</pubDate><dc:creator>Federico Mena Quintero</dc:creator></item><item><title>Feasible functors in Rust</title><link>https://varkor.github.io/blog/2018/08/28/feasible-functors-in-rust.html</link><description><![CDATA[withoutboats, one of the Rust language design team, recently posted a thread on the infeasibility of monads as a useful abstraction technique in Rust, as a response to the persistence of some (usually from outside the Rust community) in claiming that “Rust is doing things incorrectly” by developing specific solutions to problems, rather than using a general category theoretic framework for everything. The points demonstrate real difficulties with attempting to use a general framework for these problems and to me serves perfectly as a “the ball’s in your court now” to anyone claiming Rust is ignoring theory and coming up with unnecessary solutions to solved problems: if you think Rust could use monadic abstractions, you have to be able to address these counterarguments.]]></description><guid isPermaLink="false">5d84ad61-702d-400b-ac40-6325904e031d</guid><pubDate>Tue, 28 Aug 2018 12:20:10 +0000</pubDate><dc:creator>varkor</dc:creator></item><item><title>Serde Deserialize This or That into u64</title><link>https://noyez.gitlab.io/post/2018-08-28-serilize-this-or-that-into-u64/</link><description><![CDATA[Recently I ran into a bug in my code; hey, it happens. The bug was that I had a struct which could serialize into json, but could not deserialize from its own json. The struct holds a value for a mac address, which is 48-bit integer (that i store in a u64), but it is serialized using the network interface name. For example on my mac, i have a network interface named en1 with the mac address of 20:c9:d0:b0:a4:71.]]></description><guid isPermaLink="false">a2e99609-1298-4f79-b2f3-0cce908a701f</guid><pubDate>Tue, 28 Aug 2018 00:00:00 +0000</pubDate><dc:creator>Noyez</dc:creator></item><item><title>Thoughts on Rust from a PHP developer!</title><link>https://www.smashing-bugs.tk/software-development/rust/2018/08/27/on-rust-from-a-php-developer.html</link><description><![CDATA[I first starting learning Rust about 6 months ago, I was looking for a new language to learn when I came across it. At first I thought Rust was only meant to be a low level, systems programming language, but the more I learned, the more I realised the potential it has for high level programming and web applications. Also, along the way I learned many ways in which Rust prevents many of the typical bugs often found in applications written in other programming languages.]]></description><guid isPermaLink="false">90241d58-f6a1-4df5-9c3f-15c94998c6df</guid><pubDate>Mon, 27 Aug 2018 14:41:11 +0000</pubDate><dc:creator>Diego Cabrejas</dc:creator></item><item><title>Experimental async / await support for Tokio</title><link>https://tokio.rs/blog/2018-08-async-await/</link><description><![CDATA[In case you haven’t heard, async / await is a big new feature that is being worked on for Rust. It aims to make asynchronous programming easy (well, at least a little bit easier than it is today). The work has been on going for a while and is already usable today on the Rust nightly channel.

I’m happy to announce that Tokio now has experimental async / await support! Let’s dig in a bit.]]></description><guid isPermaLink="false">7a251e22-3430-4226-85e0-a94e73b3e785</guid><pubDate>Mon, 27 Aug 2018 00:00:00 +0000</pubDate><dc:creator>Carl Lerche</dc:creator></item><item><title>Programming Servo: The Debug Way</title><link>https://medium.com/coding-neutrino-blog/programming-servo-the-debug-way-5db01f09b7f4</link><description><![CDATA[Servo is a huge project. I have counted the lines of code for you. There are almost a hundred thousand lines of code in the Servo project. To develop such a big project, knowing how to debug in a right way is very important, since you would like to find the bottleneck in a fast and efficient way.

In this article, I will teach you some tips to use GDB developing and debugging your Rust code in the Servo project.]]></description><guid isPermaLink="false">fcadb47a-753e-44c9-830e-0e2cda34b365</guid><pubDate>Sun, 26 Aug 2018 14:55:42 +0000</pubDate><dc:creator>Liu An Chi</dc:creator></item><item><title>Easy proc_macro_derive&apos;s with synstructure</title><link>https://llogiq.github.io/2018/08/25/synstruct.html</link><description><![CDATA[Recently, I found myself in the market for some quickcheck. However, there were custom types, which had no Arbitrary implementation. Wondering if someone had already written a procedural macro to derive it, I found panicbit’s quickcheck_derive crate. However, to my dismay, it was severely limited in that it could only derive Arbitrary for structs.]]></description><guid isPermaLink="false">13973f76-d793-4df8-9529-bca5f5f84428</guid><pubDate>Sat, 25 Aug 2018 00:00:00 +0000</pubDate><dc:creator>Llogiq</dc:creator></item><item><title>Calling C# natively from Rust</title><link>https://medium.com/@chyyran/calling-c-natively-from-rust-1f92c506289d</link><description><![CDATA[A couple of months ago, I created my first Rust program; a music manager called seiri. seiri is actually a rewrite of a previous, much buggier program that I used to organize my music that was written in C#. The tag library of choice was of course, taglib-sharp, a port of the C++ library TagLib to the .NET ecosystem. Since Rust unfortunately doesn’t have its own native port of TagLib, and any C bindings available didn’t expose the picture API, the most obvious thing to do was to use the C# library with Rust somehow, right?]]></description><guid isPermaLink="false">4a0db6c9-2c0d-4455-b353-474e4f59c87a</guid><pubDate>Fri, 24 Aug 2018 01:07:46 +0000</pubDate><dc:creator>Ronny Chan</dc:creator></item><item><title>Why an Interior Mutable abstraction is needed in the Rust core library</title><link>http://blog.kjeka.com/rust/programming/tmcl/2018/08/24/interior-mut/</link><description><![CDATA[Interior mutabiliby is a concept known to anyone who have programmed in Rust for a while. And even though Rust's stdlib have several wrapper-types allowing interior mutability there is no trait unifying these types. Motivated by writing libraries suitable for no_std development that are fully safe to use with threads, this blog post will attempt to fill in one gap in the Rust stdlib.]]></description><guid isPermaLink="false">b0c75f8a-24c3-449e-bc2d-97638d193d3e</guid><pubDate>Fri, 24 Aug 2018 00:00:00 +0000</pubDate><dc:creator>Kjetil Kjeka</dc:creator></item><item><title>Oxidizing sourmash: Python and FFI</title><link>https://blog.luizirber.org/2018/08/23/sourmash-rust/</link><description><![CDATA[Last December I decided to give Rust a run: I spent some time porting the C++ bits of sourmash to Rust. The main advantage here is that it's a problem I know well, so I know what the code is supposed to do and can focus on figuring out syntax and the mental model for the language. I started digging into the symbolic codebase and understanding what they did, and tried to mirror or improve it for my use cases.]]></description><guid isPermaLink="false">4857abad-3757-40b8-a899-93442e4982e9</guid><pubDate>Thu, 23 Aug 2018 17:00:00 -0300</pubDate><dc:creator>Luiz Irber</dc:creator></item><item><title>More on the RLS and a 1.0 release</title><link>https://www.ncameron.org/blog/more-on-the-rls-and-a-1-0-release/</link><description><![CDATA[In my last post, I announced a release candidate for the RLS 1.0. There has been a lot of feedback (and quite a lot of that was negative on the general idea), so I wanted to expand on what 1.0 means for the RLS, and why I think it is ready. I also want to share some of my vision for the future of the RLS, in particular changes that might warrant a major version release.]]></description><guid isPermaLink="false">49ccf817-c69f-4467-9391-9fccc619e928</guid><pubDate>Thu, 23 Aug 2018 09:10:11 +0000</pubDate><dc:creator>Nick Cameron</dc:creator></item><item><title>To Make or Not to Make – Using cargo make for Rookeries v0.12.0</title><link>https://dorianpula.ca/2018/08/22/to-make-or-not-to-make-using-cargo-make-for-rookeries-v0-12-0/</link><description><![CDATA[I recently continued with my exploration of Rust through Rookeries (my attempt at a static site generator/backing API server). This time I worked on switching over from using invoke and GNU make to using a nice build system called cargo-make. Overall I am quite happy with the result.]]></description><guid isPermaLink="false">0c187e7b-4693-4f2c-b330-ce51a314c6eb</guid><pubDate>Wed, 22 Aug 2018 23:00:27 +0000</pubDate><dc:creator>Dorian Pula</dc:creator></item><item><title>Live Refreshing Cargo Docs</title><link>https://benjamincongdon.me/blog/2018/08/22/Live-Refreshing-Cargo-Docs/</link><description><![CDATA[rustdoc is a great tool, but as of now there isn’t an official way to have its generated docs refresh as you make edits. Running cargo doc with the --open argument will open the generated docs in browser window. If you make changes to your source code, you’ll need to re-run cargo doc to have the changes reflected in your browser. By chaining together a few other Rust tools, we can pretty easily get the functionality of live-reloading docs.]]></description><guid isPermaLink="false">1332a957-6689-4053-884b-ec31ca39f505</guid><pubDate>Wed, 22 Aug 2018 21:03:28 +0000</pubDate><dc:creator>Benjamin Congdon</dc:creator></item><item><title>Two Kinds of Invariants: Safety and Validity</title><link>https://www.ralfj.de/blog/2018/08/22/two-kinds-of-invariants.html</link><description><![CDATA[When talking about the Rust type system in the context of unsafe code, the discussion often revolves around invariants: Properties that must always hold, because the language generally assumes that they do. In fact, an important part of the mission of the Unsafe Code Guidelines strike force is to deepen our understanding of what these invariants are.

However, in my view, there is also more than one invariant, matching the fact that there are (at least) two distinct parties relying on these invariants: The compiler, and (authors of) safely usable code. This came up often enough in recent discussions that I think it is worth writing it down properly once, so I can just link here in the future.]]></description><guid isPermaLink="false">7c167657-c185-479c-afc3-93b0187b8359</guid><pubDate>Wed, 22 Aug 2018 00:00:00 +0000</pubDate><dc:creator>Ralf Jung</dc:creator></item><item><title>Another look at the pinning API</title><link>https://boats.gitlab.io/blog/post/rethinking-pin/</link><description><![CDATA[One thing has always nagged about the API we have right now though: the proliferation of different reference types that it implies. Today, the pin feature adds the PinMut and PinBox types, but in theory there ought to be a “pinned” version of every pointer in the standard library: PinRc and PinArc and so on. This is a very unfortunate consequence, but so far we have not found a good way to make pinning work compositionally - to have a single adapter that could be combined with any pointer.

Last night, a bit of inspiration struck me, and I realized that it is possible to make a compositional Pin type. This isn’t a fundamental change to the pinning model, just an API refactoring, but I’ve put a blocking concern on the proposal to stabilize Pin so that we can consider this possibility.]]></description><guid isPermaLink="false">edfe7063-b893-42db-aa08-61adcaddf56b</guid><pubDate>Wed, 22 Aug 2018 00:00:00 +0000</pubDate><dc:creator>boats</dc:creator></item><item><title>[blog series] From Rust to beyond: Prelude</title><link>https://mnt.io/2018/08/21/from-rust-to-beyond-prelude/</link><description><![CDATA[This series of posts is about those bindings, and explains how to send Rust beyond earth, into many different galaxies. Rust will land in: The WebAssembly galaxy, The ASM.js galaxy, The C galaxy, The PHP galaxy, and The NodeJS galaxy. The ship is currently flying into the Java galaxy, this series may continue if the ship does not crash or has enough resources to survive!]]></description><guid isPermaLink="false">e3b3767b-4228-4432-a525-15d8cbc99f77</guid><pubDate>Tue, 21 Aug 2018 08:46:20 +0000</pubDate><dc:creator>Ivan Enderlin</dc:creator></item><item><title>Safe Partial Initialization In Rust</title><link>https://scottjmaddox.github.io/Safe-partial-initialization-in-Rust/</link><description><![CDATA[Say we have a struct, Foo, with multiple fields that we would like to partially initialize without resorting to using unsafe. We could write a procedural macro called PartialInit, for example, which would be invoked using derive.]]></description><guid isPermaLink="false">29c7c773-0be7-4694-a11d-41717eac218c</guid><pubDate>Sun, 19 Aug 2018 00:00:00 +0000</pubDate><dc:creator>Scott J Maddox</dc:creator></item><item><title>A Beginner’s Guide to Rust Macros ✨</title><link>https://medium.com/@phoomparin/a-beginners-guide-to-rust-macros-5c75594498f1</link><description><![CDATA[Demystifying one of Rust’s most powerful feature.]]></description><guid isPermaLink="false">9f3fb115-f832-421a-bf28-18148cc3bde0</guid><pubDate>Sat, 18 Aug 2018 18:35:50 +0000</pubDate><dc:creator>Phoomparin Mano</dc:creator></item><item><title>Why Rust Closures are (Somewhat) Hard</title><link>http://stevedonovan.github.io/rustifications/2018/08/18/rust-closures-are-hard.html</link><description><![CDATA[Rust closures are harder for three main reasons: The first is that it is both statically and strongly typed, so we’ll need to explicitly annotate these function types. Second, Lua functions are dynamically allocated (‘boxed’.) Rust does not allocate silently because it prefers to be explicit and is a system language designed for maximally efficient code. Third, closures share references with their environment. In the case of Lua, the garbage collector ensures that these references will live long enough. With Rust, the borrow checker needs to be able to track the lifetimes of these references.]]></description><guid isPermaLink="false">e3bf830e-e1ed-462b-9a6a-edac9ba2d699</guid><pubDate>Sat, 18 Aug 2018 00:00:00 +0200</pubDate><dc:creator>Steve Donovan</dc:creator></item><item><title>Writing Integration Tests in Rust</title><link>https://dorianpula.ca/2018/08/15/writing-integration-tests-in-rust-releasing-rookeries-v0-11-0/</link><description><![CDATA[As part of my overall change over in Rookeries, from Python to Rust, I rewrote a suite of integration tests for the server API. To celebrate my successful transition, I released version 0.11.0 of Rookeries, whose tests use pure Rust now!]]></description><guid isPermaLink="false">26f81256-2d48-4d6e-b305-7ed0d88c216b</guid><pubDate>Wed, 15 Aug 2018 23:00:26 +0000</pubDate><dc:creator>Dorian Pula</dc:creator></item><item><title>Diagnosing A Weak Memory Ordering Bug</title><link>https://robert.ocallahan.org/2018/08/for-first-time-in-my-life-i-tracked.html</link><description><![CDATA[For the first time in my life I tracked a real bug's root cause to incorrect usage of weak memory orderings. Until now weak memory bugs were something I knew about but had subconciously felt were only relevant to wizards coding on big iron, partly because until recently I've spent most of my career using desktop x86 machines.]]></description><guid isPermaLink="false">4b9c619b-6d09-43a9-82bb-86887dbd3a53</guid><pubDate>Tue, 14 Aug 2018 15:18:00 +1200</pubDate><dc:creator>Robert O&apos;Callahan</dc:creator></item><item><title>A Short Serde Deserialize example</title><link>https://noyez.gitlab.io/post/2018-08-14-short-serde-deserialize-exapmle/</link><description><![CDATA[In my previous post, I described taking a simple enum and creating a custom type in diesel. This post will take that same enum and implement deserialize. I often get tripped up by the mechanics of deserializing so this simple enum makes for a good example. Again, this is to benefit anyone looking for more examples of Serde’s Deserialize as well as for myself, so I can remember next time I need to do this.]]></description><guid isPermaLink="false">45c51d1f-97ea-41ad-a1fe-3aab3c51d9ee</guid><pubDate>Tue, 14 Aug 2018 00:00:00 +0000</pubDate><dc:creator>Noyez</dc:creator></item><item><title>Rust: _(underscore) Does Not Bind</title><link>https://medium.com/codechain/rust-underscore-does-not-bind-fec6a18115a8</link><description><![CDATA[Rust is a language that utilizes the RAII idiom, resulting in different code depending on when the object is destroyed.]]></description><guid isPermaLink="false">523b014f-5ec9-4569-b31f-44720fb3bbc4</guid><pubDate>Mon, 13 Aug 2018 07:13:58 +0000</pubDate><dc:creator>Seung Woo Kim</dc:creator></item><item><title>Never patterns, exhaustive matching, and uninhabited types (oh my!)</title><link>http://smallcultfollowing.com/babysteps/blog/2018/08/13/never-patterns-exhaustive-matching-and-uninhabited-types-oh-my/</link><description><![CDATA[One of the long-standing issues that we’ve been wrestling with in Rust is how to integrate the concept of an “uninhabited type” – that is, a type which has no values at all. Uninhabited types are useful to represent the “result” of some computation you know will never execute – for example, if you have to define an error type for some computation, but this particular computation can never fail, you might use an uninhabited type.]]></description><guid isPermaLink="false">8a47c51e-2de1-47c2-8c3d-3f2d84ae13cb</guid><pubDate>Mon, 13 Aug 2018 00:00:00 -0700</pubDate><dc:creator>Niko Matsakis</dc:creator></item><item><title>I learnt Rust: less than a memoir</title><link>http://blog.kekoariggin.com/coding/i-learnt-rust-less-than-a-memoir/</link><description><![CDATA[Over the past two months, I worked on a feature for Project Fluent. My feature was needed in the Rust implementation of Fluent and was published as a Rust crate, making my code available to the entire Rust community. Completing this project brought me a great sense of satisfaction, and having contributed a fundamental internationalization crate to the Rust ecosystem is possibly the biggest milestone in my career as a developer.]]></description><guid isPermaLink="false">91714b35-a84b-4ac0-a0ed-57e2bdedc9dc</guid><pubDate>Mon, 13 Aug 2018 04:23:32 +0000</pubDate><dc:creator>Kekoa Riggin</dc:creator></item><item><title>A FizzBuzzy Tour of Traits in Rust</title><link>https://www.joshmcguigan.com/blog/fizzbuzz-tour-of-traits-rust/</link><description><![CDATA[Traits are a core part of the Rust programming language, and understanding traits, particularly those which are part of the standard library, is necessary in order to write idiomatic Rust. In this post I’ll write several FizzBuzz implementations, each demonstrating the use of a different trait from the Rust standard library.]]></description><guid isPermaLink="false">a47db977-bb96-4ecf-9203-8c64b438062d</guid><pubDate>Mon, 13 Aug 2018 00:00:00 +0000</pubDate><dc:creator>Josh Mcguigan</dc:creator></item><item><title>Refactoring with Rust macros</title><link>https://philbooth.me/blog/refactoring-with-rust-macros</link><description><![CDATA[Refactoring boilerplate code is always easy in dynamically-typed languages, but sometimes takes a bit more effort when constrained by strong typing. This is something I was puzzling over recently, when the penny dropped for me about how Rust's macros can be used to bridge the gap.]]></description><guid isPermaLink="false">ff118dd1-1fe8-4cde-a359-a00325002ebd</guid><pubDate>Sun, 12 Aug 2018 12:54:12 +0000</pubDate><dc:creator>Phil Booth</dc:creator></item><item><title>Object Models And Identities</title><link>https://vorner.github.io/2018/08/12/Object-models-and-identities.html</link><description><![CDATA[In many things, Rust is very much like C++. It’s memory management strategy is mostly the same, threading models are copied vanilla, both compile to native code and do about the same optimisations at that time, and traits and templates have a lot in common too. Both tend to be rather feature-rich languages with quite a lot to learn. While Rust is definitely better teacher (I’m looking at you, C++ error message!) and has many more „safety covers“ over the dangerous moving parts inside the engine, the design of the engine is more of an evolution from C++ than a completely new thing.

But I’ve noticed one rather subtle difference in the philosophy of the languages I’d like to describe here. To make it somewhat more complete, I’ll also throw what some other languages do in this area in.]]></description><guid isPermaLink="false">e19ac48b-7995-4b64-82d8-64d149067b54</guid><pubDate>Sun, 12 Aug 2018 00:00:00 +0000</pubDate><dc:creator>Michal &apos;vorner&apos; Vaner</dc:creator></item><item><title>How to alleviate the pain of Rust compile times</title><link>https://vfoley.xyz/rust-compile-speed-tips/</link><description><![CDATA[A few days ago, I wrote about two Rust pain points when using Rust at work. One of these points were the long compile times. In this post, I want to share a few tips that can help alleviate that pain.]]></description><guid isPermaLink="false">6f49ae97-11d3-4e1f-ab95-0307bf406aa5</guid><pubDate>Sat, 11 Aug 2018 00:00:00 +0000</pubDate><dc:creator>Vincent Foley</dc:creator></item><item><title>GSoC wrap-up - Splitting Servo&apos;s script crate</title><link>https://blog.servo.org/2018/08/09/gsoc-generic-servo/</link><description><![CDATA[I am Peter Hrvola (retep007) Twitter Github. During my Google Summer of Code (GSoC) project, I have been working on investigating the monolithic nature of Servo’s script crate and prototyping separation to smaller crates. My goal was to improve the use of resources during compilation. Current debug build consumes over 5GB of memory and takes 347s.]]></description><guid isPermaLink="false">e141f480-7f0d-4b15-82b6-44d0f807f09c</guid><pubDate>Thu,  9 Aug 2018 00:00:00 +0000</pubDate><dc:creator>Peter Hrvola</dc:creator></item><item><title>Literate Programming in Rust</title><link>https://damien.codes/posts/literate-rust/</link><description><![CDATA[In which we explore how cargo and rustdoc make it possible to write documentation and unit tests at once, resulting in code that is explained and tested from the POV of a public API.]]></description><guid isPermaLink="false">9a82c540-b8ab-4635-a68b-82754b5fe8a1</guid><pubDate>Thu,  9 Aug 2018 00:00:00 +0000</pubDate><dc:creator>Damien</dc:creator></item><item><title>Proposal: Rust Custom Test Frameworks</title><link>https://blog.jrenner.net/rust/testing/2018/08/06/custom-test-framework-prop.html</link><description><![CDATA[The Rust community recently approved a Custom Test Frameworks eRFC which lays out a series of goals and possible directions of exploration for implementing custom test frameworks. In this post, I present my own proposed fulfillment of the RFC with rationale.]]></description><guid isPermaLink="false">8c27c640-fb7d-42f9-a31f-09e9f5b35c2d</guid><pubDate>Wed,  8 Aug 2018 08:12:00 +0000</pubDate><dc:creator>John Renner</dc:creator></item><item><title>Launching the 2018 State of Rust Survey</title><link>https://blog.rust-lang.org/2018/08/08/survey.html</link><description><![CDATA[It’s that time again! Time for us to take a look at how the Rust project is doing, and what we should plan for the future. The Rust Community Team is pleased to announce our 2018 State of Rust Survey! Whether or not you use Rust today, we want to know your opinions. Your responses will help the project understand its strengths and weaknesses and establish development priorities for the future.

This year, volunteers have also translated the survey into 14 languages!]]></description><guid isPermaLink="false">f0133b81-60d3-416a-b58a-6d6c9c7afe6a</guid><pubDate>Wed,  8 Aug 2018 00:00:00 +0000</pubDate><dc:creator>The Rust Community Team</dc:creator></item><item><title>Rust concurrency patterns: No context, no cancel, no leaks</title><link>https://medium.com/@polyglot_factotum/rust-concurrency-patterns-no-context-no-cancel-no-leak-b6c1ec2dafa5</link><description><![CDATA[Let’s put ourselves to the challenge of having an ‘infinite’ generator, which will have to be told to stop generating by the consumer…]]></description><guid isPermaLink="false">bbb6ed5a-a451-4abf-bbff-2e0b33f6660a</guid><pubDate>Tue,  7 Aug 2018 10:54:56 +0000</pubDate><dc:creator>Gregory Terzian</dc:creator></item><item><title>Stacked Borrows: An Aliasing Model For Rust</title><link>https://www.ralfj.de/blog/2018/08/07/stacked-borrows.html</link><description><![CDATA[In this post, I am proposing “Stacked Borrows”: A set of rules defining which kinds of aliasing are allowed in Rust. This is intended to answer the question which pointer may be used when to perform which kinds of memory accesses.]]></description><guid isPermaLink="false">b5f6a958-c0bd-4ea9-a1ae-d8e4f5549719</guid><pubDate>Tue,  7 Aug 2018 00:00:00 +0000</pubDate><dc:creator>Ralf Jung</dc:creator></item><item><title>Clippy&apos;s &quot;cast_lossless&quot; Lint Warning</title><link>https://benjamincongdon.me/blog/2018/08/06/Clippys-cast_lossless-Lint-Warning/</link><description><![CDATA[Recently, I was trying out clippy  — a linting and static analysis tool for Rust, when I ran into a lint warning that wasn’t immediately clear to me: warning: casting u8 to u16 may become silently lossy if types change.]]></description><guid isPermaLink="false">64be78c2-0f4e-413f-ac54-1e6b21215413</guid><pubDate>Mon,  6 Aug 2018 20:28:01 +0000</pubDate><dc:creator>Benjamin Congdon</dc:creator></item><item><title>Rust Modules In Less Than 5 Minutes</title><link>https://medium.com/@erik.tate/rust-modules-in-less-than-5-minutes-9bff7f617798</link><description><![CDATA[When I started learning Rust, the module system did not at first seem to be a shining beacon of intuitive design. The Rust documentation is phenomenal, but there are definitely some areas that I found difficult to follow; this being one such topic. So I thought I might take a stab at writing up a guide that I think would have helped me through the awkward growing pains a bit quicker.]]></description><guid isPermaLink="false">7d6c2d9c-16c8-42be-93d5-d61cc9dac117</guid><pubDate>Sun,  5 Aug 2018 23:49:43 +0000</pubDate><dc:creator>Erik Tate</dc:creator></item><item><title>Logging from Rust in librsvg</title><link>https://people.gnome.org/~federico/blog/logging-in-librsvg.html</link><description><![CDATA[Over in this issue we are discussing how to add debug logging for librsvg.  A popular way to add logging to Rust code is to use the log crate. However, the log create is just a facade, and by default the messages do not get emitted anywhere. The calling code has to set up a logger. Crates like env_logger let one set up a logger, during program initialization, that gets configured through an environment variable. This is a problem for librsvg: we are not the program's initialization! Librsvg is a library; it doesn't have a main() function. And since most of the calling code is not Rust, we can't assume that they can call code that can initialize the logging framework.]]></description><guid isPermaLink="false">d711d36a-fa00-4b26-a367-26b70589af2e</guid><pubDate>Fri,  3 Aug 2018 19:29:43 -0500</pubDate><dc:creator>Federico Mena Quintero</dc:creator></item><item><title>Rust and the Case of the Redundant Comparison</title><link>https://blog.dend.ro/rust-and-the-case-of-the-redundant-comparison/</link><description><![CDATA[A couple of days ago I landed my second pull request in the Rust Programming Language repository. This is the story of how that went. This post is inspired by other posts about improving the Rust compiler.]]></description><guid isPermaLink="false">58e93b1c-f7b4-440f-88fb-fa5ab900f1c6</guid><pubDate>Sat,  4 Aug 2018 00:00:00 +0000</pubDate><dc:creator>dend</dc:creator></item><item><title>Some Slight Improvements</title><link>https://llogiq.github.io/2018/08/04/improve.html</link><description><![CDATA[Today I want to talk about two Rust PRs I recently wrote. The PRs in question are #52942 and #52997. Both are relatively small changes to Rust’s internally used data structures that improve performance and readability. Both have some basic benchmarks (the first one already had them and I wrote them for the second one), although it’s rather hard to gauge whether they really impacted compile times (as perf.rust-lang.org puts all changes of the specific day together). But that’s not the point I want to make right now.]]></description><guid isPermaLink="false">02647906-fc14-42ea-87ec-19fc717cb3d7</guid><pubDate>Sat,  4 Aug 2018 00:00:00 +0000</pubDate><dc:creator>Llogiq</dc:creator></item><item><title>Solving the Generalized Streaming Iterator Problem without GATs</title><link>http://lukaskalbertodt.github.io/2018/08/03/solving-the-generalized-streaming-iterator-problem-without-gats.html</link><description><![CDATA[Generic Associated Types (GATs for short) are a long awaited extension to Rust’s type system. They offer a way to work with higher kinded types – a necessity in a couple of situations. A common example is the streaming iterator: an iterator able to return items borrowing from self (the iterator itself). Unfortunately, GATs haven’t even landed in nightly yet. So while are waiting, we can try tackling the streaming iterator problem without GATs. In this post we explore three possible workarounds for situations where an associated type depends on the lifetime of a &self receiver.]]></description><guid isPermaLink="false">2cc12b2e-22fb-461a-be01-ffeab54caa9f</guid><pubDate>Fri,  3 Aug 2018 00:00:00 +0000</pubDate><dc:creator>Lukas Kalbertodt</dc:creator></item><item><title>Announcing Rust 1.28</title><link>https://blog.rust-lang.org/2018/08/02/Rust-1.28.html</link><description><![CDATA[The Rust team is happy to announce a new version of Rust. This release includes the global_allocator attribute to customise the allocator, improved error messages for format strings, and a number of number related stabilisations.]]></description><guid isPermaLink="false">44372b96-a1e4-44ee-af79-4496c4f629e6</guid><pubDate>Thu,  2 Aug 2018 00:00:00 +0000</pubDate><dc:creator>The Rust Core Team</dc:creator></item><item><title>Streaming UTF-8 in Haskell and Rust</title><link>https://www.fpcomplete.com/blog/2018/07/streaming-utf8-haskell-rust</link><description><![CDATA[An investigation into getting Haskell-like error handling ergonomics into a Rust application dealing with streaming UTF-8 encoding and decoding.]]></description><guid isPermaLink="false">8f26eb1d-8d0c-4785-a7fb-85c8cf5c6f27</guid><pubDate>Mon, 30 Jul 2018 09:00:00 +0000</pubDate><dc:creator>Michael Snoyman</dc:creator></item><item><title>That weekend I wasted on newtyped indices</title><link>https://exphp.github.io/2018/07/30/that-weekend-i-wasted-on-newtyped-indices.html</link><description><![CDATA[Today, ajyne posted a thread on users.rust-lang.org asking: What have been the drawbacks of static typing for you? Kornel was quick to reply with a variety of points, but this one in particular stands out to me, "With powerful type systems there’s no end to how far you can go to guarantee things about your program, but you might create a complex monster". As I see it, there is no truer answer. The type system can be a seductive beast, often promising correctness and performance at the low-low, one-time cost of your soul. I personally can name a number of examples from my own code base where I tried to abstract over something too big and failed. I call these my wasted weekends.]]></description><guid isPermaLink="false">4f9e9645-78dc-4c18-a504-653e96a0c960</guid><pubDate>Mon, 30 Jul 2018 00:00:00 +0000</pubDate><dc:creator>Michael Lamparski</dc:creator></item><item><title>Rust: controlling side effects from the test</title><link>https://blog.cyplo.net/posts/2018/07/rust-injection.html</link><description><![CDATA[Imagine you want to write a timestamping repository of some sorts, that will associate the timestamp of when the storage operation was invoked with the stored value. How to write it in Rust ? And more importantly - how to test it ? I would like to share a solution I found and talk a bit about how it works.]]></description><guid isPermaLink="false">3b874195-0df6-40ca-8667-067d3440061b</guid><pubDate>Mon, 30 Jul 2018 00:00:00 +0000</pubDate><dc:creator>Cyryl Płotnicki</dc:creator></item><item><title>Rust concurrency patterns: Natural Born Pipelines</title><link>https://medium.com/@polyglot_factotum/rust-concurrency-patterns-natural-born-pipelines-4d599e7612fc</link><description><![CDATA[There seems to be demand for a “Rust concurrent pipeline” guide à la https://blog.golang.org/pipelines, so let’s give it a try.]]></description><guid isPermaLink="false">f7eba5d3-ef85-47cb-88ec-345cf3c46ade</guid><pubDate>Sat, 28 Jul 2018 09:12:33 +0000</pubDate><dc:creator>Gregory Terzian</dc:creator></item><item><title>A Snapshot of Rust&apos;s Popularity in July 2018</title><link>http://www.jonathanturner.org/2018/07/snapshot-of-rust-popularity.html</link><description><![CDATA[Talking about a language’s popularity is traditionally a tricky topic. How do you measure popularity? How do you compare one language to another when they’re focused on different styles and different audiences? So, rather than having one or two charts, I’m going to look at a number of “slices” into Rust’s growth to see it front different angles.]]></description><guid isPermaLink="false">2dba28aa-a443-4887-9806-aba84cf787ef</guid><pubDate>Sat, 28 Jul 2018 00:00:00 +0000</pubDate><dc:creator>Jonathan Turner</dc:creator></item><item><title>Using a Mac to cross-compile Linux binaries</title><link>http://timryan.org/2018/07/27/cross-compiling-linux-binaries-from-macos.html</link><description><![CDATA[The cycle of development we’re most familiar with is: write code, compile your code, then run this code on the same machine you were writing it on. On most desktop OSes, you pick up a compiler by downloading one from your package manager. Xcode and Visual Studio are toolchains (actually IDEs) that leverage being platform-specific, each including tools tailored around the platform your code will run on and heavily showcasing the parent OS’s design language.]]></description><guid isPermaLink="false">86add592-8587-406b-8233-a06e675452f0</guid><pubDate>Fri, 27 Jul 2018 13:22:00 +0000</pubDate><dc:creator>Tim Ryan</dc:creator></item><item><title>What is Rust 2018?</title><link>https://blog.rust-lang.org/2018/07/27/what-is-rust-2018.html</link><description><![CDATA[The release of Rust 1.31.0 on December 6th will be the first release of “Rust 2018.” This marks a culmination of the last three years of Rust’s development, and brings it together in one neat package. For example, there will be a 2018 edition of the book that incorporates features stabilized since the print edition was considered finalized.]]></description><guid isPermaLink="false">2c62015d-b849-4ab6-bbc9-e62255ca3473</guid><pubDate>Fri, 27 Jul 2018 00:00:00 +0000</pubDate><dc:creator>The Rust Core Team</dc:creator></item><item><title>Version selection in Cargo</title><link>http://aturon.github.io/2018/07/25/cargo-version-selection/</link><description><![CDATA[When there are multiple ways to resolve dependencies, Cargo generally chooses the newest possible version. The goal of this post is to explain why Cargo works this way, and how that rationale relates to several recent discussions, including:]]></description><guid isPermaLink="false">d0dc161e-3fcc-4fc7-9032-f9847bf4f3b8</guid><pubDate>Wed, 25 Jul 2018 00:00:00 +0000</pubDate><dc:creator>Aaron Turon</dc:creator></item><item><title>My experience with the Rust 2018 preview</title><link>https://boats.gitlab.io/blog/post/my-experience-with-rust-2018/</link><description><![CDATA[Recently, I wrote a little a side project to sign git commits without gpg. When I did this, I decided to use the Rust 2018 edition. I also transitioned an existing library from Rust 2015 to Rust 2018 to see how that tooling worked. I thought I’d write a blog post about my experience using the Rust 2018 preview and the state of things right now.]]></description><guid isPermaLink="false">a243dc7d-5708-4a3d-bae8-20ccc3de53d0</guid><pubDate>Tue, 24 Jul 2018 00:00:00 +0000</pubDate><dc:creator>boats</dc:creator></item><item><title>Pointers Are Complicated, or: What&apos;s in a Byte?</title><link>https://www.ralfj.de/blog/2018/07/24/pointers-and-bytes.html</link><description><![CDATA[This summer, I am again working on Rust full-time, and again I will work (amongst other things) on a “memory model” for Rust/MIR. However, before I can talk about the ideas I have for this year, I have to finally take the time and dispel the myth that “pointers are simple: they are just integers”. Both parts of this statement are false, at least in languages with unsafe features like Rust or C: Pointers are neither simple nor (just) integers.

I also want to define a piece of the memory model that has to be fixed before we can even talk about some of the more complex parts: Just what is the data that is stored in memory? It is organized in bytes, the minimal addressable unit and the smallest piece that can be accessed (at least on most platforms), but what are the possible values of a byte? Again, it turns out “it’s just an 8-bit integer” does not actually work as the answer.

I hope that by the end of this post, you will agree with me on both of these statements. :)]]></description><guid isPermaLink="false">b4133437-b69d-4491-a40f-a368a8847627</guid><pubDate>Tue, 24 Jul 2018 00:00:00 +0000</pubDate><dc:creator>Ralf Jung</dc:creator></item><item><title>Building Readable Tests with Fluent Testing APIs</title><link>https://leotindall.com/tutorial/building-readable-tests-with-fluent-testing-apis/</link><description><![CDATA[One of the biggest challenges in software testing is defining the input for code under test in a way that is expressive and powerful enough to test complex situations but doesn’t distract from the intent of the test or clutter the test code to a degree that makes it difficult to read.

Many dynamic languages have testing APIs which take advantage of their looser and later type checking to provide easy mocking and stubbing, but strict, statically typed languages can make it difficult to build up suitable instances of the types needed in the test.]]></description><guid isPermaLink="false">96eb15b8-5f51-403c-a699-805553293c16</guid><pubDate>Mon, 23 Jul 2018 09:56:24 -0500</pubDate><dc:creator>Leo Tindall</dc:creator></item><item><title>On impl blocks, injection and surjection in Rust</title><link>https://phaazon.net/blog/on-rust-impl-block</link><description><![CDATA[Rust has this cool feature called impl block. An impl block is just a scope that introduces a way to augment a type with methods – do not confuse impl blocks with trait impls, used to implement a given trait.]]></description><guid isPermaLink="false">4a0e6748-9562-4507-bbfe-3cdf49b6292b</guid><pubDate>Sun, 22 Jul 2018 22:05:00 +0000</pubDate><dc:creator>Dimitri Sabadie</dc:creator></item><item><title>Rust concurrency patterns: communicate by sharing your Sender</title><link>https://medium.com/@polyglot_factotum/rust-concurrency-patterns-communicate-by-sharing-your-sender-11a496ce7791</link><description><![CDATA[Doing concurrency in ‘share by communicating’ style has been popularized by the Go community. It’s a valuable approach to concurrency in Rust too, however, one has to be aware of the different semantics of Rust vs Go channels when doing so.]]></description><guid isPermaLink="false">6c12615c-c39d-4123-993e-a8581915e2f0</guid><pubDate>Sat, 21 Jul 2018 16:10:44 +0000</pubDate><dc:creator>Gregory Terzian</dc:creator></item><item><title>Announcing Rust 1.27.2</title><link>https://blog.rust-lang.org/2018/07/20/Rust-1.27.2.html</link><description><![CDATA[The Rust team is happy to announce a new version of Rust, 1.27.2.]]></description><guid isPermaLink="false">2d302e67-f458-4d07-b1f4-78cb9ed02914</guid><pubDate>Fri, 20 Jul 2018 00:00:00 +0000</pubDate><dc:creator>The Rust Core Team</dc:creator></item><item><title>Futures 0.3.0-alpha.1</title><link>https://rust-lang-nursery.github.io/futures-rs/blog/2018/07/19/futures-0.3.0-alpha.1.html</link><description><![CDATA[Welcome to the inaugural post of the new futures-rs blog!

After several months of work, we’re happy to announce an alpha release of the new edition of future-rs, version 0.3. The immediate goal of this work is to support async/await notation (with borrowing) in Rust itself, which has entailed significant changes to the futures crate.]]></description><guid isPermaLink="false">2a8864ba-0872-45d2-89f4-87e9f368374b</guid><pubDate>Thu, 19 Jul 2018 17:00:00 +0000</pubDate><dc:creator>Aaron Turon</dc:creator></item><item><title>Auditing popular Rust crates: how a one-line unsafe has nearly ruined everything</title><link>https://medium.com/@shnatsel/auditing-popular-rust-crates-how-a-one-line-unsafe-has-nearly-ruined-everything-fab2d837ebb1</link><description><![CDATA[Following the actix-web incident (which is fixed now, at least mostly) I decided to poke other popular Rust libraries and see what comes of it.

The good news is I’ve poked at 6 popular crates now, and I’ve got not a single actually exploitable vulnerability. I am impressed. When I poked popular C libraries a few years ago it quickly ended in tears. The bad news is I’ve found one instance that was not a security vulnerability by sheer luck, plus a whole slew of denial-of-service bugs. And I can’t fix all of them by myself. Read on to find out how I did it, and how you can help!]]></description><guid isPermaLink="false">80a9211d-dd65-4da8-b8d6-5d4223ee278d</guid><pubDate>Thu, 19 Jul 2018 01:38:11 +0000</pubDate><dc:creator>Sergey &quot;Shnatsel&quot; Davidoff</dc:creator></item><item><title>Exploring inband lifetimes by converting librustc_mir</title><link>https://mark-simulacrum.github.io/2018/07/19/inband-lifetimes.html</link><description><![CDATA[Inband lifetimes is a limited change, and does not feel like it greatly enhances code. However, it also doesn’t hurt much and feels slightly better in many cases.

However, there are numerous edge cases and slight pain points, many having to do with a lack of known standard ways to do things. As such, many of the edge cases are likely to fall away as we develop after stabilization and come up with standard methods to work with the new feature.

The primary work to migrate is essentially just deleting ~all lifetime headers (<'a, 'b, 'c>) across impls and functions. More intensive migration would involve replacing untied/single-use lifetimes with '_ in all cases. This is quite hard to do from a person perspective (though compiler can likely do so fairly easily).]]></description><guid isPermaLink="false">ea8d1190-c763-4f38-8181-1fc86193bfe4</guid><pubDate>Thu, 19 Jul 2018 00:00:00 +0000</pubDate><dc:creator>Mark Rousskov</dc:creator></item><item><title>Thoughts on Compile-Time Function Evaluation and Type Systems</title><link>https://www.ralfj.de/blog/2018/07/19/const.html</link><description><![CDATA[For some time now (since the 1.26 release, to be precise), Rust has a very powerful machinery for CTFE, or compile-time function evaluation. Since then, there have been various discussions about which operations should be allowed during CTFE, which checks the compiler should do, how this all relates to promotion and which kinds of guarantees we should be able to expect around CTFE. This post is my take on those topics, and it should not be surprising that I am going to take a very type-system centric view. Expect something like a structured brain dump, so there are some unanswered questions towards the end as well.]]></description><guid isPermaLink="false">7e963a31-6451-4f7d-9817-1e8c33c4973d</guid><pubDate>Thu, 19 Jul 2018 00:00:00 +0000</pubDate><dc:creator>Ralf Jung</dc:creator></item><item><title>#[test] in 2018</title><link>https://blog.jrenner.net/rust/testing/2018/07/19/test-in-2018.html</link><description><![CDATA[Lately, I’ve been working implementing the Custom Test Frameworks eRFC for Rust. While exploring the compiler codebase, I’ve learned about the internals of testing in Rust and figured it would be interesting to share.]]></description><guid isPermaLink="false">f4903839-c307-4209-b760-15176676663f</guid><pubDate>Thu, 19 Jul 2018 00:00:00 +0000</pubDate><dc:creator>John Renner</dc:creator></item><item><title>How to help test the 2018 edition</title><link>https://www.ncameron.org/blog/how-to-help-test-the-2018-edition/</link><description><![CDATA[An edition brings together the features that have landed into a clear package, with fully updated documentation and tooling. By the end of the year we are planning to release the 2018 edition, our first since the Rust 1.0 release. You can currently opt-in to a preview of the 2018 edition to try it out and help test it.

In fact, we really need help testing it out! Once you’ve turned it on and seen its wonderful new features, what then? Here we’ve got some specific things we’d like you to test.]]></description><guid isPermaLink="false">a81b111b-b3d6-4515-81bc-00d00bf62fb9</guid><pubDate>Wed, 18 Jul 2018 03:08:04 +0000</pubDate><dc:creator>Nick Cameron</dc:creator></item><item><title>Hello Content-o-Tron</title><link>http://blog.community.rs/content-team/2018/07/16/hello-content-o-tron.html</link><description><![CDATA[Content-o-Tron is a project to help amplify the lesser heard voices in the Rust community.

We are able to do this by providing editorial assistance and technical reviews of draft blog posts.

Once your blog post is ready to publish, we will ensure it is disseminated through various channels such as Read Rust, MozHacks, social networks and of course the Rust Community’s own blog on community.rs.]]></description><guid isPermaLink="false">fbdc0364-12e8-49f4-914f-b3c4f17d43f0</guid><pubDate>Mon, 16 Jul 2018 00:00:00 +0000</pubDate><dc:creator>Mark Sta Ana</dc:creator></item><item><title>How Rust made me rethink my view about compilers</title><link>https://defphil.com/post/2018/07/15/staying-rusty/</link><description><![CDATA[It's funny how universe aligns things, just few days ago I stumbled upon Rust koans. Already familiar way of learning and exercising, patented by Ruby programmers, where you correct tests and make them work. Also whole method of learning was similar to reading 'Little Schemer' fairly popular book among fellow Lispers. So I'll use this blog post to summarize few early impressions about Rust, and let me tell you straight away, I am loving it so far!]]></description><guid isPermaLink="false">d6b87789-dd86-49e2-91b6-692607e32f67</guid><pubDate>Sun, 15 Jul 2018 00:00:00 +0000</pubDate><dc:creator>Filip Miletic</dc:creator></item><item><title>Rust vs. Go</title><link>http://julio.meroh.net/2018/07/rust-vs-go.html</link><description><![CDATA[Welcome to the Rust Review’s bonus post, which I had promised from the very beginning. I’m here to cover the big elephant in the room: Rust vs. Go. Which one is better?

There is no good answer to this question because this comparison is unfounded. I think people tend to bundle the two languages together because they were released at about the same time and the release of Rust felt like a response to the release of Go. Moreover, both languages are supposed to focus on systems software. But they are vastly different, and even as they both target systems software, they target different kinds of such software.]]></description><guid isPermaLink="false">40055859-95cc-47a0-89e3-fd3c8a000fba</guid><pubDate>Fri, 13 Jul 2018 10:45:00 +0200</pubDate><dc:creator>Julio Merino</dc:creator></item><item><title>The Tale of a Bug in Arc: Synchronization and Data Races</title><link>https://www.ralfj.de/blog/2018/07/13/arc-synchronization.html</link><description><![CDATA[While I was busy doing Rust-unrelated research, RustBelt continues to move and recently found another bug (after a missing impl !Sync that we found previously): It turns out that Arc::get_mut did not perform sufficient synchronization, leading to a data race.]]></description><guid isPermaLink="false">b2fbac94-27b1-4c37-8c21-ead67edecf43</guid><pubDate>Fri, 13 Jul 2018 00:00:00 +0000</pubDate><dc:creator>Ralf Jung</dc:creator></item><item><title>Enforcing style in CI for Rust Projects</title><link>https://medium.com/@ag_dubs/enforcing-style-in-ci-for-rust-projects-18f6b09ec69d</link><description><![CDATA[This article will attempt to help you avoid the debate entirely, at least in your Rust projects, by explaining how you can use the rustfmt tool to enforce style guidelines using CI. We’ll start with a brief introduction to rustfmt, so feel free to skip the next section if you are already familiar.]]></description><guid isPermaLink="false">59c63ab5-9b88-498e-a6ce-989f77bcdffe</guid><pubDate>Tue, 10 Jul 2018 22:03:24 +0000</pubDate><dc:creator>Ashley Williams</dc:creator></item><item><title>Why I love Rust</title><link>https://alexkitchens.net/2018/07/06/why-i-love-rust.html</link><description><![CDATA[I spent much of my free time over the past year learning Rust, and while it’s been a difficult language to fully grasp (it’s still a work in progress), I find it incredibly rewarding to write in. I also have had many conversations with people who don’t know much about Rust and are curious about the problems it solves.

This is my take on why Rust is important, and why I have fallen in love with the language.]]></description><guid isPermaLink="false">d52613f9-60c7-4448-89ed-72cd3da79346</guid><pubDate>Fri,  6 Jul 2018 08:46:39 +0000</pubDate><dc:creator>Alex Kitchens</dc:creator></item><item><title>Rust: Raw string literals</title><link>https://medium.com/@rahulthakoor/rust-raw-string-literals-9579c4feb231</link><description><![CDATA[While working with Rust, you will often come across r#"something like this"#, especially when working with JSON and TOML files. It defines a raw string literal. When would you use a raw string literal and what makes a valid raw string literal?]]></description><guid isPermaLink="false">ca7cc808-b6f7-4650-a219-b2c92be95460</guid><pubDate>Thu,  5 Jul 2018 13:26:49 +0000</pubDate><dc:creator>Rahul Thakoor</dc:creator></item><item><title>The State of Rust on Haiku</title><link>https://www.haiku-os.org/blog/nielx/2018-07-05_the_state_of_rust_on_haiku/</link><description><![CDATA[With the recent addition of Rust 1.27.0 in the HaikuPorts repository, I thought it would be good to do a short, public write-up of the current state of Rust on Haiku, and some insight into the future.]]></description><guid isPermaLink="false">415e9361-8fad-4317-ae02-7abeb1faad3d</guid><pubDate>Thu,  5 Jul 2018 07:31:51 +0200</pubDate><dc:creator>nielx</dc:creator></item><item><title>Surface Rust: The Missing IDE</title><link>https://medium.com/@wolfshirts/surface-rust-6470d0075721</link><description><![CDATA[This week I decided to do a little hacking on Rust. I thought I’d write down my first impressions of the language.]]></description><guid isPermaLink="false">54242603-6ea7-4c99-8826-bbda3f8f63db</guid><pubDate>Wed,  4 Jul 2018 21:45:48 +0000</pubDate><dc:creator>@wolfshirts</dc:creator></item><item><title>Why Rust?</title><link>https://medium.com/paritytech/why-rust-846fd3320d3f</link><description><![CDATA[Programming is hard. Not because our hardware is complex, but simply because we’re all humans. Our attention span is limited, our memory is volatile — in other words, we tend to make mistakes.]]></description><guid isPermaLink="false">1b9d4f29-d237-4f3d-bc55-23b9ab2c5d77</guid><pubDate>Wed,  4 Jul 2018 07:43:11 +0000</pubDate><dc:creator>Dmitriy Kashitsyn</dc:creator></item><item><title>Idioms of Dynamic Languages</title><link>http://willcrichton.net/notes/idioms-of-dynamic-languages/</link><description><![CDATA[Programmers think dynamic languages like Python are easier to use than static ones, but why? I look at uniquely dynamic programming idioms and their static alternatives, identifying a few broad trends that impact language usability.]]></description><guid isPermaLink="false">f12f8561-c983-40b4-a7b4-9da8b350b33d</guid><pubDate>Sun,  1 Jul 2018 00:00:00 +0000</pubDate><dc:creator>Will Crichton</dc:creator></item><item><title>llvm-tools: a new rustup component for binary inspection and profiling</title><link>https://internals.rust-lang.org/t/llvm-tools-a-new-rustup-component-for-binary-inspection-objdump-nm-size-and-profiling-profdata/7830</link><description><![CDATA[Recent nightly releases provide an opt-in llvm-tools rustup component which you can install using the command: rustup component add llvm-tools. This component contains the following LLVM tools: llvm-nm, llvm-objcopy, llvm-objdump, llvm-profdata, and llvm-size. Most of these tools are LLVM alternatives to GNU binutils. The main advantage of these LLVM tools is that they support all the architectures that the Rust compiler supports.]]></description><guid isPermaLink="false">3b171674-7223-48e4-95da-5f268ec6fa1f</guid><pubDate>Fri, 29 Jun 2018 11:22:00 +0000</pubDate><dc:creator>Jorge Aparicio</dc:creator></item><item><title>Programming Servo: The script event-loop</title><link>https://medium.com/@polyglot_factotum/programming-servo-the-script-event-loop-be687b985b3e</link><description><![CDATA[One thing I have come to appreciate over time in the design of Servo, is the concurrency story. Basically, it’s pretty much all done using channels(and their multi-process counterpart).

What is so great about channels vs shared mutable state? One thing is, it makes it easier to reason about how various threads will synchronize their behavior as they go on about their business.

The way it’s done in Servo is by combining event-loops with multi-threading/processing. What does that mean?]]></description><guid isPermaLink="false">fa4c6fb5-3c9e-4831-86b1-3585c08398de</guid><pubDate>Thu, 28 Jun 2018 05:17:48 +0000</pubDate><dc:creator>Gregory Terzian</dc:creator></item><item><title>Signal Hook: Unix signal hanadling in Rust</title><link>https://vorner.github.io/2018/06/28/signal-hook.html</link><description><![CDATA[As promised in the previous article (thanks for all the valuable feedback ‒ I didn’t have the time to act on it yet, but I will), this talks about Unix signal handling.

Long story short, I wasn’t happy about the signal handling story in Rust and this is my attempt at improving it.]]></description><guid isPermaLink="false">a721af0b-e469-40ba-8ddc-f5f2a305483f</guid><pubDate>Thu, 28 Jun 2018 00:00:00 +0000</pubDate><dc:creator>Michal &apos;vorner&apos; Vaner</dc:creator></item><item><title>A Self-ish Bug</title><link>https://llogiq.github.io/2018/06/28/self-bug.html</link><description><![CDATA[I recently found a bug in mutagen: The “exchange arguments” mutation was actually ineffective. I was in the process of refactoring the code to pull coverage reporting into the mutagen calls (to reduce the amount of code generated), so the report_coverage call was to go away anyway. Except this bug masked another, more insiduous one: When I refactored, I found that one of the test would no longer compile methods with self arguments, running into Error E0424 (self keyword used in static method). Consider me confused.]]></description><guid isPermaLink="false">696ba27d-cdab-400f-9e86-a138422c2154</guid><pubDate>Thu, 28 Jun 2018 00:00:00 +0000</pubDate><dc:creator>Llogiq</dc:creator></item><item><title>New Photon Release of Eclipse IDE Ships With Full Rust Support | </title><link>https://www.eclipse.org/org/press-release/20180627_new-photon-release-of-eclipse-ide-ships-with-full-rust-support.php</link><description><![CDATA[The release delivers native Eclipse IDE experiences for Rust and C# through Language Server based plugins. The Language Server Protocol (LSP) ecosystem delivers editing support for popular and emerging programming languages. Combined with the move to a quarterly rolling release cadence, the LSP focus demonstrates a commitment to keeping pace with evolving developer and commercial needs.]]></description><guid isPermaLink="false">19aba600-95ff-4ba2-920f-0db67b3755e4</guid><pubDate>Wed, 27 Jun 2018 00:00:00 +0000</pubDate><dc:creator>The Eclipse Foundation</dc:creator></item><item><title>Why choose Rust?</title><link>https://blog.passfort.com/why-choose-rust/</link><description><![CDATA[Many of the candidates we interview for a position at PassFort are intrigued by the fact that we use Rust, a language which is only three years old (since its 1.0 release).

Despite its relatively young age, Rust has been voted the “most loved” language in the StackOverflow developer survey every one of those three years - an impressive feat!

However, it’s not enough for a language to be well liked: the programming ecosystem changes rapidly, and many of these developers are rightly afraid to jump blindly onto the latest bandwagon. We chose Rust not because it is popular, but because we believe it is the best tool for the job we have to do, and I hope to explain that reasoning now.]]></description><guid isPermaLink="false">e9ac81fa-8018-4bb1-91a2-cfd0b705f780</guid><pubDate>Tue, 26 Jun 2018 16:00:00 +0000</pubDate><dc:creator>PassFort</dc:creator></item><item><title>A Rusty Go at Channels</title><link>https://gsquire.github.io/static/post/a-rusty-go-at-channels/</link><description><![CDATA[Channels Channels are a useful concurrency primitive that enable separate processes to safely communicate without the need for explicit synchronization. The term processes is used here to loosely describe independent threads of execution within a program. This can be an OS level thread or a runtime level thread. Channels can be seen as a pipe to connect these processes and allow them to share memory with one another. For example a program could spawn any number of processes along with a channel to transmit results that it gathers.]]></description><guid isPermaLink="false">0a781f91-aca4-47ac-81d4-f9f606f33d0f</guid><pubDate>Sun, 24 Jun 2018 10:44:31 -0700</pubDate><dc:creator>Garrett Squire</dc:creator></item><item><title>Compiler fuzzing, part 1</title><link>http://www.vegardno.net/2018/06/compiler-fuzzing.html</link><description><![CDATA[Much has been written about fuzzing compilers already, but there is not a lot that I could find about fuzzing compilers using more modern fuzzing techniques where coverage information is fed back into the fuzzer to find more bugs.

If you know me at all, you know I'll throw anything I can get my hands on at AFL. So I tried gcc. (And clang, and rustc -- but more about Rust in a later post.)]]></description><guid isPermaLink="false">34e39003-edb1-4232-ad2a-aae9d4868d81</guid><pubDate>Sun, 24 Jun 2018 15:02:00 +0200</pubDate><dc:creator>Vegard</dc:creator></item><item><title>Making Arc more atomic</title><link>https://vorner.github.io/2018/06/24/arc-more-atomic.html</link><description><![CDATA[This is a story of a tiny feature I was missing in Rust… so I created it (partly because I like the feature, because it felt wrong for Rust not to have it, but mostly for the practice and fun of beating a hard and interesting problem). You can read the story if you are interested about the behind the scenes, about the feature itself, how to use it or just for fun ☺.]]></description><guid isPermaLink="false">03d374fc-9500-42d8-8515-7f98447fd62a</guid><pubDate>Sun, 24 Jun 2018 00:00:00 +0000</pubDate><dc:creator>Michal &apos;vorner&apos; Vaner</dc:creator></item><item><title>Rust 2018: an early preview</title><link>https://internals.rust-lang.org/t/rust-2018-an-early-preview/7776</link><description><![CDATA[The Rust teams having been working hard to implement features of the 2018 edition. Today we have reached an important milestone: we are announcing that we have an alpha-quality preview of the 2018 edition ready for testing and feedback.

The preview presents a great opportunity for those of you using the stable channel to switch to nightly and try out how it feels to code in the new edition, both to help us fix bugs and to provide feedback – positive and negative – on features. Unfortunately, today’s nightly doesn’t work due to infrastructure issues, so you’ll need to run rustup install nightly-2018-06-20 in order to get a nightly that’ll work. If you’re already on the nightly channel, it’s likely that there’s no need to update the compiler.]]></description><guid isPermaLink="false">698090f0-fa77-43b5-aaed-dcd2b71d3c39</guid><pubDate>Sat, 23 Jun 2018 08:19:19 +1000</pubDate><dc:creator>Rust Team Members</dc:creator></item><item><title>Rust review: The ecosystem</title><link>http://julio.meroh.net/2018/06/rust-review-ecosystem.html</link><description><![CDATA[In this part of the review, I would like to focus on Rust’s ecosystem: in other words, how Rust plays with other parts of a functioning system and how Rust’s standard library vs. external libraries interact with each other. There are a lot of pieces to cover in these areas and they have left me with mixed feelings. Let’s look at some.]]></description><guid isPermaLink="false">295dac4f-f095-4d04-b6ee-a6a2870cc7fb</guid><pubDate>Fri, 22 Jun 2018 09:00:00 -0400</pubDate><dc:creator>Julio Merino</dc:creator></item><item><title>Announcing Rust 1.27</title><link>https://blog.rust-lang.org/2018/06/21/Rust-1.27.html</link><description><![CDATA[This release has two big language features that people have been waiting for: SIMD, and dyn Trait. Additionally there is support for searching the Rust books, and a new book about rustc.]]></description><guid isPermaLink="false">41f94ae9-ac3a-42fe-bc78-fbc6dab42d85</guid><pubDate>Thu, 21 Jun 2018 00:00:00 +0000</pubDate><dc:creator>The Rust Core Team</dc:creator></item><item><title>Proposal for a staged RFC process</title><link>http://smallcultfollowing.com/babysteps/blog/2018/06/20/proposal-for-a-staged-rfc-process/</link><description><![CDATA[I consider Rust’s RFC process one of our great accomplishments, but it’s no secret that it has a few flaws. At its best, the RFC offers an opportunity for collaborative design that is really exciting to be a part of. At its worst, it can devolve into bickering without any real motion towards consensus. If you’ve not done so already, I strongly recommend reading aturon’s excellent blog posts on this topic.

The RFC process has also evolved somewhat organically over time. What began as “just open a pull request on GitHub” has moved into a process with a number of formal and informal stages (described below). I think it’s a good time for us to take a step back and see if we can refine those stages into something that works better for everyone.]]></description><guid isPermaLink="false">220b4649-e853-4f07-9773-e4ae3d286a4f</guid><pubDate>Wed, 20 Jun 2018 00:00:00 -0400</pubDate><dc:creator>Niko Matsakis</dc:creator></item><item><title>Rust review: The book</title><link>http://julio.meroh.net/2018/06/rust-review-book.html</link><description><![CDATA[“The Rust Programming Language” is one of the free books that the community has put together to teach the language. The book does a good job in general, but there are some things that could be better. Let’s cover these, but first, some background.]]></description><guid isPermaLink="false">0122445e-8a19-4a52-bcd6-4ee7e55feb7c</guid><pubDate>Tue, 19 Jun 2018 09:00:00 -0400</pubDate><dc:creator>Julio Merino</dc:creator></item><item><title>Rust + Diesel + GitLab + CI</title><link>https://noyez.gitlab.io/post/2018-06-15-rust-plus-diesel-plus-gitlab/</link><description><![CDATA[It is very straightforward to get Rust projects to build within a CI environment. This post is going to take that build process one small step further, we’re going to build a Rust project that uses the Diesel ORM. This adds a step of complexity since to compile a Diesel project you need to have a postgresql database accessible if you’re using the infer_schema!() macro.]]></description><guid isPermaLink="false">67f2f6f8-75f9-458c-969f-4bcbe9c0223f</guid><pubDate>Mon, 18 Jun 2018 00:00:00 +0000</pubDate><dc:creator>noyez</dc:creator></item></channel></rss>