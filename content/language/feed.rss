<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/"><channel><title>Read Rust - Language</title><link>https://readrust.net/</link><description>Language posts on Read Rust</description><item><title>Neat new feature in Rust: iter::from_fn</title><link>https://weblog.latte.ca/blake/tech/rust/makingiterators.html</link><description><![CDATA[Recently Rust has introduced a couple of new features, and the one that caught my eye in particular was std::iter::from_fn, which let’s you make an iterator from a function, which is most of what that macro was trying to do, so I thought I would try to convert the various places I was using the macro to use the new function instead…]]></description><guid isPermaLink="false">c16ea768-9518-4a40-b51d-9c5e978994a2</guid><pubDate>Sat, 13 Apr 2019 20:49:00 +0000</pubDate><dc:creator>Blake Winton</dc:creator></item><item><title>Announcing Rust 1.34.0</title><link>https://blog.rust-lang.org/2019/04/11/Rust-1.34.0.html</link><description><![CDATA[The largest feature in this release is the introduction of alternative cargo registries. The release also includes support for ? in documentation tests, some improvements for #[attribute(..)]s, as well as the stabilization of TryFrom. Read on for a few highlights, or see the detailed release notes for additional information.]]></description><guid isPermaLink="false">c652e06d-95e4-4da0-8ce8-a94c007587d7</guid><pubDate>Thu, 11 Apr 2019 00:00:00 +0000</pubDate><dc:creator>The Rust Release Team</dc:creator></item><item><title>Mysteriously Low Hanging Fruit: A Big Improvement To LLD For Rust Debug Builds</title><link>https://robert.ocallahan.org/2019/04/mysteriously-low-hanging-fruit-big.html</link><description><![CDATA[LLD is generally much faster than the GNU ld.bfd and ld.gold linkers, so you would think it has been pretty well optimised. You might then be surprised to discover that a 36-line patch dramatically speeds up linking of Rust debug builds, while also shrinking the generated binaries dramatically, both in simple examples and large real-world projects.]]></description><guid isPermaLink="false">afbe8437-4dca-40c1-b6ab-034fbd57c9cd</guid><pubDate>Thu, 11 Apr 2019 00:00:00 +0000</pubDate><dc:creator>Robert O&apos;Callahan</dc:creator></item><item><title>A Love Letter to Rust Macros</title><link>https://happens.lol/posts/a-love-letter-to-rust-macros/</link><description><![CDATA[It’s no secret to people who know me that I’m a huge fan of the Rust programming language. I could talk for hours about the brilliance of the ownership system, my irrational longing for natively compiled languages without garbage collection, or the welcoming community that finally moved me to take a more active part in open source projects. But for a start, I just want to highlight one of my favourite features: Macros.]]></description><guid isPermaLink="false">749e48bb-50e5-4e7e-8e17-9dd73e1776f2</guid><pubDate>Tue,  9 Apr 2019 00:00:00 +0000</pubDate><dc:creator>Hilmar Wiegand</dc:creator></item><item><title>Javascript evaluator part 2: Parser and Basic evaluator</title><link>https://medium.com/@retep007/javascript-evaluator-part-2-parser-and-basic-evaluator-d306ff1aec83</link><description><![CDATA[This is the second part of writing Javascript evaluator series. I’m going to talk about my project developing Javascript evaluator in Rust. This post is going to briefly introduce Parsing that’s build on top of the results from Lexer in the first post. Then I will cover elements of evaluation of abstract syntax tree (AST).]]></description><guid isPermaLink="false">63c81ff0-ee39-437f-a299-70173f639777</guid><pubDate>Mon,  8 Apr 2019 06:39:05 +0000</pubDate><dc:creator>Peter Hrvola</dc:creator></item><item><title>Tricks In Arc Swap</title><link>https://vorner.github.io/2019/04/06/tricks-in-arc-swap.html</link><description><![CDATA[This is a continuation of the Making Arc more atomic post. In short, ArcSwap is a place where you can atomically store and load an Arc, similar to RwLock<Arc<T>> but without the locking. It’s a good tool if you have some data that is very frequently read but infrequently modified, like configuration or an in-memory database that answers millions of queries per second, but is replaced only every 5 minutes. The canonical example for this is routing tables ‒ you want to read them with every passing packet, but you change them only when routing changes.]]></description><guid isPermaLink="false">30a32647-13d1-4d87-89c0-804ef7d456e6</guid><pubDate>Sat,  6 Apr 2019 00:00:00 +0000</pubDate><dc:creator>Michal &apos;vorner&apos; Vaner</dc:creator></item><item><title>Our journey from nightly to stable Rust</title><link>https://blog.datalust.co/our-journey-from-rust-nightly-to-stable/</link><description><![CDATA[When we shipped Seq 5.0 back in November, our new storage engine was compiled against Rust's unstable nightly channel. As of Seq 5.1, we can instead use the supported stable channel. That feels like a bit of a milestone so I'd like to share a few details about our journey from nightly to stable, and celebrate the progress the community has made on the language, libraries, and tooling over the last twelve months that made that journey painless for us.]]></description><guid isPermaLink="false">7e90b841-ce0c-47f1-b6ab-420aa7d7bb35</guid><pubDate>Thu,  4 Apr 2019 23:44:23 +0000</pubDate><dc:creator>Ashley Mannix</dc:creator></item><item><title>Crossing the Rust FFI frontier with Protocol Buffers</title><link>https://hacks.mozilla.org/2019/04/crossing-the-rust-ffi-frontier-with-protocol-buffers/</link><description><![CDATA[The Firefox Application Services engineering team made the decision to use Rust to build cross-platform components for Firefox Sync, powering Firefox Accounts across many devices. They are implementing core business logic using Rust and wrapping it in a thin platform-native layer, such as Kotlin for Android and Swift for iOS.]]></description><guid isPermaLink="false">3046fc78-93d2-4298-a8ae-134f2fbd29b9</guid><pubDate>Tue,  2 Apr 2019 14:42:47 +0000</pubDate><dc:creator>Edouard Oger</dc:creator></item><item><title>Javascript evaluator part 1: Lexing</title><link>https://medium.com/@retep007/javascript-lexing-for-high-performance-f9a800ec930d</link><description><![CDATA[In this post I will describe my latest findings from writing my own Javascript lexer in Rust-lang. I will start by briefly describing what lexing is. Then, I will continue explaining how to implement state machines in Rust-lang. Next, I talk about how to use state machines for Javascript lexing. Last but not least, I cover further performance optimizations of my lexer.]]></description><guid isPermaLink="false">0ee4dffd-3f5f-4c26-9a66-5a2c94db3ace</guid><pubDate>Tue,  2 Apr 2019 06:08:32 +0000</pubDate><dc:creator>Peter Hrvola</dc:creator></item><item><title>How to Mock Time in Rust Tests and Cargo Gotchas We Met</title><link>https://blog.iany.me/2019/03/how-to-mock-time-in-rust-tests-and-cargo-gotchas-we-met</link><description><![CDATA[I'm working in a team developing a big Rust project recently. The project has some features depending on time. We, the developers, want to be able to mock the time in test. In this post, I'll talk about the problems we have met, mostly related to Cargo.]]></description><guid isPermaLink="false">54d19ed4-0cb7-4ab9-939e-5afcdf8b0ca5</guid><pubDate>Sun, 31 Mar 2019 00:00:00 +0000</pubDate><dc:creator>Ian Yang</dc:creator></item><item><title>Mocking in Rust with conditional compilation</title><link>https://klausi.github.io/rustnish/2019/03/31/mocking-in-rust-with-conditional-compilation.html</link><description><![CDATA[When writing automated unit tests for your application you will probably need to use mocks at some point. Classical object-oriented programming languages such as PHP solve this with reflection where mock object types are created during test runtime. The code under test expects a certain interface or class and the test code passes mock objects that implement the interface or are a subclass.]]></description><guid isPermaLink="false">5b355e5c-bc78-4134-91a2-c383b350d5f8</guid><pubDate>Sun, 31 Mar 2019 00:00:00 +0000</pubDate><dc:creator>klausi</dc:creator></item><item><title>A Story of Rust</title><link>https://jobs.zalando.com/tech/blog/story-rust/</link><description><![CDATA[Introducing Rust in an Enterprise Environment...]]></description><guid isPermaLink="false">f0be7972-25a7-4ff9-af00-904780465c8f</guid><pubDate>Thu, 28 Mar 2019 00:00:00 +0000</pubDate><dc:creator>Christian Douven</dc:creator></item><item><title>Miri available as rustup component</title><link>https://www.ralfj.de/blog/2019/03/26/miri-as-rustup-component.html</link><description><![CDATA[Running your unsafe code test suite in Miri has just gotten even easier: Miri is now available as a rustup component!]]></description><guid isPermaLink="false">ff71674c-714c-4d6d-adde-bca7a03d697e</guid><pubDate>Tue, 26 Mar 2019 00:00:00 +0000</pubDate><dc:creator>Ralf Jung</dc:creator></item><item><title>Understanding Futures In Rust - Part 1</title><link>https://www.viget.com/articles/understanding-futures-in-rust-part-1/</link><description><![CDATA[Futures make async programming in Rust easy and readable. Learn how to use futures by building them from scratch.]]></description><guid isPermaLink="false">03a41715-2772-48f5-8a75-bd0d4d1d04c7</guid><pubDate>Tue, 26 Mar 2019 00:00:00 +0000</pubDate><dc:creator>Joe Jackson</dc:creator></item><item><title>Kickstarting a database working group</title><link>https://internals.rust-lang.org/t/kickstarting-a-database-wg/9696</link><description><![CDATA[I posted the idea of a database WG on twitter recently and it was met with a lot of excitement. Also there was a post on reddit recently that proposed the same idea, taken from examples of where using Rust with databases is currently a painful experience. I would as part of this also want to work out a base charter to start the WG as well as setting up when and how to have regular meetings to discuss roadmaps and current projects that are being worked on.]]></description><guid isPermaLink="false">29538906-a949-430f-a129-f9c8dca4eb54</guid><pubDate>Mon, 25 Mar 2019 09:53:26 +0000</pubDate><dc:creator>Katharina Fey</dc:creator></item><item><title>The Phantom Builder</title><link>https://wiredforge.com/blog/phantom-builder/index.html</link><description><![CDATA[Recently on twitter, someone asked fora a practical explainer for PhantomData and while I don't have that I did want to share one place I have found PhantomData to be useful. This blog post is an overview of how I ended up using PhantomData in my builder patterns that require a generic type argument.]]></description><guid isPermaLink="false">c24a6d4f-b367-4b18-ad85-52fe59b7e6b3</guid><pubDate>Sun, 24 Mar 2019 00:00:00 +0000</pubDate><dc:creator>Robert Masen</dc:creator></item><item><title>My First 3 Weeks of Professional Rust</title><link>https://www.wezm.net/technical/2019/03/first-3-weeks-of-professional-rust/</link><description><![CDATA[For the last 15 years as a professional programmer I have worked mostly with dynamic languages. First Perl, then Python, and for the last 10 years or so, Ruby. I’ve also been writing Rust on the side for personal projects for nearly four years. Recently I started a new job and for the first time I’m writing Rust professionally. Rust represents quite a shift in language features, development process and tooling. I thought it would be interesting to reflect on that experience so far.]]></description><guid isPermaLink="false">98e50b2b-889a-49d1-9973-f1d39c9cc389</guid><pubDate>Sat, 23 Mar 2019 22:45:00 +0000</pubDate><dc:creator>Wesley Moore</dc:creator></item><item><title>Handmade Rust Part 3: Containers</title><link>http://stevenlr.com/posts/handmade-rust-3-containers/</link><description><![CDATA[The most commonly used kinds of containers are arrays and maps. Pretty much any other container type can be built using those two, so that’s what we’ll build today! Of course, just like for Unq, we won’t be making simple replacements, instead we’ll be making the most minimal containers necessary for now and add features later as needed, but we’ll be make them allocator aware.]]></description><guid isPermaLink="false">6ed35d04-359f-4971-9cf6-19d824cdcf72</guid><pubDate>Sat, 23 Mar 2019 17:12:54 +0100</pubDate><dc:creator>Steven Le Rouzic</dc:creator></item><item><title>Are we Database Yet?</title><link>https://www.reddit.com/r/rust/comments/b463rg/are_we_database_yet/</link><description><![CDATA[I'm giving a talk next month at our Rust Meetup about using Rust in production. I've been reflecting on my last few months using Rust after learning the language about a year ago. One of my most frustrating experiences tends to always be around the futures ecosystem, as that's where I oft-fruitless labour for hours before giving up on what I'm doing.

I do data engineering and software development work professionally, and these 2 areas are where I often find a lot of pain with using the language.

A few weeks ago I wanted to write something that takes csv files and writes them to a database. I used Apache Arrow's Rust library (which I've started contributing to this year) to do that. The idea was simple, Arrow has a CSV reader that can infer schema, so I map the schema's data types to a database's types, and then I sequentially write records in batches to the database.

I found the exercise quite painful, so I'd like to talk about databases and Rust.]]></description><guid isPermaLink="false">ea9c3fbe-c681-4b42-a0ef-3699a1612972</guid><pubDate>Sat, 23 Mar 2019 02:02:56 +1100</pubDate><dc:creator>nevi-me</dc:creator></item><item><title>Rust All Hands 2019: Array iterators, Rayon, and more</title><link>https://developers.redhat.com/blog/2019/03/22/rust-all-hands-2019-array-iterators-rayon-and-more/</link><description><![CDATA[A few weeks ago, I had the pleasure of attending the second annual Rust All Hands meeting, hosted by Mozilla at their Berlin office. The attendees were a mix of volunteers and corporate employees covering the full range of Rust development, including the compiler, language, libraries, docs, tools, operations, and community. Although I’m sure there will be an official summary of the meeting (like last year’s), in this article, I’ll cover a few things I was directly involved in. First, I’ll look at a feature many developers have wanted for a long time…]]></description><guid isPermaLink="false">6450a97d-c96a-47df-b999-a865defe34ae</guid><pubDate>Fri, 22 Mar 2019 07:05:51 +0000</pubDate><dc:creator>Josh Stone</dc:creator></item><item><title>Learning Rust With Entirely Too Many Linked Lists</title><link>https://rust-unofficial.github.io/too-many-lists/</link><description><![CDATA[I fairly frequently get asked how to implement a linked list in Rust. The answer honestly depends on what your requirements are, and it's obviously not super easy to answer the question on the spot. As such I've decided to write this book to comprehensively answer the question once and for all. In this series I will teach you basic and advanced Rust programming entirely by having you implement 6 linked lists.]]></description><guid isPermaLink="false">34dfeb70-4900-4ef3-b6d5-674d3caf376d</guid><pubDate>Fri, 22 Mar 2019 00:00:00 +0000</pubDate><dc:creator>Alexis Beingessner</dc:creator></item><item><title>Chaining Functions Without Returning Self</title><link>https://randompoison.github.io/posts/returning-self/</link><description><![CDATA[It’s a common pattern in the Rust ecosystem to have a function return self at the end in order to enable method chaining. This approach is often used in combination with the builder pattern, though it can also be applied to a wide variety of other situations. The example demonstrates the most straightforward of these cases (i.e. initializing and modifying an object in a single statement), but, as I’m going to demonstrate, this approach quickly breaks down when applied to a wider variety of use cases.]]></description><guid isPermaLink="false">88233a0c-3917-4ec2-b2c5-bcfd322a9662</guid><pubDate>Thu, 21 Mar 2019 00:00:00 +0000</pubDate><dc:creator>David LeGare</dc:creator></item><item><title>Why Hashbrown Does A Double-Lookup</title><link>https://gankro.github.io/blah/hashbrown-insert/</link><description><![CDATA[I recently finished a detailed review of hashbrown, which will likely become the new implementation for rust's std::collections::HashMap. One of the most surprising things I found was in the implementation of insert. It was doing something that was so offensive to people who care about collection performance that we had designed an entire API to help people avoid it: it did two lookups in the map. However, after some more discussion and review, I concluded that this implementation was reasonable. This post will try to cover why that is.]]></description><guid isPermaLink="false">38a15a60-b3e5-49c5-9036-3af3d6bc43ff</guid><pubDate>Wed, 20 Mar 2019 00:00:00 +0000</pubDate><dc:creator>Alexis Beingessner</dc:creator></item><item><title>Variance in Rust: An intuitive explanation</title><link>https://ehsanmkermani.com/2019/03/16/variance-in-rust-an-intuitive-explanation/</link><description><![CDATA[Recently I made a presentation about subtyping and variance in Rust for our local Vancouver Rust meetup, but I still think intuition was rather lost in the formalism, so here’s my shot at explaining it as intuitively as I can.]]></description><guid isPermaLink="false">ee2c7f86-323c-49fe-a707-afc505088445</guid><pubDate>Sun, 17 Mar 2019 03:24:05 +0000</pubDate><dc:creator>Ehsan M. Kermani</dc:creator></item><item><title>Procedural macro in Rust 101</title><link>https://dev.to/naufraghi/procedural-macro-in-rust-101-k3f</link><description><![CDATA[How to pick a function and make it a macro with added superpowers.]]></description><guid isPermaLink="false">d10fac5d-46ac-49b4-a8e0-517cb3cdfcba</guid><pubDate>Sun, 17 Mar 2019 00:00:00 +0000</pubDate><dc:creator>Matteo Bertini</dc:creator></item><item><title>In nightly Rust, &apos;await!&apos; may never return (dropping futures)</title><link>http://www.randomhacks.net/2019/03/09/in-nightly-rust-await-may-never-return/</link><description><![CDATA[I've been using the proposed await! and Future features in nightly Rust, and overall, I really like the design. But I did run into one surprise: await! may never return, and this has consequences I didn't fully understand. Let's take a look.]]></description><guid isPermaLink="false">eed8a936-e3c7-45b5-bc50-3e1b95ffb767</guid><pubDate>Sat,  9 Mar 2019 15:11:20 -0500</pubDate><dc:creator>Eric Kidd</dc:creator></item><item><title>Should Rust channels panic on send if nobody&apos;s listening?</title><link>http://www.randomhacks.net/2019/03/08/should-rust-channels-panic-on-send/</link><description><![CDATA[Lately, I've been working on several real-world systems using Rust's async and tokio. As you can see on the areweasyncyet.rs site, this requires using nightly Rust and the experimental tokio-async-await library. I hope to talk more about these experiences soon! But today, I want to talk about channel APIs in Rust. A question was raised by @matklad on GitHub, "I've migrated rust-analyzer to crossbeam-channel 0.3, and the thing I've noticed is that every .send is followed by .unwrap. Perhaps we should make this unwrapping behavior the default, and introduce a separate checked_send which returns a Result?".]]></description><guid isPermaLink="false">09e6b7ba-69f9-4256-9ce5-c75ea253c3ec</guid><pubDate>Fri,  8 Mar 2019 16:42:27 -0500</pubDate><dc:creator>Eric Kidd</dc:creator></item><item><title>How productive is Rust?</title><link>https://medium.com/@woutergeraedts/how-productive-is-rust-e2260db28f09</link><description><![CDATA[We often get the question how productive working with Rust is. “We know that it is awesome, but isn’t it hard to learn? Don’t you struggle with the borrow checker?”. Well, we put it to the test in Google’s Hash Code 2019 programming competition.]]></description><guid isPermaLink="false">23fcf66c-3fff-4894-836d-32a880171b46</guid><pubDate>Fri,  8 Mar 2019 12:59:39 +0000</pubDate><dc:creator>Wouter Geraedts</dc:creator></item><item><title>Enjoy Compile time function evaluation using &apos;const fn&apos; in Rust</title><link>https://blog.knoldus.com/no-more-run-time-enjoy-compile-time-function-evaluation-using-const-fn-in-rust/</link><description><![CDATA[A few days ago, I was exploring Rust’s Unstable Book and found pretty much same feature in Rust, which is const_fn. I started exploring this feature more after the recent Rust release 1.33.0, in which Rust team has announced major improvements in const fn. The idea of using const fn is to compute result at compile time so that time can be saved when code is run.]]></description><guid isPermaLink="false">48cd5e22-48f6-4711-a1d2-e9ce7338ef0d</guid><pubDate>Mon,  4 Mar 2019 15:26:43 +0000</pubDate><dc:creator>Ayush Mishra</dc:creator></item><item><title>Proposal: New channels for Rust’s standard library</title><link>https://stjepang.github.io/2019/03/02/new-channels.html</link><description><![CDATA[In this blog post, I’m proposing we also replace the guts of mpsc with crossbeam-channel for some more performance wins. However, unlike with mutexes and hash maps, this change will also enable oft-requested new features that make it tempting to deprecate mpsc altogether and introduce better channels designed from scratch.]]></description><guid isPermaLink="false">4a9fd96a-fd25-48dd-a97e-511e023b35f8</guid><pubDate>Sat,  2 Mar 2019 00:00:00 +0000</pubDate><dc:creator>Stjepan Glavina</dc:creator></item><item><title>Async-await status report</title><link>http://smallcultfollowing.com/babysteps/blog/2019/03/01/async-await-status-report/</link><description><![CDATA[I wanted to post a quick update on the status of the async-await effort. The short version is that we’re in the home stretch for some kind of stabilization, but there remain some significant questions to overcome.]]></description><guid isPermaLink="false">c838f89e-80f8-4146-b26e-622020ff2653</guid><pubDate>Fri,  1 Mar 2019 00:00:00 -0500</pubDate><dc:creator>Niko Matsakis</dc:creator></item><item><title>JavaFX UI in Rust</title><link>https://astonbitecode.github.io/blog/post/rust-javafx/</link><description><![CDATA[In this post, I would like to share the way how we can implement a Rust application that has a User Interface written in JavaFX.]]></description><guid isPermaLink="false">28f6c857-f8f6-4ff3-8a21-12c894a7dbb8</guid><pubDate>Thu, 28 Feb 2019 00:05:58 +0000</pubDate><dc:creator>Aston</dc:creator></item><item><title>Announcing Rust 1.33.0</title><link>https://blog.rust-lang.org/2019/02/28/Rust-1.33.0.html</link><description><![CDATA[The Rust team is happy to announce a new version of Rust, 1.33.0. The two largest features in this release are significant improvements to const fns, and the stabilization of a new concept: "pinning."]]></description><guid isPermaLink="false">e6376cd5-713f-4a8e-8792-2329772feee5</guid><pubDate>Thu, 28 Feb 2019 00:00:00 +0000</pubDate><dc:creator>The Rust Release Team</dc:creator></item><item><title>Rust build scripts vs. Meson</title><link>https://people.gnome.org/~federico/blog/rust-build-scripts.html</link><description><![CDATA[One of the pain points in trying to make the Meson build system work with Rust and Cargo is Cargo's use of build scripts, i.e. the build.rs that many Rust programs use for doing things before the main build. This post is about my exploration of what build.rs does.]]></description><guid isPermaLink="false">f93cc38e-4380-4174-8f53-b5c6674772da</guid><pubDate>Wed, 27 Feb 2019 12:14:12 -0600</pubDate><dc:creator>Federico Mena Quintero</dc:creator></item><item><title>Rust Case Study: Community makes Rust an easy choice for npm [pdf]</title><link>https://www.rust-lang.org/static/pdfs/Rust-npm-Whitepaper.pdf</link><description><![CDATA[Learn how npm uses Rust]]></description><guid isPermaLink="false">b149b575-39a9-4136-8749-29e04c5cf0b3</guid><pubDate>Wed, 27 Feb 2019 03:26:00 +0000</pubDate><dc:creator>The Rust Core Team</dc:creator></item><item><title>Bid adieu to tarpaulin, HTML reports are here for Rust</title><link>https://blog.knoldus.com/bid-adieu-to-tarpaulin-html-reports-are-here-for-rust/</link><description><![CDATA[Kcov is a code coverage tool for Binaries, Shell scripts as well as Python scripts. It generates an HTML file for most of the languages. But we will focus mainly on Rust language.]]></description><guid isPermaLink="false">a6483426-5600-4cf0-a514-c532946abda3</guid><pubDate>Tue, 26 Feb 2019 06:41:19 +0000</pubDate><dc:creator>Mudit Chhabra</dc:creator></item><item><title>Rust lang team working groups</title><link>http://smallcultfollowing.com/babysteps/blog/2019/02/22/rust-lang-team-working-groups/</link><description><![CDATA[Now that the Rust 2018 edition has shipped, the language design team has been thinking a lot about what to do in 2019 and over the next few years. I think we’ve got a lot of exciting stuff on the horizon, and I wanted to write about it.]]></description><guid isPermaLink="false">0d3ca45d-85aa-40ab-95f0-40ec5abaa75f</guid><pubDate>Fri, 22 Feb 2019 00:00:00 -0500</pubDate><dc:creator>Niko Matsakis</dc:creator></item><item><title>Changes in the core team</title><link>https://blog.rust-lang.org/2019/02/22/Core-team-changes.html</link><description><![CDATA[Just a quick update: You may have noticed that, in the last month or so, a number of Rust core team members have changed their jobs and/or their roles in the project.]]></description><guid isPermaLink="false">2471466d-74a1-4d19-82d7-6909e10178cd</guid><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><dc:creator>The Rust Core Team</dc:creator></item><item><title>How to document Rust&apos;s macro invocation</title><link>https://amanjeev.com/blog/rust-document-macro-invocations/</link><description><![CDATA[You can easily document your Rust items like functions by putting three slashes ///. However, if you want to document each separate invocation of your amazing! macro, it is not that straightfoward.]]></description><guid isPermaLink="false">6cab1c1c-68f3-4f20-b239-85009d4d563a</guid><pubDate>Thu, 21 Feb 2019 00:00:00 +0000</pubDate><dc:creator>Amanjeev Sethi</dc:creator></item><item><title>DOS: the final frontier...</title><link>https://www.reddit.com/r/rust/comments/ask2v5/dos_the_final_frontier/</link><description><![CDATA[In our crusade to oxidize platform after platform, I've been working to bring Rust to yet another target: MS-DOS. I don't know if this has been done before, but I couldn't find any information about it on the web, so I had to rely on information about using GCC to compile MS-DOS programs (not all of which carried over), and it took quite a bit of fiddling with the target specification to get things just right. In the end, I've managed to produce COM executables that can call DOS interrupts and interface with hardware such as the PC speaker, and presumably the rest of the hardware, given the right code.]]></description><guid isPermaLink="false">7c13bc47-79a3-408a-bfc0-d67639f4f359</guid><pubDate>Wed, 20 Feb 2019 15:47:21 +1100</pubDate><dc:creator>u/serentty</dc:creator></item><item><title>rustdoc in 2019</title><link>https://quietmisdreavus.net/code/2019/02/19/rustdoc-in-2019/</link><description><![CDATA[A recap of the 2019 Rust All-Hands from a rustdoc perspective; and the 2019 roadmap for the Rustdoc Team.]]></description><guid isPermaLink="false">5afc518c-63b7-4b76-96f2-659de41359d9</guid><pubDate>Tue, 19 Feb 2019 12:00:00 -0600</pubDate><dc:creator>QuietMisdreavus</dc:creator></item><item><title>Generators II: The Question Mark Problem</title><link>https://boats.gitlab.io/blog/post/generators-ii/</link><description><![CDATA[This is my second post on the design of generators. In the first post, I outlined what an MVP of the feature would look like. In this post, I want to take a look at the first design issue for the feature: how it integrates with the ? operator.]]></description><guid isPermaLink="false">2c43b8ca-4c87-4138-adfc-2e32660061a2</guid><pubDate>Mon, 18 Feb 2019 00:00:00 +0000</pubDate><dc:creator>withoutboats</dc:creator></item><item><title>One Hundred Rust PRs later</title><link>https://phansch.net/2019/02/18/onehundred-rust-prs/</link><description><![CDATA[It’s hard for me to believe but it’s already been over a year since I seriously committed to learning Rust and I have now reached my initial goal of 100 open source contributions to the Rust ecosystem. You can see the full list here. I want to use this blog post to review the work I’ve done, talk about the challenges I’ve come across and how I’ve tried to deal with them. I’m afraid I haven’t blogged in a long time and this is a bit longer than usual.]]></description><guid isPermaLink="false">9cb7faf6-a9cb-4bf5-9549-96ee7e80dd12</guid><pubDate>Mon, 18 Feb 2019 00:00:00 +0000</pubDate><dc:creator>Philipp Hansch</dc:creator></item><item><title>Visualizing your Rust code using graphviz</title><link>https://jonathansteyfkens.com/posts/visualizing-rust.html</link><description><![CDATA[In a previous post I mentioned that the Rust compiler allows you to output interesting intermediate languages/formats in a number of different ways. hir, mir and even flowgraphs! In this post I will be giving a brief overview of the flowgraph format and also instructions on how to generate images from your code.]]></description><guid isPermaLink="false">295b15d9-04eb-420c-bc3e-8b3c12a81882</guid><pubDate>Sun, 17 Feb 2019 00:00:00 +0000</pubDate><dc:creator>Jonathan Steyfkens</dc:creator></item><item><title>Cross compiling Rust from Linux to macOS</title><link>https://wapl.es/rust/2019/02/17/rust-cross-compile-linux-to-macos.html</link><description><![CDATA[I’ve recently been working on a Rust project at work which requires compiling for Linux (GNU), Linux (musl - for Alpine Linux) and macOS. I use Linux Mint nearly all the time, so building for macOS targets has required asking very nicely to borrow a spare Macbook Air. This is naturally a bit crap, so I set out to find a Linux-only solution to cross compile for macOS using osxcross. A weekend of pain later, and I have the following post. Hopefully it spares you a weekend of your own pain.]]></description><guid isPermaLink="false">e412275c-f2ce-4748-bf3d-c53375ff5693</guid><pubDate>Sun, 17 Feb 2019 00:00:00 +0000</pubDate><dc:creator>James Waples</dc:creator></item><item><title>Getting started with Rust FFI</title><link>https://rushsteve1.us/wp/getting-started-with-rust-ffi/</link><description><![CDATA[The memory models of Rust and C can often cause a lot of friction. This guide is born out of my own personal struggles writing transmission-sys a wrapper for the Transmission BitTorrent client. Though in this guide we will go over the much simpler example of writing a wrapper for libevent-sys.]]></description><guid isPermaLink="false">e9d10b77-3f54-4479-b685-26efa74f67ce</guid><pubDate>Fri, 15 Feb 2019 03:00:32 +0000</pubDate><dc:creator>Rushsteve1</dc:creator></item><item><title>Fearless Security: Thread Safety</title><link>https://hacks.mozilla.org/2019/02/fearless-security-thread-safety/</link><description><![CDATA[Multithreading allows programs to do more faster, but adds synchronization bugs and attacks. From a security standpoint, why do we care about thread safety?]]></description><guid isPermaLink="false">5e9e06ae-e22f-4798-b921-d8cb96bf451e</guid><pubDate>Thu, 14 Feb 2019 15:48:10 +0000</pubDate><dc:creator>Diane Hosfelt</dc:creator></item><item><title>Moving from Ruby to Rust</title><link>https://deliveroo.engineering/2019/02/14/moving-from-ruby-to-rust.html</link><description><![CDATA[How we migrated our Tier 1 service from Ruby to Rust and didn’t break production.]]></description><guid isPermaLink="false">d1d825d3-b864-466c-9909-287ae17591a9</guid><pubDate>Thu, 14 Feb 2019 00:00:00 +0000</pubDate><dc:creator>Andrii Dmytrenko</dc:creator></item><item><title>Gtk-rs: how to have mutable object in a closure?</title><link>http://sireliah.com/niusy/gtk_rust_mutable_object_in_closure/</link><description><![CDATA[I wanted, was to start the Gtk application with already generated image of the prime numbers spiral (contained in gtk::Image widget) and then be able to re-generate the image when user changed something. It could be "Generate" click action for instance to show image in different resolution or color. The problem with the button closure was that when I added the Gtk image to the box_vert container, the next time the button was pressed, the code was supposed to remove existing image and add new one, but it didn't.]]></description><guid isPermaLink="false">56014abd-0fd0-4b8c-91ba-734e4f16ddac</guid><pubDate>Tue, 12 Feb 2019 21:58:00 +0000</pubDate><dc:creator>Piotr Gołąb</dc:creator></item><item><title>No, the problem isn’t “bad coders”</title><link>https://medium.com/@sgrif/no-the-problem-isnt-bad-coders-ed4347810270</link><description><![CDATA[A recent blog article discussed the fact that 70% of all security bugs in Microsoft products are due to memory safety vulnerabilities. A lot of the comments I’ve seen on social media boil down to “The problem isn’t the use of a memory unsafe language, but that the programmers who wrote this code are bad.”

In this article, I’m going to look at a recent bug that was caught by the Rust compiler, which I think shows that not only is this assertion unreasonable but virtually impossible for reasons I haven’t seen discussed. While the example I’m going to give is about thread safety rather than memory safety, the arguments I’m going to present can be applied to both.]]></description><guid isPermaLink="false">1c46694b-ae67-4596-9f46-0e9fd419f585</guid><pubDate>Tue, 12 Feb 2019 16:13:55 +0000</pubDate><dc:creator>Sean Griffin</dc:creator></item><item><title>A Quick Look at Trait Objects in Rust</title><link>https://tratt.net/laurie/blog/entries/a_quick_look_at_trait_objects_in_rust.html</link><description><![CDATA[One of the things that baffled me for quite a long time are Rust’s “trait objects”: they felt like an odd part of the language and I was never quite sure whether I was using them or not, even when I wanted to be. Since I’ve recently had cause to look into them in more detail, I thought it might be helpful to write a few things down, in case anyone else finds my explanation useful. The first part of this blog post covers the basics and the second part takes a look at the performance implications of the way trait objects are implemented in Rust.]]></description><guid isPermaLink="false">16bded10-81dc-4ef1-bf04-83a8ab584308</guid><pubDate>Tue, 12 Feb 2019 00:00:00 +0000</pubDate><dc:creator>Laurence Tratt</dc:creator></item><item><title>All-Hands 2019 Recap</title><link>https://www.ralfj.de/blog/2019/02/12/all-hands-recap.html</link><description><![CDATA[Last week, I was in Berlin at the Rust All-Hands 2019. It was great! I will miss nerding out in discussions about type theory and having every question answered by just going to the person who’s the expert in that area, and asking them. In this post, I am summarizing the progress we made in my main areas of interest and the discussions I was involved in—this is obviously just a small slice of all the things that happened.]]></description><guid isPermaLink="false">03bb4da4-48ab-4e1a-a092-be737761fd6f</guid><pubDate>Tue, 12 Feb 2019 00:00:00 +0000</pubDate><dc:creator>Ralf Jung</dc:creator></item><item><title>Are you still using `println` in Rust for debugging?</title><link>https://blog.knoldus.com/are-you-still-using-println-in-rust-for-debugging/</link><description><![CDATA[In this blog, I will explain about new debugging macro dbg, added in Rust 1.32.0. This is a macro for quick and dirty debugging with which you can inspect the value of a given expression.]]></description><guid isPermaLink="false">3c0e89db-b8b3-44bc-a952-4cf406146fae</guid><pubDate>Mon, 11 Feb 2019 04:20:21 +0000</pubDate><dc:creator>Ayush Mishra</dc:creator></item><item><title>Generators I: Toward a minimum viable product</title><link>https://boats.gitlab.io/blog/post/generators-i/</link><description><![CDATA[We’re still not finished with the design of async/await, but it’s already become clear that it’s time to get the next phases of the feature into the pipeline. There are two extensions to the minimal async/await feature we’ve currently got that seem like the clear high priority:
 Async methods: allowing async fn to be used in traits. Generators: allowing imperative control flow to create Iterators and Streams the same way async fn allows imperative control flow to create a Future.]]></description><guid isPermaLink="false">a22c0b8e-ed54-4502-8130-a03913b6ff67</guid><pubDate>Mon, 11 Feb 2019 00:00:00 +0000</pubDate><dc:creator>withoutboats</dc:creator></item><item><title>Handmade Rust Part 2: Unq, an allocator-aware Box</title><link>http://stevenlr.com/posts/handmade-rust-2-unq/</link><description><![CDATA[In the Rust standard library, Box is a RAII wrapper for an object on the heap. It’s actually a special type that’s not implemented purely in the library, but also use special features called lang items. It uses the global allocator to allocate its memory. We want a similar type that also has an allocator associated to it. We’ll call it Unq, which mirror C++’s unique_ptr.]]></description><guid isPermaLink="false">59ecea36-40a2-4b3a-aaf5-2d156d885d24</guid><pubDate>Sun, 10 Feb 2019 16:30:21 +0100</pubDate><dc:creator>Steven Le Rouzic</dc:creator></item><item><title>Handmade Rust Part 1: Introduction &amp; Allocators</title><link>http://stevenlr.com/posts/handmade-rust-1-allocators/</link><description><![CDATA[Welcome to Handmade Rust, a series (hopefully) where I will be developing a Vulkan rendering engine in Rust the Handmade way. By this, I mean using no external libraries, not even the Rust standard library, only the core lib. I am doing this mainly for my own enjoyment but also because I want to get better at writing Rust, and sometimes the best way to really understand something is to just do it yourself. The project will be available on GitHub at stevenlr/HandmadeRust.

The first step will be to build a foundation library for memory allocation, containers, and other utilities that are not provided by the core lib.]]></description><guid isPermaLink="false">5190b436-eaa3-4067-a6a0-fec861ea8316</guid><pubDate>Sun, 10 Feb 2019 00:50:11 +0100</pubDate><dc:creator>Steven Le Rouzic</dc:creator></item><item><title>MPSC Channel API for painless usage of threads with GTK in Rust</title><link>https://coaxion.net/blog/2019/02/mpsc-channel-api-for-painless-usage-of-threads-with-gtk-in-rust/</link><description><![CDATA[A very common question that comes up on IRC or elsewhere by people trying to use the gtk-rs GTK bindings in Rust is how to modify UI state, or more specifically GTK widgets, from another thread. I’ll take this opportunity to also explain why it’s not so trivial in Rust first and also explain another solution.]]></description><guid isPermaLink="false">2c0fbe82-0ef4-455a-94f9-886472559fdb</guid><pubDate>Sat,  9 Feb 2019 13:25:55 +0000</pubDate><dc:creator>Sebastian Dröge</dc:creator></item><item><title>Summary: What are the Allocation Rules?</title><link>https://speice.io/2019/02/summary.html</link><description><![CDATA[While there’s a lot of interesting detail captured in this series, it’s often helpful to have a document that answers some “yes/no” questions. You may not care about what an Iterator looks like in assembly, you just need to know whether it allocates an object on the heap or not. And while Rust will prioritize the fastest behavior it can, here are the rules for each memory type]]></description><guid isPermaLink="false">865d719c-3067-49d0-8bfc-361bfe91d257</guid><pubDate>Sat,  9 Feb 2019 00:00:00 -0500</pubDate><dc:creator>Bradlee Speice</dc:creator></item><item><title>Custom Exit Status Codes with ? in main</title><link>https://www.joshmcguigan.com/blog/custom-exit-status-codes-rust/</link><description><![CDATA[Rust 1.26 introduced the ability to return a Result from the main method, which was a great ergonomics improvement especially for small CLI applications. If your application returns an Ok, Rust reports a success exit status code to the operating system. Likewise if your application returns an Err, Rust reports an error exit status code.

But what if you want to return a custom exit status error code for each possible error type in your application, to provide some additional feedback to your user? This leads into an exploration of the Termination and Try traits, and is the topic of this post.]]></description><guid isPermaLink="false">1e324360-c349-474e-b091-7c5250958ffc</guid><pubDate>Sat,  9 Feb 2019 00:00:00 +0000</pubDate><dc:creator>Josh Mcguigan</dc:creator></item><item><title>Exploring Rust</title><link>https://jonathansteyfkens.com/posts/explore-rust.html</link><description><![CDATA[Rust provides a lot of language constructs to enable and empower the user to write memory safe and correct code. But what happens behind these constructs? In this post I will outline ways of exploring rust and it’s compiler.

Last weekend I went to fosdem 2019. This is where I had the chance to attend a talk given by Matthias Endler. In his talk he explained how rust has got a lot of syntactic sugar to help the programmers in writing safe and correct code, part of his talk was explaining cargo-inspect to analyse this syntax and see what’s happening behind the scenes. This inspired me to dig a bit deeper and try out other tools.]]></description><guid isPermaLink="false">82089039-8f19-4e01-8d91-d0ef468bbab8</guid><pubDate>Sat,  9 Feb 2019 00:00:00 +0000</pubDate><dc:creator>Jonathan Steyfkens</dc:creator></item><item><title>Compiler Optimizations: What It&apos;s Done Lately</title><link>https://speice.io/2019/02/compiler-optimizations.html</link><description><![CDATA[Throughout the series so far, we’ve put a handicap on the code. In the name of consistent and understandable results, we’ve asked the compiler to pretty please leave the training wheels on. Now is the time where we throw out all the rules and take off the kid gloves. As it turns out, both the Rust compiler and the LLVM optimizers are incredibly sophisticated, and we’ll step back and let them do their job.

Similar to “What Has My Compiler Done For Me Lately?”, we’re focusing on interesting things the Rust language (and LLVM!) can do with memory management.]]></description><guid isPermaLink="false">4984adf8-b660-4433-a888-8bd84d669dc0</guid><pubDate>Fri,  8 Feb 2019 00:00:00 -0500</pubDate><dc:creator>Bradlee Speice</dc:creator></item><item><title>The Builder Pattern in Rust</title><link>https://oribenshir.github.io/afternoon_rusting/blog/building-rust</link><description><![CDATA[For the very first coding blog, I think it is appropriate to start with building objects. This post is about the Builder Pattern in Rust, and how it taught me I couldn’t write everything the way I want. Yes, strong typing prevents you from common pitfalls, and C++ can go quite far in this direction (as many JS/Python enthusiastic will gladly testify). It is often easy to forget how it sometimes prevents you from writing a completely legal and safe code, due to rules being too “protective”. And as Rust takes the code safety to a whole new level, sometimes a trivial code can’t be written, and without the proper knowledge, it might seem entirely arbitrary. It was a subtle restriction in the builder pattern that took me by surprise first.]]></description><guid isPermaLink="false">52b68916-b65b-4a28-9bac-e8c8038c6194</guid><pubDate>Fri,  8 Feb 2019 00:00:00 +0000</pubDate><dc:creator>Ori Ben-Shir</dc:creator></item><item><title>Dynamic Memory: A Heaping Helping</title><link>https://speice.io/2019/02/a-heaping-helping.html</link><description><![CDATA[Managing dynamic memory is hard. Some languages assume users will do it themselves (C, C++), and some languages go to extreme lengths to protect users from themselves (Java, Python). In Rust, how the language uses dynamic memory (also referred to as the heap) is a system called ownership. And as the docs mention, ownership is Rust’s most unique feature.]]></description><guid isPermaLink="false">e69005a8-5193-4715-b906-f7a1a71db4f0</guid><pubDate>Thu,  7 Feb 2019 00:00:00 -0500</pubDate><dc:creator>Bradlee Speice</dc:creator></item><item><title>Rust: A unique perspective</title><link>https://limpet.net/mbrubeck/2019/02/07/rust-a-unique-perspective.html</link><description><![CDATA[In which I try to explain the reasoning behind Rust’s memory-safety mechanisms.]]></description><guid isPermaLink="false">d7fe7d63-d2c8-4bfc-834b-a93155c10dcb</guid><pubDate>Thu,  7 Feb 2019 00:00:00 +0000</pubDate><dc:creator>Matt Brubeck</dc:creator></item><item><title>Fixed Memory: Stacking Up</title><link>https://speice.io/2019/02/stacking-up.html</link><description><![CDATA[const and static are perfectly fine, but it’s relatively rare that we know at compile-time about either values or references that will be the same for the duration of our program. Put another way, it’s not often the case that either you or your compiler knows how much memory your entire program will ever need.]]></description><guid isPermaLink="false">44856ee1-451a-44b6-8cc1-5afd881bb57d</guid><pubDate>Wed,  6 Feb 2019 00:00:00 -0500</pubDate><dc:creator>Bradlee Speice</dc:creator></item><item><title>Global Memory Usage: The Whole World</title><link>https://speice.io/2019/02/the-whole-world.html</link><description><![CDATA[The first memory type we’ll look at is pretty special: when Rust can prove that a value is fixed for the life of a program (const), and when a reference is unique for the life of a program (static as a declaration, not 'static as a lifetime), we can make use of global memory. This special section of data is embedded directly in the program binary so that variables are ready to go once the program loads; no additional computation is necessary.]]></description><guid isPermaLink="false">108f009d-94b1-43c6-8598-43088175772e</guid><pubDate>Tue,  5 Feb 2019 00:00:00 -0500</pubDate><dc:creator>Bradlee Speice</dc:creator></item><item><title>Allocations in Rust</title><link>https://speice.io/2019/02/understanding-allocations-in-rust.html</link><description><![CDATA[There’s an alchemy of distilling complex technical topics into articles and videos that change the way programmers see the tools they interact with on a regular basis. I knew what a linker was, but there’s a staggering amount of complexity in between the OS and main(). Rust programmers use the Box type all the time, but there’s a rich history of the Rust language itself wrapped up in how special it is.

In a similar vein, this series attempts to look at code and understand how memory is used; the complex choreography of operating system, compiler, and program that frees you to focus on functionality far-flung from frivolous book-keeping. The Rust compiler relieves a great deal of the cognitive burden associated with memory management, but we’re going to step into its world for a while.

Let’s learn a bit about memory in Rust.]]></description><guid isPermaLink="false">ba471387-4b93-4e46-8846-c89beddf6916</guid><pubDate>Mon,  4 Feb 2019 00:00:00 -0500</pubDate><dc:creator>Bradlee Speice</dc:creator></item><item><title>Rust Governance: Scaling Empathy</title><link>https://manishearth.github.io/blog/2019/02/04/rust-governance-scaling-empathy/</link><description><![CDATA[There’s been a lot of talk about improving Rust’s governance model lately. As we decompress from last year’s hectic edition work, we’re slowly starting to look at all the bits of debt we accumulated, and organizational debt is high on that list.

I’ve been talking in private with people about a bunch of these things for quite a while now, and I felt it worthwhile to write down as much of my thoughts as I can before the Rust All Hands in Berlin this week.]]></description><guid isPermaLink="false">66563fe6-008a-475e-9337-42ee770d649c</guid><pubDate>Mon,  4 Feb 2019 00:00:00 +0000</pubDate><dc:creator>Manish Goregaokar</dc:creator></item><item><title>How to Debug Rust with Visual Studio Code</title><link>https://www.forrestthewoods.com/blog/how-to-debug-rust-with-visual-studio-code/</link><description><![CDATA[A step-by-step guide for debugging Rust with Visual Studio Code.]]></description><guid isPermaLink="false">166e7e9f-de17-4abb-b2f4-08169793f3dd</guid><pubDate>Sun,  3 Feb 2019 20:01:00 +0000</pubDate><dc:creator>Forrest Smith</dc:creator></item><item><title>Rust: regret-less concurrency</title><link>https://medium.com/@polyglot_factotum/rust-regret-less-concurrency-2238b9e53333</link><description><![CDATA[Rust offers the promise of “fearless concurrency”, and delivers on it through memory safety. Yet this safety doesn’t guarantee code that is easy to maintain. If one is not “fearful” of complexity, concurrency can easily become a story of regrets. Can we get a “regret-less” kind of concurrency?]]></description><guid isPermaLink="false">4a6ed1c0-83d7-4392-9d2a-9b749a5433fe</guid><pubDate>Sat,  2 Feb 2019 12:15:32 +0000</pubDate><dc:creator>Polyglot Factotum</dc:creator></item><item><title>Cargo&apos;s next few years</title><link>https://www.ncameron.org/blog/cargos-next-few-years/</link><description><![CDATA[The Cargo team have been thinking about and discussing long-term plans for Cargo. In this post I'll talk about what we hope Cargo will look like around the time of the next edition (assuming there is another edition and that it happens in about three years, neither of which is confirmed). There will be another post soon on more concrete plans for this year, including some kind of roadmap.]]></description><guid isPermaLink="false">040a805b-f794-4df1-810f-5d3607a3f274</guid><pubDate>Sat,  2 Feb 2019 04:35:37 +0000</pubDate><dc:creator>Nick Cameron</dc:creator></item><item><title>The steps towards rustc, the great optimiser</title><link>https://kazlauskas.me/entries/the-road-to-bestest-optimiser.html</link><description><![CDATA[It has been more than 3 years now since the MIR ini­ti­at­ive has been ac­cep­ted. Cur­rently rustc has a num­ber of MIR op­tim­isa­tions: a simple in­lin­er, ba­sic con­stant and copy propaga­tion, a single in­struc­tion com­bin­a­tion rule, a few graph sim­pli­fic­a­tion and clean up passes… The pat­tern here is clear – most of the op­tim­isa­tions we cur­rently have are ba­sic and lim­ited in their po­tency. Given the pace at which we man­aged to bring up MIR in the first place, one would be right to ex­pect… some­thing more.

As some­body who has made an at­tempt and failed to im­ple­ment a num­ber of data­flow-­based op­tim­isa­tions (a­mong other thing­s), I con­sider my­self fairly qual­i­fied to haz­ard a guess as to what is the reason for the cur­rent state we are at. Here it goes.]]></description><guid isPermaLink="false">892a8c46-fee3-48d8-bc78-69a13a9a5c8d</guid><pubDate>Fri,  1 Feb 2019 00:00:00 +0000</pubDate><dc:creator>Simonas Kazlauskas</dc:creator></item><item><title>Killing unwrap()</title><link>https://dmerej.info/blog/post/killing-unwrap/</link><description><![CDATA[A collection of snippets to avoid unnecessary calls to unwrap() in Rust.]]></description><guid isPermaLink="false">7028c8de-9b0d-4f0f-a74e-0e07126cd80e</guid><pubDate>Wed, 30 Jan 2019 19:11:26 +0000</pubDate><dc:creator>Dimitri Merejkowsky</dc:creator></item><item><title>Salsa: Incremental recompilation</title><link>http://smallcultfollowing.com/babysteps/blog/2019/01/29/salsa-incremental-recompilation/</link><description><![CDATA[So for the last couple of months or so, I’ve been hacking in my spare time on this library named salsa, along with a number of awesome other folks. Salsa basically extracts the incremental recompilation techniques that we built for rustc into a general-purpose framework that can be used by other programs. Salsa is developing quickly: with the publishing of v0.10.0, we saw a big step up in the overall ergonomics, and I think the current interface is starting to feel very nice.]]></description><guid isPermaLink="false">30602bae-8957-4b3a-92d2-eec9e6f2fddd</guid><pubDate>Tue, 29 Jan 2019 00:00:00 -0500</pubDate><dc:creator>Niko Matsakis</dc:creator></item><item><title>Rust: The story of closures</title><link>https://medium.com/@earthengine/rust-the-story-of-closures-8f8e5af7ea1c</link><description><![CDATA[The Rust programming language introduced many leading concepts in the programming language design landscape. The most famous features are the borrow checker, the ownership management and the trait system.

However, the fantastic expressiveness of the closures is generally underestimated. Yes, from the day Javascript introduces closures to main stream programming languages, these days closures become one of the basic features for almost all modern languages. However, Rust’s ownership rules result in some brand-new observations to closures and its position in programming. Let’s start the journey now.]]></description><guid isPermaLink="false">6881b0f3-53e8-4fbf-bca2-9e108792bf29</guid><pubDate>Sun, 27 Jan 2019 03:12:11 +0000</pubDate><dc:creator>Earth Engine</dc:creator></item><item><title>Rust on iOS</title><link>https://medium.com/visly/rust-on-ios-39f799b3c1dd</link><description><![CDATA[If you’re an iOS developer you may be asking yourself how and why you would make use of Rust on iOS. This article will mostly cover the how. As to why, the most compelling reason for us at Visly is that it enables us to share code between Android and iOS in a performant and safe manner, in a language much easier to work with than C++.]]></description><guid isPermaLink="false">2d233ddd-ecb5-499d-88b8-a0f14797c1a7</guid><pubDate>Sat, 26 Jan 2019 21:30:07 +0000</pubDate><dc:creator>Emil Sjölander</dc:creator></item><item><title>Rust OSS Governance and Sustainablility I</title><link>https://mgattozzi.com/oss-governance-and-sustainablility-i/</link><description><![CDATA[Recently I travelled all the way to Waterloo from Boston for Starcon. With a 9 hour drive I had a lot of time to think about things and so I spent a good majority of it thinking about OSS Governanace and Sustainability. What I came up with and thought of is the more concrete solutions to the problems I brought up in my Rust 2019 post. With the Rust All hands in Berlin only a few weeks away I wanted to get my thoughts in order by writing out some of the solutions to specific problems I came up with. Now, this doesn't mean they'll be accepted! We might even find better solutions! I just felt a need to articulate them as both a reference point and to make sure I've thought through them well. I'll be splitting them into a few posts so I can publish more faster, rather than write one long post that won't be published in time. With that in mind let's begin!]]></description><guid isPermaLink="false">799301a7-d57a-4e9c-8412-aafc4e643f0a</guid><pubDate>Tue, 22 Jan 2019 04:20:23 +0000</pubDate><dc:creator>Michael Gattozzi</dc:creator></item><item><title>Polonius and the case of the hereditary harrop predicate</title><link>http://smallcultfollowing.com/babysteps/blog/2019/01/21/hereditary-harrop-region-constraints/</link><description><![CDATA[In my previous post about Polonius and subregion obligations, I mentioned that there needs to be a follow-up to deal with higher-ranked subregions. This post digs a bit more into what the problem is in the first place and sketches out the general solution I have in mind, but doesn’t give any concrete algorithms for it.]]></description><guid isPermaLink="false">09b9f354-aeed-4d48-b859-9c63fcdddb2e</guid><pubDate>Mon, 21 Jan 2019 00:00:00 -0500</pubDate><dc:creator>Niko Matsakis</dc:creator></item><item><title>Why aren&apos;t my Rust threads running?</title><link>https://esimmler.com/why-arent-my-rust-threads-running/</link><description><![CDATA[I got a bit tangled up while experimenting with threads and channels in Rust. The compiler prevented any undefined behavior or memory corruption, but it can only do so much. My problems came from a shaky understanding of the language’s fundamentals and the inherent complexity of parallel programming. Or, in my case, attempted parallel programming.]]></description><guid isPermaLink="false">f950f168-d74e-4b3a-b2f5-18546a7d282b</guid><pubDate>Sat, 19 Jan 2019 00:00:00 +0000</pubDate><dc:creator>Erik Simmler</dc:creator></item><item><title>Closures: Magic Functions</title><link>https://krishnasannasi.github.io/rust/syntactic/sugar/2019/01/17/Closures-Magic-Functions.html</link><description><![CDATA[Closures seem like magical functions. They can do magic like capture their environment, which normal functions can’t do. How does this work?]]></description><guid isPermaLink="false">85502039-9617-4e25-a34d-2e1f8cd2f452</guid><pubDate>Thu, 17 Jan 2019 19:00:00 +0000</pubDate><dc:creator>Krishna Sannasi</dc:creator></item><item><title>When Rust is safer than Haskell</title><link>https://www.fpcomplete.com/blog/when-rust-is-safer-than-haskell</link><description><![CDATA[Haskell generally has better safety guarantees than Rust, there are some cases when Rust is safer than Haskell. This post explores when Rust is safe to use.]]></description><guid isPermaLink="false">65dcfcd4-e17a-4e0d-bd56-ccea6cfe062f</guid><pubDate>Thu, 17 Jan 2019 18:09:09 +0000</pubDate><dc:creator>Michael Snoyman</dc:creator></item><item><title>Polonius and region errors</title><link>http://smallcultfollowing.com/babysteps/blog/2019/01/17/polonius-and-region-errors/</link><description><![CDATA[Now that NLL has been shipped, I’ve been doing some work revisiting the Polonius project. Polonius is the project that implements the “alias-based formulation” described in my older blogpost. Polonius has come a long way since that post; it’s now quite fast and also experimentally integrated into rustc, where it passes the full test suite.]]></description><guid isPermaLink="false">2afd97b3-7b60-4a21-b07a-7f353a23dc4d</guid><pubDate>Thu, 17 Jan 2019 00:00:00 -0500</pubDate><dc:creator>Niko Matsakis</dc:creator></item><item><title>Announcing Rust 1.32.0</title><link>https://blog.rust-lang.org/2019/01/17/Rust-1.32.0.html</link><description><![CDATA[Rust 1.32.0 has a few quality of life improvements, switches the default allocator, and makes additional functions const.]]></description><guid isPermaLink="false">97ace8ce-4c4f-442d-bab3-10a97bd119df</guid><pubDate>Thu, 17 Jan 2019 00:00:00 +0000</pubDate><dc:creator>The Rust Release Team</dc:creator></item><item><title>How to order Rust code</title><link>https://deterministic.space/how-to-order-rust-code.html</link><description><![CDATA[Note:This post is about how I arrange the code I write in Rust.If you wanted to “order” Rust codein the “hire someone to write code” sense,you should still keep on readingas this is excellent material for a job interview.(Not the opinion I present but having an opinion on the topic.)]]></description><guid isPermaLink="false">90b0ffa9-1711-4870-9e30-37375be50515</guid><pubDate>Thu, 17 Jan 2019 00:00:00 +0100</pubDate><dc:creator>Pascal Hertleif</dc:creator></item><item><title>Scala Developer Journey into Rust - Part 2 : Type Inference</title><link>http://blog.madhukaraphatak.com/rust-scala-part-2/</link><description><![CDATA[Rust is one of the major programming languages that’s been getting popular in recent years. It has many advanced high level language features like Scala.This made me interested to learn Rust. So in this next series of blogs I will share my experience with Rust from a Scala developer point of view. I would like to explore how these two language approach things. I would like to explore the similarities and their differences.]]></description><guid isPermaLink="false">0b01d8d7-aa94-4382-8fbf-c2979f7018ad</guid><pubDate>Mon, 14 Jan 2019 00:00:00 +0000</pubDate><dc:creator>Madhukara Phatak</dc:creator></item><item><title>Exploring Column-Oriented Data in Rust with frunk HLists</title><link>https://paulkernfeld.com/2019/01/13/frunk-column.html</link><description><![CDATA[Row-oriented storage and column-oriented storage are two major ways of laying out data in memory. In Rust, there is a simple way to think of this: row-oriented storage is like an array of structs, whereas column-oriented storage is like a struct of arrays. It’s easy to use row-oriented storage in Rust, so this post is going to explore column-oriented storage.]]></description><guid isPermaLink="false">b4d25622-7886-48c7-901c-e382c05122cb</guid><pubDate>Sun, 13 Jan 2019 00:00:00 +0000</pubDate><dc:creator>Paul Kernfeld</dc:creator></item><item><title>Letting the compiler tell you what to do - an example using Rust</title><link>https://dmerej.info/blog/post/letting-the-compiler-tell-you-what-to-do/</link><description><![CDATA[If you’ve ever wrote code in a compiled language (C, C++, Java, …), you are probably used to compiler error messages, and you may think there are only here to prevent you from making mistakes. Well sometimes you can also use compiler error messages to design and implement new features. Let me show you with a simple command-line program written in Rust.]]></description><guid isPermaLink="false">e743cfa5-87bc-46d7-9dc6-693352d91e6a</guid><pubDate>Sat, 12 Jan 2019 12:26:27 +0000</pubDate><dc:creator>Dimitri Merejkowsky</dc:creator></item><item><title>Hindsight on Advent of Code 2018</title><link>https://phaazon.net/blog/aoc-18-hindsight</link><description><![CDATA[On the 1st of December 2018, I decided to give it a try to Advent of Code. AoC is, basically, a programming challenge website where you get two puzzles unlocked every day of December from 1st to 25th – hence the name. It has a ranking system which scores are based on the absolute time you took to solve the puzzles – i.e. spent time as soon as the puzzles got unlocked. As a French living in Paris, I find this a bit unfair (we get puzzles unlocked at around 5:00 AM!) and then I just realized I could do the puzzles for fun only.

This blog post sums up what I did with AoC#18, my thoughts about the puzzles and even a meta-discussion about programming challenges. I used Haskell for most challenges and switched to Rust for no specific reason. Just fun.]]></description><guid isPermaLink="false">365d8318-a9d3-4c1e-9f2a-73c4c5d812ee</guid><pubDate>Sat, 12 Jan 2019 00:20:00 +0000</pubDate><dc:creator>Dimitri Sabadie</dc:creator></item><item><title>const types, traits and implementations in Rust</title><link>https://varkor.github.io/blog/2019/01/11/const-types-traits-and-implementations-in-Rust.html</link><description><![CDATA[Rust permits a limited form of compile-time function execution in the form of const and const fn. While, initially, const may seem like a reasonaby straightforward feature, it turns out to raise a wealth of interesting and complex design questions. In this post, we’re going to look at a particular design question that has been under discussion for some time and propose a design that is natural and expressive. This is motivated both from a syntactic perspective and a theoretic perspective.]]></description><guid isPermaLink="false">dfbac96b-1ab3-48a8-9c50-917188335ddd</guid><pubDate>Fri, 11 Jan 2019 19:02:40 +0000</pubDate><dc:creator>varkor</dc:creator></item><item><title>Librsvg is almost rustified now</title><link>https://people.gnome.org/~federico/blog/librsvg-is-almost-rustified.html</link><description><![CDATA[Since a few days ago, librsvg's library implementation is almost 100% Rust code. Paolo Borelli's and Carlos Martín Nieto's latest commits made it possible. What does "almost 100% Rust code" mean here?]]></description><guid isPermaLink="false">54ecd8fa-cc4f-4c5f-acef-fc75e1e6ce7f</guid><pubDate>Thu, 10 Jan 2019 12:28:11 -0600</pubDate><dc:creator>Federico Mena Quintero</dc:creator></item><item><title>Proposed Rust community norm for unsafe code</title><link>http://sanxiyn.blogspot.com/2019/01/proposed-rust-community-norm-for-unsafe.html</link><description><![CDATA[Recently cessen asked  people to write their thoughts on Rust community norm for unsafe code. So here it is.]]></description><guid isPermaLink="false">60e20969-d592-4d79-91e8-633409505b03</guid><pubDate>Thu, 10 Jan 2019 19:03:00 +0900</pubDate><dc:creator>Seo Sanghyeon</dc:creator></item><item><title>Understanding Rust Lifetimes</title><link>https://medium.com/nearprotocol/understanding-rust-lifetimes-e813bcd405fa</link><description><![CDATA[No, seriously, this time for real.]]></description><guid isPermaLink="false">5c15ca59-eba1-43d8-9dd4-206f574826cf</guid><pubDate>Thu, 10 Jan 2019 01:26:26 +0000</pubDate><dc:creator>Maksym Zavershynskyi</dc:creator></item><item><title>Rust Community Norms for Unsafe Code</title><link>https://blog.cessen.com/post/2019_01_09_rust_community_norms_for_unsafe_code</link><description><![CDATA[I recently released Ropey 1.0, a text rope library for Rust. Ropey uses unsafe code internally, and its use of unsafe unsurprisingly came up in the 1.0 release thread on Reddit.

The ensuing discussion (especially thanks to Shnatsel) helped me significantly reduce the amount of unsafe code in Ropey with minimal (though not non-existent) performance degradation. But the whole thing nevertheless got me thinking about unsafe code and community norms around it, and I figured writing some of those thoughts down might be useful.]]></description><guid isPermaLink="false">fa5229de-d279-44c7-9d62-0163e7dc1771</guid><pubDate>Wed,  9 Jan 2019 00:00:00 +0000</pubDate><dc:creator>Nathan Vegdahl</dc:creator></item><item><title>Comparing Rust and JavaScript Ergonomics with a Simple Linked List</title><link>https://www.codesections.com/blog/javascript-vs-rust-linked-list/</link><description><![CDATA[My day-to-day work involves writing a fair bit of JavaScript but, lately, I've gotten really interested in Rust. The other day, I decided to take a slightly different approach: I decided to take a simple linked list program—the type can and do ask my students to implement in JavaScript in ~20 minutes—and re-implement it in Rust. Specifically, I decided to build a queue implemented with a singly linked list.]]></description><guid isPermaLink="false">a46b1128-605b-4cab-b36f-5766125ba2f3</guid><pubDate>Sun,  6 Jan 2019 00:00:00 +0000</pubDate><dc:creator>Daniel Long Sockwell</dc:creator></item><item><title>Building a JS Interpreter in Rust – Part 2</title><link>https://jason-williams.co.uk/building-a-js-interpreter-in-rust-part-2/</link><description><![CDATA[When writing an interpreter or a compiler for any language, you usually need to start with a lexer and a parser. Boa here is no different, our first task will be to do the same but what do these do?]]></description><guid isPermaLink="false">916f96ed-c1cc-4955-ade6-626b3ebf08bd</guid><pubDate>Wed,  2 Jan 2019 00:00:00 +0000</pubDate><dc:creator>Jason Williams</dc:creator></item><item><title>Deriving Traits in Rust with Procedural Macros</title><link>https://naftuli.wtf/2019/01/02/rust-derive-macros/</link><description><![CDATA[Procedural macros in Rust are a really compelling feature that I didn’t understand until recently. There are a few gotchas, but they make it super easy to implement custom #[derive()] expansions for implementing traits with a single line of code. Let’s dive in.]]></description><guid isPermaLink="false">470de398-add8-4fdd-9b38-c79c781c58fa</guid><pubDate>Wed,  2 Jan 2019 00:00:00 +0000</pubDate><dc:creator>Naftuli Kay</dc:creator></item><item><title>What is &apos;Placement New&apos; in Rust?</title><link>http://blakesmith.me/2018/12/31/what-is-placement-new-in-rust.html</link><description><![CDATA[Placement new is a feature currently being discussed for the Rust programming language. It gives programmer control of memory allocation and memory placement, where current memory allocation implementations are hidden behind compiler internals via the Box::new interface. This is Rust’s answer to C++ placement new, allowing one to control not only when and how memory is freed, but also where it is allocated and freed from.]]></description><guid isPermaLink="false">793ef59c-ee13-4673-a06b-e65d461e7b1c</guid><pubDate>Mon, 31 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Blake Smith</dc:creator></item><item><title>A Rusty Advent of Code</title><link>https://cprimozic.net/blog/a-rusty-aoc/</link><description><![CDATA[For the first time, I took part in the Advent of Code this year. If you haven't heard of it, it's a daily programming challenge that can be solved in any programming language. Rust was very present in the Advent of Code community with people contributing a ton of Rust-related content. In the daily solutions thread on the /r/aoc subreddit, there were always several Rust solutions posted. Advent of Code really helps show off the things that make Rust shine, demonstrating the power and utility of many community-created crates as well as the language itself.]]></description><guid isPermaLink="false">04d1c753-5242-4aa9-bff7-500a717a62bc</guid><pubDate>Thu, 27 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Casey Primozic</dc:creator></item><item><title>Barriers and Two-phase Borrows in Stacked Borrows</title><link>https://www.ralfj.de/blog/2018/12/26/stacked-borrows-barriers.html</link><description><![CDATA[My internship (“research assistantship”) with Mozilla has ended several weeks ago, and this post is a report of the most recent tweaks I made to Miri and Stacked Borrows. Neither project is by any means “done”, of course. However, both have reached a fairly reasonable state, so I felt some kind of closing report made sense. Also, if I ever want to finish my PhD, I’ll have to seriously scale down the amount of time I work on Rust – so at least from my side, things will move more slowly from now on.

In particular, installing Miri and running your test suite in it is now just a single command away! Scroll all the way down if you are not interested in the rest.]]></description><guid isPermaLink="false">152067d5-472f-4ba2-9429-6a5de749bf99</guid><pubDate>Wed, 26 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Ralf Jung</dc:creator></item><item><title>Handling failure in Rust</title><link>https://esimmler.com/handling-failure-in-rust/</link><description><![CDATA[I’ve begun to seriously dig into the Rust programming language. The learning curve is real, but I already appreciate the work they’ve put into ergonomics. I’m writing a simple photo thumbnail endpoint using the Rocket web framework (v0.4) and Image library (v0.20.1). My first pass used a lot of unwrapping to ignore potential errors. A lot can go wrong, even in this “simple” case. Rocket catches any panics thrown by route handlers, so this is about as robust as a naive equivalent in most other languages. However, Rust at least forces us to be explicit and purposeful about when we want to be sloppy. This is great for a first quick and dirty pass, but we can do much better.]]></description><guid isPermaLink="false">0a14c8b2-c25a-4733-9682-e1cc71567cc9</guid><pubDate>Wed, 26 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Erik Simmler</dc:creator></item></channel></rss>