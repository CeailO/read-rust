<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/"><channel><title>Read Rust - Language</title><link>https://readrust.net/</link><description>Language posts on Read Rust</description><item><title>Making a Brainf*ck to C Compiler in Rust</title><link>https://medium.com/@CanHasCommunism/making-a-brainf-ck-to-c-compiler-in-rust-10f0c01a282d</link><description>Let’s make a tokenizer and code generator to understand the basics behind tiny compilers.</description><guid isPermaLink="false">39d1ac9b-501b-46c3-b2e6-68f2d4aabe1d</guid><pubDate>Sat,  3 Mar 2018 18:13:20 +0000</pubDate><dc:creator>Aesl</dc:creator></item><item><title>Opportunistic Mutations</title><link>https://llogiq.github.io/2018/03/03/opportune.html</link><description>As you may know, my current mutagen project deals with mutation testing in Rust. However, as I remarked, Rust’s famed flexibility leaves us little room to do mutations while keeping the type checker happy. For example, other mutation testing frameworks can mutate x + y to x - y.

This is an interesting mutation, because it’s so easy to do in languages like Java, which have full type information available at the bytecode level and so hard to do in Rust, because the std::ops traits make everything so hecking flexible.</description><guid isPermaLink="false">2f386775-d0a5-474b-a9de-c14af7453c40</guid><pubDate>Sat,  3 Mar 2018 00:00:00 +0000</pubDate><dc:creator>Llogiq</dc:creator></item><item><title>Stopping a Rust worker</title><link>https://matklad.github.io/2018/03/02/stopping-a-rust-worker.html</link><description>This is a small post about a specific pattern for cancellation in the Rust programming language. The pattern is simple and elegant, but it’s rather difficult to come up with it by yourself.</description><guid isPermaLink="false">407d3ba2-d0af-4121-b13a-468b1f0f66cd</guid><pubDate>Fri,  2 Mar 2018 20:11:50 +0000</pubDate><dc:creator>Aleksey Kladov</dc:creator></item><item><title>Docker Multi-Stage Build</title><link>https://blog.jawg.io/docker-multi-stage-build/</link><description>On June 13, 2017 took place the Paris Container Day. They unveiled a new docker feature: multi-stage build. That&apos;s the subject of this article.</description><guid isPermaLink="false">ab076ead-649f-47ff-8fa2-a7c243ba3dca</guid><pubDate>Thu,  1 Mar 2018 14:00:00 +0000</pubDate><dc:creator>Jones Magloire</dc:creator></item><item><title>Object Shadowing for Serialization of Complex Types</title><link>https://commiebstrd.github.io/rustlang/serde/json/2018/03/01/object-shadowing.html</link><description>Presently, I’m busy writing a capture the flag (CTF) scoreboard, it requires rather complex structures and relationships with other internal objects. Being a security event, I’d also like to maintain explicit control of user data. While serialization in Rust has come a significant way, leveraging auto-generation presents some issues.</description><guid isPermaLink="false">257617e2-c1fe-44c7-9cb9-7c07495b96ec</guid><pubDate>Thu,  1 Mar 2018 05:00:00 +0000</pubDate><dc:creator>Spenser Reinhardt</dc:creator></item><item><title>Add examples to your Rust libraries</title><link>http://xion.io/post/code/rust-examples.html</link><description>When you’re writing a library for other programs to depend on, it is paramount to think how the developers are going to use it in their code.

The best way to ensure they have a pleasant experience is to put yourself in their shoes. Forget the internal details of your package, and consider only its outward interface. Then, come up with a realistic use case and just implement it.

In other words, you should create complete, end-to-end, and (somewhat) usable example applications.</description><guid isPermaLink="false">ca98f7f9-8927-48e9-8028-15e81f20f8a6</guid><pubDate>Wed, 28 Feb 2018 08:37:00 +0100</pubDate><dc:creator>Karol Kuczmarski</dc:creator></item><item><title>My Rust Dockerfile</title><link>https://blog.sedrik.se/posts/my-docker-setup-for-rust/</link><description>Lets deploy small docker images for Rust</description><guid isPermaLink="false">d001ce02-fbfb-4a08-8389-0f713b09bf72</guid><pubDate>Mon, 26 Feb 2018 00:00:00 +0000</pubDate><dc:creator>Fredrik Park</dc:creator></item><item><title>Writing a doubly linked list in Rust is easy</title><link>https://www.reddit.com/r/rust/comments/7zsy72/writing_a_doubly_linked_list_in_rust_is_easy/</link><description>This is a response to the recently submitted blog post titled Why Writing a Linked List in (safe) Rust is So Damned Hard. The post on Reddit was even more dramatic: Why Writing a Linked List in Rust is Basically Impossible.

I see exaggarated claims like these very often - and strongly disagree. Writing a doubly linked list in Rust is not hard - in fact, it&apos;s fairly easy! The best strategy, in my opinion, is creating a vector for allocating nodes and using indices instead of pointers. This strategy is often overlooked, getting a &apos;honorauble mention&apos; at best.</description><guid isPermaLink="false">cec6c9fd-a92b-4f5a-8d9b-9b84c263c48f</guid><pubDate>Sat, 24 Feb 2018 00:35:43 +0000</pubDate><dc:creator>/u/stjepang</dc:creator></item><item><title>Reasoning with Types in Rust</title><link>https://aaronweiss.us/posts/2018-02-26-reasoning-with-types-in-rust.html</link><description>Rust is a modern programming language which is marketed primarily on the basis of its very nice type system, and I’d like to tell you about how you can use this type system to reason about your programs in interesting ways. Most of the time when its type system is discussed, the focus is on its guarantee of data race freedom and ability to enable so-called fearless concurrency (and rightfully so—this is a place where Rust truly shines!). Today, I have a different focus in mind, characterized perhaps most succinctly as follows:</description><guid isPermaLink="false">5e572868-98d0-4944-b897-14cca13a39a4</guid><pubDate>Mon, 26 Feb 2018 00:00:00 +0000</pubDate><dc:creator>Aaron Weiss</dc:creator></item><item><title>Pushing Rust To 2019</title><link>https://medium.com/@dumindu/pushing-rust-to-2019-9616d82172d3</link><description>Some of these suggestions are not entirely new and have been added as posts/ comments on /r/rust, Github threads. But I believe better listing down all in a one place, because now we are in the correct time even I am bit late.</description><guid isPermaLink="false">0493daa3-4abb-46eb-82de-e75daea4bbac</guid><pubDate>Fri, 23 Feb 2018 15:44:16 +0000</pubDate><dc:creator>Dumindu Madunuwan</dc:creator></item><item><title>How doctests get made</title><link>https://quietmisdreavus.net/code/2018/02/23/how-the-doctests-get-made/</link><description>One of rustdoc’s greatest features is the ability to take code samples within your documentation and run them like tests. This ensures that all your samples stay up to date with your library’s API changes. However, there are some steps that need to happen to massage these “doctests” into something that can be compiled and run like a regular program.</description><guid isPermaLink="false">516e4eaf-1ce1-49be-a457-a471e9f97329</guid><pubDate>Fri, 23 Feb 2018 16:00:00 -0600</pubDate><dc:creator>QuietMisdreavus</dc:creator></item><item><title>Rust Typestates</title><link>https://yoric.github.io/post/rust-typestate/</link><description>A long time ago, the Rust language was a language with typestate. Officially, typestates were dropped long before Rust 1.0. In this entry, I’ll get you in on the worst kept secret of the Rust community: Rust still has typestates.</description><guid isPermaLink="false">450ba7fc-c3ea-4af5-bda4-06842f062de8</guid><pubDate>Thu, 22 Feb 2018 15:15:55 +0100</pubDate><dc:creator>David Teller</dc:creator></item><item><title>Why Writing a Linked List in Rust is Basically Impossible [in safe Rust]</title><link>https://rcoh.me/posts/rust-linked-list-basically-impossible/</link><description>Before I start this post, let me preface it by saying that I’m not an experienced Rustacean by any means. Errata and corrections are appreciated. This post is aimed at helping other fledgling rust-learners avoid my mistake. First, by helping Rust learners pick good introductory projects that will fit naturally in idiomatic rust. Second, by helping Rust learners start building Rust-friendly design intuition. I’d heard about Rust and it’s inscrutable borrow checker for years, but after reading a few blog posts about compiler error improvements, I figured it might be user-friendly enough to give it a try.</description><guid isPermaLink="false">45772a5b-1f22-4db9-9eee-f888c0c82660</guid><pubDate>Tue, 20 Feb 2018 08:55:56 -0800</pubDate><dc:creator>Russell Cohen</dc:creator></item><item><title>Rust for Cross-Language System Libraries</title><link>https://libpasta.github.io/blog/bindings/</link><description>We have been building libpasta as a simple, usable solution to password hashing and migration. The goal for libpasta is to be a cross-platform, cross-language system library. libpasta is written in Rust, exports a C-style API, and builds to a static/shared library. Most languages support calling external libraries through foreign function interfaces (FFIs), and the end result can be seen in the documentation where each language has access to the libpasta functionality.</description><guid isPermaLink="false">3dc17991-d359-4205-917a-80b37a564b37</guid><pubDate>Wed, 21 Feb 2018 00:00:00 +0000</pubDate><dc:creator>libpasta</dc:creator></item><item><title>Snips Uses Rust to Build an Embedded Voice Assistant</title><link>https://blog.mozilla.org/blog/2018/02/21/snips-uses-rust-build-embedded-voice-assistant/</link><description>The team at Paris-based Snips has created a voice assistant that can be embedded in a single device or used in a home network to control lights, thermostat, music, and more. You can build a home hub on a Raspberry Pi and ask it for a weather report, to play your favorite song, or to brew up a double espresso. Manufacturers like Keecker are adding Snips’ technology to products like multimedia home robots. And Snips works closely with leaders across the value chain, like NVIDIA, EBV, and Analog Devices, in order to voice-enable an increasingly wider range of device types, from speakers to home automation systems to cars.</description><guid isPermaLink="false">8e33c7c4-2788-418b-8e47-ca8990ae0d38</guid><pubDate>Wed, 21 Feb 2018 12:34:56 -0800</pubDate><dc:creator>Judy DeMocker</dc:creator></item><item><title>Using macro to generate generic docs?</title><link>https://blog.guillaume-gomez.fr/articles/2018-02-19+Using+macro+to+generate+generic+docs%3F</link><description>We were recently able to finally make the docs for integer primitive types much more accurate (thanks to @antoyo!). Now, the code examples match the type for which they&apos;re written. No more i32 examples for i128 (I think you got the idea at this point)! Now, I think a few people might be interested by the method we used to achieve such a result so let&apos;s talk about it.</description><guid isPermaLink="false">c078b1d0-a902-42c5-84d0-5d262146e64c</guid><pubDate>Mon, 19 Feb 2018 00:00:00 +0000</pubDate><dc:creator>Guillaume Gomez</dc:creator></item><item><title>Ferrous Oxide For Jaguars And Incremented Crocodiles</title><link>https://eno.space/blog/2018/02/Ferrous-oxide-for-jaguars-and-incremented-crocodiles</link><description>Caveat lector: the primary purpose of the article is to introduce a reader proficient in one of the popular object-oriented languages how not to program in Rust. While each feature of the language will be briefly introduced where it is used, no great efforts will be made to explain the feature in detail. Links to the Rust book should provide that.</description><guid isPermaLink="false">5ecd2c77-20dd-4fd5-84a7-6c8e2364ebde</guid><pubDate>Thu, 15 Feb 2018 00:00:00 +0100</pubDate><dc:creator>@u0060</dc:creator></item><item><title>Rust things I miss in C</title><link>https://people.gnome.org/~federico/blog/rust-things-i-miss-in-c.html</link><description>Librsvg feels like it is reaching a tipping point, where suddenly it seems like it would be easier to just port some major parts from C to Rust than to just add accessors for them. Also, more and more of the meat of the library is in Rust now. I&apos;m switching back and forth a lot between C and Rust these days, and C feels very, very primitive these days.</description><guid isPermaLink="false">6d0e61c5-087e-48dc-abd8-ded4f3e43a8a</guid><pubDate>Sun, 18 Feb 2018 21:26:04 -0600</pubDate><dc:creator>Federico Mena Quintero</dc:creator></item><item><title>Sorting in Rust: Selection, Insertion, and Counting Sort</title><link>https://medium.com/@spyr1014/sorting-in-rust-selection-insertion-and-counting-sort-2c4d3575e364</link><description>Sorting is an invaluable skill and often covered early in a computer science curriculum. Have you ever tried to look up a friends phone number in an unsorted list!? You’d have to look at every single entry. Sorting creates all sorts of ways to access data quicker.</description><guid isPermaLink="false">f77cc701-eca9-4b85-a450-dd10c1766966</guid><pubDate>Sun, 18 Feb 2018 23:57:10 +0000</pubDate><dc:creator>Andrew Jakubowicz</dc:creator></item><item><title>Borrow cycles in Rust: arenas v.s. drop-checking</title><link>https://exyr.org/2018/rust-arenas-vs-dropck/</link><description>Ownership and borrowing are the fundamentals of data structures in Rust. However, both taking owneship of a value (moving it) or taking a reference to it can only happen after the value was created. This ordering seems to prevent having any cycle in a data structure, even though that’s sometimes useful or necessary. For example in a web page’s content tree, from any DOM node, one can easily access (if any) its first and last child, previous and next sibling, (so children of a node form a doubly-linked list) and parent. Some other applications might need to manipulate arbitrary graphs in their full generality.</description><guid isPermaLink="false">ff94e8a6-c203-4cbe-af46-8f99e2896dd8</guid><pubDate>Sat, 17 Feb 2018 00:00:00 +0000</pubDate><dc:creator>Simon Sapin</dc:creator></item><item><title>&quot;The Expressive C++17 Coding Challenge (in Rust)&quot; Revisited</title><link>http://words.steveklabnik.com/the-expressive-c-17-coding-challenge-in-rust-revisited</link><description>In October of last year, I wrote a post, “The Expressive C++17 Coding Challenge (in Rust)”. For various reasons, it got brought up again in the D world, and seb has written a new post. It’s good, you should check it out! However, it links to my gist, not my blog post. As I said back then: I held myself to the same constraints as the original contest; no external packages is a bit painful in Rust, but it’s not too bad. Mostly it would let me eliminate boilerplate while also improving correctness, and making the code a bit shorter. So, that got me thinking: What would this look like if I could use external packages? I took about an hour, and knocked it out. I have two versions to show you today, one where I pay no attention to allocations, and one where it’s zero-allocation.</description><guid isPermaLink="false">938457b4-8905-4954-9007-88c80a2c24d6</guid><pubDate>Wed, 14 Feb 2018 10:12:15 -0800</pubDate><dc:creator>Steve Klabnik</dc:creator></item><item><title>Reflecting on ppbert</title><link>https://vfoley.xyz/ppbert/</link><description>I had an itch: I was pretty-printing the BERT-encoded terms that we use in a production system at work and it was very slow. The Erlang shell took more than two minutes to dump the largest file. (It took about 0.1 second to read and parse the file; the rest was spent in io:format.) I decided to scratch that itch: I wrote ppbert, a command-line utility that reads BERT-encoded values and pretty-prints them. I’ve worked sporadically on ppbert for almost a year now, I use it daily at work, I’m happy with it, and I want to write about some of the things I learned during that journey.</description><guid isPermaLink="false">28ce1b60-8837-4443-87fb-669bf176db9b</guid><pubDate>Fri,  9 Feb 2018 00:00:00 +0000</pubDate><dc:creator>Vincent Foley</dc:creator></item><item><title>Maximally minimal specialization: always applicable impls</title><link>http://smallcultfollowing.com/babysteps/blog/2018/02/09/maximally-minimal-specialization-always-applicable-impls/</link><description>So aturon wrote this beautiful post about what a good week it has been. In there, they wrote: &quot;Breakthrough #2: @nikomatsakis had a eureka moment and figured out a path to make specialization sound, while still supporting its most important use cases (blog post forthcoming!). Again, this suddenly puts specialization on the map for Rust Epoch 2018&quot;. Sheesh I wish they hadn’t written that! Now the pressure is on. Well, here goes nothing =).</description><guid isPermaLink="false">c7a9c9d2-8858-4f47-afa3-19ec1f2f6b86</guid><pubDate>Fri,  9 Feb 2018 00:00:00 -0500</pubDate><dc:creator>Niko Matsakis</dc:creator></item><item><title>Closing out an incredible week in Rust</title><link>http://aturon.github.io/2018/02/09/amazing-week/</link><description>This week has been so amazing that I just had to write about it. Here’s a quick list of some of what went down in one week:</description><guid isPermaLink="false">325af8a8-af88-4a07-9c8f-16d2865f01f3</guid><pubDate>Fri,  9 Feb 2018 00:00:00 +0000</pubDate><dc:creator>Aaron Turon</dc:creator></item><item><title>Async/Await V: Getting back to the futures</title><link>https://boats.gitlab.io/blog/post/2018-02-08-async-v-getting-back-to-the-futures/</link><description>Two posts ago I proposed a particular interface for shipping self-referential generators this year. Immediately after that, eddyb showed me a better interface, which I described in the next post. Now, to tie everything together, its time to talk about how we can integrate this into the futures ecosystem. Starting point: this Generator API To begin, I want to document the generator API I’ll be using in this post, which is roughly what followed from my previous post:</description><guid isPermaLink="false">4924a3b4-b71f-4a15-ae2d-0a77bcb30e98</guid><pubDate>Thu,  8 Feb 2018 00:00:00 +0000</pubDate><dc:creator>boats</dc:creator></item><item><title>Async/Await IV: An Even Better Proposal</title><link>https://boats.gitlab.io/blog/post/2018-02-07-async-iv-an-even-better-proposal/</link><description>I did not plan to write this blog post. I thought that the fourth post in my series would explain how we could go from the generator API in my previous post to a futures API in which you don’t have to heap allocate every async call. But eddyb surprised me, and now I have to revisit the API in the previous post, because we can implement everything we need from immovability with a safe interface afterall.</description><guid isPermaLink="false">ac0c5546-f21b-4b47-b4a4-950464472aad</guid><pubDate>Wed,  7 Feb 2018 00:00:00 +0000</pubDate><dc:creator>boats</dc:creator></item><item><title>A vision for portability in Rust</title><link>http://aturon.github.io/2018/02/06/portability-vision/</link><description>TL;DR: This post proposes to deprecate the std facade, instead having a unified std that uses target- and capability-based cfgs to control API availability. Leave comments on internals!</description><guid isPermaLink="false">6e3c698d-7f42-43d4-9c08-2ee084945e5c</guid><pubDate>Tue,  6 Feb 2018 00:00:00 +0000</pubDate><dc:creator>Aaron Turon</dc:creator></item><item><title>Rust Lifetimes for the Uninitialised</title><link>http://asquera.de/blog/2018-01-29/rust-lifetimes-for-the-uninitialised/</link><description>Lifetimes are a interesting subject: a lot of people seem to gain a day-to-day familiarity with them, without fully understanding what they are. Maybe, they are truly Rust&apos;s Monads. Let&apos;s talk about what they are, where you encounter them and then how to get competent with them.</description><guid isPermaLink="false">c0b3d7ad-673f-4eb9-aa54-45447d1eafb0</guid><pubDate>Mon, 29 Jan 2018 15:30:00 +0100</pubDate><dc:creator>Florian Gilcher</dc:creator></item><item><title>Introduction to Procedural Macros</title><link>https://tinkering.xyz/posts/introduction-to-proc-macros/</link><description>As a newcomer to Rust, I heard the phrase “procedural macro” thrown around a lot without really understanding what it meant. I figured that I would learn about them if I ever needed them. Well, I’m working on the guts of relm, and a large chunk of it is procedural macros. I’ve learned enough about procedural macros to be dangerous, so I thought I would pass on some knowledge.</description><guid isPermaLink="false">f4e99fe5-2dab-418d-9256-813a75036164</guid><pubDate>Sat,  3 Feb 2018 19:36:37 -0500</pubDate><dc:creator>Zach Mitchell</dc:creator></item><item><title>Async/Await III: Moving Forward with Something Shippable</title><link>https://boats.gitlab.io/blog/post/2018-01-30-async-iii-moving-forward/</link><description>In the first post, we looked at the relationship between generators and a more general notion of self-references. In the second post, we narrowed down exactly what problem we need to solve to make generators work, and talked about some solutions that we’ve considered but don’t feel like we could ship in the near future.
In the original post, I promised that I would have a near term solution by the end of this series.</description><guid isPermaLink="false">25060712-7d38-4492-991d-a52a9111891c</guid><pubDate>Sun,  4 Feb 2018 00:00:00 +0000</pubDate><dc:creator>boats</dc:creator></item></channel></rss>