<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/"><channel><title>Read Rust - Language</title><link>https://readrust.net/</link><description>Language posts on Read Rust</description><item><title>Reflecting on ppbert</title><link>https://vfoley.xyz/ppbert/</link><description>I had an itch: I was pretty-printing the BERT-encoded terms that we use in a production system at work and it was very slow. The Erlang shell took more than two minutes to dump the largest file. (It took about 0.1 second to read and parse the file; the rest was spent in io:format.) I decided to scratch that itch: I wrote ppbert, a command-line utility that reads BERT-encoded values and pretty-prints them. I’ve worked sporadically on ppbert for almost a year now, I use it daily at work, I’m happy with it, and I want to write about some of the things I learned during that journey.</description><guid isPermaLink="false">28ce1b60-8837-4443-87fb-669bf176db9b</guid><pubDate>Fri,  9 Feb 2018 00:00:00 +0000</pubDate><dc:creator>Vincent Foley</dc:creator></item><item><title>Maximally minimal specialization: always applicable impls</title><link>http://smallcultfollowing.com/babysteps/blog/2018/02/09/maximally-minimal-specialization-always-applicable-impls/</link><description>So aturon wrote this beautiful post about what a good week it has been. In there, they wrote: &quot;Breakthrough #2: @nikomatsakis had a eureka moment and figured out a path to make specialization sound, while still supporting its most important use cases (blog post forthcoming!). Again, this suddenly puts specialization on the map for Rust Epoch 2018&quot;. Sheesh I wish they hadn’t written that! Now the pressure is on. Well, here goes nothing =).</description><guid isPermaLink="false">c7a9c9d2-8858-4f47-afa3-19ec1f2f6b86</guid><pubDate>Fri,  9 Feb 2018 00:00:00 -0500</pubDate><dc:creator>Niko Matsakis</dc:creator></item><item><title>Closing out an incredible week in Rust</title><link>http://aturon.github.io/2018/02/09/amazing-week/</link><description>This week has been so amazing that I just had to write about it. Here’s a quick list of some of what went down in one week:</description><guid isPermaLink="false">325af8a8-af88-4a07-9c8f-16d2865f01f3</guid><pubDate>Fri,  9 Feb 2018 00:00:00 +0000</pubDate><dc:creator>Aaron Turon</dc:creator></item><item><title>Async/Await V: Getting back to the futures</title><link>https://boats.gitlab.io/blog/post/2018-02-08-async-v-getting-back-to-the-futures/</link><description>Two posts ago I proposed a particular interface for shipping self-referential generators this year. Immediately after that, eddyb showed me a better interface, which I described in the next post. Now, to tie everything together, its time to talk about how we can integrate this into the futures ecosystem. Starting point: this Generator API To begin, I want to document the generator API I’ll be using in this post, which is roughly what followed from my previous post:</description><guid isPermaLink="false">4924a3b4-b71f-4a15-ae2d-0a77bcb30e98</guid><pubDate>Thu,  8 Feb 2018 00:00:00 +0000</pubDate><dc:creator>boats</dc:creator></item><item><title>Async/Await IV: An Even Better Proposal</title><link>https://boats.gitlab.io/blog/post/2018-02-07-async-iv-an-even-better-proposal/</link><description>I did not plan to write this blog post. I thought that the fourth post in my series would explain how we could go from the generator API in my previous post to a futures API in which you don’t have to heap allocate every async call. But eddyb surprised me, and now I have to revisit the API in the previous post, because we can implement everything we need from immovability with a safe interface afterall.</description><guid isPermaLink="false">ac0c5546-f21b-4b47-b4a4-950464472aad</guid><pubDate>Wed,  7 Feb 2018 00:00:00 +0000</pubDate><dc:creator>boats</dc:creator></item><item><title>A vision for portability in Rust</title><link>http://aturon.github.io/2018/02/06/portability-vision/</link><description>TL;DR: This post proposes to deprecate the std facade, instead having a unified std that uses target- and capability-based cfgs to control API availability. Leave comments on internals!</description><guid isPermaLink="false">6e3c698d-7f42-43d4-9c08-2ee084945e5c</guid><pubDate>Tue,  6 Feb 2018 00:00:00 +0000</pubDate><dc:creator>Aaron Turon</dc:creator></item><item><title>Rust Lifetimes for the Uninitialised</title><link>http://asquera.de/blog/2018-01-29/rust-lifetimes-for-the-uninitialised/</link><description>Lifetimes are a interesting subject: a lot of people seem to gain a day-to-day familiarity with them, without fully understanding what they are. Maybe, they are truly Rust&apos;s Monads. Let&apos;s talk about what they are, where you encounter them and then how to get competent with them.</description><guid isPermaLink="false">c0b3d7ad-673f-4eb9-aa54-45447d1eafb0</guid><pubDate>Mon, 29 Jan 2018 15:30:00 +0100</pubDate><dc:creator>Florian Gilcher</dc:creator></item><item><title>Introduction to Procedural Macros</title><link>https://tinkering.xyz/posts/introduction-to-proc-macros/</link><description>As a newcomer to Rust, I heard the phrase “procedural macro” thrown around a lot without really understanding what it meant. I figured that I would learn about them if I ever needed them. Well, I’m working on the guts of relm, and a large chunk of it is procedural macros. I’ve learned enough about procedural macros to be dangerous, so I thought I would pass on some knowledge.</description><guid isPermaLink="false">f4e99fe5-2dab-418d-9256-813a75036164</guid><pubDate>Sat,  3 Feb 2018 19:36:37 -0500</pubDate><dc:creator>Zach Mitchell</dc:creator></item><item><title>Async/Await III: Moving Forward with Something Shippable</title><link>https://boats.gitlab.io/blog/post/2018-01-30-async-iii-moving-forward/</link><description>In the first post, we looked at the relationship between generators and a more general notion of self-references. In the second post, we narrowed down exactly what problem we need to solve to make generators work, and talked about some solutions that we’ve considered but don’t feel like we could ship in the near future.
In the original post, I promised that I would have a near term solution by the end of this series.</description><guid isPermaLink="false">25060712-7d38-4492-991d-a52a9111891c</guid><pubDate>Sun,  4 Feb 2018 00:00:00 +0000</pubDate><dc:creator>boats</dc:creator></item></channel></rss>