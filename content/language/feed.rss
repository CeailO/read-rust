<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/"><channel><title>Read Rust - Language</title><link>https://readrust.net/</link><description>Language posts on Read Rust</description><item><title>The Rustc Learning Working Group - An Introduction</title><link>https://blog.rust-lang.org/inside-rust/2019/10/28/rustc-learning-working-group-introduction.html</link><description><![CDATA[The Learning Working Group, formed in April 2019, is focused on making the compiler easier to learn by ensuring that rustc-guide and API docs are "complete". It is one of the many efforts by the Rust Compiler team to decrease the barrier of contributing to the compiler.]]></description><guid isPermaLink="false">884f2a1b-a04c-44b4-ae44-c7f1b489cbc6</guid><pubDate>Mon, 28 Oct 2019 00:00:00 +0000</pubDate><dc:creator>Amanjeev Sethi</dc:creator></item><item><title>Programming Servo: the incredibly shrinking timer</title><link>https://medium.com/programming-servo/programming-servo-the-incredibly-shrinking-timer-7283ae2a2669</link><description><![CDATA[How to build a timer in Rust in five easy evolutionary steps.]]></description><guid isPermaLink="false">49a2176c-55b0-4603-8f20-d0d15ab56ca4</guid><pubDate>Sun, 27 Oct 2019 15:40:54 +0000</pubDate><dc:creator>Gregory Terzian</dc:creator></item><item><title>Audio Processing for Dummies</title><link>http://adventures.michaelfbryan.com/posts/audio-processing-for-dummies/</link><description><![CDATA[In my spare time I’m an emergency services volunteer, and one of the tasks our unit has is to run the radio network and keep track of what’s happening. This can be a pretty stressful job, especially when there’s lots of radio traffic, and it’s not unusual to miss words or entire transmissions.

To help with a personal project that could make the job easier I’d like to implement a basic component of audio processing, the Noise Gate.]]></description><guid isPermaLink="false">6d1c1c33-6e97-4911-af35-4b6e621da968</guid><pubDate>Sun, 27 Oct 2019 23:34:00 +0800</pubDate><dc:creator>Michael-F-Bryan</dc:creator></item><item><title>Why async fn in traits are hard</title><link>http://smallcultfollowing.com/babysteps/blog/2019/10/26/async-fn-in-traits-are-hard/</link><description><![CDATA[After reading boat’s excellent post on asynchronous destructors, I thought it might be a good idea to write some about async fn in traits. Support for async fn in traits is probably the single most common feature request that I hear about. It’s also one of the more complex topics. So I thought it’d be nice to do a blog post kind of giving the “lay of the land” on that feature – what makes it complicated? What questions remain open?]]></description><guid isPermaLink="false">da517b10-2b8a-4b94-97c3-34b0c049de42</guid><pubDate>Sat, 26 Oct 2019 00:00:00 -0400</pubDate><dc:creator>Niko Matsakis</dc:creator></item><item><title>Announcing the LLVM ICE-breaker group</title><link>https://blog.rust-lang.org/inside-rust/2019/10/22/LLVM-ICE-breakers.html</link><description><![CDATA[Today I'm announcing a new experiment in the compiler team, the LLVM ICE-breaker group. If you're familiar with LLVM and would like to contribute to rustc -- but without taking on a large commitment -- then the LLVM ICE-breaker group might well be for you!]]></description><guid isPermaLink="false">5a7311d2-3cf3-47fa-bce5-10b0747b30e8</guid><pubDate>Tue, 22 Oct 2019 00:00:00 +0000</pubDate><dc:creator>Niko Matsakis</dc:creator></item><item><title>How to not rewrite it in Rust</title><link>http://adventures.michaelfbryan.com/posts/how-not-to-riir/</link><description><![CDATA[Once you get past the growing pains of the Borrow Checker and realise Rust gives you the power to do things which would be unheard of (or just plain dangerous) in other languages, the temptation to Rewrite it in Rust can be quite strong. However at best, the temptation to RiiR is unproductive (unnecessary duplication of effort), and at worst it can promote the creation of buggy software (why would you be better equipped to write a library for some domain-specific purpose than the original author?]]></description><guid isPermaLink="false">e8d05615-a728-4bea-8f43-400827903e1a</guid><pubDate>Sun, 20 Oct 2019 19:45:00 +0800</pubDate><dc:creator>Michael-F-Bryan</dc:creator></item><item><title>Cost of rust-analyzer</title><link>https://rust-analyzer.github.io/2019/10/16/finance.html</link><description><![CDATA[In this post, we’ll talk about financial side of the rust-analyzer project. The goal is to find out how much rust-analyzer costs now, formulate financial goals for speeding up the development and document the Open Collective expenses policy.]]></description><guid isPermaLink="false">6e9b1816-3105-4847-b96e-d3af713b9ebc</guid><pubDate>Wed, 16 Oct 2019 09:00:00 +0000</pubDate><dc:creator>Aleksey Kladov</dc:creator></item><item><title>Asynchronous Destructors</title><link>https://boats.gitlab.io/blog/post/poll-drop/</link><description><![CDATA[The first version of async/await syntax is in the beta release, set to be shipped to stable in 1.39 on November 7, next month. There are a wide variety of additional features we could add to async/await in Rust beyond what we’re shipping in that release, but speaking for myself I know that I’d like to pump the breaks on pushing forward big ticket items in this space. Let’s let the ecosystem develop around what we have now before we start sprinting toward more big additions to the language.]]></description><guid isPermaLink="false">9b853968-186e-414b-af4a-f4a6cf9e7392</guid><pubDate>Wed, 16 Oct 2019 00:00:00 +0000</pubDate><dc:creator>boats</dc:creator></item><item><title>Announcing Rustup 1.20.0</title><link>https://blog.rust-lang.org/2019/10/15/Rustup-1.20.0.html</link><description><![CDATA[The highlights of this release are profiles support, the ability to get the latest available nightly with all the components you need, and improvements to the rustup doc command. You can also check out the changelog for a list of all the changes included in this release.]]></description><guid isPermaLink="false">8629a67f-d7a6-41e9-80b1-e568f491c325</guid><pubDate>Tue, 15 Oct 2019 00:00:00 +0000</pubDate><dc:creator>The Rustup Working Group</dc:creator></item><item><title>Detecting Application Uniqueness and interprocess communication in Rust</title><link>https://gitlab.com/snippets/1903637</link><description><![CDATA[The aim of this article is to demonstrate one of many ways to detect application uniqueness and establish unilateral interprocess communication in Rust in the Linux platform. Note that the APIs used in this article is not portable to Windows and other *nix systems. Also note that methods used in this article may not be best suitable for all use cases.]]></description><guid isPermaLink="false">8b2ade3b-1476-4770-a7e2-838c3623a381</guid><pubDate>Mon, 14 Oct 2019 00:00:00 +0000</pubDate><dc:creator>9898287</dc:creator></item><item><title>We couldn&apos;t get Bitcode and Rust to play nice, until we did</title><link>https://www.ditto.live/blog/rust-bitcode-with-xcode</link><description><![CDATA[The Rust compiler has problems creating Bitcode that's compatible with recent versions of Xcode. Ditto uses a custom toolchain that stays in sync with Apple—and you can too.]]></description><guid isPermaLink="false">dabffd4d-73ef-4700-8711-b648230659b9</guid><pubDate>Thu, 10 Oct 2019 00:00:00 +0000</pubDate><dc:creator>Tom Karpiniec</dc:creator></item><item><title>The Node Experiment - Exploring Async Basics with Rust</title><link>https://cfsamson.github.io/book-exploring-async-basics/</link><description><![CDATA[After originally researching the history and discussions about Rusts Async story, I realized I needed a better understanding of async basics and the result is this book. It's published it as a gitbook to make this journey easier for the next person (hopefully).]]></description><guid isPermaLink="false">e131911e-9ccb-4b6f-9c05-f95611cb66d2</guid><pubDate>Thu, 10 Oct 2019 00:00:00 +0000</pubDate><dc:creator>Carl Fredrik Samson</dc:creator></item><item><title>How I handle errors in Rust</title><link>https://blog.kiani.io/blog/how-i-handle-errors-in-rust/</link><description><![CDATA[derive_more is a crate which has many proc macros, amongst which is a macro for deriving From for structs, enums, and newtypes. From is the basic mechanism for using ? ergonomically in a function which returns Result<T, Error>. Almost everything I write has the derive_more crate as a dependency, and the following pattern for handling errors.]]></description><guid isPermaLink="false">79f41426-ad58-4eac-9adb-88b27c2a63ba</guid><pubDate>Wed,  9 Oct 2019 00:00:00 +0000</pubDate><dc:creator>Ashkan Kiani</dc:creator></item><item><title>Designing a COM library for Rust</title><link>https://msrc-blog.microsoft.com/2019/10/08/designing-a-com-library-for-rust/</link><description><![CDATA[I interned with Microsoft as a Software Engineering Intern in the MSRC UK team in Cheltenham this past summer. I worked in the Safe Systems Programming Language (SSPL) group, which explores safe programming languages as a proactive measure against memory-safety related vulnerabilities.

This blog post describes the project that I have been working on under the mentorship of the SSPL team. Hopefully, this provides additional insight into the work Microsoft interns do! My goal was to build an open-sourced Rust library that will allow developers to both consume and produce in-process Component Object Model (COM) components in an idiomatic manner.]]></description><guid isPermaLink="false">409c73c3-8c32-4c3a-97a9-30f700237fe8</guid><pubDate>Tue,  8 Oct 2019 17:00:03 +0000</pubDate><dc:creator>Hadrian Wei Heng Lim</dc:creator></item><item><title>Why we’re bringing Astropad cross-platform with Rust</title><link>https://blog.astropad.com/why-rust/</link><description><![CDATA[Over the past few years, we’ve heard over and over again about an exodus from Mac to Windows in the creative community. Here at Astropad, we’ve kept a close eye on this shift, knowing that Windows would be a big part of our company’s future. Our flagship products — Astropad Studio and Luna Display — primarily serve the creative pro market. Both products run on our low-latency, high-fidelity video streaming technology called Liquid that was designed to meet the demands of professional illustrators, animators, and photographers.

When we were first building our products, we used the tools we were most comfortable with, like Objective-C and the Cocoa APIs. This allowed us to move quickly, launch Astropad 1.0, and establish product-market fit in a relatively short period of time. But as we grew, we made the mistake of doubling down on Objective-C, and we pushed off the Windows effort because it created a catch-22 situation of engineering hurdles. Our Liquid engine was tightly wrapped around the Apple ecosystem, and the thought of unraveling ourselves was hard to imagine. ]]></description><guid isPermaLink="false">6907953b-62d5-475e-8695-0e89fec37b5e</guid><pubDate>Mon,  7 Oct 2019 19:23:43 +0000</pubDate><dc:creator>Matt Ronge</dc:creator></item><item><title>Async Foundations Update: Time for polish!</title><link>https://blog.rust-lang.org/inside-rust/2019/10/07/AsyncAwait-WG-Focus-Issues.html</link><description><![CDATA[As you've perhaps heard, recently the async-await feature landed on the Rust beta branch. This marks a big turning point in the usability story for Async Rust. But there's still a lot of work to do. As we mentioned in the main post, the focus for the Async Foundations WG in the immediate term is going to be polish, polish and (ahem) more polish.

In particular, we want to take aim at a backlog of strange diagnostics, suboptimal performance, and the occasional inexplicable type-check failure. This is a shift: whereas before, we could have laser focus on things that truly blocked stabilization, we've now got a large set of bugs, often without a clear prioritization between them. This requires us to mix up how the Async Foundations WG is operating.]]></description><guid isPermaLink="false">15c5520b-d7f9-4acc-939f-371cb8fbab95</guid><pubDate>Mon,  7 Oct 2019 00:00:00 +0000</pubDate><dc:creator>Niko Matsakis</dc:creator></item><item><title>The &quot;Inside Rust&quot; Blog</title><link>https://blog.rust-lang.org/inside-rust/</link><description><![CDATA[This is the "Inside Rust" blog. This blog is aimed at those who wish to follow along with Rust development. The various Rust teams and working groups use this blog to post status updates, calls for help, and other similar announcements.]]></description><guid isPermaLink="false">55e7a635-29bd-4a2d-aaac-b0d599006ff7</guid><pubDate>Fri,  4 Oct 2019 01:18:00 +0000</pubDate><dc:creator>Niko Matsakis</dc:creator></item><item><title>Building the Azure IoT Edge Security Daemon in Rust</title><link>https://msrc-blog.microsoft.com/2019/09/30/building-the-azure-iot-edge-security-daemon-in-rust/</link><description><![CDATA[Azure IoT Edge is an open source, cross platform software project from the Azure IoT team at Microsoft that seeks to solve the problem of managing distribution of compute to the edge of your on-premise network from the cloud. This post explains some of the rationale behind our choice of Rust as the implementation programming language for the Security Daemon component in the product.]]></description><guid isPermaLink="false">f7d6bffe-ea86-4fbc-9aa6-4ba15b3929a5</guid><pubDate>Mon, 30 Sep 2019 16:45:48 +0000</pubDate><dc:creator>Raj Vengalil</dc:creator></item><item><title>Plugins in Rust</title><link>http://adventures.michaelfbryan.com/posts/plugins-in-rust/</link><description><![CDATA[Imagine you are implementing a calculator application and want users to be able to extend the application with their own functionality. For example, imagine a user wants to provide a random() function that generates true random numbers using random.org instead of the pseudo-random numbers that a crate like rand would provide.

The Rust language gives you a lot of really powerful tools for adding flexibility and extensibility to your applications (e.g. traits, enums, macros), but all of these happen at compile time. Unfortunately, to get the flexibility that we’re looking we’ll need to be able to add new functionalty at runtime. This can be achieved using a technique called Dynamic Loading.]]></description><guid isPermaLink="false">7a86a452-ec34-4489-b209-f91aecdd6d98</guid><pubDate>Mon, 30 Sep 2019 22:04:58 +0800</pubDate><dc:creator>Michael-F-Bryan</dc:creator></item><item><title>Async-await hits beta!</title><link>https://blog.rust-lang.org/2019/09/30/Async-await-hits-beta.html</link><description><![CDATA[Big news! As of this writing, syntactic support for async-await is available in the Rust beta channel! It will be available in the 1.39 release, which is expected to be released on November 7th, 2019. Once async-await hits stable, that will mark the culmination of a multi-year effort to enable efficient and ergonomic asynchronous I/O in Rust. It will not, however, mark the end of the road: there is still more work to do, both in terms of polish (some of the error messages we get today are, um, not great) and in terms of feature set (async fn in traits, anyone?).]]></description><guid isPermaLink="false">fbf09d15-52c8-4ab6-a6bf-22c0b238aedb</guid><pubDate>Mon, 30 Sep 2019 00:00:00 +0000</pubDate><dc:creator>Niko Matsakis</dc:creator></item><item><title>Figthting The Async Fragmentation</title><link>https://vorner.github.io/2019/09/29/figthting-the-async-fragmentation.html</link><description><![CDATA[Sometimes, I get this nudging feeling that something is not exactly right and that I have to go out and save the world and fix it (even though it’s usually something minor or doesn’t need fixing at all). I guess everyone has days like these. It’s part what drives me to invest my free time to writing software.

This is about some dead ends when trying to fix the problem of Rust’s async networking fragmentation. I haven’t been successful, but I can at least share what I tried and discovered, maybe someone else is having the same bugging feeling so they don’t have to repeat them. Or just maybe some of the approaches would work for some other problems. And because we have a bunch of success stories out there, having some failure stories to balance it doesn’t hurt.]]></description><guid isPermaLink="false">51a1a155-fccb-426f-b0e5-f4670be28e9d</guid><pubDate>Sun, 29 Sep 2019 00:00:00 +0000</pubDate><dc:creator>Michal &apos;vorner&apos; Vaner</dc:creator></item><item><title>Announcing Rust 1.38.0</title><link>https://blog.rust-lang.org/2019/09/26/Rust-1.38.0.html</link><description><![CDATA[The highlight of this release is pipelined compilation. The release also includes linting of some incorrect uses of mem::{uninitialized, zeroed}, #[deprecated] macros, std::any::type_name, and more.]]></description><guid isPermaLink="false">d9b796b1-aacb-4a2f-ad7b-05ce22cc3ec1</guid><pubDate>Thu, 26 Sep 2019 00:00:00 +0000</pubDate><dc:creator>The Rust Release Team</dc:creator></item><item><title>Async Builders</title><link>https://blog.yoshuawuyts.com/async-finalizers/</link><description><![CDATA[Last month we introduced Surf, an async cross-platform streaming HTTP client for Rust. It was met with a great reception, and people generally seem to be really enjoying it. A common piece of feedback we've gotten is how much people enjoy the interface, in particular how little code it requires to create HTTP requests. In this post we'll cover a pattern at the heart of Surf's ergonomics stjepang came up with: the "async finalizer".]]></description><guid isPermaLink="false">258e95ec-03a2-47b2-b577-cf45ad96924e</guid><pubDate>Sat, 21 Sep 2019 00:00:00 +0000</pubDate><dc:creator>Yoshua Wuyts</dc:creator></item><item><title>Futures Concurrency</title><link>https://blog.yoshuawuyts.com/futures-concurrency/</link><description><![CDATA[In a previous post we've looked at Rust streams. In this post we're going to discuss another problem in the async space: futures concurrency combinators. We're going to cover the different forms of concurrency that can be expressed with Futures, and cover both fallible and infallible variants.]]></description><guid isPermaLink="false">d821223f-0e0c-4bbf-a248-7191d0c0c1da</guid><pubDate>Mon,  2 Sep 2019 00:00:00 +0000</pubDate><dc:creator>Yoshua Wuyts</dc:creator></item><item><title>How Rust optimizes async/await II: Program analysis</title><link>https://tmandry.gitlab.io/blog/posts/optimizing-await-2/</link><description><![CDATA[In Part 1, we covered how async fns in Rust are compiled to state machines. We saw that the internal compiler implementation uses generators and the yield statement to facilitate this transformation. In this post, we'll go over some subtleties that the compiler implementation must consider when optimizing generators. We'll look at two different kinds of analysis, liveness analysis and storage conflict detection.]]></description><guid isPermaLink="false">7304ebe7-ee28-48a9-b88c-dd03e2605a10</guid><pubDate>Mon,  2 Sep 2019 00:00:00 +0000</pubDate><dc:creator>Tyler Mandry</dc:creator></item><item><title>Async Stack Traces in Rust</title><link>http://fitzgeraldnick.com/2019/08/27/async-stacks-in-rust.html</link><description><![CDATA[One neat result of Rust’s futures and async/await design is that all of the async callers are on the stack below the async callees. In most other languages, only the youngest async callee is on the stack, and none of the async callers. Because the youngest frame is most often not where a bug’s root cause lies, this extra context makes debugging async code easier in Rust.]]></description><guid isPermaLink="false">518da2d7-644e-4028-95a2-388b2cb5fc0f</guid><pubDate>Tue, 27 Aug 2019 00:00:00 -0700</pubDate><dc:creator>Nick Fitzgerald</dc:creator></item><item><title>Wrapping Unsafe C Libraries in Rust</title><link>https://medium.com/dwelo-r-d/wrapping-unsafe-c-libraries-in-rust-d75aeb283c65</link><description><![CDATA[In this article, we will explore how to wrap those functions and make them safe for normal use. We’ll go over how to define a wrapper struct that handles initialization and cleanup, and describe some traits that describe how application developers can safely use your library with threads. We’ll also talk a bit about how to turn a function’s random integer return into an ergonomic, type-checked Result, how to translate strings and arrays to and from the world of C, and how to turn raw pointers returned from C into scoped objects with inherited lifetimes.

The overall goal of this step is to dig into the C library’s documentation and make each function’s internal assumptions explicit.]]></description><guid isPermaLink="false">eb9194f2-85b1-412c-aa0b-0218529bf163</guid><pubDate>Sat, 24 Aug 2019 07:09:28 +0000</pubDate><dc:creator>Jeff Hiner</dc:creator></item><item><title>Is This Magic!? Ferris Explores Rustc!</title><link>https://quietmisdreavus.net/code/2019/08/23/is-this-magic-ferris-explores-rustc/</link><description><![CDATA[A companion to the RustConf 2019 talk with the same name; an introduction to making your first contribution to the Rust compiler.]]></description><guid isPermaLink="false">63fb93a7-e179-491f-83b9-84a7e284fe48</guid><pubDate>Fri, 23 Aug 2019 11:00:00 -0500</pubDate><dc:creator>QuietMisdreavus</dc:creator></item><item><title>Join Your Threads</title><link>https://matklad.github.io/2019/08/23/join-your-threads.html</link><description><![CDATA[This is a note on how to make multithreaded programs more robust. It’s not really specific to Rust, but I get to advertise my new jod-thread micro-crate :)]]></description><guid isPermaLink="false">c50ebb87-7e8f-4d08-bc8c-ebe51377faf4</guid><pubDate>Fri, 23 Aug 2019 00:00:00 +0000</pubDate><dc:creator>Aleksey Kladov</dc:creator></item><item><title>Thoughts on Rust bloat</title><link>https://raphlinus.github.io/rust/2019/08/21/rust-bloat.html</link><description><![CDATA[I’m about to accept a PR that will increase druid’s compile time about 3x and its executable size almost 2x. In this case, I think the tradeoff is worth it (without localization, a GUI toolkit is strictly a toy), but the bloat makes me unhappy and I think there is room for improvement in the Rust ecosystem.]]></description><guid isPermaLink="false">5b9044be-428f-48ff-b1f3-b9f0e6b63732</guid><pubDate>Wed, 21 Aug 2019 17:17:42 +0000</pubDate><dc:creator>Raph Levien</dc:creator></item><item><title>Introduction</title><link>https://rust-lang.github.io/compiler-team/</link><description><![CDATA[A home for compiler team planning documents, meeting minutes, and other such things. If you’re interested in learning about how rustc works – as well as advice on building the compiler, preparing a PR, and other similar topics – check out the rustc-guide.]]></description><guid isPermaLink="false">6f824da5-4033-40da-994f-581a7909e50e</guid><pubDate>Sun, 18 Aug 2019 04:30:25 +0000</pubDate><dc:creator>Rust Lang Compiler Team</dc:creator></item><item><title>Using C Libraries in Rust</title><link>https://medium.com/dwelo-r-d/using-c-libraries-in-rust-13961948c72a</link><description><![CDATA[Today I want to dig into one of the difficulties we ran into while trying to rewrite our IoT Python code in Rust: specifically FFI, or the “Foreign Function Interface” — the bit that allows Rust to interact with other languages. When I tried to write Rust code to integrate with C libraries a year ago, the existing documents and guides often gave conflicting advice, and I had to stumble through the process on my own. This guide is intended to help future Rustaceans work through the process of porting C libraries to Rust, and familiarize the reader with the most common problems we encountered while doing the same.]]></description><guid isPermaLink="false">86fe455b-cfd7-472b-860b-2d969a8cd5ba</guid><pubDate>Sat, 17 Aug 2019 00:22:36 +0000</pubDate><dc:creator>Jeff Hiner</dc:creator></item><item><title>Understanding Futures in Rust -- Part 2</title><link>https://www.viget.com/articles/understanding-futures-is-rust-part-2/</link><description><![CDATA[If you're familiar with promises in JavaScript and followed the last blog post you may have been confused about where the familiar combinators (then, catch, and finally) were in the previous post. You will find their equivalents in this post, and, by the end, the following code will compile. You will also gain an understanding of the types, traits, and underling concepts that make futures work.]]></description><guid isPermaLink="false">4bf39b49-7652-4132-8a42-c12c7d922ab9</guid><pubDate>Thu, 15 Aug 2019 00:00:00 +0000</pubDate><dc:creator>Joe Jackson</dc:creator></item><item><title>Announcing Rust 1.37.0</title><link>https://blog.rust-lang.org/2019/08/15/Rust-1.37.0.html</link><description><![CDATA[The highlights of Rust 1.37.0 include referring to enum variants through type aliases, built-in cargo vendor, unnamed const items, profile-guided optimization, a default-run key in Cargo, and #[repr(align(N))] on enums. Read on for a few highlights, or see the detailed release notes for additional information.]]></description><guid isPermaLink="false">76cefd5b-2344-4629-84fb-5bf5c45c0ce0</guid><pubDate>Thu, 15 Aug 2019 00:00:00 +0000</pubDate><dc:creator>The Rust Release Team</dc:creator></item><item><title>Updating to Async/Await</title><link>https://leshow.github.io/post/async_await/</link><description><![CDATA[We’re pleased to announce the release of the first Tokio alpha with async & await support. This includes updating all of the Tokio crates to use std::future instead of futures 0.1. It also includes adding async fn versions of the APIs.]]></description><guid isPermaLink="false">dac15914-213c-4397-8485-eb2156b0e88b</guid><pubDate>Mon, 12 Aug 2019 09:30:08 -0400</pubDate><dc:creator>Evan Cameron</dc:creator></item><item><title>Runtime Configuration Reloading</title><link>https://vorner.github.io/2019/08/11/runtime-configuration-reloading.html</link><description><![CDATA[A lot of programs need to read some kind of configuration at startup. But the challenge doesn’t end here. Some programs ‒ certainly not all, but some ‒ are long running. For these, restarting them to change configuration isn’t something you’d want to do. The unix daemon convention is to send a SIGHUP signal to the process.]]></description><guid isPermaLink="false">2938c850-88bc-4bec-b0fb-f2561f4a0b17</guid><pubDate>Sun, 11 Aug 2019 00:00:00 +0000</pubDate><dc:creator>Michal &apos;vorner&apos; Vaner</dc:creator></item><item><title>Parsing Rust Strings into Slices</title><link>https://wduquette.github.io/parsing-strings-into-slices/</link><description><![CDATA[A Rust String is a vector of bytes containing a UTF-8 string, which is an uneasy combination. You can’t simply index into a String: the compiler forbids it, because you’re far too likely to get one byte of a multi-byte UTF-8 char. Instead you need to use a Chars iterator to parse out the string character by character.]]></description><guid isPermaLink="false">318ffc1c-1f3c-4d9a-b5ea-edaa476d3438</guid><pubDate>Sat, 10 Aug 2019 00:00:00 +0000</pubDate><dc:creator>Will Duquette</dc:creator></item><item><title>Follow-up to Method on Emulating Higher-Kinded Types (HKTs) in Rust</title><link>https://gist.github.com/edmundsmith/e09d5f473172066c0023ef84ee830cad</link><description><![CDATA[First off, thanks for all the comments and kind words on the original writeup; I've been meaning to follow up on some of the suggestions and write about the different ways to represent monads (and functors, HKTs, etc) that now exist, but a month of being busy has kind of gotten in the way (mainly with three new kittens!).

And for sure, I do not expect (nor do I want) this to become the norm for production-level Rust: rather, I hope that this can contribute to the foundations of programming with higher-level abstractions in Rust, somewhat like how early template metaprogramming in C++ and typeclass-constraint-unification metaprogramming in Haskell have contributed, perhaps indirectly, to later innovations in their respective languages and ecosystems that were much more reasoned, sound and usable.]]></description><guid isPermaLink="false">2a87f758-3eaf-4971-a00f-02f3175d0db5</guid><pubDate>Thu,  8 Aug 2019 11:44:35 +0000</pubDate><dc:creator>Edmund Smith</dc:creator></item><item><title>Await a minute, why bother?</title><link>https://docs.rs/dtolnay/0.0.5/dtolnay/macro._01__await_a_minute.html</link><description><![CDATA[Recently I have been retooling some core Rust libraries at $work to play nicely with native async/await syntax. This note covers my thoughts on why this feature is so important to our async codebase if it's "just" syntax sugar for a job that could just be done using raw Futures instead.]]></description><guid isPermaLink="false">902d33e4-a66a-479e-8758-f543083da639</guid><pubDate>Thu,  8 Aug 2019 00:00:00 +0000</pubDate><dc:creator>David Tolnay</dc:creator></item><item><title>My First Three Months With Rust</title><link>https://blog.aclysma.com/my-first-three-months-with-rust/</link><description><![CDATA[I’ve used C++ professionally in games and simulations for over 10 years, and in the past few years I’ve also used C# to build distributed backend systems. Lately, I’ve been exploring Rust.]]></description><guid isPermaLink="false">27ce3b2b-a0fc-4cf2-ade4-1d4bcd1dabf7</guid><pubDate>Wed,  7 Aug 2019 19:13:41 +0000</pubDate><dc:creator>Philip Degarmo</dc:creator></item><item><title>My Thoughts on Rust&apos;s Future: A Positive Outlook</title><link>https://cprimozic.net/blog/my-thoughts-on-rusts-future/</link><description><![CDATA[I'm feeling really positive about Rust's prospects of popularity and wide-spread adoption in the future. I've been a part of the Rust community for three years now, and it feels like the stars are starting to align in order to let Rust jump into a position of dominance in the programming language world. There are several different, wide-spread, and mostly unrelated trends that I've noticed are all coming together with positive implications for Rust.]]></description><guid isPermaLink="false">ac36b146-f880-46e7-9f3f-819ab9daefa8</guid><pubDate>Sat,  3 Aug 2019 00:00:00 +0000</pubDate><dc:creator>Casey Primozic</dc:creator></item><item><title>Rust: safe and unsafe as theorems and axioms</title><link>https://iandouglasscott.com/2019/07/26/rust-safe-and-unsafe-as-theorems-and-axioms/</link><description><![CDATA[There is a fair amount of confusion about what unsafe means in Rust, as well as debate about how one should think about it. Recently I’ve seen several blog posts like What is Rust’s unsafe?, The Temptation of Unsafe and Unsafe as a Human-Assisted Type System. I’m not really attempting to explain what is considered unsafe in Rust, which is explained by the reference. Nor am I going to try to answer the question of precisely when unsafe should be used and how often. My basic suggestion: we can think of unsafe in terms of mathematical axioms and theorems. This understanding is somewhere in between actual mathematical rigour and an analogy.]]></description><guid isPermaLink="false">398562a1-3ec5-4277-8a7c-5c3388fed5ba</guid><pubDate>Fri, 26 Jul 2019 15:37:00 -0700</pubDate><dc:creator>Ian Douglas Scott</dc:creator></item><item><title>Python vs Rust for Neural Networks</title><link>https://ngoldbaum.github.io/posts/python-vs-rust-nn/</link><description><![CDATA[In a previous post I introduced the MNIST dataset and the problem of classifying handwritten digits. In this post I’ll be using the code I wrote in that post to port a simple neural network implementation to rust. My goal is to explore performance and ergonomics for data science workflows in Rust.]]></description><guid isPermaLink="false">d6e69577-47b1-4490-a336-a01b166fff6e</guid><pubDate>Fri, 26 Jul 2019 14:17:19 -0400</pubDate><dc:creator>Nathan Goldbaum</dc:creator></item><item><title>Unsafe as a Human-Assisted Type System</title><link>https://matklad.github.io/2019/07/25/unsafe-as-a-type-system.html</link><description><![CDATA[This is a short note about yet another way to look at Rust’s unsafe. Today, an interesting bug was found in rustc, which made me aware just how useful unsafe is for making code maintainable. The story begins a couple of months ago, when I was casually browsing through recent pull requests for rust-lang/rust. I was probably waiting for my code to compile at that moment :] Anyway, a pull request caught my attention, and, while I was reading the diff, I noticed a usage of unsafe.]]></description><guid isPermaLink="false">98583b20-bd88-4cad-8a18-5e375c6c369f</guid><pubDate>Thu, 25 Jul 2019 00:00:00 +0300</pubDate><dc:creator>Aleksey Kladov</dc:creator></item><item><title>HOWTO: Replace mem::uninitialized with mem::MaybeUninit</title><link>https://www.reddit.com/r/rust/comments/cefgec/howto_replace_memuninitialized_with_memmaybeuninit/</link><description><![CDATA[The recent 1.36.0 release of Rust has brought a mem::MaybeUninit union that allows safer handling of possibly uninitialized data. MaybeUninit is a replacement of mem::uninitialized. Why? Because using mem::uninitialized it is damn easy to shoot yourself in the foot.]]></description><guid isPermaLink="false">ab2b1d95-83c2-4541-9f2d-bb5224d0b713</guid><pubDate>Fri, 19 Jul 2019 10:59:18 +0000</pubDate><dc:creator>Roman Proskuryakov</dc:creator></item><item><title>Rust for OOP - Closures</title><link>https://oribenshir.github.io/afternoon_rusting/blog/closures</link><description><![CDATA[Turning functions into first-class citizens in our programming languages is one of the major changes of the decade. Well, kind of. The concept, also known as lambda, is far from new. Functional programming languages had it from the very start, during the late ’50s. Even some of the object-oriented languages like Python had it quite early, back in 1994. However it became an official part of C++ only in 2011, and Java brought it even later in 2014. And with those two languages and many others, it became the norm, even for non-functional programming. As first-class citizens, functions can be saved as variables or transfer as arguments to functions easily.]]></description><guid isPermaLink="false">fd4779eb-f9f4-4c63-98c9-d7fe21fb6bac</guid><pubDate>Fri, 19 Jul 2019 00:00:00 +0000</pubDate><dc:creator>Ori Ben-Shir</dc:creator></item><item><title>The Temptation of Unsafe</title><link>https://inejge.github.io/blog/2019/07/18/The-Temptation-of-Unsafe.html</link><description><![CDATA[Recently, another round of discussion concerning the use of Rust’s unsafe features in the Actix web framework happened, or rather erupted, on Reddit, even more heated and acrimonious than the first time around. (I am not linking to any of the threads, as I believe that they don’t need any more exposure. Use your favorite search engine.) This proves, if more proof is needed, that people hold passionate beliefs about the matter.]]></description><guid isPermaLink="false">a0f3d2bb-e52e-440b-809f-169497494769</guid><pubDate>Thu, 18 Jul 2019 00:00:00 +0000</pubDate><dc:creator>inejge</dc:creator></item><item><title>Perils of Constructors</title><link>https://matklad.github.io/2019/07/16/perils-of-constructors.html</link><description><![CDATA[One of my favorite blog posts about Rust is Things Rust Shipped Without by Graydon Hoare. To me, footguns that don’t exist in a language are usually more important than expressiveness. In this slightly philosophical essay, I want to tell about a missing Rust feature I especially like: constructors.]]></description><guid isPermaLink="false">85b61a6b-91ab-4194-a236-43a690cc3f2f</guid><pubDate>Tue, 16 Jul 2019 00:00:00 +0300</pubDate><dc:creator>Aleksey Kladov</dc:creator></item><item><title>&quot;What The Hardware Does&quot; is not What Your Program Does: Uninitialized Memory</title><link>https://www.ralfj.de/blog/2019/07/14/uninit.html</link><description><![CDATA[This post is about uninitialized memory, but also about the semantics of highly optimized “low-level” languages in general. I will try to convince you that reasoning by “what the hardware does” is inherently flawed when talking about languages such as Rust, C or C++. These are not low-level languages. I have made this point before in the context of pointers; this time it is going to be about uninitialized memory.]]></description><guid isPermaLink="false">3161bc30-9df4-4273-8ff7-301ea0426d9f</guid><pubDate>Sun, 14 Jul 2019 00:00:00 +0000</pubDate><dc:creator>Ralf Jung</dc:creator></item><item><title>What Is Rust&apos;s unsafe?</title><link>https://nora.codes/post/what-is-rusts-unsafe/</link><description><![CDATA[I’ve seen a lot of misconceptions around what the unsafe keyword means for the utility and validity of Rust and its marketing as a “safe systems language”. The truth is a lot more complicated than a single pithy tweet can possibly sum up, unfortunately; here it is as I see it.

Basically, the unsafe keyword does not turn off the advanced type system that keeps Rust code honest. It only allows a few select “superpowers”, like dereferencing raw pointers. It is used to implement safe abstractions over a fundamentally unsafe world so that the majority of Rust code can use those abstractions and avoid memory unsafety.]]></description><guid isPermaLink="false">a05e51b1-ea5d-4365-949c-80c0c3e48d54</guid><pubDate>Fri, 12 Jul 2019 10:00:00 -0700</pubDate><dc:creator>Leonora Tindall</dc:creator></item><item><title>Testable Component Design in Rust</title><link>http://iextendable.com/2019/07/12/testable-component-design-in-rust/</link><description><![CDATA[I consider myself an advanced beginner in Rust. There is still much I’m wrapping my head around–and I still get caught off guard by the “move” and “mutability” rules Rust enforces. However, in keeping with my personal emphasis, I’ve devoted my efforts to learning how to create automated tests in Rust. The below guidelines are not exhaustive, but represent my learning so far. Feedback is welcome!]]></description><guid isPermaLink="false">20553a37-476d-45bb-8180-3de54aa932cd</guid><pubDate>Fri, 12 Jul 2019 13:57:01 +0000</pubDate><dc:creator>Chris McKenzie</dc:creator></item><item><title>AiC: Unbounded queues and lang design</title><link>http://smallcultfollowing.com/babysteps/blog/2019/07/10/aic-unbounded-queues-and-lang-design/</link><description><![CDATA[I have been thinking about how language feature development works in Rust1. I wanted to write a post about what I see as one of the key problems: too much concurrency in our design process, without any kind of “back-pressure” to help keep the number of “open efforts” under control. This setup does enable us to get a lot of things done sometimes, but I believe it also leads to a number of problems.

Although I don’t make any proposals in this post, I am basically advocating for changes to our process that can help us to stay focused on a few active things at a time. Basically, incorporating a notion of capacity such that, if we want to start something new, we either have to finish up with something or else find a way to grow our capacity.]]></description><guid isPermaLink="false">6d02baa8-8fcd-45fa-9f96-d36a635a2379</guid><pubDate>Wed, 10 Jul 2019 00:00:00 -0400</pubDate><dc:creator>Niko Matsakis</dc:creator></item><item><title>Async-await status report #2</title><link>http://smallcultfollowing.com/babysteps/blog/2019/07/08/async-await-status-report-2/</link><description><![CDATA[I wanted to give an update on the status of the “async-await foundations” working group. This post aims to cover three things: the “async await MVP” that we are currently targeting; how that fits into the bigger picture; and how you can help, if you’re so inclined;]]></description><guid isPermaLink="false">815aa1ce-d98e-484c-8dbf-a91fce9a4167</guid><pubDate>Mon,  8 Jul 2019 00:00:00 -0400</pubDate><dc:creator>Niko Matsakis</dc:creator></item><item><title>Method for Emulating Higher-Kinded Types in Rust</title><link>https://gist.github.com/edmundsmith/855fcf0cb35dd467c29a9350481f0ecf</link><description><![CDATA[I've been fiddling about with an idea lately, looking at how higher-kinded types can be represented in such a way that we can reason with them in Rust here and now, without having to wait a couple years for what would be a significant change to the language and compiler.

There have been multiple discussions on introducing higher-ranked polymorphism into Rust, using Haskell-style Higher-Kinded Types (HKTs) or Scala-looking Generalised Associated Types (GATs). The benefit of higher-ranked polymorphism is to allow higher-level, richer abstractions and pattern expression than just the rank-1 polymorphism we have today.]]></description><guid isPermaLink="false">55481592-1914-40bc-a2be-f7be9702c5c7</guid><pubDate>Sun,  7 Jul 2019 20:47:09 +0000</pubDate><dc:creator>Edmund Smith</dc:creator></item><item><title>Rust vs C++ - Implementing a Neural Network</title><link>http://nicktasios.nl/posts/rust-vs-c%2B%2B-implementing-a-neural-network.html</link><description><![CDATA[I first learned Rust back in 2014, before it was stable. Rust is definitely a very interesting language so I have decided to revisit it by programming a simple neural network. For comparison, I also implemented the network in C++, the language I'm looking to replace.]]></description><guid isPermaLink="false">649aefcc-0d0c-4e1c-b2d2-337d3110c606</guid><pubDate>Sat,  6 Jul 2019 19:18:48 +0200</pubDate><dc:creator>Nick Tasios</dc:creator></item><item><title>Functional Programming Jargon in Rust</title><link>https://functional.works-hub.com/learn/functional-programming-jargon-in-rust-1b555</link><description><![CDATA[Github Repository: https://github.com/JasonShin/functional-programming-jargon.rsFunctional programming (FP) provides many advantages, and its popula...]]></description><guid isPermaLink="false">3d786e81-3097-48f1-aea9-9a86473f6957</guid><pubDate>Fri,  5 Jul 2019 00:00:00 +0000</pubDate><dc:creator>Jason Shin</dc:creator></item><item><title>Cargo --offline ✈️</title><link>https://www.ncameron.org/blog/cargo-offline/</link><description><![CDATA[Rust 1.36 is released on the 4th July and includes a bunch of new stuff. This blog post is about one newly stable feature in Cargo: --offline.]]></description><guid isPermaLink="false">4ab235dc-fc27-4dfe-aefc-1bcc16a23199</guid><pubDate>Thu,  4 Jul 2019 08:13:57 +0000</pubDate><dc:creator>Nick Cameron</dc:creator></item><item><title>Rust std study series: alloc</title><link>https://ehsanmkermani.com/2019/07/03/rust-std-study-series-alloc/</link><description><![CDATA[Let’s get deep into std::alloc! The very basic need for any program to compile and execute is having access to either physical memory or virtual memory. An allocator is responsible for providing such an access. You can think of an allocator as a service, taking some sort of requests and either giving back a (pointer) to block of memory or some errors. In Rust, a request is a Layout i.e. some meta-data about how the memory we want is supposed to take up the space.]]></description><guid isPermaLink="false">a11e4440-7ad1-4e28-95d7-db6cc8a4544b</guid><pubDate>Thu,  4 Jul 2019 00:20:38 +0000</pubDate><dc:creator>Ehsan M. Kermani</dc:creator></item><item><title>Announcing Rust 1.36.0</title><link>https://blog.rust-lang.org/2019/07/04/Rust-1.36.0.html</link><description><![CDATA[This release brings many changes, including the stabilization of the Future trait, the alloc crate, the MaybeUninit<T> type, NLL for Rust 2015, a new HashMap<K, V> implementation, and --offline support in Cargo. Read on for a few highlights, or see the detailed release notes for additional information.]]></description><guid isPermaLink="false">75040309-d3a6-4941-a8d1-28c6f8bdfc19</guid><pubDate>Thu,  4 Jul 2019 00:00:00 +0000</pubDate><dc:creator>The Rust Release Team</dc:creator></item><item><title>Status of rust-analyzer: Achievements and Open Collective</title><link>https://ferrous-systems.com/blog/rust-analyzer-status-opencollective/</link><description><![CDATA[rust-analyzer is an experimental compiler frontend for the Rust programming language. The ultimate goal for this project is to provide the perfect IDE experience for Rust, with all IDE features working flawlessly while editing code. This post talks about what happened to rust-analyzer in between the all-hands and today, discusses future plans, and also announces the rust-analyzer Open Collective.]]></description><guid isPermaLink="false">09564ee8-19af-4b03-95c4-b231ffd7f24f</guid><pubDate>Mon,  1 Jul 2019 22:00:00 +0000</pubDate><dc:creator>Aleksey Kladov</dc:creator></item><item><title>Rust modules vs files</title><link>https://amos.me/blog/2019/rust-modules-vs-files/</link><description><![CDATA[A while back, I asked on Twitter what people found confusing in Rust, and one of the top topics was “how the module system maps to files”. I remember struggling with that a lot when I first started Rust, so I’ll try to explain it in a way that makes sense to me.]]></description><guid isPermaLink="false">ec53084d-522d-4916-90b2-c8adda4b75f2</guid><pubDate>Mon,  1 Jul 2019 00:00:00 +0000</pubDate><dc:creator>amos</dc:creator></item><item><title>One Program Written in Python, Go, and Rust</title><link>http://www.nicolas-hahn.com/python/go/rust/programming/2019/07/01/program-in-python-go-rust/</link><description><![CDATA[This is a subjective, primarily developer-ergonomics-based comparison of the three languages from the perspective of a Python developer, but you can skip the prose and go to the code samples, the performance comparison if you want some hard numbers, the takeaway for the tl;dr, or the Python, Go, and Rust diffimg implementations.]]></description><guid isPermaLink="false">a7b2c09d-06ca-4ae2-89c2-70bf78282396</guid><pubDate>Mon,  1 Jul 2019 00:00:00 +0000</pubDate><dc:creator>Nicolas Hahn</dc:creator></item><item><title>Sharing references between Python and Rust</title><link>https://raphaelgomes.dev/blog/articles/2019-07-01-sharing-references-between-python-and-rust.html</link><description><![CDATA[In 2018, the Mercurial project decided to use Rust to improve performance and maintainability of previous high-performance code. We have faced some interesting challenges when bridging the Python implementation with the new Rust code, and this is one that I have not found any literature about.]]></description><guid isPermaLink="false">38abc54a-6b27-48ec-8789-363ead337d8a</guid><pubDate>Mon,  1 Jul 2019 00:00:00 +0000</pubDate><dc:creator>Raphaël Gomès</dc:creator></item><item><title>Writing a small ray tracer in Rust and Zig</title><link>https://nelari.us/post/raytracer_with_rust_and_zig/</link><description><![CDATA[The two languages that I spent most of my time daydreaming about writing code in are Rust and Zig. Would the lack of features in Zig make me more or less productive than with Rust’s feature overload? Which language is more enjoyable to use for writing a small, self-contained computer graphics project?  To find out, I decided to implement the same simple project in both languages: a small ray tracer, following the book Ray Tracing in One Weekend.]]></description><guid isPermaLink="false">6e2a2811-942b-4e62-b173-6d2b0d3e0acd</guid><pubDate>Thu, 27 Jun 2019 20:00:00 +0200</pubDate><dc:creator>Johann Muszynski</dc:creator></item><item><title>Non-Lexical Lifetimes arrives for everyone</title><link>http://blog.pnkfx.org/blog/2019/06/26/breaking-news-non-lexical-lifetimes-arrives-for-everyone/</link><description><![CDATA[It has been literally years since I last posted to this blog. I have been doing a bunch of Rust compiler work. One big feature has been deployed: Non-Lexical Lifetimes (hereafter denoted “NLL”).

The motivation for this blog post: The next version of Rust, 1.36, is going to have NLL turned on for the 2015 edition. Going forward, all editions of Rust will now use NLL.]]></description><guid isPermaLink="false">d682ecb5-9935-4073-8865-f5a66f2a65f5</guid><pubDate>Wed, 26 Jun 2019 12:54:29 +0200</pubDate><dc:creator>Felix S. Klock II</dc:creator></item><item><title>Understanding Closures in Rust</title><link>https://medium.com/swlh/understanding-closures-in-rust-21f286ed1759</link><description><![CDATA[Summary: Closures are a combination of a function pointer (fn) and a context. A closure with no context is just a function pointer. A closure which has an immutable context belongs to Fn. A closure which has a mutable context belongs to FnMut. A closure that owns its context belongs to FnOnce.]]></description><guid isPermaLink="false">c39c6210-76a8-46f1-ab2d-b6f1be909232</guid><pubDate>Wed, 26 Jun 2019 10:27:58 +0000</pubDate><dc:creator>Andrew Pritchard</dc:creator></item><item><title>Rust type language - journey to rust</title><link>https://medium.com/journey-to-rust/rust-type-language-48e1c43b1ef4</link><description><![CDATA[Disclaimer: If you are learning Rust, take this with grain of salt. I’m learning Rust too and I may be utterly wrong in my guesses. The more I read and do Rust, the more I realize, that Rust consists of two (three, if macros counts) languages.]]></description><guid isPermaLink="false">4b9faf2d-145a-4deb-909d-ac58ea05bdc8</guid><pubDate>Tue, 25 Jun 2019 14:10:43 +0000</pubDate><dc:creator>George Shuklin</dc:creator></item><item><title>std time</title><link>https://blog.yoshuawuyts.com/std-time/</link><description><![CDATA[Over the past month we've been hard at work to add time support to the Runtime crate. One of the things we've had to think about has been examples. Which means we've had a chance to become intimately familiar with the good and less good parts of the std::time API.

In this post we'll look at the std::time API, and some of the proposed changes to smooth things out a bit. Also disclaimer: I've been involved with these proposals, hehe.]]></description><guid isPermaLink="false">f0491f48-a0cd-4f35-a781-a8907f277e8a</guid><pubDate>Tue, 25 Jun 2019 00:00:00 +0000</pubDate><dc:creator>Yoshua Wuyts</dc:creator></item><item><title>Why we&apos;re using Rust for cloud rendering</title><link>https://www.digitalbridge.com/blog/why-were-using-rust-for-cloud-rendering</link><description><![CDATA[We initially began replacing a small component of our stack using Rust, but it quickly became clear that a larger effort would allow a great reduction in complexity. In the end, all the C, C++, and Python components of the service were rebuilt, with Rust used from task loading through to dispatching GPU operations.]]></description><guid isPermaLink="false">91f9b804-7782-4a78-ade2-e4d8008923cf</guid><pubDate>Mon, 24 Jun 2019 12:07:47 +0000</pubDate><dc:creator>Iain MacIver</dc:creator></item><item><title>My iterator is returning a reference to a reference</title><link>https://blog.tawhidhannan.co.uk/rust/tidbits/rust-double-ref</link><description><![CDATA[Sometimes you mean it. Other times you really don't. It can be a bit of a headscratcher, but is not a particularly complicated situation, just easy to stumble into on a tired afternoon. In the end it all comes down to the ensuring you're being purposeful about what you're iterating over. I'll take a relatively brief dive into what can cause this, and how you can get back to iterating over what you want to iterate over.]]></description><guid isPermaLink="false">cb4c2736-6856-435e-a605-8d7b2155a1c3</guid><pubDate>Sun, 23 Jun 2019 00:00:00 +0000</pubDate><dc:creator>Tawhid Hannan</dc:creator></item><item><title>A Detailed Look at Rust Streams</title><link>https://blog.yoshuawuyts.com/rust-streams/</link><description><![CDATA[As Rust's async story is evolving, so is Rust's streaming story. In this post we'll take a look at how Rust's streaming model works, how to use it effectively, and where things are heading in the future.]]></description><guid isPermaLink="false">7602cf1d-bae1-41bb-bfb8-4d7967af1704</guid><pubDate>Thu, 20 Jun 2019 00:00:00 +0000</pubDate><dc:creator>Yoshua Wuyts</dc:creator></item><item><title>Distributed Systems Training in Rust and Go</title><link>https://tikv.org/blog/talent-training/</link><description><![CDATA[PingCAP is creating a series of training courses on writing distributed systems in Rust and Go. These courses consist of:

Practical Networked Applications in Rust. A series of projects that incrementally develop a single Rust project from the ground up into a high-performance, networked, parallel and asynchronous key/value store. Along the way various real-world and practical Rust development subject matter are explored and discussed.

Distributed Systems in Rust. Adapted from the MIT 6.824 distributed systems coursework, this course focuses on implementing important distributed algorithms, including the Raft consensus algorithm, and the Percolator distributed transaction protocol.]]></description><guid isPermaLink="false">f756eb13-90c3-407a-a304-66e198248d3b</guid><pubDate>Thu, 20 Jun 2019 00:00:00 +0000</pubDate><dc:creator>Brian Anderson</dc:creator></item><item><title>Rust std study series: Interior mutability</title><link>https://ehsanmkermani.com/2019/06/18/rust-std-study-series-interior-mutability/</link><description><![CDATA[Continuing the standard library study, it’s time for Cell<T>!]]></description><guid isPermaLink="false">ca449299-1f7d-493f-9857-b1954e1f371d</guid><pubDate>Tue, 18 Jun 2019 20:27:25 +0000</pubDate><dc:creator>Ehsan M. Kermani</dc:creator></item><item><title>Rust Creator Graydon Hoare Talks About Security, History, and Rust</title><link>https://thenewstack.io/rust-creator-graydon-hoare-talks-about-security-history-and-rust/</link><description><![CDATA[We’re approaching the 9th anniversary of the day Graydon Hoare (and numerous contributors) first revealed to the world the newly-designed Rust programming language. So we thought it’d be a good time to assess our current landscape.

Hoare graciously agreed, sharing his thoughts on everything from the state of systems programming, to the difficulty of defining safety on ever-more complex systems — and whether we’re truly more secure today, or confronting an inherited software mess that will take decades to clean up.]]></description><guid isPermaLink="false">f6b00396-a786-403b-b392-16e784f32241</guid><pubDate>Tue, 18 Jun 2019 13:00:49 +0000</pubDate><dc:creator>David Cassel</dc:creator></item><item><title>Experiment with streams, reading files with futures</title><link>https://chilimatic.hashnode.dev/experiment-with-streams-reading-files-with-futures-cjx1q0gmo001eurs1pt0c27kz</link><description><![CDATA[We were experimenting with streams and I wanted to play around with them as well. There are some tokio implementations for async file reading futuers, but since linux filesystems before kernel 5.1 do not really support non blocking file operations. I thought lets have fun breaking things ourselves. As I mentioned this is not really non blocking I/O esp. since there are two ways to view futures in their current state. ]]></description><guid isPermaLink="false">98e8bcf7-00d1-4f6d-ba28-ea41f2d7b705</guid><pubDate>Tue, 18 Jun 2019 00:00:00 +0000</pubDate><dc:creator>j</dc:creator></item><item><title>A simple plugin interface for the Rust FFI</title><link>http://kmdouglass.github.io/posts/a-simple-plugin-interface-for-the-rust-ffi/</link><description><![CDATA[I present a straight-forward design of a plugin interface using the Rust FFI.]]></description><guid isPermaLink="false">d0496592-58c8-4e56-8cfb-890df49f7b6c</guid><pubDate>Sun, 16 Jun 2019 07:33:33 +0000</pubDate><dc:creator>Kyle M. Douglass</dc:creator></item><item><title>On public API and private implementation</title><link>https://phaazon.net/blog/public-api-private-implementation</link><description><![CDATA[In this blog article, I want to explore a problem I’ve been facing from time to time in luminance. The manual dispatch problem. The idea is simple: you are writing a crate and want to expose an API to people. You want them to know which type they can use with a given operation (let’s call it update). However, the actual implementation of this update function is not performed directly by your API but is deferred to a backend implementation. Some people usually like to do that with several crates; in my case, I really don’t care and let’s think in terms of types / modules instead.]]></description><guid isPermaLink="false">7fc0def8-20e5-4923-922d-33732b5fc86c</guid><pubDate>Thu, 13 Jun 2019 17:05:00 +0000</pubDate><dc:creator>Dimitri Sabadie</dc:creator></item><item><title>A Journey Through Rust Lifetimes</title><link>https://medium.com/@richardanaya/a-journey-through-rust-lifetimes-5a08782c7091</link><description><![CDATA[I wanted to write an article about one aspect of Rust I really put off for a long while — lifetimes. They are one of the hardest parts about Rust to wrap one’s brain around. Many of us are simply not used to a compiler with a paradigm around memory ownership where such things are needed.

Lifetimes help the compiler make your code safer (i.e. less prone to crashing by using unexpected places in memory). Even if we don’t write them in our code, the compiler is smart enough to figure out your lifetimes without you under the covers. They are often times your secret allies, so let's learn a bit about them.]]></description><guid isPermaLink="false">ed6c2d09-739d-476b-b46f-441a1eefc6e3</guid><pubDate>Thu, 13 Jun 2019 00:09:47 +0000</pubDate><dc:creator>Richard Anaya</dc:creator></item><item><title>Bzip2 in Rust: porting the randomization table</title><link>https://people.gnome.org/~federico/blog/bzip2-in-rust-randomization-table.html</link><description><![CDATA[Here is a straightforward port of some easy code. randtable.c has a lookup table with seemingly-random numbers. This table is used by the following macros in bzlib_private.h]]></description><guid isPermaLink="false">05531a2c-35fc-4e51-ad25-77b362b99e03</guid><pubDate>Tue, 11 Jun 2019 14:30:17 -0500</pubDate><dc:creator>Federico Mena Quintero</dc:creator></item><item><title>How do you impl Display for Vec?</title><link>https://medium.com/apolitical-engineering/how-do-you-impl-display-for-vec-b8dbb21d814f</link><description><![CDATA[Or, more generally, how do you implement any trait that is outside of your crate, for a type that is also outside of your crate? Lets create a micro app that helps us explore the problem. We’ll create a simple struct, implement Display for that, then try to implement Display for a Vec of that struct. Once we understand the problem we’ll discuss a simple solution and how to make that solution more idiomatic.]]></description><guid isPermaLink="false">6ca39c1c-1424-4f6f-86c0-8e93f84718c0</guid><pubDate>Mon, 10 Jun 2019 14:03:02 +0000</pubDate><dc:creator>Daniel Mason</dc:creator></item><item><title>How macros make your Rust life easier and generally better</title><link>https://blog.x5ff.xyz/blog/easy-programming-with-rust-macros/</link><description><![CDATA[Let’s explore a topic that has been quite foreign to me for a long time: macros.]]></description><guid isPermaLink="false">170dcb20-7011-4222-afe7-e3eb2298a661</guid><pubDate>Fri,  7 Jun 2019 00:00:00 +0000</pubDate><dc:creator>Claus</dc:creator></item><item><title>Threads in rust</title><link>https://chilimatic.hashnode.dev/threads-in-rust-cjwmbxw9e003pzjs19n7pa0bt</link><description><![CDATA[In our regular hacksession, the current season ;), we are focusing on threading. Concurrency/Multithreading is a really hard topic it has a lot of very specific nomenclature and there are different 'levels' of concurrency one might say. I will start with the nomenclature starting from the programmers / OS perspective.]]></description><guid isPermaLink="false">922ec00d-8aa7-48eb-9344-c1d1eacc44ec</guid><pubDate>Fri,  7 Jun 2019 00:00:00 +0000</pubDate><dc:creator>j</dc:creator></item><item><title>Determining if a Rust Vector has all equal elements</title><link>https://sts10.github.io/2019/06/06/is-all-equal-function.html</link><description><![CDATA[Earlier today, I tooted out a Rust question: How would you write a function to determine if a Vector of integers are all the same, or not. Anyway, the Fediverse is wonderful and full of helpful Rust friends – I ended up getting about a dozen solutions (none exactly the same I don’t think?)]]></description><guid isPermaLink="false">c4166c18-6984-4c64-bda0-68d98d5b3ae7</guid><pubDate>Thu,  6 Jun 2019 22:11:00 +0000</pubDate><dc:creator>Sam Schlinkert</dc:creator></item><item><title>Solutions to the first 20 project euler problems</title><link>https://ngoldbaum.github.io/posts/project-euler/</link><description><![CDATA[I’m getting more and more used to thinking about Rust code in an idiomatic way, but I don’t think I’m comfortable enough to call myself a rustacean yet. To further my goal of oxidizing my brain with rust knowledge, I decided to start working through project euler problems sequentially. I’ve recently finished the first 20 problems and I though I’d share the highlights of what I learned about rust along the way.]]></description><guid isPermaLink="false">30deb171-6751-4af4-9f56-202fe6a78110</guid><pubDate>Thu,  6 Jun 2019 10:23:45 -0400</pubDate><dc:creator>Nathan Goldbaum</dc:creator></item><item><title>Overlapping blanket impls</title><link>https://codesandwich.github.io/overlapping_blanket_impls/</link><description><![CDATA[Rust doesn’t allow multiple impls of a trait on the same type. This rule keeps resolution transparent and reliable. It also has an ugly side effect, that for every trait there can be only 1 blanket impl. Compiler is completely distrustful here. What if somebody somewhere created a structure that implemented both ToString and Clone? Should such combination suddenly be forbidden? What about String and u32? This rule prevents type hierarchy from sliding into minefield of odd rules and breakages on every other dependency update.]]></description><guid isPermaLink="false">37400230-0f89-41d9-a9e4-a0d7460217ab</guid><pubDate>Wed,  5 Jun 2019 12:00:00 +0000</pubDate><dc:creator>CodeSandwich</dc:creator></item><item><title>Understanding Lifetimes</title><link>https://rniczh.github.io/blog/lifetimes-intro/</link><description><![CDATA[In this post, I want to describe the Lifetimes in a different way that what I’m learned from the RFC. Audience: You may already have read the Rust Book. Nice if you took a compiler course.]]></description><guid isPermaLink="false">461ba118-af83-41c6-8afc-42b1d320a826</guid><pubDate>Wed,  5 Jun 2019 00:00:00 +0000</pubDate><dc:creator>Hong-Sheng Zheng</dc:creator></item><item><title>The Typestate Pattern in Rust</title><link>http://cliffle.com/blog/rust-typestate/</link><description><![CDATA[The typestate pattern is an API design pattern that encodes information about an object's run-time state in its compile-time type. This pattern is so easy in Rust that it's almost obvious, to the point that you may have already written code that uses it, perhaps without realizing it. I haven't seen a detailed examination of the nuances of this pattern, so here's my contribution.]]></description><guid isPermaLink="false">7d1887a3-55d1-448d-8643-2a520bfddc41</guid><pubDate>Wed,  5 Jun 2019 00:00:00 +0000</pubDate><dc:creator>Cliff L. Biffle</dc:creator></item><item><title>Bzip2 in Rust - Basic infrastructure and CRC32 computation</title><link>https://people.gnome.org/~federico/blog/bzip2-in-rust-basic-infra.html</link><description><![CDATA[I have started a little experiment in porting bits of the widely-used bzip2/bzlib to Rust. I hope this can serve to refresh bzip2, which had its last release in 2010 and has been nominally unmaintained for years.

I hope to make several posts detailing how this port is done. In this post, I'll talk about setting up a Rust infrastructure for bzip2 and my experiments in replacing the C code that does CRC32 computations.]]></description><guid isPermaLink="false">332be129-192f-46d1-aefc-c3765e5b1b56</guid><pubDate>Thu, 30 May 2019 10:36:19 -0500</pubDate><dc:creator>Federico Mena Quintero</dc:creator></item><item><title>Rust&apos;s custom derives in a hexagonal architecture: Incompatible ideas?</title><link>https://blog.eizinger.io/5835/rust-s-custom-derives-in-a-hexagonal-architecture-incompatible-ideas</link><description><![CDATA[This blog post is a manifestation of a problem that has been floating around in my head for quite a while now. It is about the seemingly incompatible idea of fully embracing Rust's custom derive system in an application that puts a strong focus on a hexagonal architecture.

To discuss this problem, I am going to first write about both concepts individually. Feel free to skip over those sections if you are already familiar with the topics. The blog post finishes off with some ideas on how Rust could be extended to better support these kind of usecases.]]></description><guid isPermaLink="false">d6200716-96c2-4c9c-890d-0047906b7c72</guid><pubDate>Thu, 30 May 2019 00:00:00 +0000</pubDate><dc:creator>Thomas Eizinger</dc:creator></item><item><title>Update on await syntax</title><link>https://boats.gitlab.io/blog/post/await-decision-ii/</link><description><![CDATA[In my previous post I said that the lang team would be making our final decision about the syntax of the await operator in the May 23 meeting. That was last Thursday, and we did reach a decision. In brief, we decided to go forward with the preliminary proposal I outlined earlier: a postfix dot syntax, future.await. For more background, in addition the previous post on my blog, you can read this write up about some of the trade offs from April.]]></description><guid isPermaLink="false">b3ca84bd-3574-43f7-aef3-988cbc6389a4</guid><pubDate>Tue, 28 May 2019 00:00:00 +0000</pubDate><dc:creator>boats</dc:creator></item><item><title>Calling a Go Library from Rust: A Case Study with SQIP</title><link>https://blog.arranfrance.com/post/cgo-sqip-rust/</link><description><![CDATA[A brief run-down of how to wrap a Go library in a CGO FFI to enable its functions to be called by Rust.]]></description><guid isPermaLink="false">ec3d6230-6b29-4459-8a62-c40a8ef08430</guid><pubDate>Mon, 27 May 2019 00:00:00 +0000</pubDate><dc:creator>Arran France</dc:creator></item><item><title>Creating a &apos;paged&apos; Vec in Rust</title><link>https://dev.to/kdrakon/creating-a-paged-vec-in-rust-193l</link><description><![CDATA[In this post I'll show you some code I wrote for paginating over a Vec collection in Rust. I needed this for a CLI tool I wrote which was meant to display all the vector entries retrieved from a remote server. In most cases, I expected to receive a lot of results, so to display them in a terminal efficiently, I couldn't reasonably render them all. I decided I would page the results.]]></description><guid isPermaLink="false">51cdd7b5-fed9-439c-b6f8-c50ee7f93ea2</guid><pubDate>Fri, 24 May 2019 06:36:49 +0000</pubDate><dc:creator>Sean Policarpio</dc:creator></item><item><title>Announcing Rust 1.35.0</title><link>https://blog.rust-lang.org/2019/05/23/Rust-1.35.0.html</link><description><![CDATA[The highlight of this release is the implementation of the FnOnce, FnMut, and Fn closure traits for Box<dyn FnOnce>, Box<dyn FnMut>, and Box<dyn Fn> respectively. Additionally, closures may now be coerced to unsafe function pointers. The dbg! macro introduced in Rust 1.32.0 can now also be called without arguments. Moreover, there were a number of standard library stabilizations. Read on for a few highlights, or see the detailed release notes for additional information.]]></description><guid isPermaLink="false">53c0e6e9-a95e-4509-b70a-74e945e74e92</guid><pubDate>Thu, 23 May 2019 00:00:00 +0000</pubDate><dc:creator>The Rust Release Team</dc:creator></item><item><title>Putting the stack back into Stacked Borrows</title><link>https://www.ralfj.de/blog/2019/05/21/stacked-borrows-2.1.html</link><description><![CDATA[Less than a month ago, I announced Stacked Borrows 2. In particular, I hoped that that version would bring us closer to proper support for two-phase borrows. Turns out I was a bit too optimistic! Last week, @Manishearth asked on Zulip why Miri rejected a certain program, and it turned out that the issue was related to two-phase borrows: in combination with interior mutability, behavior wasn’t always what we wanted it to be. So, I went back to the drawing board and tried to adjust Stacked Borrows.

In the end, I decided to give up on “proper” support for two-phase borrows for now, which I explained here. But I also made some tweaks to Stacked Borrows that affect all accesses (not just two-phase borrows), and that’s what this post is about. I am referring to this as “Stacked Borrows 2.1”.]]></description><guid isPermaLink="false">c12cd1dc-8523-4caf-add8-4ba0322a3cb6</guid><pubDate>Tue, 21 May 2019 00:00:00 +0000</pubDate><dc:creator>Ralf Jung</dc:creator></item><item><title>Here&apos;s My Type, So Initialize Me Maybe (mem::uninitialized is deprecated)</title><link>https://gankro.github.io/blah/initialize-me-maybe/</link><description><![CDATA[Rust's infamous mem::uninitialized method has been deprecated in today's nightly build. Its replacement, MaybeUninit, has been stabilized. If you are using the former, you should migrate to using the latter as soon as possible (probably when it hits stable in 6 weeks). This was done because it was determined that mem::uninitialized was fundamentally broken, and could not be made to work.]]></description><guid isPermaLink="false">bab17ec7-d45f-40fa-963b-10c3085fa7bf</guid><pubDate>Tue, 21 May 2019 00:00:00 +0000</pubDate><dc:creator>Alexis Beingessner</dc:creator></item><item><title>dtolnay/case-studies: Analysis of various tricky Rust code</title><link>https://github.com/dtolnay/case-studies</link><description><![CDATA[This repository showcases some examples of tricky Rust code that I have encountered during my years working with a variety of advanced macro libraries in Rust (my own and others').]]></description><guid isPermaLink="false">4dfd194e-9cc6-4b75-b2f4-8900d8fdebcd</guid><pubDate>Tue, 21 May 2019 00:00:00 +0000</pubDate><dc:creator>David Tolnay</dc:creator></item><item><title>Polyglot Projects</title><link>https://myrrlyn.net/blog/misc/polyglot-projects</link><description><![CDATA[An exploration of how I wrote a C++ binding API for my Rust library.]]></description><guid isPermaLink="false">812b46b0-ec10-45f3-9fc6-4aaa2ae2534e</guid><pubDate>Mon, 20 May 2019 00:00:00 +0000</pubDate><dc:creator>Alexander Payne</dc:creator></item><item><title>Rust In Avast</title><link>https://vorner.github.io/2019/05/19/rust-in-avast.html</link><description><![CDATA[When I joined Avast about a year and a half ago, I did it because of two things:  I wanted to work on interesting problems and I wanted to share the Wisdom of Rust with few more people.

Originally, I was hired because of my experience with writing software for „bigger embedded“ (think a home router or Raspberry PI ‒ it runs Linux kernel, has a shell, but the file system is a bad joke, your libc has bunch of weird bugs features, you really need to think twice not to waste RAM needlessly and you have to cross-compile), low-level networking knowledge and C++.

But I don’t enjoy writing C++ (not speaking about the libc features). And I have other skills I like to practice too. So I would drop an occasional comment about how this or that would be better done in Rust. I’ve done internal courses and workshops about Rust for whoever was interested, in the hope more people would start asking to be allowed to do stuff in Rust and I could participate in such projects.]]></description><guid isPermaLink="false">eedb81ef-265f-4dc2-a1d9-559d2d68594d</guid><pubDate>Sun, 19 May 2019 00:00:00 +0000</pubDate><dc:creator>Michal &apos;vorner&apos; Vaner</dc:creator></item><item><title>Evaluating pipelined rustc compilation</title><link>https://internals.rust-lang.org/t/evaluating-pipelined-rustc-compilation/10199</link><description><![CDATA[Recently landed in nightly is the ability for Cargo to execute rustc in a “pipelined” fashion which has the promise of faster build times across the ecosystem. This support is turned off by default and the Cargo team is interested to gather more data and information about this feature, and that’s where you come in! If you’re interested in faster compiles, we’re interested in getting your feedback on this feature!]]></description><guid isPermaLink="false">64f26c72-e208-4900-90b5-cd1c61ec450b</guid><pubDate>Fri, 17 May 2019 16:09:30 +0000</pubDate><dc:creator>Alex Crichton</dc:creator></item><item><title>Tutorial: Use FlatBuffers in Rust</title><link>https://rwinslow.com/posts/use-flatbuffers-in-rust/</link><description><![CDATA[The FlatBuffers project is an extremely efficient schema-versioned serialization library. In this tutorial, you’ll learn how to use it in Rust.]]></description><guid isPermaLink="false">7d2d904d-78a6-42be-8c41-c1934b975516</guid><pubDate>Fri, 17 May 2019 00:00:00 +0000</pubDate><dc:creator>Robert Winslow</dc:creator></item></channel></rss>