<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/"><channel><title>Read Rust - Language</title><link>https://readrust.net/</link><description>Language posts on Read Rust</description><item><title>Pointers Are Complicated, or: What&apos;s in a Byte?</title><link>https://www.ralfj.de/blog/2018/07/24/pointers-and-bytes.html</link><description><![CDATA[This summer, I am again working on Rust full-time, and again I will work (amongst other things) on a “memory model” for Rust/MIR. However, before I can talk about the ideas I have for this year, I have to finally take the time and dispel the myth that “pointers are simple: they are just integers”. Both parts of this statement are false, at least in languages with unsafe features like Rust or C: Pointers are neither simple nor (just) integers.

I also want to define a piece of the memory model that has to be fixed before we can even talk about some of the more complex parts: Just what is the data that is stored in memory? It is organized in bytes, the minimal addressable unit and the smallest piece that can be accessed (at least on most platforms), but what are the possible values of a byte? Again, it turns out “it’s just an 8-bit integer” does not actually work as the answer.

I hope that by the end of this post, you will agree with me on both of these statements. :)]]></description><guid isPermaLink="false">b4133437-b69d-4491-a40f-a368a8847627</guid><pubDate>Tue, 24 Jul 2018 00:00:00 +0000</pubDate><dc:creator>Ralf Jung</dc:creator></item><item><title>Announcing Rust 1.27.2</title><link>https://blog.rust-lang.org/2018/07/20/Rust-1.27.2.html</link><description><![CDATA[The Rust team is happy to announce a new version of Rust, 1.27.2.]]></description><guid isPermaLink="false">2d302e67-f458-4d07-b1f4-78cb9ed02914</guid><pubDate>Fri, 20 Jul 2018 00:00:00 +0000</pubDate><dc:creator>The Rust Core Team</dc:creator></item><item><title>Futures 0.3.0-alpha.1</title><link>https://rust-lang-nursery.github.io/futures-rs/blog/2018/07/19/futures-0.3.0-alpha.1.html</link><description><![CDATA[Welcome to the inaugural post of the new futures-rs blog!

After several months of work, we’re happy to announce an alpha release of the new edition of future-rs, version 0.3. The immediate goal of this work is to support async/await notation (with borrowing) in Rust itself, which has entailed significant changes to the futures crate.]]></description><guid isPermaLink="false">2a8864ba-0872-45d2-89f4-87e9f368374b</guid><pubDate>Thu, 19 Jul 2018 17:00:00 +0000</pubDate><dc:creator>Aaron Turon</dc:creator></item><item><title>Auditing popular Rust crates: how a one-line unsafe has nearly ruined everything</title><link>https://medium.com/@shnatsel/auditing-popular-rust-crates-how-a-one-line-unsafe-has-nearly-ruined-everything-fab2d837ebb1</link><description><![CDATA[Following the actix-web incident (which is fixed now, at least mostly) I decided to poke other popular Rust libraries and see what comes of it.

The good news is I’ve poked at 6 popular crates now, and I’ve got not a single actually exploitable vulnerability. I am impressed. When I poked popular C libraries a few years ago it quickly ended in tears. The bad news is I’ve found one instance that was not a security vulnerability by sheer luck, plus a whole slew of denial-of-service bugs. And I can’t fix all of them by myself. Read on to find out how I did it, and how you can help!]]></description><guid isPermaLink="false">80a9211d-dd65-4da8-b8d6-5d4223ee278d</guid><pubDate>Thu, 19 Jul 2018 01:38:11 +0000</pubDate><dc:creator>Sergey &quot;Shnatsel&quot; Davidoff</dc:creator></item><item><title>Thoughts on Compile-Time Function Evaluation and Type Systems</title><link>https://www.ralfj.de/blog/2018/07/19/const.html</link><description><![CDATA[For some time now (since the 1.26 release, to be precise), Rust has a very powerful machinery for CTFE, or compile-time function evaluation. Since then, there have been various discussions about which operations should be allowed during CTFE, which checks the compiler should do, how this all relates to promotion and which kinds of guarantees we should be able to expect around CTFE. This post is my take on those topics, and it should not be surprising that I am going to take a very type-system centric view. Expect something like a structured brain dump, so there are some unanswered questions towards the end as well.]]></description><guid isPermaLink="false">7e963a31-6451-4f7d-9817-1e8c33c4973d</guid><pubDate>Thu, 19 Jul 2018 00:00:00 +0000</pubDate><dc:creator>Ralf Jung</dc:creator></item><item><title>#[test] in 2018</title><link>https://blog.jrenner.net/rust/testing/2018/07/19/test-in-2018.html</link><description><![CDATA[Lately, I’ve been working implementing the Custom Test Frameworks eRFC for Rust. While exploring the compiler codebase, I’ve learned about the internals of testing in Rust and figured it would be interesting to share.]]></description><guid isPermaLink="false">f4903839-c307-4209-b760-15176676663f</guid><pubDate>Thu, 19 Jul 2018 00:00:00 +0000</pubDate><dc:creator>John Renner</dc:creator></item><item><title>How to help test the 2018 edition</title><link>https://www.ncameron.org/blog/how-to-help-test-the-2018-edition/</link><description><![CDATA[An edition brings together the features that have landed into a clear package, with fully updated documentation and tooling. By the end of the year we are planning to release the 2018 edition, our first since the Rust 1.0 release. You can currently opt-in to a preview of the 2018 edition to try it out and help test it.

In fact, we really need help testing it out! Once you’ve turned it on and seen its wonderful new features, what then? Here we’ve got some specific things we’d like you to test.]]></description><guid isPermaLink="false">a81b111b-b3d6-4515-81bc-00d00bf62fb9</guid><pubDate>Wed, 18 Jul 2018 03:08:04 +0000</pubDate><dc:creator>Nick Cameron</dc:creator></item><item><title>Hello Content-o-Tron</title><link>http://blog.community.rs/content-team/2018/07/16/hello-content-o-tron.html</link><description><![CDATA[Content-o-Tron is a project to help amplify the lesser heard voices in the Rust community.

We are able to do this by providing editorial assistance and technical reviews of draft blog posts.

Once your blog post is ready to publish, we will ensure it is disseminated through various channels such as Read Rust, MozHacks, social networks and of course the Rust Community’s own blog on community.rs.]]></description><guid isPermaLink="false">fbdc0364-12e8-49f4-914f-b3c4f17d43f0</guid><pubDate>Mon, 16 Jul 2018 00:00:00 +0000</pubDate><dc:creator>Mark Sta Ana</dc:creator></item><item><title>Rust vs. Go</title><link>http://julio.meroh.net/2018/07/rust-vs-go.html</link><description><![CDATA[Welcome to the Rust Review’s bonus post, which I had promised from the very beginning. I’m here to cover the big elephant in the room: Rust vs. Go. Which one is better?

There is no good answer to this question because this comparison is unfounded. I think people tend to bundle the two languages together because they were released at about the same time and the release of Rust felt like a response to the release of Go. Moreover, both languages are supposed to focus on systems software. But they are vastly different, and even as they both target systems software, they target different kinds of such software.]]></description><guid isPermaLink="false">40055859-95cc-47a0-89e3-fd3c8a000fba</guid><pubDate>Fri, 13 Jul 2018 10:45:00 +0200</pubDate><dc:creator>Julio Merino</dc:creator></item><item><title>The Tale of a Bug in Arc: Synchronization and Data Races</title><link>https://www.ralfj.de/blog/2018/07/13/arc-synchronization.html</link><description><![CDATA[While I was busy doing Rust-unrelated research, RustBelt continues to move and recently found another bug (after a missing impl !Sync that we found previously): It turns out that Arc::get_mut did not perform sufficient synchronization, leading to a data race.]]></description><guid isPermaLink="false">b2fbac94-27b1-4c37-8c21-ead67edecf43</guid><pubDate>Fri, 13 Jul 2018 00:00:00 +0000</pubDate><dc:creator>Ralf Jung</dc:creator></item><item><title>Why I love Rust</title><link>https://alexkitchens.net/2018/07/06/why-i-love-rust.html</link><description><![CDATA[I spent much of my free time over the past year learning Rust, and while it’s been a difficult language to fully grasp (it’s still a work in progress), I find it incredibly rewarding to write in. I also have had many conversations with people who don’t know much about Rust and are curious about the problems it solves.

This is my take on why Rust is important, and why I have fallen in love with the language.]]></description><guid isPermaLink="false">d52613f9-60c7-4448-89ed-72cd3da79346</guid><pubDate>Fri,  6 Jul 2018 08:46:39 +0000</pubDate><dc:creator>Alex Kitchens</dc:creator></item><item><title>Rust: Raw string literals</title><link>https://medium.com/@rahulthakoor/rust-raw-string-literals-9579c4feb231</link><description><![CDATA[While working with Rust, you will often come across r#"something like this"#, especially when working with JSON and TOML files. It defines a raw string literal. When would you use a raw string literal and what makes a valid raw string literal?]]></description><guid isPermaLink="false">ca7cc808-b6f7-4650-a219-b2c92be95460</guid><pubDate>Thu,  5 Jul 2018 13:26:49 +0000</pubDate><dc:creator>Rahul Thakoor</dc:creator></item><item><title>Surface Rust: The Missing IDE</title><link>https://medium.com/@wolfshirts/surface-rust-6470d0075721</link><description><![CDATA[This week I decided to do a little hacking on Rust. I thought I’d write down my first impressions of the language.]]></description><guid isPermaLink="false">54242603-6ea7-4c99-8826-bbda3f8f63db</guid><pubDate>Wed,  4 Jul 2018 21:45:48 +0000</pubDate><dc:creator>@wolfshirts</dc:creator></item><item><title>Why Rust?</title><link>https://medium.com/paritytech/why-rust-846fd3320d3f</link><description><![CDATA[Programming is hard. Not because our hardware is complex, but simply because we’re all humans. Our attention span is limited, our memory is volatile — in other words, we tend to make mistakes.]]></description><guid isPermaLink="false">1b9d4f29-d237-4f3d-bc55-23b9ab2c5d77</guid><pubDate>Wed,  4 Jul 2018 07:43:11 +0000</pubDate><dc:creator>Dmitriy Kashitsyn</dc:creator></item><item><title>Idioms of Dynamic Languages</title><link>http://willcrichton.net/notes/idioms-of-dynamic-languages/</link><description><![CDATA[Programmers think dynamic languages like Python are easier to use than static ones, but why? I look at uniquely dynamic programming idioms and their static alternatives, identifying a few broad trends that impact language usability.]]></description><guid isPermaLink="false">f12f8561-c983-40b4-a7b4-9da8b350b33d</guid><pubDate>Sun,  1 Jul 2018 00:00:00 +0000</pubDate><dc:creator>Will Crichton</dc:creator></item><item><title>llvm-tools: a new rustup component for binary inspection and profiling</title><link>https://internals.rust-lang.org/t/llvm-tools-a-new-rustup-component-for-binary-inspection-objdump-nm-size-and-profiling-profdata/7830</link><description><![CDATA[Recent nightly releases provide an opt-in llvm-tools rustup component which you can install using the command: rustup component add llvm-tools. This component contains the following LLVM tools: llvm-nm, llvm-objcopy, llvm-objdump, llvm-profdata, and llvm-size. Most of these tools are LLVM alternatives to GNU binutils. The main advantage of these LLVM tools is that they support all the architectures that the Rust compiler supports.]]></description><guid isPermaLink="false">3b171674-7223-48e4-95da-5f268ec6fa1f</guid><pubDate>Fri, 29 Jun 2018 11:22:00 +0000</pubDate><dc:creator>Jorge Aparicio</dc:creator></item><item><title>Programming Servo: The script event-loop</title><link>https://medium.com/@polyglot_factotum/programming-servo-the-script-event-loop-be687b985b3e</link><description><![CDATA[One thing I have come to appreciate over time in the design of Servo, is the concurrency story. Basically, it’s pretty much all done using channels(and their multi-process counterpart).

What is so great about channels vs shared mutable state? One thing is, it makes it easier to reason about how various threads will synchronize their behavior as they go on about their business.

The way it’s done in Servo is by combining event-loops with multi-threading/processing. What does that mean?]]></description><guid isPermaLink="false">fa4c6fb5-3c9e-4831-86b1-3585c08398de</guid><pubDate>Thu, 28 Jun 2018 05:17:48 +0000</pubDate><dc:creator>Gregory Terzian</dc:creator></item><item><title>Signal Hook: Unix signal hanadling in Rust</title><link>https://vorner.github.io/2018/06/28/signal-hook.html</link><description><![CDATA[As promised in the previous article (thanks for all the valuable feedback ‒ I didn’t have the time to act on it yet, but I will), this talks about Unix signal handling.

Long story short, I wasn’t happy about the signal handling story in Rust and this is my attempt at improving it.]]></description><guid isPermaLink="false">a721af0b-e469-40ba-8ddc-f5f2a305483f</guid><pubDate>Thu, 28 Jun 2018 00:00:00 +0000</pubDate><dc:creator>Michal &apos;vorner&apos; Vaner</dc:creator></item><item><title>A Self-ish Bug</title><link>https://llogiq.github.io/2018/06/28/self-bug.html</link><description><![CDATA[I recently found a bug in mutagen: The “exchange arguments” mutation was actually ineffective. I was in the process of refactoring the code to pull coverage reporting into the mutagen calls (to reduce the amount of code generated), so the report_coverage call was to go away anyway. Except this bug masked another, more insiduous one: When I refactored, I found that one of the test would no longer compile methods with self arguments, running into Error E0424 (self keyword used in static method). Consider me confused.]]></description><guid isPermaLink="false">696ba27d-cdab-400f-9e86-a138422c2154</guid><pubDate>Thu, 28 Jun 2018 00:00:00 +0000</pubDate><dc:creator>Llogiq</dc:creator></item><item><title>New Photon Release of Eclipse IDE Ships With Full Rust Support | </title><link>https://www.eclipse.org/org/press-release/20180627_new-photon-release-of-eclipse-ide-ships-with-full-rust-support.php</link><description><![CDATA[The release delivers native Eclipse IDE experiences for Rust and C# through Language Server based plugins. The Language Server Protocol (LSP) ecosystem delivers editing support for popular and emerging programming languages. Combined with the move to a quarterly rolling release cadence, the LSP focus demonstrates a commitment to keeping pace with evolving developer and commercial needs.]]></description><guid isPermaLink="false">19aba600-95ff-4ba2-920f-0db67b3755e4</guid><pubDate>Wed, 27 Jun 2018 00:00:00 +0000</pubDate><dc:creator>The Eclipse Foundation</dc:creator></item><item><title>Why choose Rust?</title><link>https://blog.passfort.com/why-choose-rust/</link><description><![CDATA[Many of the candidates we interview for a position at PassFort are intrigued by the fact that we use Rust, a language which is only three years old (since its 1.0 release).

Despite its relatively young age, Rust has been voted the “most loved” language in the StackOverflow developer survey every one of those three years - an impressive feat!

However, it’s not enough for a language to be well liked: the programming ecosystem changes rapidly, and many of these developers are rightly afraid to jump blindly onto the latest bandwagon. We chose Rust not because it is popular, but because we believe it is the best tool for the job we have to do, and I hope to explain that reasoning now.]]></description><guid isPermaLink="false">e9ac81fa-8018-4bb1-91a2-cfd0b705f780</guid><pubDate>Tue, 26 Jun 2018 16:00:00 +0000</pubDate><dc:creator>PassFort</dc:creator></item><item><title>A Rusty Go at Channels</title><link>https://gsquire.github.io/static/post/a-rusty-go-at-channels/</link><description><![CDATA[Channels Channels are a useful concurrency primitive that enable separate processes to safely communicate without the need for explicit synchronization. The term processes is used here to loosely describe independent threads of execution within a program. This can be an OS level thread or a runtime level thread. Channels can be seen as a pipe to connect these processes and allow them to share memory with one another. For example a program could spawn any number of processes along with a channel to transmit results that it gathers.]]></description><guid isPermaLink="false">0a781f91-aca4-47ac-81d4-f9f606f33d0f</guid><pubDate>Sun, 24 Jun 2018 10:44:31 -0700</pubDate><dc:creator>Garrett Squire</dc:creator></item><item><title>Compiler fuzzing, part 1</title><link>http://www.vegardno.net/2018/06/compiler-fuzzing.html</link><description><![CDATA[Much has been written about fuzzing compilers already, but there is not a lot that I could find about fuzzing compilers using more modern fuzzing techniques where coverage information is fed back into the fuzzer to find more bugs.

If you know me at all, you know I'll throw anything I can get my hands on at AFL. So I tried gcc. (And clang, and rustc -- but more about Rust in a later post.)]]></description><guid isPermaLink="false">34e39003-edb1-4232-ad2a-aae9d4868d81</guid><pubDate>Sun, 24 Jun 2018 15:02:00 +0200</pubDate><dc:creator>Vegard</dc:creator></item><item><title>Making Arc more atomic</title><link>https://vorner.github.io/2018/06/24/arc-more-atomic.html</link><description><![CDATA[This is a story of a tiny feature I was missing in Rust… so I created it (partly because I like the feature, because it felt wrong for Rust not to have it, but mostly for the practice and fun of beating a hard and interesting problem). You can read the story if you are interested about the behind the scenes, about the feature itself, how to use it or just for fun ☺.]]></description><guid isPermaLink="false">03d374fc-9500-42d8-8515-7f98447fd62a</guid><pubDate>Sun, 24 Jun 2018 00:00:00 +0000</pubDate><dc:creator>Michal &apos;vorner&apos; Vaner</dc:creator></item><item><title>Rust 2018: an early preview</title><link>https://internals.rust-lang.org/t/rust-2018-an-early-preview/7776</link><description><![CDATA[The Rust teams having been working hard to implement features of the 2018 edition. Today we have reached an important milestone: we are announcing that we have an alpha-quality preview of the 2018 edition ready for testing and feedback.

The preview presents a great opportunity for those of you using the stable channel to switch to nightly and try out how it feels to code in the new edition, both to help us fix bugs and to provide feedback – positive and negative – on features. Unfortunately, today’s nightly doesn’t work due to infrastructure issues, so you’ll need to run rustup install nightly-2018-06-20 in order to get a nightly that’ll work. If you’re already on the nightly channel, it’s likely that there’s no need to update the compiler.]]></description><guid isPermaLink="false">698090f0-fa77-43b5-aaed-dcd2b71d3c39</guid><pubDate>Sat, 23 Jun 2018 08:19:19 +1000</pubDate><dc:creator>Rust Team Members</dc:creator></item><item><title>Rust review: The ecosystem</title><link>http://julio.meroh.net/2018/06/rust-review-ecosystem.html</link><description><![CDATA[In this part of the review, I would like to focus on Rust’s ecosystem: in other words, how Rust plays with other parts of a functioning system and how Rust’s standard library vs. external libraries interact with each other. There are a lot of pieces to cover in these areas and they have left me with mixed feelings. Let’s look at some.]]></description><guid isPermaLink="false">295dac4f-f095-4d04-b6ee-a6a2870cc7fb</guid><pubDate>Fri, 22 Jun 2018 09:00:00 -0400</pubDate><dc:creator>Julio Merino</dc:creator></item><item><title>Announcing Rust 1.27</title><link>https://blog.rust-lang.org/2018/06/21/Rust-1.27.html</link><description><![CDATA[This release has two big language features that people have been waiting for: SIMD, and dyn Trait. Additionally there is support for searching the Rust books, and a new book about rustc.]]></description><guid isPermaLink="false">41f94ae9-ac3a-42fe-bc78-fbc6dab42d85</guid><pubDate>Thu, 21 Jun 2018 00:00:00 +0000</pubDate><dc:creator>The Rust Core Team</dc:creator></item><item><title>Proposal for a staged RFC process</title><link>http://smallcultfollowing.com/babysteps/blog/2018/06/20/proposal-for-a-staged-rfc-process/</link><description><![CDATA[I consider Rust’s RFC process one of our great accomplishments, but it’s no secret that it has a few flaws. At its best, the RFC offers an opportunity for collaborative design that is really exciting to be a part of. At its worst, it can devolve into bickering without any real motion towards consensus. If you’ve not done so already, I strongly recommend reading aturon’s excellent blog posts on this topic.

The RFC process has also evolved somewhat organically over time. What began as “just open a pull request on GitHub” has moved into a process with a number of formal and informal stages (described below). I think it’s a good time for us to take a step back and see if we can refine those stages into something that works better for everyone.]]></description><guid isPermaLink="false">220b4649-e853-4f07-9773-e4ae3d286a4f</guid><pubDate>Wed, 20 Jun 2018 00:00:00 -0400</pubDate><dc:creator>Niko Matsakis</dc:creator></item><item><title>Rust review: The book</title><link>http://julio.meroh.net/2018/06/rust-review-book.html</link><description><![CDATA[“The Rust Programming Language” is one of the free books that the community has put together to teach the language. The book does a good job in general, but there are some things that could be better. Let’s cover these, but first, some background.]]></description><guid isPermaLink="false">0122445e-8a19-4a52-bcd6-4ee7e55feb7c</guid><pubDate>Tue, 19 Jun 2018 09:00:00 -0400</pubDate><dc:creator>Julio Merino</dc:creator></item><item><title>Rust + Diesel + GitLab + CI</title><link>https://noyez.gitlab.io/post/2018-06-15-rust-plus-diesel-plus-gitlab/</link><description><![CDATA[It is very straightforward to get Rust projects to build within a CI environment. This post is going to take that build process one small step further, we’re going to build a Rust project that uses the Diesel ORM. This adds a step of complexity since to compile a Diesel project you need to have a postgresql database accessible if you’re using the infer_schema!() macro.]]></description><guid isPermaLink="false">67f2f6f8-75f9-458c-969f-4bcbe9c0223f</guid><pubDate>Mon, 18 Jun 2018 00:00:00 +0000</pubDate><dc:creator>noyez</dc:creator></item><item><title>Rust Is Not So Hairy</title><link>https://nevi.me/rust-is-not-so-hairy/</link><description><![CDATA[TL;DR I decided to learn Rust on my nth attempt. Writing small programs helped me get stuff done. I converted a Java gRPC service into Rust for comparison I'm super-impressed with Rust's low CPU and memory footprint.]]></description><guid isPermaLink="false">41722089-9cfe-413c-aa51-02c244fb4d67</guid><pubDate>Sat, 16 Jun 2018 14:05:48 +0000</pubDate><dc:creator>Neville</dc:creator></item><item><title>Dynamic Casting for Traits</title><link>http://idubrov.name/rust/2018/06/16/dynamic-casting-traits.html</link><description><![CDATA[In Rust, traits are a powerful tool to use polymorphism, both static and dynamic. I’m going to skip the basics about the traits and just link to another blog post with a good explanation about static and dynamic dispatch in Rust: Traits and Trait Objects in Rust.

Instead, I would like to do an experiment of making dynamic dispatch even more dynamic! Like in Java1.]]></description><guid isPermaLink="false">977aa3cd-7136-4d69-84ac-0c15c6396ae4</guid><pubDate>Sat, 16 Jun 2018 00:00:00 +0000</pubDate><dc:creator>Ivan Dubrov</dc:creator></item><item><title>Rust review: The match keyword</title><link>http://julio.meroh.net/2018/06/rust-review-match-keyword.html</link><description><![CDATA[A commonly-acclaimed feature of Rust is its match keyword: a “conditional on steroids”. match lets you take the value of an expression and compare it against a bunch of values—or, more generally, patterns.

As you write and read Rust, you will notice that this keyword is used everywhere because it’s the way to access certain types, like Option values or error codes.]]></description><guid isPermaLink="false">b5fe7539-f996-4c57-9fc1-5fa06b6a68b2</guid><pubDate>Fri, 15 Jun 2018 09:00:00 -0400</pubDate><dc:creator>Julio Merino</dc:creator></item><item><title>MIR-based borrow check (NLL) status update</title><link>http://smallcultfollowing.com/babysteps/blog/2018/06/15/mir-based-borrow-check-nll-status-update/</link><description><![CDATA[I’ve been getting a lot of questions about the status of “Non-lexical lifetimes” (NLL) – or, as I prefer to call it these days, the MIR-based borrow checker – so I wanted to post a status update.

The single most important fact is that the MIR-based borrow check is feature complete and available on nightly. What this means is that the behavior of #![feature(nll)] is roughly what we intend to ship for “version 1”, except that (a) the performance needs work and (b) we are still improving the diagnostics.]]></description><guid isPermaLink="false">c55b518c-125b-4fb9-82c5-08c3367bb6c6</guid><pubDate>Fri, 15 Jun 2018 00:00:00 -0700</pubDate><dc:creator>Niko Matsakis</dc:creator></item><item><title>What do you think are the most interesting/exciting projects using Rust?</title><link>https://www.ncameron.org/blog/interesting_projects/</link><description><![CDATA[Last week I tweeted "What do you think are the most interesting/exciting projects using Rust? (No self-promotion :-) )". The response was awesome! Jonathan Turner suggested I write up the responses as a blog post, and here we are.]]></description><guid isPermaLink="false">f6f3b55c-c39c-4366-9de1-ebf3b230ee6c</guid><pubDate>Wed, 13 Jun 2018 16:26:29 +0000</pubDate><dc:creator>Nick Cameron</dc:creator></item><item><title>Rust review: Expressions, expressions, expressions</title><link>http://julio.meroh.net/2018/06/rust-review-expressions.html</link><description><![CDATA[Rust resembles a functional language in many ways although it does not claim to be one. In fact, I have been thinking of Rust as a “pragmatic Haskell” or as a “well-balanced mixture between C++ and Haskell”.

One of the ways the functional aspects show up is via expressions and how pretty much any construct in Rust can be treated as an expression. But before we begin, a little warning: the examples below are, by no means, idiomatic Rust—I just hope they are simple enough to illustrate what I want to show.]]></description><guid isPermaLink="false">8e5085a4-0057-4ed8-81dc-93242e35b6e9</guid><pubDate>Tue, 12 Jun 2018 09:00:00 -0400</pubDate><dc:creator>Julio Merino</dc:creator></item><item><title>From Go to Rust - JSON and YAML</title><link>http://technosophos.com/2018/06/12/from-go-to-rust-json-and-yaml.html</link><description><![CDATA[One of Go's big selling points for me was its novel approach to JSON encoding. Learning about Rust's encoding has made me even more excited. In this post, we'll start with Go's JSON encoder, and then see how Rust does encoding. And we'll even through in some YAML!]]></description><guid isPermaLink="false">79d23f1b-0e7b-4d75-a061-9e5b9930424b</guid><pubDate>Tue, 12 Jun 2018 00:00:00 +0000</pubDate><dc:creator>Matt Butcher</dc:creator></item><item><title>Automatic Type Coercions with Procedural Macros in Rust</title><link>http://willcrichton.net/notes/automatic-type-coercions-macros-rust/</link><description><![CDATA[I briefly demonstrate how to use procedural macros to automatically perform type coercion in Rust, mimicking the behavior of dynamic languages.]]></description><guid isPermaLink="false">4749d178-b87d-4946-b8e2-0a6d17d7495e</guid><pubDate>Tue, 12 Jun 2018 00:00:00 +0000</pubDate><dc:creator>Will Crichton</dc:creator></item><item><title>Traits and Trait Objects in Rust</title><link>https://joshleeb.com/posts/rust-traits-and-trait-objects/</link><description><![CDATA[I’ve been really confused lately about Rust’s trait objects. Specifically when it comes to questions about the difference between &Trait, Box<Trait>, impl Trait, and dyn Trait.]]></description><guid isPermaLink="false">2b4b4efe-3a50-4ceb-ac4c-267b708c2ce8</guid><pubDate>Tue, 12 Jun 2018 00:00:00 +0000</pubDate><dc:creator>Josh Leeb-du Toit</dc:creator></item><item><title>Where do Rust threads come from?</title><link>http://squidarth.com/rc/rust/concurrency/2018/06/09/rust-threads-detach.html</link><description><![CDATA[Last week, I wrote a post in which I discussed some of the things that I learned about Rust concurrency. One of the things that I pointed out was that when you spawn a thread within another thread, they both have the main process as their parent.]]></description><guid isPermaLink="false">34b26ba8-daa3-431f-ba53-9c0d9d873459</guid><pubDate>Sat,  9 Jun 2018 09:00:38 -0400</pubDate><dc:creator>Sid Shanker</dc:creator></item><item><title>From ActiveRecord to Diesel</title><link>http://patshaughnessy.net/2018/6/9/from-activerecord-to-diesel</link><description><![CDATA[Recently I needed to run a simple SQL query on a Postgres database and produce a one-off report. I could have done this in 5 minutes using Ruby and ActiveRecord. Instead, I decided to use Rust and Diesel – a language and a tool I hadn’t used before. Instead of 5 minutes it took several hours, but I learned something new. I’ve written up the steps I took here today. Get your mind’s exercise for today and read on to learn how to execute a SQL statement using Rust.]]></description><guid isPermaLink="false">c883f036-9e31-44b2-995a-24b575c524b8</guid><pubDate>Sat,  9 Jun 2018 03:00:00 +0000</pubDate><dc:creator>Pat Shaughnessy</dc:creator></item><item><title>First Impressions of the Rust Programming Language</title><link>http://jakob.space/blog/post/First+Impressions+of+the+Rust+Programming+Language</link><description><![CDATA[C is almost 50 years old, and C++ is almost 40 years old. While age is usually indicative of mature implementations with decades of optimization under their belts, it also means that the language's feature set is mostly devoid of modern advancements in programming language design. For that reason, you see a great deal of encouragement nowadays to move to newer languages - they're designed with contemporary platforms in mind, rather than working within the limitations of platforms like the PDP-11. Among said "new languages" are Zig, Myrddin, Go, Nim, D, Rust.. even languages like Java and Elixir that run on a virtual machine are occasionally suggested as alternatives to the AOT-compiled C and C++.

I have plans to look into the characteristics that distinguish each and every one of these new programming languages, learning them and documenting my first impressions in the form of blog posts. This post is the beginning of that adventure: my first impressions of Rust.]]></description><guid isPermaLink="false">4ab9c39f-72ed-4b84-a5e7-abe4c594c019</guid><pubDate>Fri,  8 Jun 2018 13:02:33 -0500</pubDate><dc:creator>Jakob</dc:creator></item><item><title>Rust review: Learning curve</title><link>http://julio.meroh.net/2018/06/rust-review-learning-curve.html</link><description><![CDATA[Writing Rust code is not restricted to programming gurus—but there is no denying that the learning curve is steeper than that of other languages. Or is it? In this post, I'll try to convince you that the curve does feel steep, but it isn't when taken into perspective.
Let's first start by stating that learning a language is not the same as learning its syntax. Learning a language involves learning the syntax, of course, but it also involves familiarizing oneself with its common idioms and grabbing a good sense of what the standard libraries provide.]]></description><guid isPermaLink="false">644f8b30-47a3-4da8-b4e9-1b72755d69b0</guid><pubDate>Fri,  8 Jun 2018 09:00:00 -0400</pubDate><dc:creator>Julio Merino</dc:creator></item><item><title>Rust review: Protect the data</title><link>http://julio.meroh.net/2018/06/rust-review-protect-the-data.html</link><description><![CDATA[The one thing that blew my mind about Rust is its approach to data sharing in concurrent situations.

I had always thought of mutexes as something that is easy to get wrong and was convinced that the use of a RAII pattern to prevent lock leaks never happen (like with Abseil’s MutexLock) was the panacea. (I’m a fan of RAII in C++ by the way, in case you haven’t noticed.)]]></description><guid isPermaLink="false">046762b0-c3da-4f38-8d4a-7bb515f73d4b</guid><pubDate>Tue,  5 Jun 2018 09:00:00 -0400</pubDate><dc:creator>Julio Merino</dc:creator></item><item><title>Why PhantomData</title><link>http://troubles.md/posts/why-phantomdata/</link><description><![CDATA[We’re not allowed to have a type parameter that goes unused. If we want to have a type that looks like the one above we have to add a marker to it like so: struct Tagged<T>(usize, PhantomData<T>);]]></description><guid isPermaLink="false">cebd59fa-c884-49cd-9de7-4da401e26642</guid><pubDate>Tue,  5 Jun 2018 13:41:30 +0200</pubDate><dc:creator>troubles.md</dc:creator></item><item><title>Announcing Rust 1.26.2</title><link>https://blog.rust-lang.org/2018/06/05/Rust-1.26.2.html</link><description><![CDATA[This patch release fixes a bug in the borrow checker verification of match expressions. This bug was introduced in 1.26.0 with the stabilization of match ergonomics. Specifically, it permitted code which took two mutable borrows of the bar path at the same time.]]></description><guid isPermaLink="false">901dde63-68f7-45d0-b161-cf585e47d266</guid><pubDate>Tue,  5 Jun 2018 00:00:00 +0000</pubDate><dc:creator>The Rust Core Team</dc:creator></item><item><title>The Future of Clippy (the Rust Linter)</title><link>https://manishearth.github.io/blog/2018/06/05/the-future-of-clippy-the-rust-linter/</link><description><![CDATA[We’ve recently been making lots of progress on future plans for clippy and I thought I’d post an update.]]></description><guid isPermaLink="false">2b743aaf-6ae4-4bda-8de9-6bef817e9a4d</guid><pubDate>Tue,  5 Jun 2018 00:00:00 +0000</pubDate><dc:creator>Manish Goregaokar</dc:creator></item><item><title>Safe Concurrency with Rust</title><link>http://www.squidarth.com/rc/rust/2018/06/04/rust-concurrency.html</link><description><![CDATA[Last week, I started learning Rust, and published a post about the “ownership” system. One of the places where Rust’s ownership system really shines is in threading and concurrency. Kevin and I decided to dig into this more on Friday, and did some work on the dining philosophers problem.

In this post I’ll be covering what we learned, and how the Rust compiler saves you from some scary concurrency issues.]]></description><guid isPermaLink="false">314ba2b8-5ace-4348-b96a-b704c628e2b3</guid><pubDate>Mon,  4 Jun 2018 09:00:38 -0400</pubDate><dc:creator>Sid Shanker</dc:creator></item><item><title>Async Methods II: object safety</title><link>https://boats.gitlab.io/blog/post/async-methods-ii/</link><description><![CDATA[Last time, we introduced the idea of async methods, and talked about how they would be implemented: as a kind of anonymous associated type on the trait that declares the method, which corresponds to a different, anonymous future type for each implementation of that method. Starting this week we’re going to look at some of the implications of that. The first one we’re going to look at is object safety.]]></description><guid isPermaLink="false">d4896054-d302-4629-8679-7456e1a741ef</guid><pubDate>Mon,  4 Jun 2018 00:00:00 +0000</pubDate><dc:creator>boats</dc:creator></item><item><title>Newtype Index Pattern</title><link>https://matklad.github.io//2018/06/03/newtype-index-pattern.html</link><description><![CDATA[Similarly to the previous post, we will once again add types to the Rust code which works perfectly fine without them. This time, we’ll try to improve the pervasive pattern of using indexes to manage cyclic data structures.]]></description><guid isPermaLink="false">e672721a-5577-4897-b440-619731384ac1</guid><pubDate>Sun,  3 Jun 2018 21:21:45 +0000</pubDate><dc:creator>Aleksey Kladov</dc:creator></item><item><title>The Secret Life of Cows</title><link>https://deterministic.space/secret-life-of-cows.html</link><description><![CDATA[A lot of people at RustFest Paris mentioned Cows – which may be surprising if you’ve never seen std::borrow::Cow!

Cow in this context stands for “Clone on Write” and is a type that allows you to reuse data if it is not modified. Somehow, these bovine super powers of Rust’s standard library appear to be a well-kept secret even though they are not new. This post will dig into this very useful pointer type by explaining why in systems programming languages you need such fine control, explain Cows in detail, and compare them to other ways of organizing your data.]]></description><guid isPermaLink="false">d8c6d9c0-38eb-4656-a28e-0125ca9e5cd1</guid><pubDate>Sat,  2 Jun 2018 00:00:00 +0200</pubDate><dc:creator>Pascal Hertleif</dc:creator></item><item><title>Rust review: The borrow checker</title><link>http://julio.meroh.net/2018/06/rust-review-borrow-checker.html</link><description><![CDATA[Aaaah, the borrow checker: the dreaded enemy lurking within the Rust compiler, ready to make its move to bring pain to your life by preventing your code from compiling. Or that’s what everyone seems to say, which is one of the reasons I put off learning Rust for so long. In reality… the borrow checker is a blessing, but it is true that getting past its gates is difficult at first.]]></description><guid isPermaLink="false">09d6be59-4bee-49e0-aa34-d43622422cb8</guid><pubDate>Fri,  1 Jun 2018 09:00:00 -0400</pubDate><dc:creator>Julio Merino</dc:creator></item><item><title>Infinite Negative Utility: The Rust Language and Special Cases</title><link>https://blog.infinitenegativeutility.com/2018/6/the-rust-language-and-special-cases</link><description><![CDATA[I first came across Rust back in 2010 or 2011, and it was a very different language than the one it is today, both syntactically and semantically. I remember at the time that newcomers would often complain loudly about the terse keywords—like the fact that the return keyword had been shortened to ret—and the omnipresent tildes scattered throughout the language like fallen leaves in autumn. My programming background was in functional languages—specifically in Scheme and Haskell—and I found this language fascinating, sitting in an interesting and unexplored place in the spectrum of programming languages and bringing something genuinely new to the table.]]></description><guid isPermaLink="false">19239f2e-41c0-44cb-8b3d-02199eaa57b1</guid><pubDate>Fri,  1 Jun 2018 00:00:00 +0000</pubDate><dc:creator>Getty Ritter</dc:creator></item><item><title>Tricking the HashMap</title><link>https://idubrov.github.io/rust/2018/06/01/tricking-the-hashmap.html</link><description><![CDATA[Is it possible to find something in a hashmap if the key you are looking for is not exactly the same as the one you put into that hashmap? At first glance, this might not make any sense at all. The whole purpose of a hashmap is to store something under some key and then look it up using the same key. Right?]]></description><guid isPermaLink="false">ab635755-efd4-432a-8407-7b1c94649f8f</guid><pubDate>Fri,  1 Jun 2018 00:00:00 +0000</pubDate><dc:creator>Ivan Dubrov</dc:creator></item><item><title>Assignment Semantics in Python, JavaScript, Java, C++, and Rust</title><link>https://www.apress.com/us/blog/all-blog-posts/assignment-semantics/15805464</link><description><![CDATA[What happens when a data collection is copied and then the new copy is changed? Does the original remain the same, or does it change too?

If you think of copying as creating a completely new object, of course you expect that any change to the new copy does not affect the original object. But if you think of copying as creating a new name for the same, single object, then you expect that any change to the object through the new name appears also when you access the same object through the old name.

Let's see how is the behavior of Python, Javascript, Java, C++, and Rust regarding the assignment operator ("=") between collection variables.]]></description><guid isPermaLink="false">80930880-f4a9-4485-b372-648928490dca</guid><pubDate>Fri,  1 Jun 2018 00:00:00 +0000</pubDate><dc:creator>Carlo Milanesi</dc:creator></item><item><title>Fear not the Rust Borrow Checker</title><link>http://www.squidarth.com/rc/rust/2018/05/31/rust-borrowing-and-ownership.html</link><description><![CDATA[I spent pretty much the whole day banging my head against the wall trying to figure out how ownership and borrowing work in Rust, and finally have a grasp on what’s going on.

In this post I’m going to demonstrate how these concepts work through some examples of code that break Rust’s rules, and explain why they’re problematic. I assume very little knowledge of the Rust programming language. I’ve also added comments to all of the code blocks that indicate whether the code is valid Rust or not.]]></description><guid isPermaLink="false">1f808812-4e70-4dcb-90a0-c45964863cd5</guid><pubDate>Thu, 31 May 2018 12:00:38 -0400</pubDate><dc:creator>Sid Shanker</dc:creator></item><item><title>Async Methods I: generic associated types</title><link>https://boats.gitlab.io/blog/post/async-methods-i/</link><description><![CDATA[Async/await continues to move along swimmingly. We’ve accepted an RFC describing how the async/await syntax will work in Rust, and work is underway on implementing support for it in the compiler. We’re hopeful that users will be able to start experimenting with the syntax on nightly by early July.

The RFC for async/await didn’t address one important thing: async methods. It is very important for people defining libraries to be able to define traits that contain async functions, like this:]]></description><guid isPermaLink="false">d5a4da56-2e7e-4f30-bd1a-d0211958a00a</guid><pubDate>Thu, 31 May 2018 00:00:00 +0000</pubDate><dc:creator>boats</dc:creator></item><item><title>Mutagen - An Inopportune Consumption</title><link>https://llogiq.github.io/2018/05/30/inop.html</link><description><![CDATA[I just failed to implement what looked to be a relatively simple opportunistic replacement so that the compiler would accept the mutated code. But I’m getting ahead of myself.]]></description><guid isPermaLink="false">aea72b83-8f56-4c8d-a9d7-c88fded0cfc7</guid><pubDate>Wed, 30 May 2018 00:00:00 +0000</pubDate><dc:creator>Llogiq</dc:creator></item><item><title>Rust review: Immutable by default</title><link>http://julio.meroh.net/2018/05/rust-review-immutable-by-default.html</link><description><![CDATA[Let’s start the deep dive by looking into a powerful feature of Rust: all variables and references are immutable by default unless qualified with mut.
To understand why this is important, let’s cover some context first. One of my pet peeves when reviewing C++ code is to ask authors to sprinkle the const qualifier everywhere: if something ain’t mutated, say so explicitly. This includes marking local variables, function arguments, function return values, class attributes, etc.]]></description><guid isPermaLink="false">d9877c7d-7175-490d-89a8-46fad05d9903</guid><pubDate>Tue, 29 May 2018 09:00:00 -0400</pubDate><dc:creator>Julio Merino</dc:creator></item><item><title>Evolving Rust</title><link>https://blog.shivoa.net/2018/05/evolving-rust.html</link><description><![CDATA[When you're just building some very basic tool programs, I'd probably not even think about threading in C, but here it is so easy that I've been quick to drop a (for example, typically) 30ms loop down to 3.5ms. One of the things I've been somewhat missing is easy access to SIMD intrinsics, but this brings me to something else I've been enjoying this year: Rust is evolving.]]></description><guid isPermaLink="false">da46cfde-97b2-4e16-9e08-4308a34d6826</guid><pubDate>Tue, 29 May 2018 12:11:00 +0100</pubDate><dc:creator>Shivoa Birch</dc:creator></item><item><title>Announcing Rust 1.26.1</title><link>https://blog.rust-lang.org/2018/05/29/Rust-1.26.1.html</link><description><![CDATA[A couple of issues were found in 1.26.0 which were deemed sufficient for a patch release.

A quick summary of the changes:

RLS no longer interferes with command line builds
Rustfmt stopped badly formatting text in some cases
Returning from main via impl Trait where the Trait is not Termination is no longer permitted
::<> (turbofish) no longer works for method arguments whose type is impl Trait

NaN > NaN no longer returns true in const contexts
rustup should no longer fail due to missing documentation on some platforms]]></description><guid isPermaLink="false">ae63f930-3568-433f-b8e6-35feb516b4c2</guid><pubDate>Tue, 29 May 2018 00:00:00 +0000</pubDate><dc:creator>The Rust Core Team</dc:creator></item><item><title>Exploring Rust fat pointers</title><link>https://iandouglasscott.com/2018/05/28/exploring-rust-fat-pointers/</link><description><![CDATA[Beware that at any point the code here may stop compiling, segfault, and otherwise behave in weird ways, some of which involve Velociraptors.

Now that that’s out of the way, what is a fat pointer anyway? All pointers are the same right? Just a number indicating an address in memory. Well, yes and no.]]></description><guid isPermaLink="false">95a6f9d4-dcfa-4b20-8ee7-f240cde435b1</guid><pubDate>Mon, 28 May 2018 02:46:00 -0700</pubDate><dc:creator>Ian Douglas Scott</dc:creator></item><item><title>The Go Developer&apos;s Quickstart Guide to Rust</title><link>http://technosophos.com/2018/05/27/the-go-developers-quickstart-guide-to-rust.html</link><description><![CDATA[As the co-author of Go in Practice, I have felt a certain obligation to Go. But I'm ready for a change. Rust topped the satisfaction survey in Stack Overflow's survey of languages (screenshot above). I've decided to give it a try. While Go and Rust are often compared, they are remarkably different languages.

Coming from a Go background, there are things about Rust that feel very natural, and things (like memory management) that feel utterly foreign. And so as I learn Rust, I am cataloging how it feels for a Go programmer. And rather than leading others to "dive in at the deep end" as I did (when I tried to write a full web service), I decided to approach Rust by starting with similarities and working toward differences.]]></description><guid isPermaLink="false">1572c586-709c-44a9-9232-ae4d3b9466ec</guid><pubDate>Sun, 27 May 2018 00:00:00 +0000</pubDate><dc:creator>Matt Butcher</dc:creator></item><item><title>Rust review: Introduction</title><link>http://julio.meroh.net/2018/05/rust-review-introduction.html</link><description><![CDATA[I had been meaning to learn Rust since I first toyed with Go a couple of years ago. During this period, I’ve written a non-trivial amount of Go code both inside and outside Google, but never found the chance to sit back and learn Rust.

This changed a month ago during my yearly family trip to Korea. This time around, I decided upfront that I would not work on any personal or work projects for the 2-week long vacation. Instead, I would focus all spare time in reading. And I would read “The Rust Programming Language”, second edition. The plan worked: getting through the book took the two weeks and I barely wrote any code.]]></description><guid isPermaLink="false">d25787d1-089e-4455-ac6a-1183548d48cd</guid><pubDate>Fri, 25 May 2018 09:00:00 -0400</pubDate><dc:creator>Julio Merino</dc:creator></item><item><title>Fuzz testing in Rust with Cargo-fuzz</title><link>https://medium.com/@seasoned_sw/fuzz-testing-in-rust-with-cargo-fuzz-13b89feecc30</link><description><![CDATA[In this post, I go through how I added the first automated fuzz test for my hobby project Hat — a snapshotting backup system written in Rust. I’ll briefly go through what a fuzz test is and how it works. In a follow-up post, I will share how I made the test more effective by running it through Seasoned Software.]]></description><guid isPermaLink="false">e0370259-0204-491d-9bd1-3769a682f6e1</guid><pubDate>Fri, 25 May 2018 10:08:45 +0000</pubDate><dc:creator>Seasoned Software</dc:creator></item><item><title>Typed Key Pattern</title><link>https://matklad.github.io/2018/05/24/typed-key-pattern.html</link><description><![CDATA[In this post, I’ll talk about a pattern for extracting values from a weakly typed map. This pattern applies to all statically typed languages, and even to dynamically typed ones, but the post is rather Rust-specific.]]></description><guid isPermaLink="false">5b8ae1bc-5625-4115-ab3a-3f399e157314</guid><pubDate>Thu, 24 May 2018 10:18:13 +0000</pubDate><dc:creator>Aleksey Kladov</dc:creator></item><item><title>impl Trait in Rust explanation</title><link>https://medium.com/@iopguy/impl-trait-in-rust-explanation-efde0d94946a</link><description><![CDATA[In Rust 1.26 a new feature called impl Trait was stabilized. How does it work? Instead of specifying an exact type, you can say that your function either returns or takes something that implements a trait.]]></description><guid isPermaLink="false">80818d94-c29b-47b1-8307-f5c9e1d03808</guid><pubDate>Wed, 23 May 2018 04:37:08 +0000</pubDate><dc:creator>Igor Polyakov</dc:creator></item><item><title>Moving out of a Drop struct in Rust?</title><link>http://phaazon.netkblog/rust-no-drop</link><description><![CDATA[Rust doesn’t allow you to move out of a value which type implements Drop, and this is quite logical. When Foo::take returns, because of self going out of scope, it must call its Drop::drop implementation. If you have moved out of it – both a: A and b: B fields, the Drop::drop implementation is now a complete UB. So Rust is right here and doesn’t allow you to do this.

But imagine that we have to do this. For insance, we need to hand over both the scarce resources a and b to another struct (in our case, a (A, B), but you could easily imagine a better type for this).

There’s a way to, still, implement Foo::take with Foo implementing Drop. Here’s how:]]></description><guid isPermaLink="false">7518f181-39ba-4c9c-a76d-1a07b697d264</guid><pubDate>Tue, 22 May 2018 22:22:00 +0000</pubDate><dc:creator>Dimitri Sabadie</dc:creator></item><item><title>Rust is Incredibly Productive for CLIs</title><link>https://www.chriskrycho.com/2018/rust-is-incredibly-productive-for-clis.html</link><description><![CDATA[I built a little tool in Rust to convert an Evernote export file to Markdown. It was impressively easy.]]></description><guid isPermaLink="false">d2971f3f-a40d-45c9-a544-ed94f3b962f6</guid><pubDate>Sun, 20 May 2018 08:35:00 -0400</pubDate><dc:creator>Chris Krycho</dc:creator></item><item><title>Rust for Android games using SDL2</title><link>https://lliwynd.blogspot.com.au/2018/05/rust-for-android-games-using-sdl2.html</link><description><![CDATA[I've been wanting to write a simple Android game for my daughter, and decided to use it as an excuse to learn Rust.  Thus began an odyssey.

I'll ignore the game itself in this post in favour of describing how to get a simple Rust on Android game environment.  For my game I didn't want anything fancy - I wanted to load some jpg files and blit rectangles from those textures to the screen.  But I don't know OpenGL, and I don't really feel the need to learn for this project - if I hit the need to use a shader, then I backtracked and tried another approach.  The plan was to get a simple, high-level graphics API for Rust running on Android.]]></description><guid isPermaLink="false">6e5c626c-f240-41fa-9520-a3d5586523b3</guid><pubDate>Sat, 19 May 2018 16:15:00 +1000</pubDate><dc:creator>William Uther</dc:creator></item><item><title>A boolean&apos;s story</title><link>https://dmerej.info/blog/post/a-booleans-story/</link><description><![CDATA[Earlier this month I told you about my pet project in Rust.

As a reminder, it’s a tool named rusync which contains some of the functionality offered by the rsync command-line tool.

Today I’d like to talk about a feature I’ve added recently, and take this opportunity to show you a few principles of good design along the way.]]></description><guid isPermaLink="false">999b0809-c97d-42c2-b102-d8d2567e8979</guid><pubDate>Fri, 18 May 2018 13:50:38 +0000</pubDate><dc:creator>Dimitri Merejkowsky</dc:creator></item><item><title>Compile Time Prevention of SQL-Injections in Rust</title><link>https://polyfloyd.net/post/compile-time-prevention-of-sql-injections/</link><description><![CDATA[SQL injection vulnerabilities have been a plague ever since such databases have been combined with user facing applications. Such vulnerabilities arise when a SQL query string is naively combined with data that is controlled by an attacker.

To mitigate, people should make use of placeholders and prepared statements provided by SQL client libraries. This separates the variable data from the actual query, ensuring that these two never mix. Pretty much all modern SQL client libraries offer this functionality, but of course, it’s still possible to mix variable data and SQL by means of string concatenation.]]></description><guid isPermaLink="false">c1e5c8e3-46e1-412d-98fe-6735ad9e4f19</guid><pubDate>Fri, 18 May 2018 00:00:00 +0000</pubDate><dc:creator>polyfloyd</dc:creator></item><item><title>FizzBuzz Can Finally Be Implemented in Stable Rust</title><link>https://medium.com/@iopguy/fizzbuzz-can-finally-be-implemented-in-stable-rust-87649a882f2d</link><description><![CDATA[I have been editing my FizzBuzz repository since 2014. After four years, I was finally able to switch from nightly to stable due to the 1.26 release. Let’s back up a little bit and appreciate the changes since the first revision.]]></description><guid isPermaLink="false">2bdd1638-e211-477d-8bb8-3ae0de703661</guid><pubDate>Thu, 17 May 2018 17:23:27 +0000</pubDate><dc:creator>Igor Polyakov</dc:creator></item><item><title>Rust turns three</title><link>https://blog.rust-lang.org/2018/05/15/Rust-turns-three.html</link><description><![CDATA[Three years ago today, the Rust community released Rust 1.0 to the world, with our initial vision of fearless systems programming. As per tradition, we’ll celebrate Rust’s birthday by taking stock of the people and the product, and especially of what’s happened in the last year.]]></description><guid isPermaLink="false">50ca4f3e-2051-4779-adf4-a12615b72d99</guid><pubDate>Tue, 15 May 2018 00:00:00 +0000</pubDate><dc:creator>Aaron Turon</dc:creator></item><item><title>Announcing Rust 1.26</title><link>https://blog.rust-lang.org/2018/05/10/Rust-1.26.html</link><description><![CDATA[The past few releases have had a steady stream of relatively minor additions. We’ve been working on a lot of stuff, however, and it’s all starting to land in stable. 1.26 is possibly the most feature-packed release since Rust 1.0.]]></description><guid isPermaLink="false">c65ddae5-51e1-4eb4-96ab-365e0d819d0f</guid><pubDate>Thu, 10 May 2018 00:00:00 +0000</pubDate><dc:creator>The Rust Core Team</dc:creator></item><item><title>Asynchronous warmy: a prequel</title><link>http://phaazon.net/blog/asynchronous_warmy_prequel</link><description><![CDATA[Last weeks were interesting for warmy, a crate I’ve been writing for several weeks / months now that enables you to hot load and reload scarce resources – e.g. textures, meshes, configuration, JSON parameters, dependency nodes, whatever. warmy received several interesting features.]]></description><guid isPermaLink="false">940f0d10-67ee-49d4-a243-d4310077a962</guid><pubDate>Tue,  8 May 2018 19:30:00 +0000</pubDate><dc:creator>Dimitri Sabadie</dc:creator></item><item><title>Rust: Enterprise Services Need Not Suck</title><link>https://medium.com/@paulhoughton/rust-enterprise-services-need-not-suck-679b79edcab5</link><description><![CDATA[I practice Barbarian Leadership. Standing on the back lines with hand in pocket giving orders is missing the fun. More importantly, knowledge is created on the cutting edge of action. People you work with know this. They value modern, non-hierarchical organizations where a leader dives into the fray, sword in hand, and gets to know intimately the problems and tools for solving them. So I dove into the fight despite knowing that it is “hard language”.]]></description><guid isPermaLink="false">a7a257bb-3da8-42f1-b341-dad7221b9ab3</guid><pubDate>Mon,  7 May 2018 12:59:10 +0000</pubDate><dc:creator>Paul Houghton</dc:creator></item><item><title>Encapsulating Lifetime of the Field</title><link>https://matklad.github.io/2018/05/04/encapsulating-lifetime-of-the-field.html</link><description><![CDATA[This is a post about an annoying Rust pattern and an annoyingworkaround, without a good solution :)]]></description><guid isPermaLink="false">ca367462-e3ba-4b03-9b46-05b7850bdcba</guid><pubDate>Fri,  4 May 2018 17:47:23 +0000</pubDate><dc:creator>Aleksey Kladov</dc:creator></item><item><title>Embedding Rustup into Cargo and the Wrapper</title><link>https://medium.com/@tibotz/embedding-rustup-into-cargo-and-the-wrapper-d5b447f381fc</link><description><![CDATA[One of my issue when building a project from scratch is the amount of manual steps required to be able to run a simple project. This is not so much a concern when you are a single developer but the larger the team, the most obvious it becomes.]]></description><guid isPermaLink="false">cb34566e-4c96-4191-9179-eca6bc9ac07f</guid><pubDate>Fri,  4 May 2018 05:53:28 +0000</pubDate><dc:creator>Tibo Delor</dc:creator></item><item><title>Procedural Macros in Rust</title><link>https://joshleeb.com/posts/rust-procedural-macros/</link><description><![CDATA[Procedural macros are a really powerful language feature in Rust and something I haven’t seen in many other languages.

There are a heap of tutorials out there for procedural macros, including in The Rust Reference, and the first edition of the Rust Book. One of the more entertaining (and useful) posts is by Zach Mitchell where you get to “learn Rust procedural macros with Nic Cage”.

I won’t go into depth about what procedural macros are and why they’re so powerful.]]></description><guid isPermaLink="false">7fe0f8aa-fbe1-4fef-bba3-e64b98b00bc2</guid><pubDate>Fri,  4 May 2018 00:00:00 +0000</pubDate><dc:creator>Josh Leeb-du Toit</dc:creator></item><item><title>Refactoring Apache Arrow to use traits and generics</title><link>https://andygrove.io/2018/05/apache-arrow-traits-generics/</link><description><![CDATA[I am currently working on a refactor of the Rust implementation of Apache Arrow to change the way that arrays are represented. This is a relatively large change even though this is a tiny codebase so far and I thought it would be good to write up this blog post to explain why I think this is needed. I think this information will also be interesting for any Rust developer who is struggling with making the right choice between (or using the right combination of) enums, structs, generics and traits. I was inspired to write this up after reading this blog post that was posted to Reddit just a few days ago.]]></description><guid isPermaLink="false">266098f6-079e-42d6-8d15-3a7867687f49</guid><pubDate>Fri,  4 May 2018 00:00:00 +0000</pubDate><dc:creator>Andy Grove</dc:creator></item><item><title>Rust in production at Figma</title><link>https://blog.figma.com/rust-in-production-at-figma-e10a0ec31929</link><description><![CDATA[How Mozilla’s new language dramatically improved our server-side performance.]]></description><guid isPermaLink="false">d9100be3-bb0c-4ea5-9aff-3fa3b7946b12</guid><pubDate>Wed,  2 May 2018 15:14:00 +0000</pubDate><dc:creator>Evan Wallace</dc:creator></item><item><title>Mutagen – More opportunities</title><link>https://llogiq.github.io/2018/05/01/moreop.html</link><description><![CDATA[Recently I gave a talk at our Rust Meetup about mutagen, and I also showed how our opportunistic mutations work (I however left out that gnarly thing about shifts, but in my defense I was short on time). That got me thinking whether we always do the right thing elsewhere.]]></description><guid isPermaLink="false">4539d16d-f909-4fff-9eda-dc6763fa7a3b</guid><pubDate>Tue,  1 May 2018 00:00:00 +0000</pubDate><dc:creator>Llogiq</dc:creator></item><item><title>How to speed up the Rust compiler in 2018</title><link>https://blog.mozilla.org/nnethercote/2018/04/30/how-to-speed-up-the-rust-compiler-in-2018/</link><description><![CDATA[18 months ago I wrote about some work I did to speed up the Rust compiler (rustc). I’ve recently taken this work up again. Also, in the meantime rustc’s build system has been replaced and its benchmark suite has been overhauled. So it’s a good time for an update.]]></description><guid isPermaLink="false">1c59d8b2-c755-4f10-859e-4847be81bc4c</guid><pubDate>Mon, 30 Apr 2018 04:13:45 +0000</pubDate><dc:creator>Nicholas Nethercote</dc:creator></item><item><title>Installing Rust Offline</title><link>https://hatsunearu.github.io/2018/04/29/rust-offline/</link><description><![CDATA[I wanted to use Rust on an offline Linux system, but it seemed like there isn’t a nice guide to install Rust and some popular packages all in one go (like Anaconda, though what I describe here is much more ghetto), so I decided to summarize the procedure to install the Rust toolchain and some popular libraries all in one go on a system with no internet access.]]></description><guid isPermaLink="false">1d371a92-135a-4456-aca8-5537c9d53c81</guid><pubDate>Sun, 29 Apr 2018 14:00:00 +0000</pubDate><dc:creator>hatsunearu</dc:creator></item><item><title>rustref - memorable Rust reference links</title><link>https://rustref.com/</link><description><![CDATA[This contains shorthand URLs for navigating to Rust documentation.]]></description><guid isPermaLink="false">fce158e9-2134-4c57-bbc8-67483dc0b0d8</guid><pubDate>Fri, 27 Apr 2018 20:12:36 +0000</pubDate><dc:creator>Mackenzie Hauck</dc:creator></item><item><title>An alias-based formulation of the borrow checker</title><link>http://smallcultfollowing.com/babysteps/blog/2018/04/27/an-alias-based-formulation-of-the-borrow-checker/</link><description><![CDATA[Ever since the Rust All Hands, I’ve been experimenting with an alternative formulation of the Rust borrow checker. The goal is to find a formulation that overcomes some shortcomings of the current proposal while hopefully also being faster to compute. I have implemented a prototype for this analysis. It passes the full NLL test suite and also handles a few cases – such as #47680 – that the current NLL analysis cannot handle. However, the performance has a long way to go (it is currently slower than existing analysis). That said, I haven’t even begun to optimize yet, and I know I am doing some naive and inefficient things that can definitely be done better; so I am still optimistic we’ll be able to make big strides there.]]></description><guid isPermaLink="false">282a816f-1c0b-4efc-9939-0674020ee1ef</guid><pubDate>Fri, 27 Apr 2018 00:00:00 -0400</pubDate><dc:creator>Niko Matsakis</dc:creator></item><item><title>Adventures in Rust</title><link>https://dev.to/tmr232/adventures-in-rust-56fc</link><description><![CDATA[A tale of my time in Rust-land]]></description><guid isPermaLink="false">803b6bf7-0cde-4a49-9e63-a117e95de2c0</guid><pubDate>Fri, 27 Apr 2018 00:00:00 +0000</pubDate><dc:creator>Tamir Bahar</dc:creator></item><item><title>Reflections on Rust, and the Sand Castle Metaphor</title><link>https://brandur.org/fragments/rust-reflections</link><description><![CDATA[A month ago, I wrote about how I was frustrated with my progress in Rust. These days, I’m still no expert, but I’ve made progress.]]></description><guid isPermaLink="false">67b88f7c-7b39-43ad-863a-0d03dd180faf</guid><pubDate>Fri, 27 Apr 2018 00:00:00 +0000</pubDate><dc:creator>Brandur Leach</dc:creator></item><item><title>Ask an expert: How do you maintain Rust?</title><link>https://increment.com/programming-languages/maintaining-rust/</link><description><![CDATA[From team structure and annual surveys to RFCs and the release process, a staff research engineer on Mozilla’s Rust team shares what it takes.]]></description><guid isPermaLink="false">76fb9740-07d0-45c8-a6b3-17534f293c54</guid><pubDate>Thu, 26 Apr 2018 19:00:00 +0000</pubDate><dc:creator>Jonathan Turner</dc:creator></item><item><title>Borrowing in async code</title><link>http://aturon.github.io/2018/04/24/async-borrowing/</link><description><![CDATA[The networking working group is pushing hard on async/await notation for Rust, and @withoutboats in particular wrote a fantastic blog series working through the design space. I wanted to talk a little bit about some of the implications of async/await, which may not have been entirely clear. In particular, async/await is not just about avoiding combinators; it completely changes the game for borrowing.]]></description><guid isPermaLink="false">5e0ef28e-278a-48f1-92d1-256a37f76e47</guid><pubDate>Tue, 24 Apr 2018 00:00:00 +0000</pubDate><dc:creator>Aaron Turon</dc:creator></item><item><title>Rust Case Study: Chucklefish Taps Rust to Bring Safe Concurrency to Video Games [pdf]</title><link>https://www.rust-lang.org/pdfs/Rust-Chucklefish-Whitepaper.pdf</link><description><![CDATA[Chucklefish, an independent game studio based in London, publishes hit video games like Stardew Valley and Starbound. Now, the company is developing its next game, code-named Witchbrook, using the Rust programming language instead of C++. Why the switch? Two main reasons: to get better performance on multiprocessor hardware and to have fewer crashes during game play.]]></description><guid isPermaLink="false">49014ace-e742-49f8-887a-8fa7d1b627cc</guid><pubDate>Mon, 23 Apr 2018 17:38:56 +0000</pubDate><dc:creator>The Rust Project Developers</dc:creator></item><item><title>GLib/GIO async operations and Rust futures + async/await</title><link>https://coaxion.net/blog/2018/04/glib-gio-async-operations-and-rust-futures-async-await/</link><description><![CDATA[Unfortunately I was not able to attend the Rust+GNOME hackfest in Madrid last week, but I could at least spend some of my work time at Centricular on implementing one of the things I wanted to work on during the hackfest. The other one, more closely related to the gnome-class work, will be the topic &#8230; <a href="https://coaxion.net/blog/2018/04/glib-gio-async-operations-and-rust-futures-async-await/" class="more-link">Continue reading <span class="screen-reader-text">GLib/GIO async operations and Rust futures + async/await</span></a>]]></description><guid isPermaLink="false">096f02f7-0ce4-41ef-8896-f8209ca126f5</guid><pubDate>Mon, 23 Apr 2018 08:46:32 +0000</pubDate><dc:creator>With the latest GIT version of the Rust bindings for GLib, GTK, etc it is now possible to make use of the Rust futures infrastructure for GIO async operations and various other functions. This should make writing of GNOME, and in general GLib-using, applications in Rust quite a bit more convenient.</dc:creator></item><item><title>BYO Standard: An Explorer&apos;s Guide to Complier Plugins</title><link>https://polysync.io/explorers-guide-to-compiler-plugins</link><description><![CDATA[The Rust programming language provides powerful guarantees around memory and thread safety. It also exposes all the knobs required for implementing custom rules, enabling a project to make additional guarantees and enforce opinions on best practice. Embedded standards are very opinionated about software practices—like using floating point values as loop counters or the number of possible exit points of a function—and Rust’s defaults don’t prevent every runtime panic (for example, recursion that goes too deep and overflows the stack).

For PolySync, a runtime panic means the potential for an unsafe situation on the road, and with that in mind, we’ve explored ways to restrict that potential. Of course, we aren’t the only ones thinking about ways to improve the quality of code at compile time by enforcing the right rules for the job. Active projects like rust-clippy are working to do that too by providing lints to supplement the rustc defaults.

In this post we’ll explore how to enforce a rule by prohibiting a practice we’ve formed an opinion about, the indexing of a vector or an array.]]></description><guid isPermaLink="false">4096f192-ba2d-4a25-b1be-f3e4b0b40b51</guid><pubDate>Sat, 21 Apr 2018 00:00:00 +0000</pubDate><dc:creator>Shea Newton</dc:creator></item><item><title>Why Rust&apos;s error handling is awesome</title><link>http://rantsideasstuff.com/posts/2018/04/20-rust-error-handling-awesome/</link><description><![CDATA[This post is about the process of transforming something you would write as a one-off script in Python (or any other scripting language) into a library including error handling.]]></description><guid isPermaLink="false">ba2b10d2-16a7-4036-8e8f-1fe0d113b0ac</guid><pubDate>Fri, 20 Apr 2018 10:00:00 +0200</pubDate><dc:creator>Zoran Zaric</dc:creator></item><item><title>Dev-tools in 2018</title><link>https://www.ncameron.org/blog/dev-tools-in-2018/</link><description><![CDATA[This is a bit late (how is it the middle of April already?!), but the dev-tools team has lots of exciting plans for 2018 and I want to talk about them! Our goals for 2018 Here's a summary of our goals for the year. Ship it! We want to ship]]></description><guid isPermaLink="false">017d9ce1-f259-4d95-bffc-b3d44dfc8cde</guid><pubDate>Thu, 19 Apr 2018 19:31:53 +0000</pubDate><dc:creator>Nick Cameron</dc:creator></item><item><title>Implementing multiprocessing.pool.ThreadPool from Python in Rust</title><link>https://blog.petrzemek.net/2018/04/16/implementing-multiprocessing-pool-threadpool-from-python-in-rust/</link><description><![CDATA[In this post, we will implement multiprocessing.pool.ThreadPool from Python in Rust. It represents a thread-oriented version of multiprocessing.Pool, which offers a convenient means of parallelizing the execution of a function across multiple input values by distributing the input data across processes. We will use an existing thread-pool implementation and focus on adjusting its interface to match that of multiprocessing.pool.ThreadPool.]]></description><guid isPermaLink="false">447b930e-7350-4ef3-80d4-2ec23a4c5708</guid><pubDate>Mon, 16 Apr 2018 15:14:15 +0000</pubDate><dc:creator>Petr Zemek</dc:creator></item><item><title>Rust pattern: Rooting an Rc handle</title><link>http://smallcultfollowing.com/babysteps/blog/2018/04/16/rust-pattern-rooting-an-rc-handle/</link><description><![CDATA[I’ve decided to do a little series of posts about Rust compiler errors. Each one will talk about a particular error that I got recently and try to explain (a) why I am getting it and (b) how I fixed it. The purpose of this series of posts is partly to explain Rust, but partly just to gain data for myself. I may also write posts about errors I’m not getting – basically places where I anticipated an error, and used a pattern to avoid it. I hope that after writing enough of these posts, I or others will be able to synthesize some of these facts to make intermediate Rust material, or perhaps to improve the language itself.]]></description><guid isPermaLink="false">89612f07-abeb-400f-8bf1-0826601e17d1</guid><pubDate>Mon, 16 Apr 2018 00:00:00 -0400</pubDate><dc:creator>Niko Matsakis</dc:creator></item><item><title>A Useful Feature Few Rust Programmers Know About</title><link>http://rickyhan.com/jekyll/update/2018/04/16/the-best-kept-secret-rust-feature.html</link><description><![CDATA[Surprisingly few know about the built-in pretty-printer. In the book, there is only a short passage that mentions {:#?} in passing. It aligns structs and enums based on nested positions and is automatically derived with Debug.]]></description><guid isPermaLink="false">c3057e94-6b2a-4f19-b109-d6f7b17aefbe</guid><pubDate>Mon, 16 Apr 2018 04:00:00 +0000</pubDate><dc:creator>Ricky Han</dc:creator></item><item><title>From Chaos to Order -- Tools and Techniques for Testing TiDB, A Distributed NewSQL Database</title><link>https://pingcap.com/blog/chaos-practice-in-tidb/</link><description><![CDATA[As an open source distributed NewSQL Hybrid Transactional/Analytical Processing (HTAP) database, TiDB contains the most important asset of our customers--their data. One of the fundamental and foremost requirements of our system is to be fault-tolerant. But how do you ensure fault tolerance in a distributed database? This article covers the top fault injection tools and techniques in Chaos Engineering, as well as how to execute Chaos practices in TiDB.]]></description><guid isPermaLink="false">f4d6ff64-87eb-466f-94a6-fbbaa28fab7d</guid><pubDate>Sat, 14 Apr 2018 00:00:00 +0000</pubDate><dc:creator>Siddon Tang</dc:creator></item></channel></rss>