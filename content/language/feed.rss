<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/"><channel><title>Read Rust - Language</title><link>https://readrust.net/</link><description>Language posts on Read Rust</description><item><title>Cross compiling Rust from Linux to macOS</title><link>https://wapl.es/rust/2019/02/17/rust-cross-compile-linux-to-macos.html</link><description><![CDATA[I’ve recently been working on a Rust project at work which requires compiling for Linux (GNU), Linux (musl - for Alpine Linux) and macOS. I use Linux Mint nearly all the time, so building for macOS targets has required asking very nicely to borrow a spare Macbook Air. This is naturally a bit crap, so I set out to find a Linux-only solution to cross compile for macOS using osxcross. A weekend of pain later, and I have the following post. Hopefully it spares you a weekend of your own pain.]]></description><guid isPermaLink="false">e412275c-f2ce-4748-bf3d-c53375ff5693</guid><pubDate>Sun, 17 Feb 2019 00:00:00 +0000</pubDate><dc:creator>James Waples</dc:creator></item><item><title>Moving from Ruby to Rust</title><link>https://deliveroo.engineering/2019/02/14/moving-from-ruby-to-rust.html</link><description><![CDATA[How we migrated our Tier 1 service from Ruby to Rust and didn’t break production.]]></description><guid isPermaLink="false">d1d825d3-b864-466c-9909-287ae17591a9</guid><pubDate>Thu, 14 Feb 2019 00:00:00 +0000</pubDate><dc:creator>Andrii Dmytrenko</dc:creator></item><item><title>Gtk-rs: how to have mutable object in a closure?</title><link>http://sireliah.com/niusy/gtk_rust_mutable_object_in_closure/</link><description><![CDATA[I wanted, was to start the Gtk application with already generated image of the prime numbers spiral (contained in gtk::Image widget) and then be able to re-generate the image when user changed something. It could be "Generate" click action for instance to show image in different resolution or color. The problem with the button closure was that when I added the Gtk image to the box_vert container, the next time the button was pressed, the code was supposed to remove existing image and add new one, but it didn't.]]></description><guid isPermaLink="false">56014abd-0fd0-4b8c-91ba-734e4f16ddac</guid><pubDate>Tue, 12 Feb 2019 21:58:00 +0000</pubDate><dc:creator>Piotr Gołąb</dc:creator></item><item><title>No, the problem isn’t “bad coders”</title><link>https://medium.com/@sgrif/no-the-problem-isnt-bad-coders-ed4347810270</link><description><![CDATA[A recent blog article discussed the fact that 70% of all security bugs in Microsoft products are due to memory safety vulnerabilities. A lot of the comments I’ve seen on social media boil down to “The problem isn’t the use of a memory unsafe language, but that the programmers who wrote this code are bad.”

In this article, I’m going to look at a recent bug that was caught by the Rust compiler, which I think shows that not only is this assertion unreasonable but virtually impossible for reasons I haven’t seen discussed. While the example I’m going to give is about thread safety rather than memory safety, the arguments I’m going to present can be applied to both.]]></description><guid isPermaLink="false">1c46694b-ae67-4596-9f46-0e9fd419f585</guid><pubDate>Tue, 12 Feb 2019 16:13:55 +0000</pubDate><dc:creator>Sean Griffin</dc:creator></item><item><title>All-Hands 2019 Recap</title><link>https://www.ralfj.de/blog/2019/02/12/all-hands-recap.html</link><description><![CDATA[Last week, I was in Berlin at the Rust All-Hands 2019. It was great! I will miss nerding out in discussions about type theory and having every question answered by just going to the person who’s the expert in that area, and asking them. In this post, I am summarizing the progress we made in my main areas of interest and the discussions I was involved in—this is obviously just a small slice of all the things that happened.]]></description><guid isPermaLink="false">03bb4da4-48ab-4e1a-a092-be737761fd6f</guid><pubDate>Tue, 12 Feb 2019 00:00:00 +0000</pubDate><dc:creator>Ralf Jung</dc:creator></item><item><title>Are you still using `println` in Rust for debugging?</title><link>https://blog.knoldus.com/are-you-still-using-println-in-rust-for-debugging/</link><description><![CDATA[In this blog, I will explain about new debugging macro dbg, added in Rust 1.32.0. This is a macro for quick and dirty debugging with which you can inspect the value of a given expression.]]></description><guid isPermaLink="false">3c0e89db-b8b3-44bc-a952-4cf406146fae</guid><pubDate>Mon, 11 Feb 2019 04:20:21 +0000</pubDate><dc:creator>Ayush Mishra</dc:creator></item><item><title>Rust: A unique perspective</title><link>https://limpet.net/mbrubeck/2019/02/07/rust-a-unique-perspective.html</link><description><![CDATA[In which I try to explain the reasoning behind Rust’s memory-safety mechanisms.]]></description><guid isPermaLink="false">d7fe7d63-d2c8-4bfc-834b-a93155c10dcb</guid><pubDate>Thu,  7 Feb 2019 00:00:00 +0000</pubDate><dc:creator>Matt Brubeck</dc:creator></item><item><title>Rust Governance: Scaling Empathy</title><link>https://manishearth.github.io/blog/2019/02/04/rust-governance-scaling-empathy/</link><description><![CDATA[There’s been a lot of talk about improving Rust’s governance model lately. As we decompress from last year’s hectic edition work, we’re slowly starting to look at all the bits of debt we accumulated, and organizational debt is high on that list.

I’ve been talking in private with people about a bunch of these things for quite a while now, and I felt it worthwhile to write down as much of my thoughts as I can before the Rust All Hands in Berlin this week.]]></description><guid isPermaLink="false">66563fe6-008a-475e-9337-42ee770d649c</guid><pubDate>Mon,  4 Feb 2019 00:00:00 +0000</pubDate><dc:creator>Manish Goregaokar</dc:creator></item><item><title>Rust: regret-less concurrency</title><link>https://medium.com/@polyglot_factotum/rust-regret-less-concurrency-2238b9e53333</link><description><![CDATA[Rust offers the promise of “fearless concurrency”, and delivers on it through memory safety. Yet this safety doesn’t guarantee code that is easy to maintain. If one is not “fearful” of complexity, concurrency can easily become a story of regrets. Can we get a “regret-less” kind of concurrency?]]></description><guid isPermaLink="false">4a6ed1c0-83d7-4392-9d2a-9b749a5433fe</guid><pubDate>Sat,  2 Feb 2019 12:15:32 +0000</pubDate><dc:creator>Polyglot Factotum</dc:creator></item><item><title>Cargo&apos;s next few years</title><link>https://www.ncameron.org/blog/cargos-next-few-years/</link><description><![CDATA[The Cargo team have been thinking about and discussing long-term plans for Cargo. In this post I'll talk about what we hope Cargo will look like around the time of the next edition (assuming there is another edition and that it happens in about three years, neither of which is confirmed). There will be another post soon on more concrete plans for this year, including some kind of roadmap.]]></description><guid isPermaLink="false">040a805b-f794-4df1-810f-5d3607a3f274</guid><pubDate>Sat,  2 Feb 2019 04:35:37 +0000</pubDate><dc:creator>Nick Cameron</dc:creator></item><item><title>The steps towards rustc, the great optimiser</title><link>https://kazlauskas.me/entries/the-road-to-bestest-optimiser.html</link><description><![CDATA[It has been more than 3 years now since the MIR ini­ti­at­ive has been ac­cep­ted. Cur­rently rustc has a num­ber of MIR op­tim­isa­tions: a simple in­lin­er, ba­sic con­stant and copy propaga­tion, a single in­struc­tion com­bin­a­tion rule, a few graph sim­pli­fic­a­tion and clean up passes… The pat­tern here is clear – most of the op­tim­isa­tions we cur­rently have are ba­sic and lim­ited in their po­tency. Given the pace at which we man­aged to bring up MIR in the first place, one would be right to ex­pect… some­thing more.

As some­body who has made an at­tempt and failed to im­ple­ment a num­ber of data­flow-­based op­tim­isa­tions (a­mong other thing­s), I con­sider my­self fairly qual­i­fied to haz­ard a guess as to what is the reason for the cur­rent state we are at. Here it goes.]]></description><guid isPermaLink="false">892a8c46-fee3-48d8-bc78-69a13a9a5c8d</guid><pubDate>Fri,  1 Feb 2019 00:00:00 +0000</pubDate><dc:creator>Simonas Kazlauskas</dc:creator></item><item><title>Killing unwrap()</title><link>https://dmerej.info/blog/post/killing-unwrap/</link><description><![CDATA[A collection of snippets to avoid unnecessary calls to unwrap() in Rust.]]></description><guid isPermaLink="false">7028c8de-9b0d-4f0f-a74e-0e07126cd80e</guid><pubDate>Wed, 30 Jan 2019 19:11:26 +0000</pubDate><dc:creator>Dimitri Merejkowsky</dc:creator></item><item><title>Salsa: Incremental recompilation</title><link>http://smallcultfollowing.com/babysteps/blog/2019/01/29/salsa-incremental-recompilation/</link><description><![CDATA[So for the last couple of months or so, I’ve been hacking in my spare time on this library named salsa, along with a number of awesome other folks. Salsa basically extracts the incremental recompilation techniques that we built for rustc into a general-purpose framework that can be used by other programs. Salsa is developing quickly: with the publishing of v0.10.0, we saw a big step up in the overall ergonomics, and I think the current interface is starting to feel very nice.]]></description><guid isPermaLink="false">30602bae-8957-4b3a-92d2-eec9e6f2fddd</guid><pubDate>Tue, 29 Jan 2019 00:00:00 -0500</pubDate><dc:creator>Niko Matsakis</dc:creator></item><item><title>Rust on iOS</title><link>https://medium.com/visly/rust-on-ios-39f799b3c1dd</link><description><![CDATA[If you’re an iOS developer you may be asking yourself how and why you would make use of Rust on iOS. This article will mostly cover the how. As to why, the most compelling reason for us at Visly is that it enables us to share code between Android and iOS in a performant and safe manner, in a language much easier to work with than C++.]]></description><guid isPermaLink="false">2d233ddd-ecb5-499d-88b8-a0f14797c1a7</guid><pubDate>Sat, 26 Jan 2019 21:30:07 +0000</pubDate><dc:creator>Emil Sjölander</dc:creator></item><item><title>Rust OSS Governance and Sustainablility I</title><link>https://mgattozzi.com/oss-governance-and-sustainablility-i/</link><description><![CDATA[Recently I travelled all the way to Waterloo from Boston for Starcon. With a 9 hour drive I had a lot of time to think about things and so I spent a good majority of it thinking about OSS Governanace and Sustainability. What I came up with and thought of is the more concrete solutions to the problems I brought up in my Rust 2019 post. With the Rust All hands in Berlin only a few weeks away I wanted to get my thoughts in order by writing out some of the solutions to specific problems I came up with. Now, this doesn't mean they'll be accepted! We might even find better solutions! I just felt a need to articulate them as both a reference point and to make sure I've thought through them well. I'll be splitting them into a few posts so I can publish more faster, rather than write one long post that won't be published in time. With that in mind let's begin!]]></description><guid isPermaLink="false">799301a7-d57a-4e9c-8412-aafc4e643f0a</guid><pubDate>Tue, 22 Jan 2019 04:20:23 +0000</pubDate><dc:creator>Michael Gattozzi</dc:creator></item><item><title>Polonius and the case of the hereditary harrop predicate</title><link>http://smallcultfollowing.com/babysteps/blog/2019/01/21/hereditary-harrop-region-constraints/</link><description><![CDATA[In my previous post about Polonius and subregion obligations, I mentioned that there needs to be a follow-up to deal with higher-ranked subregions. This post digs a bit more into what the problem is in the first place and sketches out the general solution I have in mind, but doesn’t give any concrete algorithms for it.]]></description><guid isPermaLink="false">09b9f354-aeed-4d48-b859-9c63fcdddb2e</guid><pubDate>Mon, 21 Jan 2019 00:00:00 -0500</pubDate><dc:creator>Niko Matsakis</dc:creator></item><item><title>Why aren&apos;t my Rust threads running?</title><link>https://esimmler.com/why-arent-my-rust-threads-running/</link><description><![CDATA[I got a bit tangled up while experimenting with threads and channels in Rust. The compiler prevented any undefined behavior or memory corruption, but it can only do so much. My problems came from a shaky understanding of the language’s fundamentals and the inherent complexity of parallel programming. Or, in my case, attempted parallel programming.]]></description><guid isPermaLink="false">f950f168-d74e-4b3a-b2f5-18546a7d282b</guid><pubDate>Sat, 19 Jan 2019 00:00:00 +0000</pubDate><dc:creator>Erik Simmler</dc:creator></item><item><title>Closures: Magic Functions</title><link>https://krishnasannasi.github.io/rust/syntactic/sugar/2019/01/17/Closures-Magic-Functions.html</link><description><![CDATA[Closures seem like magical functions. They can do magic like capture their environment, which normal functions can’t do. How does this work?]]></description><guid isPermaLink="false">85502039-9617-4e25-a34d-2e1f8cd2f452</guid><pubDate>Thu, 17 Jan 2019 19:00:00 +0000</pubDate><dc:creator>Krishna Sannasi</dc:creator></item><item><title>When Rust is safer than Haskell</title><link>https://www.fpcomplete.com/blog/when-rust-is-safer-than-haskell</link><description><![CDATA[Haskell generally has better safety guarantees than Rust, there are some cases when Rust is safer than Haskell. This post explores when Rust is safe to use.]]></description><guid isPermaLink="false">65dcfcd4-e17a-4e0d-bd56-ccea6cfe062f</guid><pubDate>Thu, 17 Jan 2019 18:09:09 +0000</pubDate><dc:creator>Michael Snoyman</dc:creator></item><item><title>Polonius and region errors</title><link>http://smallcultfollowing.com/babysteps/blog/2019/01/17/polonius-and-region-errors/</link><description><![CDATA[Now that NLL has been shipped, I’ve been doing some work revisiting the Polonius project. Polonius is the project that implements the “alias-based formulation” described in my older blogpost. Polonius has come a long way since that post; it’s now quite fast and also experimentally integrated into rustc, where it passes the full test suite.]]></description><guid isPermaLink="false">2afd97b3-7b60-4a21-b07a-7f353a23dc4d</guid><pubDate>Thu, 17 Jan 2019 00:00:00 -0500</pubDate><dc:creator>Niko Matsakis</dc:creator></item><item><title>Announcing Rust 1.32.0</title><link>https://blog.rust-lang.org/2019/01/17/Rust-1.32.0.html</link><description><![CDATA[Rust 1.32.0 has a few quality of life improvements, switches the default allocator, and makes additional functions const.]]></description><guid isPermaLink="false">97ace8ce-4c4f-442d-bab3-10a97bd119df</guid><pubDate>Thu, 17 Jan 2019 00:00:00 +0000</pubDate><dc:creator>The Rust Release Team</dc:creator></item><item><title>How to order Rust code</title><link>https://deterministic.space/how-to-order-rust-code.html</link><description><![CDATA[Note:This post is about how I arrange the code I write in Rust.If you wanted to “order” Rust codein the “hire someone to write code” sense,you should still keep on readingas this is excellent material for a job interview.(Not the opinion I present but having an opinion on the topic.)]]></description><guid isPermaLink="false">90b0ffa9-1711-4870-9e30-37375be50515</guid><pubDate>Thu, 17 Jan 2019 00:00:00 +0100</pubDate><dc:creator>Pascal Hertleif</dc:creator></item><item><title>Scala Developer Journey into Rust - Part 2 : Type Inference</title><link>http://blog.madhukaraphatak.com/rust-scala-part-2/</link><description><![CDATA[Rust is one of the major programming languages that’s been getting popular in recent years. It has many advanced high level language features like Scala.This made me interested to learn Rust. So in this next series of blogs I will share my experience with Rust from a Scala developer point of view. I would like to explore how these two language approach things. I would like to explore the similarities and their differences.]]></description><guid isPermaLink="false">0b01d8d7-aa94-4382-8fbf-c2979f7018ad</guid><pubDate>Mon, 14 Jan 2019 00:00:00 +0000</pubDate><dc:creator>Madhukara Phatak</dc:creator></item><item><title>Exploring Column-Oriented Data in Rust with frunk HLists</title><link>https://paulkernfeld.com/2019/01/13/frunk-column.html</link><description><![CDATA[Row-oriented storage and column-oriented storage are two major ways of laying out data in memory. In Rust, there is a simple way to think of this: row-oriented storage is like an array of structs, whereas column-oriented storage is like a struct of arrays. It’s easy to use row-oriented storage in Rust, so this post is going to explore column-oriented storage.]]></description><guid isPermaLink="false">b4d25622-7886-48c7-901c-e382c05122cb</guid><pubDate>Sun, 13 Jan 2019 00:00:00 +0000</pubDate><dc:creator>Paul Kernfeld</dc:creator></item><item><title>Letting the compiler tell you what to do - an example using Rust</title><link>https://dmerej.info/blog/post/letting-the-compiler-tell-you-what-to-do/</link><description><![CDATA[If you’ve ever wrote code in a compiled language (C, C++, Java, …), you are probably used to compiler error messages, and you may think there are only here to prevent you from making mistakes. Well sometimes you can also use compiler error messages to design and implement new features. Let me show you with a simple command-line program written in Rust.]]></description><guid isPermaLink="false">e743cfa5-87bc-46d7-9dc6-693352d91e6a</guid><pubDate>Sat, 12 Jan 2019 12:26:27 +0000</pubDate><dc:creator>Dimitri Merejkowsky</dc:creator></item><item><title>const types, traits and implementations in Rust</title><link>https://varkor.github.io/blog/2019/01/11/const-types-traits-and-implementations-in-Rust.html</link><description><![CDATA[Rust permits a limited form of compile-time function execution in the form of const and const fn. While, initially, const may seem like a reasonaby straightforward feature, it turns out to raise a wealth of interesting and complex design questions. In this post, we’re going to look at a particular design question that has been under discussion for some time and propose a design that is natural and expressive. This is motivated both from a syntactic perspective and a theoretic perspective.]]></description><guid isPermaLink="false">dfbac96b-1ab3-48a8-9c50-917188335ddd</guid><pubDate>Fri, 11 Jan 2019 19:02:40 +0000</pubDate><dc:creator>varkor</dc:creator></item><item><title>Librsvg is almost rustified now</title><link>https://people.gnome.org/~federico/blog/librsvg-is-almost-rustified.html</link><description><![CDATA[Since a few days ago, librsvg's library implementation is almost 100% Rust code. Paolo Borelli's and Carlos Martín Nieto's latest commits made it possible. What does "almost 100% Rust code" mean here?]]></description><guid isPermaLink="false">54ecd8fa-cc4f-4c5f-acef-fc75e1e6ce7f</guid><pubDate>Thu, 10 Jan 2019 12:28:11 -0600</pubDate><dc:creator>Federico Mena Quintero</dc:creator></item><item><title>Proposed Rust community norm for unsafe code</title><link>http://sanxiyn.blogspot.com/2019/01/proposed-rust-community-norm-for-unsafe.html</link><description><![CDATA[Recently cessen asked  people to write their thoughts on Rust community norm for unsafe code. So here it is.]]></description><guid isPermaLink="false">60e20969-d592-4d79-91e8-633409505b03</guid><pubDate>Thu, 10 Jan 2019 19:03:00 +0900</pubDate><dc:creator>Seo Sanghyeon</dc:creator></item><item><title>Understanding Rust Lifetimes</title><link>https://medium.com/nearprotocol/understanding-rust-lifetimes-e813bcd405fa</link><description><![CDATA[No, seriously, this time for real.]]></description><guid isPermaLink="false">5c15ca59-eba1-43d8-9dd4-206f574826cf</guid><pubDate>Thu, 10 Jan 2019 01:26:26 +0000</pubDate><dc:creator>Maksym Zavershynskyi</dc:creator></item><item><title>Rust Community Norms for Unsafe Code</title><link>https://blog.cessen.com/post/2019_01_09_rust_community_norms_for_unsafe_code</link><description><![CDATA[I recently released Ropey 1.0, a text rope library for Rust. Ropey uses unsafe code internally, and its use of unsafe unsurprisingly came up in the 1.0 release thread on Reddit.

The ensuing discussion (especially thanks to Shnatsel) helped me significantly reduce the amount of unsafe code in Ropey with minimal (though not non-existent) performance degradation. But the whole thing nevertheless got me thinking about unsafe code and community norms around it, and I figured writing some of those thoughts down might be useful.]]></description><guid isPermaLink="false">fa5229de-d279-44c7-9d62-0163e7dc1771</guid><pubDate>Wed,  9 Jan 2019 00:00:00 +0000</pubDate><dc:creator>Nathan Vegdahl</dc:creator></item><item><title>Comparing Rust and JavaScript Ergonomics with a Simple Linked List</title><link>https://www.codesections.com/blog/javascript-vs-rust-linked-list/</link><description><![CDATA[My day-to-day work involves writing a fair bit of JavaScript but, lately, I've gotten really interested in Rust. The other day, I decided to take a slightly different approach: I decided to take a simple linked list program—the type can and do ask my students to implement in JavaScript in ~20 minutes—and re-implement it in Rust. Specifically, I decided to build a queue implemented with a singly linked list.]]></description><guid isPermaLink="false">a46b1128-605b-4cab-b36f-5766125ba2f3</guid><pubDate>Sun,  6 Jan 2019 00:00:00 +0000</pubDate><dc:creator>Daniel Long Sockwell</dc:creator></item><item><title>Building a JS Interpreter in Rust – Part 2</title><link>https://jason-williams.co.uk/building-a-js-interpreter-in-rust-part-2/</link><description><![CDATA[When writing an interpreter or a compiler for any language, you usually need to start with a lexer and a parser. Boa here is no different, our first task will be to do the same but what do these do?]]></description><guid isPermaLink="false">916f96ed-c1cc-4955-ade6-626b3ebf08bd</guid><pubDate>Wed,  2 Jan 2019 00:00:00 +0000</pubDate><dc:creator>Jason Williams</dc:creator></item><item><title>Deriving Traits in Rust with Procedural Macros</title><link>https://naftuli.wtf/2019/01/02/rust-derive-macros/</link><description><![CDATA[Procedural macros in Rust are a really compelling feature that I didn’t understand until recently. There are a few gotchas, but they make it super easy to implement custom #[derive()] expansions for implementing traits with a single line of code. Let’s dive in.]]></description><guid isPermaLink="false">470de398-add8-4fdd-9b38-c79c781c58fa</guid><pubDate>Wed,  2 Jan 2019 00:00:00 +0000</pubDate><dc:creator>Naftuli Kay</dc:creator></item><item><title>What is &apos;Placement New&apos; in Rust?</title><link>http://blakesmith.me/2018/12/31/what-is-placement-new-in-rust.html</link><description><![CDATA[Placement new is a feature currently being discussed for the Rust programming language. It gives programmer control of memory allocation and memory placement, where current memory allocation implementations are hidden behind compiler internals via the Box::new interface. This is Rust’s answer to C++ placement new, allowing one to control not only when and how memory is freed, but also where it is allocated and freed from.]]></description><guid isPermaLink="false">793ef59c-ee13-4673-a06b-e65d461e7b1c</guid><pubDate>Mon, 31 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Blake Smith</dc:creator></item><item><title>A Rusty Advent of Code</title><link>https://cprimozic.net/blog/a-rusty-aoc/</link><description><![CDATA[For the first time, I took part in the Advent of Code this year. If you haven't heard of it, it's a daily programming challenge that can be solved in any programming language. Rust was very present in the Advent of Code community with people contributing a ton of Rust-related content. In the daily solutions thread on the /r/aoc subreddit, there were always several Rust solutions posted. Advent of Code really helps show off the things that make Rust shine, demonstrating the power and utility of many community-created crates as well as the language itself.]]></description><guid isPermaLink="false">04d1c753-5242-4aa9-bff7-500a717a62bc</guid><pubDate>Thu, 27 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Casey Primozic</dc:creator></item><item><title>Barriers and Two-phase Borrows in Stacked Borrows</title><link>https://www.ralfj.de/blog/2018/12/26/stacked-borrows-barriers.html</link><description><![CDATA[My internship (“research assistantship”) with Mozilla has ended several weeks ago, and this post is a report of the most recent tweaks I made to Miri and Stacked Borrows. Neither project is by any means “done”, of course. However, both have reached a fairly reasonable state, so I felt some kind of closing report made sense. Also, if I ever want to finish my PhD, I’ll have to seriously scale down the amount of time I work on Rust – so at least from my side, things will move more slowly from now on.

In particular, installing Miri and running your test suite in it is now just a single command away! Scroll all the way down if you are not interested in the rest.]]></description><guid isPermaLink="false">152067d5-472f-4ba2-9429-6a5de749bf99</guid><pubDate>Wed, 26 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Ralf Jung</dc:creator></item><item><title>Handling failure in Rust</title><link>https://esimmler.com/handling-failure-in-rust/</link><description><![CDATA[I’ve begun to seriously dig into the Rust programming language. The learning curve is real, but I already appreciate the work they’ve put into ergonomics. I’m writing a simple photo thumbnail endpoint using the Rocket web framework (v0.4) and Image library (v0.20.1). My first pass used a lot of unwrapping to ignore potential errors. A lot can go wrong, even in this “simple” case. Rocket catches any panics thrown by route handlers, so this is about as robust as a naive equivalent in most other languages. However, Rust at least forces us to be explicit and purposeful about when we want to be sloppy. This is great for a first quick and dirty pass, but we can do much better.]]></description><guid isPermaLink="false">0a14c8b2-c25a-4733-9682-e1cc71567cc9</guid><pubDate>Wed, 26 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Erik Simmler</dc:creator></item><item><title>async-io-demo: Rust asynchronous io: from mio to stackless coroutine</title><link>https://github.com/Hexilee/async-io-demo</link><description><![CDATA[2019 is approaching. The rust team keeps their promise about asynchronous IO: async is introduced as keywords, Pin, Future, Poll and await! is introduced into standard library. I have never used rust for asynchronous IO programming earlier, so I almost know nothing about it. However, I would use it for a project recently but couldn't find many documents that are remarkably helpful for newbie of rust asynchronous programming. My purpose of writing this blog is to review and summarize, I will be happy if it can help someone who are interested in rust asynchronous programming.]]></description><guid isPermaLink="false">fe9a3482-44e2-48d3-8728-0a15b4d2fd48</guid><pubDate>Wed, 26 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Li Chenxi</dc:creator></item><item><title>Currying in rust Part 3 (The circle of life ... aka why borrowchecker ... why?!)</title><link>https://hashnode.com/post/currying-in-rust-part-3-the-circle-of-life-aka-why-borrowchecker-why-cjq3z1dd800dknds1sls4dqav</link><description><![CDATA[Today we're going to take a look at the 'pipe' function my friend has written and why all of the sudden lifetimes get important esp. when using references.]]></description><guid isPermaLink="false">bddc8eb0-f2db-4330-87fa-2eca9a68e9e5</guid><pubDate>Tue, 25 Dec 2018 16:35:00 +0000</pubDate><dc:creator>j</dc:creator></item><item><title>Generate Rust tests from data files</title><link>https://blog.cyplo.net/posts/2018/12/generate-rust-tests-from-data.html</link><description><![CDATA[Sometimes you just have a bunch of example data laying around and you want to make sure your code works with all of them. Some of them are probably short and sweet and could live happily as doctests, which are amazing btw. But some of them are more awkward to present in such form, because, for example, of their size or number. Typically when you have an example of how the program should behave you write an example-based unit test. Ideally, each of them would represent an isolated example and they should fail independently. But, converting your source data files into a unit test one by one, manually, can be a bit tedious. Rust build scripts to the rescue !]]></description><guid isPermaLink="false">2eb4baa4-aac1-4bc2-8162-d2eb290a1ac9</guid><pubDate>Tue, 25 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Cyryl Płotnicki</dc:creator></item><item><title>On Rust</title><link>https://dehora.net/journal/2018/12/23/on-rust</link><description><![CDATA[Back in 2013, I started a series of posts on programming languages I found interesting. One of the languages I wanted to write about at that time was Rust. As often happens, life got in the way, and it’s only now, in the twilight of 2018 I’m coming round to a long overdue post.]]></description><guid isPermaLink="false">0717e76b-2097-4ee0-87b1-5f6cffadbdf0</guid><pubDate>Sun, 23 Dec 2018 16:34:59 +0000</pubDate><dc:creator>Bill de hÓra</dc:creator></item><item><title>Visualizing Crates.io</title><link>https://8-p.info/visualizing-crates-io/</link><description><![CDATA[Visualizing Rust's growing ecosystem through crates.io, Rust's central package repository.]]></description><guid isPermaLink="false">7dd6ca97-374d-4c01-86fb-f3fed29bb6f6</guid><pubDate>Sun, 23 Dec 2018 12:06:00 +0000</pubDate><dc:creator>Kazuyoshi Kato</dc:creator></item><item><title>Methods for Array Initialization in Rust</title><link>https://www.joshmcguigan.com/blog/array-initialization-rust/</link><description><![CDATA[Arrays in Rust are fixed size, and Rust requires that every element in an array is initialized to a valid value when the array is initialized. The result of these requirements is array initialization in Rust is a much deeper topic then it would seem.]]></description><guid isPermaLink="false">5e9ee3df-617a-4a7c-b8bd-ade701971b10</guid><pubDate>Sat, 22 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Josh Mcguigan</dc:creator></item><item><title>Six years with Rust</title><link>https://words.steveklabnik.com/six-years-with-rust</link><description><![CDATA[This past year was… intense. Rust 1.31 was basically Rust 2.0, at least in the marketing sense. I burned myself out getting the first edition of the book together for Rust 1.0, and I burned myself out getting the edition shipped.

Let’s talk about the bad and the good. Bad first so we end on the high notes.]]></description><guid isPermaLink="false">deb0916b-c8e3-47b1-b957-bfa8015b73ff</guid><pubDate>Fri, 21 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Steve Klabnik</dc:creator></item><item><title>Procedural Macros in Rust 2018</title><link>https://blog.rust-lang.org/2018/12/21/Procedural-Macros-in-Rust-2018.html</link><description><![CDATA[Perhaps my favorite feature in the Rust 2018 edition is procedural macros. Procedural macros have had a long and storied history in Rust (and will continue to have a storied future!), and now is perhaps one of the best times to get involved with them because the 2018 edition has so dramatically improved the experience both defining and using them.

Here I'd like to explore what procedural macros are, what they're capable of, notable new features, and some fun use cases of procedural macros. I might even convince you that this is Rust 2018's best feature as well!]]></description><guid isPermaLink="false">e01f334f-a14e-4a54-b7d7-76c9cc6ccdc7</guid><pubDate>Fri, 21 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Alex Crichton</dc:creator></item><item><title>Creating an empty iterator of a certain type in Rust</title><link>https://www.freedomlayer.org/offst/option-iterator/</link><description><![CDATA[I am working these days on the development of offst's Index server. I needed to implement a basic directed graph structure, allowing to run the BFS algorithm to find routes with a certain amount of capacity. During the work on the Index server I had the problem of wanting to return an empty iterator in an early flow of a function.]]></description><guid isPermaLink="false">3f750cea-55f1-44cf-b965-b3a2803de32b</guid><pubDate>Sat, 15 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Freedomlayer</dc:creator></item><item><title>Rust 2019 - my 2¢</title><link>https://www.reddit.com/r/rust/comments/a5s024/rust_2019_my_2/</link><description><![CDATA[I will not be really original here, but I really hope to see the following features to land on stable in 2019: const generics, async/await, GATs, inherent traits, minimum supported Rust version:]]></description><guid isPermaLink="false">dd6ec508-904b-4cd2-96ca-3df2ed99b074</guid><pubDate>Thu, 13 Dec 2018 20:24:49 +1100</pubDate><dc:creator>u/newpavlov</dc:creator></item><item><title>Yet another Rust 2018 wishlist</title><link>https://www.reddit.com/r/rust/comments/a5q7eb/yet_another_rust_2018_wishlist/</link><description><![CDATA[The 2018 year brought a lot of incredible new features and I'm impressed with all the work that was put in to make the 2018 edition happen. I want to join the other users asking for 2019 to be a year we adjust to all the new changes and focus on cleaning and polishing, not entirely new projects*. For the upcoming year I'd like to see progress on compilation speed and maintenance attention in the library ecosystem.]]></description><guid isPermaLink="false">d4acf845-6f69-4f54-bd37-96d62f83a54c</guid><pubDate>Thu, 13 Dec 2018 15:38:32 +1100</pubDate><dc:creator>u/Saefroch</dc:creator></item><item><title>Bootstrapping Rust</title><link>https://www.gnu.org/software/guix/blog/2018/bootstrapping-rust/</link><description><![CDATA[It has been a long-standing tradition to develop a language far enough to be able to write the language's compiler in the same language, and Rust does the same. Rust is nowadays written in Rust. We've tracked down the earlier Rust versions, which were written in OCaml, and were planning to use these to bootstrap Rust. But in parallel, John Hudge (Mutabah) developed a Rust compiler, called "mrustc", written in C++. mrustc is now good enough to compile Rust 1.19.0. Using mrustc, we were able to build Rust entirely from source with a bootstrap chain]]></description><guid isPermaLink="false">6bf8dccd-51b6-4dcb-a9eb-e38923d28a2c</guid><pubDate>Tue, 11 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Danny Milosavljevic</dc:creator></item><item><title>Existential types in Rust</title><link>https://adelbertc.github.io/posts/2018-12-10-rust-existentials.html</link><description><![CDATA[The Rust project I am working on is a caching layer, currently backed by Redis, and it came to a point where I needed to leverage pipelining. On its own, pipelining is straightforward as the redis crate implements it already. However all notions of a cache in our code are abstracted out behind a trait so we can have alternative implementations, such as an in-memory HashMap-backed implementation.

The problem arises with representing the pipeline in code. It would force any implementation of our cache to Redis’s notion of a pipeline. Not only would this make it difficult to introspect during testing, but it would also be nonsensical for our HashMap-backed cache. My usual answer to this in languages that support higher-kinded types is to use tagless-final algebras, but Rust’s type system currently doesn’t support higher-kinded types1. Fortunately, there is a pretty good alternative that Rust does support: existential types.]]></description><guid isPermaLink="false">4fe3c55c-a091-40c2-ada0-8c5d371afc31</guid><pubDate>Mon, 10 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Adelbert Chang</dc:creator></item><item><title>Rust 2019</title><link>https://vfoley.xyz/rust-2019/</link><description><![CDATA[In 2019, there are three areas where I would like to see the Rust community focus its efforts: Improved compile times, A community effort to review crates, More “80% solutions”.]]></description><guid isPermaLink="false">a02deaa2-0f75-48c6-86ef-f6a314be6355</guid><pubDate>Sun,  9 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Vincent Foley</dc:creator></item><item><title>Inside Rust’s Async Transform</title><link>https://blag.nemo157.com/2018/12/09/inside-rusts-async-transform.html</link><description><![CDATA[As you likely know if you’re reading this post Rust has an upcoming async/await feature being tested in nightly. Because of Rust’s unique features and positioning fully understanding the implementation powering this syntax is very different to understanding other well-known implementations (C# and JavaScript’s being the ones I am familiar with). Instead of thinking of a CPS-like transform where an async function is split into a series of continuations that are chained together via a Future::then method, Rust instead uses a generator/coroutine transform to turn the function into a state machine (C# and probably most JavaScript implementations use a similar transform under the hood, but as far as I’m aware because of the garbage collector these are indistinguishable from the naive CPS transform they are normally described as). For more detail on why Rust is taking this approach you should read eRFC 2033: Experimental Coroutines, that lays out the why’s much better than I could here.

What I’m going to try and provide instead, is a look into how this actually works today. What steps the compiler takes to turn an async fn into a normal function returning a state machine that you could write if you wanted to (but you definitely don’t).]]></description><guid isPermaLink="false">9303577c-bd85-4bfa-9b0c-30685300155c</guid><pubDate>Sun,  9 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Wim Looman</dc:creator></item><item><title>Debugging Cargo Test</title><link>https://www.wihlidal.com/blog/general/2018-12-07-debugging-cargo-test/</link><description><![CDATA[While developing some crates in rust, I ran into a few crashes in certain situations when using these crates from another application. In order to more easily reproduce the problem, and also minimize or eliminate future regressions, I decided to write some unit tests for these issues, and use them to more easily debug the problems… or so I thought!]]></description><guid isPermaLink="false">b9206a7e-5ee3-4336-b756-afab50e9992f</guid><pubDate>Fri,  7 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Graham Wihlidal</dc:creator></item><item><title>Rust 2018 is here… but what is it?</title><link>https://hacks.mozilla.org/2018/12/rust-2018-is-here/</link><description><![CDATA[Starting today, the Rust 2018 edition is in its first release. With this edition, we’ve focused on making Rust developers as productive as they can be. But beyond that, it can be hard to explain exactly what Rust 2018 is.]]></description><guid isPermaLink="false">a9fa887f-3615-45d9-ab2d-d400d30f1039</guid><pubDate>Thu,  6 Dec 2018 16:13:55 +0000</pubDate><dc:creator>Lin Clark</dc:creator></item><item><title> A call for Rust 2019 Roadmap blog posts</title><link>https://blog.rust-lang.org/2018/12/06/call-for-rust-2019-roadmap-blogposts.html</link><description><![CDATA[Starting today and running until of January 15, we’d like to ask the community to write blogposts reflecting on Rust in 2018 and proposing goals and directions for Rust in 2019.]]></description><guid isPermaLink="false">3234baba-f03d-467c-b032-d7d0dec7a12d</guid><pubDate>Thu,  6 Dec 2018 00:00:00 +0000</pubDate><dc:creator>The Rust Community Team</dc:creator></item><item><title> Announcing Rust 1.31 and Rust 2018</title><link>https://blog.rust-lang.org/2018/12/06/Rust-1.31-and-rust-2018.html</link><description><![CDATA[The Rust team is happy to announce a new version of Rust, 1.31.0, and "Rust 2018" as well. Rust is a programming language that empowers everyone to build reliable and efficient software.]]></description><guid isPermaLink="false">18cf1853-dbff-4634-8045-fbcaf36bd4fc</guid><pubDate>Thu,  6 Dec 2018 00:00:00 +0000</pubDate><dc:creator>The Rust Core Team</dc:creator></item><item><title>More on RLS version numbering</title><link>https://www.ncameron.org/blog/more-on-rls-version-numbering/</link><description><![CDATA[In a few days the 2018 edition is going to roll out, and that will include some new framing around Rust's tooling. We've got a core set of developer tools which are stable and ready for widespread use. We're going to have a blog post all about that, but for]]></description><guid isPermaLink="false">2b4ef111-3f3b-416d-b94d-55fe01a94455</guid><pubDate>Tue,  4 Dec 2018 03:00:20 +0000</pubDate><dc:creator>Nick Cameron</dc:creator></item><item><title>How I Wrote a Modern C++ Library in Rust</title><link>https://hsivonen.fi/modern-cpp-in-rust/</link><description><![CDATA[Since version 56, Firefox has had a new character encoding conversion library called encoding_rs. It is written in Rust and replaced the old C++ character encoding conversion library called uconv that dated from early 1999. Initially, all the callers of the character encoding conversion library were C++ code, so the new library, despite being written in Rust, needed to feel usable when used from C++ code. In fact, the library appears to C++ callers as a modern C++ library. Here are the patterns that I used to accomplish that.]]></description><guid isPermaLink="false">823c892a-d7a2-4185-b80f-ba0b47899b25</guid><pubDate>Mon,  3 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Henri Sivonen</dc:creator></item><item><title>Refactoring allowed URLs in librsvg</title><link>https://people.gnome.org/~federico/blog/refactoring-allowed-urls-in-librsvg.html</link><description><![CDATA[While in the middle of converting librsvg's code that processes XML from C to Rust, I went into a digression that has to do with the way librsvg decides which files are allowed to be referenced from within an SVG. There was a central function rsvg_io_acquire_stream() which took a URL as a string. The code assumed that that URL had been first validated with a function called allow_load(url). Rust made it possible to actually make it impossible to acquire a disallowed URL.]]></description><guid isPermaLink="false">8788ae2c-06ea-4226-a28e-8755b31c6860</guid><pubDate>Thu, 29 Nov 2018 11:31:37 -0600</pubDate><dc:creator>Federico Mena Quintero</dc:creator></item><item><title>Rust Flow, Part Two</title><link>https://myrrlyn.net/blog/misc/rust-flow-part-two</link><description><![CDATA[Rust doesn’t have a language-level concept of generic mutability, which makes “method threading” (which take `self` by some handle, and return it in the same way) hard to write. This article covers how to write in that pattern in a less painful way.]]></description><guid isPermaLink="false">5a0c9b1f-c433-44e6-947e-74076725fc32</guid><pubDate>Thu, 29 Nov 2018 00:00:00 +0000</pubDate><dc:creator>Alexander Payne</dc:creator></item><item><title>A new look for rust-lang.org</title><link>https://blog.rust-lang.org/2018/11/29/a-new-look-for-rust-lang-org.html</link><description><![CDATA[Today, we’d like to announce a beta of the new rust-lang.org. If you go to https://beta.rust-lang.org, you’ll see a preview of the new site.]]></description><guid isPermaLink="false">6afc7e52-af6d-4ecd-a5af-fb9e27a6ccf6</guid><pubDate>Thu, 29 Nov 2018 00:00:00 +0000</pubDate><dc:creator>The Rust Core Team</dc:creator></item><item><title>Rust Quiz</title><link>https://dtolnay.github.io/rust-quiz/</link><description><![CDATA[Test your Rust knowledge with tricky Rust questions.]]></description><guid isPermaLink="false">8c1f73a9-291c-4aa2-9e50-2cf4538f36db</guid><pubDate>Thu, 29 Nov 2018 00:00:00 +0000</pubDate><dc:creator>David Tolnay and Alex Crichton</dc:creator></item><item><title>Rust Language Cheat Sheet</title><link>https://cheats.rs/</link><description><![CDATA[This is the "Rust Language Cheat Sheet". It is for users who: are early Rust professionals (experienced programmers, intermediate Rust users), and prefer visual, example-driven content. Use cases, in order of priority: "identification guide" for unknown or symbolic constructs encountered in code. Provide further reading from easy to advanced (Book to Nomicon). Quick lookup for language related problems. Discover constructs in the language you might not know.]]></description><guid isPermaLink="false">ed652ceb-f7cd-4566-b37c-757f6d089240</guid><pubDate>Wed, 28 Nov 2018 00:00:00 +0000</pubDate><dc:creator>Ralf Biedert</dc:creator></item><item><title>Rust Survey 2018 Results</title><link>https://blog.rust-lang.org/2018/11/27/Rust-survey-2018.html</link><description><![CDATA[Another year means another Rust survey, and this year marks Rust’s third annual survey. This year, the survey launched for the first time in multiple languages. In total 14 languages, in addition to English, were covered. The results from non-English languages totalled 25% of all responses and helped pushed the number of responses to a new record of 5991 responses. Before we begin the analysis, we just want to give a big “thank you!” to all the people who took the time to respond and give us your thoughts. It’s because of your help that Rust will continue to improve year after year.]]></description><guid isPermaLink="false">5ed5c8fa-d94a-44ab-836b-35ee61f1f048</guid><pubDate>Tue, 27 Nov 2018 00:00:00 +0000</pubDate><dc:creator>The Rust Survey Team</dc:creator></item><item><title>Haskell and Rust</title><link>https://www.fpcomplete.com/blog/2018/11/haskell-and-rust</link><description><![CDATA[Learn more about how the Rust programming language shares many of the advantages offered by Haskell such as a strong type system, great tooling, polymorphism, immutability, concurrency, and great software testing methodologies.  Rust is a good choice when you need to squeeze in extra performance.]]></description><guid isPermaLink="false">400c4c0d-78d0-41fe-bd07-c4a720ade708</guid><pubDate>Mon, 26 Nov 2018 17:33:00 +0000</pubDate><dc:creator>Chris Allen</dc:creator></item><item><title>Getting started with nightly async/await support</title><link>https://jsdw.me/posts/rust-asyncawait-preview/</link><description><![CDATA[Following on from my last post, I thought I would look at async/await support in Rust. The async/await support coming to Rust brings with it a much more ergonomic way to work with asynchronous computations. In this post I'll introduce std::future::Future, and run through how to make use of them, and how to interoperate with the current ecosystem which is built around version 0.1 of the futures package.]]></description><guid isPermaLink="false">c1afc363-1078-4dbd-a3e4-e0f05f255d62</guid><pubDate>Mon, 26 Nov 2018 00:00:00 +0000</pubDate><dc:creator>James Wilson</dc:creator></item><item><title>Converting AsyncRead and AsyncWrite to Futures, Sinks and Streams</title><link>https://jsdw.me/posts/rust-futures-tokio/</link><description><![CDATA[Prior to this experience, I had thought that Futures, Sinks and Streams were the smallest building blocks in the world of Tokio, and so I went looking through the Tokio documentation for these things. Actually, all of the fundamental objects to read and write bytes to things implement one or both of AsyncRead and AsyncWrite, but not the Future, Sink or Stream traits. In fact, there are lots of poll_x methods dotted around, so I realised I needed to figure out how to make use of them.]]></description><guid isPermaLink="false">22495ae4-a7be-4899-92ab-ede35669df1b</guid><pubDate>Sun, 25 Nov 2018 00:00:00 +0000</pubDate><dc:creator>James Wilson</dc:creator></item><item><title>Propagating Errors</title><link>https://people.gnome.org/~federico/blog/propagating-errors.html</link><description><![CDATA[Lately, I have been converting the code in librsvg that handles XML from C to Rust. For many technical reasons, the library still uses libxml2, GNOME's historic XML parsing library, but some of the callbacks to handle XML events like start_element, end_element, characters, are now implemented in Rust. This has meant that I'm running into all the cases where the original C code in librsvg failed to handle errors properly; Rust really makes it obvious when that happens.

In this post I want to talk a bit about propagating errors. You call a function, it returns an error, and then what?]]></description><guid isPermaLink="false">ff73c006-4009-4e7b-9405-7d4ea2b3c08d</guid><pubDate>Wed, 21 Nov 2018 13:58:12 -0600</pubDate><dc:creator>Federico Mena Quintero</dc:creator></item><item><title>Compile Time Feature Flags in Rust</title><link>https://www.worthe-it.co.za/programming/2018/11/18/compile-time-feature-flags-in-rust.html</link><description><![CDATA[Toggling feature flags when you compile for zero runtime cost]]></description><guid isPermaLink="false">24375765-7fa7-4729-8b69-734c409c47fb</guid><pubDate>Sun, 18 Nov 2018 00:00:00 +0000</pubDate><dc:creator>Justin Worthe</dc:creator></item><item><title>Can you Drop it?</title><link>http://optimistictypes.com/can-you-drop-it/</link><description><![CDATA[Resource allocation & the implementation of drop logic in Rust.]]></description><guid isPermaLink="false">18ce3041-0f7a-4bf8-8e5a-ccea2a6c8053</guid><pubDate>Sat, 17 Nov 2018 00:00:00 +0000</pubDate><dc:creator>J Haigh</dc:creator></item><item><title>Programming Servo: A background-hang-monitor</title><link>https://medium.com/programming-servo/programming-servo-a-background-hang-monitor-73e89185ce1</link><description><![CDATA[Let’s say you’re contributing to a system in Rust consisting of a bunch of different components, running in their own threads or processes, for example an engine to make the Web run.

When one of those components seemingly hangs on something, how can you find out what it is hanging on? Maybe a backtrace of what that component is doing at that time would be useful?

That’s easy, for that we have thebacktrace-rs crate, right?

Well, there’s a catch: how do we call Backtrace::new() from a thread that is hanging?]]></description><guid isPermaLink="false">40ed3562-277a-453f-84a6-29ab5314ed0c</guid><pubDate>Fri, 16 Nov 2018 12:30:06 +0000</pubDate><dc:creator>Gregory Terzian</dc:creator></item><item><title>Stacked Borrows Implemented</title><link>https://www.ralfj.de/blog/2018/11/16/stacked-borrows-implementation.html</link><description><![CDATA[Three months ago, I proposed Stacked Borrows as a model for defining what kinds of aliasing are allowed in Rust, and the idea of a validity invariant that has to be maintained by all code at all times. Since then I have been busy implementing both of these, and developed Stacked Borrows further in doing so. This post describes the latest version of Stacked Borrows, and reports my findings from the implementation phase: What worked, what did not, and what remains to be done. There will also be an opportunity for you to help the effort!]]></description><guid isPermaLink="false">4d211c62-3ab3-4db5-a900-94731f798765</guid><pubDate>Fri, 16 Nov 2018 00:00:00 +0000</pubDate><dc:creator>Ralf Jung</dc:creator></item><item><title>Managing Rust Dependencies with Nix, Part I</title><link>https://www.hadean.com/blog/managing-rust-dependencies-with-nix-part-i</link><description><![CDATA[Learn how to integrate Rust Cargo package manager with the Nix package manager.]]></description><guid isPermaLink="false">a4b9f89c-49bd-4910-b1c6-de1c0da5786c</guid><pubDate>Thu, 15 Nov 2018 16:03:00 +0000</pubDate><dc:creator>James Kay</dc:creator></item><item><title>Program Synthesis is Possible in Rust</title><link>http://fitzgeraldnick.com/2018/11/15/program-synthesis-is-possible-in-rust.html</link><description><![CDATA[Program synthesis is the act of automatically constructing a program thatfulfills a given specification. I recently stumbled across Adrian Sampson’s Program Synthesis is Possible blog post. Adrian describes and implements minisynth, a toy program synthesizer that generates constants for holes in a template program when given a specification. What fun! As a way to learn more about program synthesis myself, I ported minisynth to Rust.]]></description><guid isPermaLink="false">e8b911ca-d007-441e-93e3-d8f1f1b89a00</guid><pubDate>Thu, 15 Nov 2018 00:00:00 -0800</pubDate><dc:creator>Nick Fitzgerald</dc:creator></item><item><title>Things Rust doesn’t let you do</title><link>https://medium.com/@GolDDranks/things-rust-doesnt-let-you-do-draft-f596a3c740a5</link><description><![CDATA[A survey of things that Rust doesn’t let you do although arguably safe.]]></description><guid isPermaLink="false">858249f6-6979-48c9-a138-1b7fd2fc9502</guid><pubDate>Mon, 12 Nov 2018 01:34:25 +0000</pubDate><dc:creator>Pyry Kontio</dc:creator></item><item><title>Rust Flow: Function and Method Sequences in Rust</title><link>https://myrrlyn.net/blog/misc/rust-flow</link><description><![CDATA[Rust allows for a very functional style of value “flow” without sacrificing the performance of a more traditionally imperative sequence. Furthermore, the functional flow may offer more clarity about value lifetimes and error handling that the imperative sequence might obscure.]]></description><guid isPermaLink="false">d435191e-e40d-477d-a5ee-908808ee5eee</guid><pubDate>Sun, 11 Nov 2018 14:44:00 +0000</pubDate><dc:creator>Alexander Payne</dc:creator></item><item><title>Truly Zero Cost</title><link>https://vorner.github.io/2018/11/11/truly-zero-cost.html</link><description><![CDATA[I know it is claimed how Rust has zero cost abstractions and such and that all these levels of abstractions will just go away in a release build. But there’s a difference in hearing the theory and seeing it really happen in practice. And I don’t appreciate it because I’d consider it magic, but more because I understand how that is being done and it still looks cool.]]></description><guid isPermaLink="false">c6c90807-5108-434e-9dc0-c5ba8135420d</guid><pubDate>Sun, 11 Nov 2018 00:00:00 +0000</pubDate><dc:creator>Michal &apos;vorner&apos; Vaner</dc:creator></item><item><title>Monadic do notation in Rust: Part I</title><link>https://varkor.github.io/blog/2018/11/10/monadic-do-notation-in-rust-part-i.html</link><description><![CDATA[Following last time, where we saw that, given parameterision over traits (rather than just types), we could implement functors and monads in Rust that supported existing “monad-like” traits like Iterator and Future, I thought it would be interesting to tackle another one of the arguments against monads in Rust.]]></description><guid isPermaLink="false">364d5469-2447-49c8-ab4c-e0b82da96f27</guid><pubDate>Sat, 10 Nov 2018 20:10:56 +0000</pubDate><dc:creator>varkor</dc:creator></item><item><title>After NLL: Moving from borrowed data and the sentinel pattern</title><link>http://smallcultfollowing.com/babysteps/blog/2018/11/10/after-nll-moving-from-borrowed-data-and-the-sentinel-pattern/</link><description><![CDATA[Continuing on with my “After NLL” series, I want to look at another common error that I see and its solution: today’s choice is about moves from borrowed data and the Sentinel Pattern that can be used to enable them.]]></description><guid isPermaLink="false">9dae526e-703d-4726-b68c-92f847e3c85f</guid><pubDate>Sat, 10 Nov 2018 00:00:00 -0500</pubDate><dc:creator>Niko Matsakis</dc:creator></item><item><title>Storing unboxed trait objects in Rust</title><link>https://guiand.xyz/blog-posts/unboxed-trait-objects.html</link><description><![CDATA[This blog post will outline the creation of dynstack, a stack datastructure that stores trait objects unboxed to minimize the number of heap allocations necessary.]]></description><guid isPermaLink="false">c02900f4-a733-4865-980c-3c139ffe0ac8</guid><pubDate>Sat, 10 Nov 2018 00:00:00 +0000</pubDate><dc:creator>Gui Andrade</dc:creator></item><item><title>proc_macro_attribute Revisited</title><link>https://llogiq.github.io/2018/11/10/proc-macro.html</link><description><![CDATA[Recently, the procedural macro interface was somewhat stabilized. OK, there’s still the unstable proc_macro_hygiene feature you have to activate, but at least the registrar and rustc_private are no longer needed.]]></description><guid isPermaLink="false">190265bb-a65b-4acd-99e9-3d6f8a06969c</guid><pubDate>Sat, 10 Nov 2018 00:00:00 +0000</pubDate><dc:creator>Llogiq</dc:creator></item><item><title>How to get the size of Rust types with -Zprint-type-sizes</title><link>https://blog.mozilla.org/nnethercote/2018/11/09/how-to-get-the-size-of-rust-types-with-zprint-type-sizes/</link><description><![CDATA[When optimizing Rust code it’s sometimes useful to know how big a type is, i.e. how many bytes it takes up in memory. std::mem::size_of can tell you, but often you want to know the exact layout as well. For example, an enum might be surprisingly big, in which case you probably will want to know if, for example, there is one variant that is much bigger than the others.]]></description><guid isPermaLink="false">4ace2654-b6a1-4a4a-9917-07f9e12c1ec2</guid><pubDate>Fri,  9 Nov 2018 03:42:40 +0000</pubDate><dc:creator>Nicholas Nethercote</dc:creator></item><item><title>Making progress in await syntax</title><link>https://boats.gitlab.io/blog/post/await-syntax/</link><description><![CDATA[One thing we’ve left as an unresolved question so far in the matter of async/await syntax is the exact final syntax for the await operation. In the current implementation, awaits are written using a compiler plugin:

async fn foo() {
await!(bar());
}

This is not because of any technical limitation: the reason we have done this is that we have not decided on the precise, final syntax for the await operation.]]></description><guid isPermaLink="false">89cf760b-0385-4e81-ad78-45b7eb3b2aa2</guid><pubDate>Thu,  8 Nov 2018 00:00:00 +0000</pubDate><dc:creator>withoutboats</dc:creator></item><item><title>Still in love with Rust</title><link>https://dpc.pw/still-in-love-with-rust</link><description><![CDATA[I think I've discovered Rust somewhere around the year 2012. With time I grew more and more fond of Rust. The language kept evolving in a direction that was my personal sweet spot: a modern C. And at some point I realized I'm in love with Rust. And I still am today, after a couple of years of using it. So let me tell you why is Rust my darling programming language.]]></description><guid isPermaLink="false">c9fdbd06-59fd-444f-b7a9-cd238817a72f</guid><pubDate>Tue,  6 Nov 2018 07:38:10 +0000</pubDate><dc:creator>Dawid Ciężarkiewicz aka `dpc`</dc:creator></item><item><title>A hammer you can only hold by the handle</title><link>https://blog.systems.ethz.ch/blog/2018/a-hammer-you-can-only-hold-by-the-handle.html</link><description><![CDATA[Today we’re looking at the rust borrow checker from a different perspective. As you may know, the borrow checker is designed to safely handle memory allocation and ownership, preventing accessess to invalid memory and ensuring data-race freedom. This is a form of resource management: the borrow checker is tracking who’s in charge of a chunk of memory, and who is currently allowed to read or write to it. In this post, we’ll see how these facilities can be used to enforce higher-level API constraints in your libraries and software. Once you’re familiar with these techniques, we’ll cover how the same principles apply to advanced memory management and handling of other more abstract resources.]]></description><guid isPermaLink="false">495a9412-287b-4baf-af46-007603eff49a</guid><pubDate>Mon,  5 Nov 2018 00:00:00 +0000</pubDate><dc:creator>Andrea Lattuada</dc:creator></item><item><title>A New Way of Thinking</title><link>https://boakye.yiadom.org/rust/new/</link><description><![CDATA[Rust was my language of the year. You know, that thing where programmers set out to learn a new programming language every year. Usually not to be productive at it but to familiarize themselves with current trends in language design, implementation, and paradigms. I had heard a lot of good stuff about Rust and decided late last year to make it my 2018 language. I’m only a few days in but I’ve been smacked by some of what I consider the best ideas in programming I’ve encountered yet.]]></description><guid isPermaLink="false">6e6bbbca-9a60-4c29-a050-1d34f08192ea</guid><pubDate>Sun,  4 Nov 2018 23:59:50 +0000</pubDate><dc:creator>Yaw Boakye</dc:creator></item><item><title>On dealing with owning and borrowing in public interfaces</title><link>https://phaazon.net/blog/on-owning-borrowing-pub-interface</link><description><![CDATA[I’ve been writing on a few examples code lately to add to documentations of some crates of mine. I write a lot of code that creates new objects that need other objects in order to be built. Most of the APIs you can see around tend to love the borrow principle – and I do.]]></description><guid isPermaLink="false">dd822196-d8f4-4764-9727-6096581c035a</guid><pubDate>Sun,  4 Nov 2018 01:30:00 +0000</pubDate><dc:creator>Dimitri Sabadie</dc:creator></item><item><title>Optional Arguments in Rust</title><link>https://hoverbear.org/2018/11/04/optional-arguments/</link><description><![CDATA[When designing an API for your crate one topic which can come is how to handle optional arguments. Let’s explore our Options in Rust!]]></description><guid isPermaLink="false">125dced7-207a-4c36-904b-3d17c903c508</guid><pubDate>Sun,  4 Nov 2018 00:00:00 +0000</pubDate><dc:creator>Andrew Hobden</dc:creator></item><item><title>Higher-Order Functions in Rust</title><link>https://dev.to/deciduously/higher-order-functions-in-rust-287h</link><description><![CDATA[Rust is an imperative language but it provides many tools in the standard library which adhere to a more functional style, like the Iterator trait and its methods like map, for_each, and filter. This is a quick run-down of how to define your own higher-order functions in Rust which can both take closures as parameters and return closures in such a way that you can use the two together.]]></description><guid isPermaLink="false">bfe6aa2d-0dbd-4966-81cc-eebed27ca28d</guid><pubDate>Sat,  3 Nov 2018 00:00:00 +0000</pubDate><dc:creator>Ben Lovy</dc:creator></item><item><title>Anchored and Uniform Paths</title><link>https://boats.gitlab.io/blog/post/anchored-uniform/</link><description><![CDATA[Rust 2018 is almost out the door, but there is one big decision the language team has yet to make. It has to do with the modules and paths system, so of course it is a very easy decision that no one has a strong opinion about. ;-)
In Rust 2018, we’ll be making some big changes to how paths work to try to create a more consistent experience. The “lodestar” (if you will) of these changes is an idea we call “1path:” the idea no matter where you are in your project, whether in a use statement or normal code, a path is interpreted the same way.]]></description><guid isPermaLink="false">7be81fee-ef29-448f-9e03-9be0fc63fbb7</guid><pubDate>Fri,  2 Nov 2018 00:00:00 +0000</pubDate><dc:creator>withoutboats</dc:creator></item><item><title>After NLL: Interprocedural conflicts</title><link>http://smallcultfollowing.com/babysteps/blog/2018/11/01/after-nll-interprocedural-conflicts/</link><description><![CDATA[In my previous post on the status of NLL, I promised to talk about “What is next?” for ownership and borrowing in Rust. I want to lay out the various limitat...]]></description><guid isPermaLink="false">bfd4f2e7-3e44-4383-a144-ae5da7c664fa</guid><pubDate>Thu,  1 Nov 2018 00:00:00 -0400</pubDate><dc:creator>Niko Matsakis</dc:creator></item><item><title>MIR-based borrowck is almost here</title><link>http://smallcultfollowing.com/babysteps/blog/2018/10/31/mir-based-borrowck-is-almost-here/</link><description><![CDATA[Now that the final Rust 2018 Release Candidate has shipped, I thought it would be a good idea to do another update on the state of the MIR-based borrow check (aka NLL). Let’s get the highlights out of the way. Most importantly, Rust 2018 crates will use NLL by default. Once the Rust 2018 release candidate becomes stable, we plan to switch Rust 2015 crates to use NLL as well, but we’re holding off until we have some more experience with people using it in the wild.]]></description><guid isPermaLink="false">3c73e50b-c4cd-43ea-9214-49f711bf3058</guid><pubDate>Wed, 31 Oct 2018 00:00:00 -0400</pubDate><dc:creator>Niko Matsakis</dc:creator></item><item><title>From Rust to beyond: The PHP galaxy</title><link>https://mnt.io/2018/10/29/from-rust-to-beyond-the-php-galaxy/</link><description><![CDATA[This blog post is part of a series explaining how to send Rust beyond earth, into many different galaxies. The galaxy we will explore today is the PHP galaxy. This post will explain what PHP is, how to compile any Rust program to C and then to a PHP native extension.]]></description><guid isPermaLink="false">6bf46601-8824-4e8e-b625-f3b6f9d074da</guid><pubDate>Mon, 29 Oct 2018 10:17:12 +0000</pubDate><dc:creator>Ivan Enderlin</dc:creator></item><item><title>Finding and fixing memory leaks in a Hyper application or &apos;How I Learned to Stop Worrying and Love the Allocator&apos;</title><link>https://blog.1aim.com/2018/10/finding-and-fixing-memory-leaks-in-a-hyper-application-or-how-i-learned-to-stop-worrying-and-love-the-allocator/</link><description><![CDATA[I was doing some initial load testing of the next version our application, so that performance regressions can be tracked, when I noticed something. After only a few seconds of throwing wrk at it, our backend was using 1.3GB of memory, growing at around 50MB/s. Yikes.]]></description><guid isPermaLink="false">1f6655e8-89c4-4e30-91e6-776449b88293</guid><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><dc:creator>Ferdia McKeogh</dc:creator></item><item><title>My release checklist for Rust programs</title><link>https://dev.to/sharkdp/my-release-checklist-for-rust-programs-1m33</link><description><![CDATA[After some practice with three of my Rust projects (fd, hyperfine and bat), my workflow has converged to something that works quite well and avoids many pitfalls that I have walked into in the past. My hope in writing this post is that this process can be useful for others as well. The following is my release checklist for fd, but I have very similar lists for other projects.]]></description><guid isPermaLink="false">e5f786a1-6dd9-427f-8202-03b5a38a7ace</guid><pubDate>Sun, 28 Oct 2018 00:00:00 +0000</pubDate><dc:creator>David Peter</dc:creator></item><item><title>Improving ndarray-csv: Goodbye failure, Hello Extension Traits</title><link>https://paulkernfeld.com/2018/10/27/improving-ndarray-csv.html</link><description><![CDATA[Two weeks ago, I wrote a blog post explaining some design decisions that I made for the ndarray-csv crate. Based on some excellent Reddit comments and GitHub issues from dtolnay, I have amended some of these decisions.]]></description><guid isPermaLink="false">427d9cb0-4562-45c7-b6f0-3defc4df172b</guid><pubDate>Sat, 27 Oct 2018 00:00:00 +0000</pubDate><dc:creator>Paul Kernfeld</dc:creator></item><item><title>Problems Scaling A Large Multi-Crate Rust Project</title><link>https://robert.ocallahan.org/2018/10/problems-scaling-large-multi-crate-rust.html?m=1</link><description><![CDATA[We have 85K lines of Rust code implementing the backend of our Pernosco debugger. To impose some modularity constraints and to reduce build times, from the beginning we organized our code as a large set of crates in a single Cargo workspace in a single Gitlab repository. Currently we have 48 crates. This has mostly worked pretty well but as the number of our crates keeps increasing, we have hit some serious scalability problems.]]></description><guid isPermaLink="false">e64df9c0-3056-4720-837e-670543317c59</guid><pubDate>Thu, 25 Oct 2018 00:00:00 +0000</pubDate><dc:creator>Robert O&apos;Callahan</dc:creator></item><item><title>The Case For Macros</title><link>https://llogiq.github.io/2018/10/25/macros.html</link><description><![CDATA[I know a few Rustaceans who are wary of macros. One privately admitted to hating them with a passion. They are right; macros can make code harder to understand (both for humans and computers, for example many clippy lints have an explicit check to only lint outside of macros), so they should be used with some caution.]]></description><guid isPermaLink="false">451e814b-f0e1-4d88-bdda-9862ab107902</guid><pubDate>Thu, 25 Oct 2018 00:00:00 +0000</pubDate><dc:creator>Llogiq</dc:creator></item><item><title>Announcing Rust 1.30</title><link>https://blog.rust-lang.org/2018/10/25/Rust-1.30.0.html</link><description><![CDATA[The Rust team is happy to announce a new version of Rust, 1.30.0. Rust 1.30 is an exciting release with a number of features: Procedural Macros, Module system improvements, Raw Identifiers, and more.]]></description><guid isPermaLink="false">3db4746e-d5ac-46c7-af24-a25e2db1b7d2</guid><pubDate>Thu, 25 Oct 2018 00:00:00 +0000</pubDate><dc:creator>The Rust Core Team</dc:creator></item><item><title>Rust&apos;s Orphan Rule Is Good, Actually</title><link>https://davidlegare.ghost.io/rusts-orphan-rule/</link><description><![CDATA[The orphan trait rule in Rust is interesting and works impressively well for what it intends to do. While I'm often frustrated by the limitations it imposes, it absolutely succeeds at removing ambiguity in whether or not a trait will be implemented for a type.]]></description><guid isPermaLink="false">c2e61957-0d95-43e3-af09-3173307bf95c</guid><pubDate>Sat, 20 Oct 2018 05:42:04 +0000</pubDate><dc:creator>David LeGare</dc:creator></item></channel></rss>