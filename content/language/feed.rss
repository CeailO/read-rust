<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/"><channel><title>Read Rust - Language</title><link>https://readrust.net/</link><description>Language posts on Read Rust</description><item><title>Rust review: The book</title><link>http://julio.meroh.net/2018/06/rust-review-book.html</link><description><![CDATA[“The Rust Programming Language” is one of the free books that the community has put together to teach the language. The book does a good job in general, but there are some things that could be better. Let’s cover these, but first, some background.]]></description><guid isPermaLink="false">0122445e-8a19-4a52-bcd6-4ee7e55feb7c</guid><pubDate>Tue, 19 Jun 2018 09:00:00 -0400</pubDate><dc:creator>Julio Merino</dc:creator></item><item><title>Rust + Diesel + GitLab + CI</title><link>https://noyez.gitlab.io/post/2018-06-15-rust-plus-diesel-plus-gitlab/</link><description><![CDATA[It is very straightforward to get Rust projects to build within a CI environment. This post is going to take that build process one small step further, we’re going to build a Rust project that uses the Diesel ORM. This adds a step of complexity since to compile a Diesel project you need to have a postgresql database accessible if you’re using the infer_schema!() macro.]]></description><guid isPermaLink="false">67f2f6f8-75f9-458c-969f-4bcbe9c0223f</guid><pubDate>Mon, 18 Jun 2018 00:00:00 +0000</pubDate><dc:creator>noyez</dc:creator></item><item><title>Rust Is Not So Hairy</title><link>https://nevi.me/rust-is-not-so-hairy/</link><description><![CDATA[TL;DR I decided to learn Rust on my nth attempt. Writing small programs helped me get stuff done. I converted a Java gRPC service into Rust for comparison I'm super-impressed with Rust's low CPU and memory footprint.]]></description><guid isPermaLink="false">41722089-9cfe-413c-aa51-02c244fb4d67</guid><pubDate>Sat, 16 Jun 2018 14:05:48 +0000</pubDate><dc:creator>Neville</dc:creator></item><item><title>Dynamic Casting for Traits</title><link>http://idubrov.name/rust/2018/06/16/dynamic-casting-traits.html</link><description><![CDATA[In Rust, traits are a powerful tool to use polymorphism, both static and dynamic. I’m going to skip the basics about the traits and just link to another blog post with a good explanation about static and dynamic dispatch in Rust: Traits and Trait Objects in Rust.

Instead, I would like to do an experiment of making dynamic dispatch even more dynamic! Like in Java1.]]></description><guid isPermaLink="false">977aa3cd-7136-4d69-84ac-0c15c6396ae4</guid><pubDate>Sat, 16 Jun 2018 00:00:00 +0000</pubDate><dc:creator>Ivan Dubrov</dc:creator></item><item><title>Rust review: The match keyword</title><link>http://julio.meroh.net/2018/06/rust-review-match-keyword.html</link><description><![CDATA[A commonly-acclaimed feature of Rust is its match keyword: a “conditional on steroids”. match lets you take the value of an expression and compare it against a bunch of values—or, more generally, patterns.

As you write and read Rust, you will notice that this keyword is used everywhere because it’s the way to access certain types, like Option values or error codes.]]></description><guid isPermaLink="false">b5fe7539-f996-4c57-9fc1-5fa06b6a68b2</guid><pubDate>Fri, 15 Jun 2018 09:00:00 -0400</pubDate><dc:creator>Julio Merino</dc:creator></item><item><title>MIR-based borrow check (NLL) status update</title><link>http://smallcultfollowing.com/babysteps/blog/2018/06/15/mir-based-borrow-check-nll-status-update/</link><description><![CDATA[I’ve been getting a lot of questions about the status of “Non-lexical lifetimes” (NLL) – or, as I prefer to call it these days, the MIR-based borrow checker – so I wanted to post a status update.

The single most important fact is that the MIR-based borrow check is feature complete and available on nightly. What this means is that the behavior of #![feature(nll)] is roughly what we intend to ship for “version 1”, except that (a) the performance needs work and (b) we are still improving the diagnostics.]]></description><guid isPermaLink="false">c55b518c-125b-4fb9-82c5-08c3367bb6c6</guid><pubDate>Fri, 15 Jun 2018 00:00:00 -0700</pubDate><dc:creator>Niko Matsakis</dc:creator></item><item><title>What do you think are the most interesting/exciting projects using Rust?</title><link>https://www.ncameron.org/blog/interesting_projects/</link><description><![CDATA[Last week I tweeted "What do you think are the most interesting/exciting projects using Rust? (No self-promotion :-) )". The response was awesome! Jonathan Turner suggested I write up the responses as a blog post, and here we are.]]></description><guid isPermaLink="false">f6f3b55c-c39c-4366-9de1-ebf3b230ee6c</guid><pubDate>Wed, 13 Jun 2018 16:26:29 +0000</pubDate><dc:creator>Nick Cameron</dc:creator></item><item><title>Rust review: Expressions, expressions, expressions</title><link>http://julio.meroh.net/2018/06/rust-review-expressions.html</link><description><![CDATA[Rust resembles a functional language in many ways although it does not claim to be one. In fact, I have been thinking of Rust as a “pragmatic Haskell” or as a “well-balanced mixture between C++ and Haskell”.

One of the ways the functional aspects show up is via expressions and how pretty much any construct in Rust can be treated as an expression. But before we begin, a little warning: the examples below are, by no means, idiomatic Rust—I just hope they are simple enough to illustrate what I want to show.]]></description><guid isPermaLink="false">8e5085a4-0057-4ed8-81dc-93242e35b6e9</guid><pubDate>Tue, 12 Jun 2018 09:00:00 -0400</pubDate><dc:creator>Julio Merino</dc:creator></item><item><title>From Go to Rust - JSON and YAML</title><link>http://technosophos.com/2018/06/12/from-go-to-rust-json-and-yaml.html</link><description><![CDATA[One of Go's big selling points for me was its novel approach to JSON encoding. Learning about Rust's encoding has made me even more excited. In this post, we'll start with Go's JSON encoder, and then see how Rust does encoding. And we'll even through in some YAML!]]></description><guid isPermaLink="false">79d23f1b-0e7b-4d75-a061-9e5b9930424b</guid><pubDate>Tue, 12 Jun 2018 00:00:00 +0000</pubDate><dc:creator>Matt Butcher</dc:creator></item><item><title>Automatic Type Coercions with Procedural Macros in Rust</title><link>http://willcrichton.net/notes/automatic-type-coercions-macros-rust/</link><description><![CDATA[I briefly demonstrate how to use procedural macros to automatically perform type coercion in Rust, mimicking the behavior of dynamic languages.]]></description><guid isPermaLink="false">4749d178-b87d-4946-b8e2-0a6d17d7495e</guid><pubDate>Tue, 12 Jun 2018 00:00:00 +0000</pubDate><dc:creator>Will Crichton</dc:creator></item><item><title>Traits and Trait Objects in Rust</title><link>https://joshleeb.com/posts/rust-traits-and-trait-objects/</link><description><![CDATA[I’ve been really confused lately about Rust’s trait objects. Specifically when it comes to questions about the difference between &Trait, Box<Trait>, impl Trait, and dyn Trait.]]></description><guid isPermaLink="false">2b4b4efe-3a50-4ceb-ac4c-267b708c2ce8</guid><pubDate>Tue, 12 Jun 2018 00:00:00 +0000</pubDate><dc:creator>Josh Leeb-du Toit</dc:creator></item><item><title>Where do Rust threads come from?</title><link>http://squidarth.com/rc/rust/concurrency/2018/06/09/rust-threads-detach.html</link><description><![CDATA[Last week, I wrote a post in which I discussed some of the things that I learned about Rust concurrency. One of the things that I pointed out was that when you spawn a thread within another thread, they both have the main process as their parent.]]></description><guid isPermaLink="false">34b26ba8-daa3-431f-ba53-9c0d9d873459</guid><pubDate>Sat,  9 Jun 2018 09:00:38 -0400</pubDate><dc:creator>Sid Shanker</dc:creator></item><item><title>First Impressions of the Rust Programming Language</title><link>http://jakob.space/blog/post/First+Impressions+of+the+Rust+Programming+Language</link><description><![CDATA[C is almost 50 years old, and C++ is almost 40 years old. While age is usually indicative of mature implementations with decades of optimization under their belts, it also means that the language's feature set is mostly devoid of modern advancements in programming language design. For that reason, you see a great deal of encouragement nowadays to move to newer languages - they're designed with contemporary platforms in mind, rather than working within the limitations of platforms like the PDP-11. Among said "new languages" are Zig, Myrddin, Go, Nim, D, Rust.. even languages like Java and Elixir that run on a virtual machine are occasionally suggested as alternatives to the AOT-compiled C and C++.

I have plans to look into the characteristics that distinguish each and every one of these new programming languages, learning them and documenting my first impressions in the form of blog posts. This post is the beginning of that adventure: my first impressions of Rust.]]></description><guid isPermaLink="false">4ab9c39f-72ed-4b84-a5e7-abe4c594c019</guid><pubDate>Fri,  8 Jun 2018 13:02:33 -0500</pubDate><dc:creator>Jakob</dc:creator></item><item><title>Rust review: Learning curve</title><link>http://julio.meroh.net/2018/06/rust-review-learning-curve.html</link><description><![CDATA[Writing Rust code is not restricted to programming gurus—but there is no denying that the learning curve is steeper than that of other languages. Or is it? In this post, I'll try to convince you that the curve does feel steep, but it isn't when taken into perspective.
Let's first start by stating that learning a language is not the same as learning its syntax. Learning a language involves learning the syntax, of course, but it also involves familiarizing oneself with its common idioms and grabbing a good sense of what the standard libraries provide.]]></description><guid isPermaLink="false">644f8b30-47a3-4da8-b4e9-1b72755d69b0</guid><pubDate>Fri,  8 Jun 2018 09:00:00 -0400</pubDate><dc:creator>Julio Merino</dc:creator></item><item><title>Rust review: Protect the data</title><link>http://julio.meroh.net/2018/06/rust-review-protect-the-data.html</link><description><![CDATA[The one thing that blew my mind about Rust is its approach to data sharing in concurrent situations.

I had always thought of mutexes as something that is easy to get wrong and was convinced that the use of a RAII pattern to prevent lock leaks never happen (like with Abseil’s MutexLock) was the panacea. (I’m a fan of RAII in C++ by the way, in case you haven’t noticed.)]]></description><guid isPermaLink="false">046762b0-c3da-4f38-8d4a-7bb515f73d4b</guid><pubDate>Tue,  5 Jun 2018 09:00:00 -0400</pubDate><dc:creator>Julio Merino</dc:creator></item><item><title>Why PhantomData</title><link>http://troubles.md/posts/why-phantomdata/</link><description><![CDATA[We’re not allowed to have a type parameter that goes unused. If we want to have a type that looks like the one above we have to add a marker to it like so: struct Tagged<T>(usize, PhantomData<T>);]]></description><guid isPermaLink="false">cebd59fa-c884-49cd-9de7-4da401e26642</guid><pubDate>Tue,  5 Jun 2018 13:41:30 +0200</pubDate><dc:creator>troubles.md</dc:creator></item><item><title>Announcing Rust 1.26.2</title><link>https://blog.rust-lang.org/2018/06/05/Rust-1.26.2.html</link><description><![CDATA[This patch release fixes a bug in the borrow checker verification of match expressions. This bug was introduced in 1.26.0 with the stabilization of match ergonomics. Specifically, it permitted code which took two mutable borrows of the bar path at the same time.]]></description><guid isPermaLink="false">901dde63-68f7-45d0-b161-cf585e47d266</guid><pubDate>Tue,  5 Jun 2018 00:00:00 +0000</pubDate><dc:creator>The Rust Core Team</dc:creator></item><item><title>The Future of Clippy (the Rust Linter)</title><link>https://manishearth.github.io/blog/2018/06/05/the-future-of-clippy-the-rust-linter/</link><description><![CDATA[We’ve recently been making lots of progress on future plans for clippy and I thought I’d post an update.]]></description><guid isPermaLink="false">2b743aaf-6ae4-4bda-8de9-6bef817e9a4d</guid><pubDate>Tue,  5 Jun 2018 00:00:00 +0000</pubDate><dc:creator>Manish Goregaokar</dc:creator></item><item><title>Safe Concurrency with Rust</title><link>http://www.squidarth.com/rc/rust/2018/06/04/rust-concurrency.html</link><description><![CDATA[Last week, I started learning Rust, and published a post about the “ownership” system. One of the places where Rust’s ownership system really shines is in threading and concurrency. Kevin and I decided to dig into this more on Friday, and did some work on the dining philosophers problem.

In this post I’ll be covering what we learned, and how the Rust compiler saves you from some scary concurrency issues.]]></description><guid isPermaLink="false">314ba2b8-5ace-4348-b96a-b704c628e2b3</guid><pubDate>Mon,  4 Jun 2018 09:00:38 -0400</pubDate><dc:creator>Sid Shanker</dc:creator></item><item><title>Async Methods II: object safety</title><link>https://boats.gitlab.io/blog/post/async-methods-ii/</link><description><![CDATA[Last time, we introduced the idea of async methods, and talked about how they would be implemented: as a kind of anonymous associated type on the trait that declares the method, which corresponds to a different, anonymous future type for each implementation of that method. Starting this week we’re going to look at some of the implications of that. The first one we’re going to look at is object safety.]]></description><guid isPermaLink="false">d4896054-d302-4629-8679-7456e1a741ef</guid><pubDate>Mon,  4 Jun 2018 00:00:00 +0000</pubDate><dc:creator>boats</dc:creator></item><item><title>Newtype Index Pattern</title><link>https://matklad.github.io//2018/06/03/newtype-index-pattern.html</link><description><![CDATA[Similarly to the previous post, we will once again add types to the Rust code which works perfectly fine without them. This time, we’ll try to improve the pervasive pattern of using indexes to manage cyclic data structures.]]></description><guid isPermaLink="false">e672721a-5577-4897-b440-619731384ac1</guid><pubDate>Sun,  3 Jun 2018 21:21:45 +0000</pubDate><dc:creator>Aleksey Kladov</dc:creator></item><item><title>The Secret Life of Cows</title><link>https://deterministic.space/secret-life-of-cows.html</link><description><![CDATA[A lot of people at RustFest Paris mentioned Cows – which may be surprising if you’ve never seen std::borrow::Cow!

Cow in this context stands for “Clone on Write” and is a type that allows you to reuse data if it is not modified. Somehow, these bovine super powers of Rust’s standard library appear to be a well-kept secret even though they are not new. This post will dig into this very useful pointer type by explaining why in systems programming languages you need such fine control, explain Cows in detail, and compare them to other ways of organizing your data.]]></description><guid isPermaLink="false">d8c6d9c0-38eb-4656-a28e-0125ca9e5cd1</guid><pubDate>Sat,  2 Jun 2018 00:00:00 +0200</pubDate><dc:creator>Pascal Hertleif</dc:creator></item><item><title>Rust review: The borrow checker</title><link>http://julio.meroh.net/2018/06/rust-review-borrow-checker.html</link><description><![CDATA[Aaaah, the borrow checker: the dreaded enemy lurking within the Rust compiler, ready to make its move to bring pain to your life by preventing your code from compiling. Or that’s what everyone seems to say, which is one of the reasons I put off learning Rust for so long. In reality… the borrow checker is a blessing, but it is true that getting past its gates is difficult at first.]]></description><guid isPermaLink="false">09d6be59-4bee-49e0-aa34-d43622422cb8</guid><pubDate>Fri,  1 Jun 2018 09:00:00 -0400</pubDate><dc:creator>Julio Merino</dc:creator></item><item><title>Infinite Negative Utility: The Rust Language and Special Cases</title><link>https://blog.infinitenegativeutility.com/2018/6/the-rust-language-and-special-cases</link><description><![CDATA[I first came across Rust back in 2010 or 2011, and it was a very different language than the one it is today, both syntactically and semantically. I remember at the time that newcomers would often complain loudly about the terse keywords—like the fact that the return keyword had been shortened to ret—and the omnipresent tildes scattered throughout the language like fallen leaves in autumn. My programming background was in functional languages—specifically in Scheme and Haskell—and I found this language fascinating, sitting in an interesting and unexplored place in the spectrum of programming languages and bringing something genuinely new to the table.]]></description><guid isPermaLink="false">19239f2e-41c0-44cb-8b3d-02199eaa57b1</guid><pubDate>Fri,  1 Jun 2018 00:00:00 +0000</pubDate><dc:creator>Getty Ritter</dc:creator></item><item><title>Tricking the HashMap</title><link>https://idubrov.github.io/rust/2018/06/01/tricking-the-hashmap.html</link><description><![CDATA[Is it possible to find something in a hashmap if the key you are looking for is not exactly the same as the one you put into that hashmap? At first glance, this might not make any sense at all. The whole purpose of a hashmap is to store something under some key and then look it up using the same key. Right?]]></description><guid isPermaLink="false">ab635755-efd4-432a-8407-7b1c94649f8f</guid><pubDate>Fri,  1 Jun 2018 00:00:00 +0000</pubDate><dc:creator>Ivan Dubrov</dc:creator></item><item><title>Assignment Semantics in Python, JavaScript, Java, C++, and Rust</title><link>https://www.apress.com/us/blog/all-blog-posts/assignment-semantics/15805464</link><description><![CDATA[What happens when a data collection is copied and then the new copy is changed? Does the original remain the same, or does it change too?

If you think of copying as creating a completely new object, of course you expect that any change to the new copy does not affect the original object. But if you think of copying as creating a new name for the same, single object, then you expect that any change to the object through the new name appears also when you access the same object through the old name.

Let's see how is the behavior of Python, Javascript, Java, C++, and Rust regarding the assignment operator ("=") between collection variables.]]></description><guid isPermaLink="false">80930880-f4a9-4485-b372-648928490dca</guid><pubDate>Fri,  1 Jun 2018 00:00:00 +0000</pubDate><dc:creator>Carlo Milanesi</dc:creator></item><item><title>Fear not the Rust Borrow Checker</title><link>http://www.squidarth.com/rc/rust/2018/05/31/rust-borrowing-and-ownership.html</link><description><![CDATA[I spent pretty much the whole day banging my head against the wall trying to figure out how ownership and borrowing work in Rust, and finally have a grasp on what’s going on.

In this post I’m going to demonstrate how these concepts work through some examples of code that break Rust’s rules, and explain why they’re problematic. I assume very little knowledge of the Rust programming language. I’ve also added comments to all of the code blocks that indicate whether the code is valid Rust or not.]]></description><guid isPermaLink="false">1f808812-4e70-4dcb-90a0-c45964863cd5</guid><pubDate>Thu, 31 May 2018 12:00:38 -0400</pubDate><dc:creator>Sid Shanker</dc:creator></item><item><title>Async Methods I: generic associated types</title><link>https://boats.gitlab.io/blog/post/async-methods-i/</link><description><![CDATA[Async/await continues to move along swimmingly. We’ve accepted an RFC describing how the async/await syntax will work in Rust, and work is underway on implementing support for it in the compiler. We’re hopeful that users will be able to start experimenting with the syntax on nightly by early July.

The RFC for async/await didn’t address one important thing: async methods. It is very important for people defining libraries to be able to define traits that contain async functions, like this:]]></description><guid isPermaLink="false">d5a4da56-2e7e-4f30-bd1a-d0211958a00a</guid><pubDate>Thu, 31 May 2018 00:00:00 +0000</pubDate><dc:creator>boats</dc:creator></item><item><title>Mutagen - An Inopportune Consumption</title><link>https://llogiq.github.io/2018/05/30/inop.html</link><description><![CDATA[I just failed to implement what looked to be a relatively simple opportunistic replacement so that the compiler would accept the mutated code. But I’m getting ahead of myself.]]></description><guid isPermaLink="false">aea72b83-8f56-4c8d-a9d7-c88fded0cfc7</guid><pubDate>Wed, 30 May 2018 00:00:00 +0000</pubDate><dc:creator>Llogiq</dc:creator></item><item><title>Rust review: Immutable by default</title><link>http://julio.meroh.net/2018/05/rust-review-immutable-by-default.html</link><description><![CDATA[Let’s start the deep dive by looking into a powerful feature of Rust: all variables and references are immutable by default unless qualified with mut.
To understand why this is important, let’s cover some context first. One of my pet peeves when reviewing C++ code is to ask authors to sprinkle the const qualifier everywhere: if something ain’t mutated, say so explicitly. This includes marking local variables, function arguments, function return values, class attributes, etc.]]></description><guid isPermaLink="false">d9877c7d-7175-490d-89a8-46fad05d9903</guid><pubDate>Tue, 29 May 2018 09:00:00 -0400</pubDate><dc:creator>Julio Merino</dc:creator></item><item><title>Evolving Rust</title><link>https://blog.shivoa.net/2018/05/evolving-rust.html</link><description><![CDATA[When you're just building some very basic tool programs, I'd probably not even think about threading in C, but here it is so easy that I've been quick to drop a (for example, typically) 30ms loop down to 3.5ms. One of the things I've been somewhat missing is easy access to SIMD intrinsics, but this brings me to something else I've been enjoying this year: Rust is evolving.]]></description><guid isPermaLink="false">da46cfde-97b2-4e16-9e08-4308a34d6826</guid><pubDate>Tue, 29 May 2018 12:11:00 +0100</pubDate><dc:creator>Shivoa Birch</dc:creator></item><item><title>Announcing Rust 1.26.1</title><link>https://blog.rust-lang.org/2018/05/29/Rust-1.26.1.html</link><description><![CDATA[A couple of issues were found in 1.26.0 which were deemed sufficient for a patch release.

A quick summary of the changes:

RLS no longer interferes with command line builds
Rustfmt stopped badly formatting text in some cases
Returning from main via impl Trait where the Trait is not Termination is no longer permitted
::<> (turbofish) no longer works for method arguments whose type is impl Trait

NaN > NaN no longer returns true in const contexts
rustup should no longer fail due to missing documentation on some platforms]]></description><guid isPermaLink="false">ae63f930-3568-433f-b8e6-35feb516b4c2</guid><pubDate>Tue, 29 May 2018 00:00:00 +0000</pubDate><dc:creator>The Rust Core Team</dc:creator></item><item><title>Exploring Rust fat pointers</title><link>https://iandouglasscott.com/2018/05/28/exploring-rust-fat-pointers/</link><description><![CDATA[Beware that at any point the code here may stop compiling, segfault, and otherwise behave in weird ways, some of which involve Velociraptors.

Now that that’s out of the way, what is a fat pointer anyway? All pointers are the same right? Just a number indicating an address in memory. Well, yes and no.]]></description><guid isPermaLink="false">95a6f9d4-dcfa-4b20-8ee7-f240cde435b1</guid><pubDate>Mon, 28 May 2018 02:46:00 -0700</pubDate><dc:creator>Ian Douglas Scott</dc:creator></item><item><title>The Go Developer&apos;s Quickstart Guide to Rust</title><link>http://technosophos.com/2018/05/27/the-go-developers-quickstart-guide-to-rust.html</link><description><![CDATA[As the co-author of Go in Practice, I have felt a certain obligation to Go. But I'm ready for a change. Rust topped the satisfaction survey in Stack Overflow's survey of languages (screenshot above). I've decided to give it a try. While Go and Rust are often compared, they are remarkably different languages.

Coming from a Go background, there are things about Rust that feel very natural, and things (like memory management) that feel utterly foreign. And so as I learn Rust, I am cataloging how it feels for a Go programmer. And rather than leading others to "dive in at the deep end" as I did (when I tried to write a full web service), I decided to approach Rust by starting with similarities and working toward differences.]]></description><guid isPermaLink="false">1572c586-709c-44a9-9232-ae4d3b9466ec</guid><pubDate>Sun, 27 May 2018 00:00:00 +0000</pubDate><dc:creator>Matt Butcher</dc:creator></item><item><title>Rust review: Introduction</title><link>http://julio.meroh.net/2018/05/rust-review-introduction.html</link><description><![CDATA[I had been meaning to learn Rust since I first toyed with Go a couple of years ago. During this period, I’ve written a non-trivial amount of Go code both inside and outside Google, but never found the chance to sit back and learn Rust.

This changed a month ago during my yearly family trip to Korea. This time around, I decided upfront that I would not work on any personal or work projects for the 2-week long vacation. Instead, I would focus all spare time in reading. And I would read “The Rust Programming Language”, second edition. The plan worked: getting through the book took the two weeks and I barely wrote any code.]]></description><guid isPermaLink="false">d25787d1-089e-4455-ac6a-1183548d48cd</guid><pubDate>Fri, 25 May 2018 09:00:00 -0400</pubDate><dc:creator>Julio Merino</dc:creator></item><item><title>Fuzz testing in Rust with Cargo-fuzz</title><link>https://medium.com/@seasoned_sw/fuzz-testing-in-rust-with-cargo-fuzz-13b89feecc30</link><description><![CDATA[In this post, I go through how I added the first automated fuzz test for my hobby project Hat — a snapshotting backup system written in Rust. I’ll briefly go through what a fuzz test is and how it works. In a follow-up post, I will share how I made the test more effective by running it through Seasoned Software.]]></description><guid isPermaLink="false">e0370259-0204-491d-9bd1-3769a682f6e1</guid><pubDate>Fri, 25 May 2018 10:08:45 +0000</pubDate><dc:creator>Seasoned Software</dc:creator></item><item><title>Typed Key Pattern</title><link>https://matklad.github.io/2018/05/24/typed-key-pattern.html</link><description><![CDATA[In this post, I’ll talk about a pattern for extracting values from a weakly typed map. This pattern applies to all statically typed languages, and even to dynamically typed ones, but the post is rather Rust-specific.]]></description><guid isPermaLink="false">5b8ae1bc-5625-4115-ab3a-3f399e157314</guid><pubDate>Thu, 24 May 2018 10:18:13 +0000</pubDate><dc:creator>Aleksey Kladov</dc:creator></item><item><title>impl Trait in Rust explanation</title><link>https://medium.com/@iopguy/impl-trait-in-rust-explanation-efde0d94946a</link><description><![CDATA[In Rust 1.26 a new feature called impl Trait was stabilized. How does it work? Instead of specifying an exact type, you can say that your function either returns or takes something that implements a trait.]]></description><guid isPermaLink="false">80818d94-c29b-47b1-8307-f5c9e1d03808</guid><pubDate>Wed, 23 May 2018 04:37:08 +0000</pubDate><dc:creator>Igor Polyakov</dc:creator></item><item><title>Moving out of a Drop struct in Rust?</title><link>http://phaazon.netkblog/rust-no-drop</link><description><![CDATA[Rust doesn’t allow you to move out of a value which type implements Drop, and this is quite logical. When Foo::take returns, because of self going out of scope, it must call its Drop::drop implementation. If you have moved out of it – both a: A and b: B fields, the Drop::drop implementation is now a complete UB. So Rust is right here and doesn’t allow you to do this.

But imagine that we have to do this. For insance, we need to hand over both the scarce resources a and b to another struct (in our case, a (A, B), but you could easily imagine a better type for this).

There’s a way to, still, implement Foo::take with Foo implementing Drop. Here’s how:]]></description><guid isPermaLink="false">7518f181-39ba-4c9c-a76d-1a07b697d264</guid><pubDate>Tue, 22 May 2018 22:22:00 +0000</pubDate><dc:creator>Dimitri Sabadie</dc:creator></item><item><title>Rust is Incredibly Productive for CLIs</title><link>https://www.chriskrycho.com/2018/rust-is-incredibly-productive-for-clis.html</link><description><![CDATA[I built a little tool in Rust to convert an Evernote export file to Markdown. It was impressively easy.]]></description><guid isPermaLink="false">d2971f3f-a40d-45c9-a544-ed94f3b962f6</guid><pubDate>Sun, 20 May 2018 08:35:00 -0400</pubDate><dc:creator>Chris Krycho</dc:creator></item><item><title>Rust for Android games using SDL2</title><link>https://lliwynd.blogspot.com.au/2018/05/rust-for-android-games-using-sdl2.html</link><description><![CDATA[I've been wanting to write a simple Android game for my daughter, and decided to use it as an excuse to learn Rust.  Thus began an odyssey.

I'll ignore the game itself in this post in favour of describing how to get a simple Rust on Android game environment.  For my game I didn't want anything fancy - I wanted to load some jpg files and blit rectangles from those textures to the screen.  But I don't know OpenGL, and I don't really feel the need to learn for this project - if I hit the need to use a shader, then I backtracked and tried another approach.  The plan was to get a simple, high-level graphics API for Rust running on Android.]]></description><guid isPermaLink="false">6e5c626c-f240-41fa-9520-a3d5586523b3</guid><pubDate>Sat, 19 May 2018 16:15:00 +1000</pubDate><dc:creator>William Uther</dc:creator></item><item><title>A boolean&apos;s story</title><link>https://dmerej.info/blog/post/a-booleans-story/</link><description><![CDATA[Earlier this month I told you about my pet project in Rust.

As a reminder, it’s a tool named rusync which contains some of the functionality offered by the rsync command-line tool.

Today I’d like to talk about a feature I’ve added recently, and take this opportunity to show you a few principles of good design along the way.]]></description><guid isPermaLink="false">999b0809-c97d-42c2-b102-d8d2567e8979</guid><pubDate>Fri, 18 May 2018 13:50:38 +0000</pubDate><dc:creator>Dimitri Merejkowsky</dc:creator></item><item><title>Compile Time Prevention of SQL-Injections in Rust</title><link>https://polyfloyd.net/post/compile-time-prevention-of-sql-injections/</link><description><![CDATA[SQL injection vulnerabilities have been a plague ever since such databases have been combined with user facing applications. Such vulnerabilities arise when a SQL query string is naively combined with data that is controlled by an attacker.

To mitigate, people should make use of placeholders and prepared statements provided by SQL client libraries. This separates the variable data from the actual query, ensuring that these two never mix. Pretty much all modern SQL client libraries offer this functionality, but of course, it’s still possible to mix variable data and SQL by means of string concatenation.]]></description><guid isPermaLink="false">c1e5c8e3-46e1-412d-98fe-6735ad9e4f19</guid><pubDate>Fri, 18 May 2018 00:00:00 +0000</pubDate><dc:creator>polyfloyd</dc:creator></item><item><title>FizzBuzz Can Finally Be Implemented in Stable Rust</title><link>https://medium.com/@iopguy/fizzbuzz-can-finally-be-implemented-in-stable-rust-87649a882f2d</link><description><![CDATA[I have been editing my FizzBuzz repository since 2014. After four years, I was finally able to switch from nightly to stable due to the 1.26 release. Let’s back up a little bit and appreciate the changes since the first revision.]]></description><guid isPermaLink="false">2bdd1638-e211-477d-8bb8-3ae0de703661</guid><pubDate>Thu, 17 May 2018 17:23:27 +0000</pubDate><dc:creator>Igor Polyakov</dc:creator></item><item><title>Rust turns three</title><link>https://blog.rust-lang.org/2018/05/15/Rust-turns-three.html</link><description><![CDATA[Three years ago today, the Rust community released Rust 1.0 to the world, with our initial vision of fearless systems programming. As per tradition, we’ll celebrate Rust’s birthday by taking stock of the people and the product, and especially of what’s happened in the last year.]]></description><guid isPermaLink="false">50ca4f3e-2051-4779-adf4-a12615b72d99</guid><pubDate>Tue, 15 May 2018 00:00:00 +0000</pubDate><dc:creator>Aaron Turon</dc:creator></item><item><title>Announcing Rust 1.26</title><link>https://blog.rust-lang.org/2018/05/10/Rust-1.26.html</link><description><![CDATA[The past few releases have had a steady stream of relatively minor additions. We’ve been working on a lot of stuff, however, and it’s all starting to land in stable. 1.26 is possibly the most feature-packed release since Rust 1.0.]]></description><guid isPermaLink="false">c65ddae5-51e1-4eb4-96ab-365e0d819d0f</guid><pubDate>Thu, 10 May 2018 00:00:00 +0000</pubDate><dc:creator>The Rust Core Team</dc:creator></item><item><title>Asynchronous warmy: a prequel</title><link>http://phaazon.net/blog/asynchronous_warmy_prequel</link><description><![CDATA[Last weeks were interesting for warmy, a crate I’ve been writing for several weeks / months now that enables you to hot load and reload scarce resources – e.g. textures, meshes, configuration, JSON parameters, dependency nodes, whatever. warmy received several interesting features.]]></description><guid isPermaLink="false">940f0d10-67ee-49d4-a243-d4310077a962</guid><pubDate>Tue,  8 May 2018 19:30:00 +0000</pubDate><dc:creator>Dimitri Sabadie</dc:creator></item><item><title>Rust: Enterprise Services Need Not Suck</title><link>https://medium.com/@paulhoughton/rust-enterprise-services-need-not-suck-679b79edcab5</link><description><![CDATA[I practice Barbarian Leadership. Standing on the back lines with hand in pocket giving orders is missing the fun. More importantly, knowledge is created on the cutting edge of action. People you work with know this. They value modern, non-hierarchical organizations where a leader dives into the fray, sword in hand, and gets to know intimately the problems and tools for solving them. So I dove into the fight despite knowing that it is “hard language”.]]></description><guid isPermaLink="false">a7a257bb-3da8-42f1-b341-dad7221b9ab3</guid><pubDate>Mon,  7 May 2018 12:59:10 +0000</pubDate><dc:creator>Paul Houghton</dc:creator></item><item><title>Encapsulating Lifetime of the Field</title><link>https://matklad.github.io/2018/05/04/encapsulating-lifetime-of-the-field.html</link><description><![CDATA[This is a post about an annoying Rust pattern and an annoyingworkaround, without a good solution :)]]></description><guid isPermaLink="false">ca367462-e3ba-4b03-9b46-05b7850bdcba</guid><pubDate>Fri,  4 May 2018 17:47:23 +0000</pubDate><dc:creator>Aleksey Kladov</dc:creator></item><item><title>Embedding Rustup into Cargo and the Wrapper</title><link>https://medium.com/@tibotz/embedding-rustup-into-cargo-and-the-wrapper-d5b447f381fc</link><description><![CDATA[One of my issue when building a project from scratch is the amount of manual steps required to be able to run a simple project. This is not so much a concern when you are a single developer but the larger the team, the most obvious it becomes.]]></description><guid isPermaLink="false">cb34566e-4c96-4191-9179-eca6bc9ac07f</guid><pubDate>Fri,  4 May 2018 05:53:28 +0000</pubDate><dc:creator>Tibo Delor</dc:creator></item><item><title>Procedural Macros in Rust</title><link>https://joshleeb.com/posts/rust-procedural-macros/</link><description><![CDATA[Procedural macros are a really powerful language feature in Rust and something I haven’t seen in many other languages.

There are a heap of tutorials out there for procedural macros, including in The Rust Reference, and the first edition of the Rust Book. One of the more entertaining (and useful) posts is by Zach Mitchell where you get to “learn Rust procedural macros with Nic Cage”.

I won’t go into depth about what procedural macros are and why they’re so powerful.]]></description><guid isPermaLink="false">7fe0f8aa-fbe1-4fef-bba3-e64b98b00bc2</guid><pubDate>Fri,  4 May 2018 00:00:00 +0000</pubDate><dc:creator>Josh Leeb-du Toit</dc:creator></item><item><title>Refactoring Apache Arrow to use traits and generics</title><link>https://andygrove.io/2018/05/apache-arrow-traits-generics/</link><description><![CDATA[I am currently working on a refactor of the Rust implementation of Apache Arrow to change the way that arrays are represented. This is a relatively large change even though this is a tiny codebase so far and I thought it would be good to write up this blog post to explain why I think this is needed. I think this information will also be interesting for any Rust developer who is struggling with making the right choice between (or using the right combination of) enums, structs, generics and traits. I was inspired to write this up after reading this blog post that was posted to Reddit just a few days ago.]]></description><guid isPermaLink="false">266098f6-079e-42d6-8d15-3a7867687f49</guid><pubDate>Fri,  4 May 2018 00:00:00 +0000</pubDate><dc:creator>Andy Grove</dc:creator></item><item><title>Rust in production at Figma</title><link>https://blog.figma.com/rust-in-production-at-figma-e10a0ec31929</link><description><![CDATA[How Mozilla’s new language dramatically improved our server-side performance.]]></description><guid isPermaLink="false">d9100be3-bb0c-4ea5-9aff-3fa3b7946b12</guid><pubDate>Wed,  2 May 2018 15:14:00 +0000</pubDate><dc:creator>Evan Wallace</dc:creator></item><item><title>Mutagen – More opportunities</title><link>https://llogiq.github.io/2018/05/01/moreop.html</link><description><![CDATA[Recently I gave a talk at our Rust Meetup about mutagen, and I also showed how our opportunistic mutations work (I however left out that gnarly thing about shifts, but in my defense I was short on time). That got me thinking whether we always do the right thing elsewhere.]]></description><guid isPermaLink="false">4539d16d-f909-4fff-9eda-dc6763fa7a3b</guid><pubDate>Tue,  1 May 2018 00:00:00 +0000</pubDate><dc:creator>Llogiq</dc:creator></item><item><title>How to speed up the Rust compiler in 2018</title><link>https://blog.mozilla.org/nnethercote/2018/04/30/how-to-speed-up-the-rust-compiler-in-2018/</link><description><![CDATA[18 months ago I wrote about some work I did to speed up the Rust compiler (rustc). I’ve recently taken this work up again. Also, in the meantime rustc’s build system has been replaced and its benchmark suite has been overhauled. So it’s a good time for an update.]]></description><guid isPermaLink="false">1c59d8b2-c755-4f10-859e-4847be81bc4c</guid><pubDate>Mon, 30 Apr 2018 04:13:45 +0000</pubDate><dc:creator>Nicholas Nethercote</dc:creator></item><item><title>Installing Rust Offline</title><link>https://hatsunearu.github.io/2018/04/29/rust-offline/</link><description><![CDATA[I wanted to use Rust on an offline Linux system, but it seemed like there isn’t a nice guide to install Rust and some popular packages all in one go (like Anaconda, though what I describe here is much more ghetto), so I decided to summarize the procedure to install the Rust toolchain and some popular libraries all in one go on a system with no internet access.]]></description><guid isPermaLink="false">1d371a92-135a-4456-aca8-5537c9d53c81</guid><pubDate>Sun, 29 Apr 2018 14:00:00 +0000</pubDate><dc:creator>hatsunearu</dc:creator></item><item><title>rustref - memorable Rust reference links</title><link>https://rustref.com/</link><description><![CDATA[This contains shorthand URLs for navigating to Rust documentation.]]></description><guid isPermaLink="false">fce158e9-2134-4c57-bbc8-67483dc0b0d8</guid><pubDate>Fri, 27 Apr 2018 20:12:36 +0000</pubDate><dc:creator>Mackenzie Hauck</dc:creator></item><item><title>An alias-based formulation of the borrow checker</title><link>http://smallcultfollowing.com/babysteps/blog/2018/04/27/an-alias-based-formulation-of-the-borrow-checker/</link><description><![CDATA[Ever since the Rust All Hands, I’ve been experimenting with an alternative formulation of the Rust borrow checker. The goal is to find a formulation that overcomes some shortcomings of the current proposal while hopefully also being faster to compute. I have implemented a prototype for this analysis. It passes the full NLL test suite and also handles a few cases – such as #47680 – that the current NLL analysis cannot handle. However, the performance has a long way to go (it is currently slower than existing analysis). That said, I haven’t even begun to optimize yet, and I know I am doing some naive and inefficient things that can definitely be done better; so I am still optimistic we’ll be able to make big strides there.]]></description><guid isPermaLink="false">282a816f-1c0b-4efc-9939-0674020ee1ef</guid><pubDate>Fri, 27 Apr 2018 00:00:00 -0400</pubDate><dc:creator>Niko Matsakis</dc:creator></item><item><title>Adventures in Rust</title><link>https://dev.to/tmr232/adventures-in-rust-56fc</link><description><![CDATA[A tale of my time in Rust-land]]></description><guid isPermaLink="false">803b6bf7-0cde-4a49-9e63-a117e95de2c0</guid><pubDate>Fri, 27 Apr 2018 00:00:00 +0000</pubDate><dc:creator>Tamir Bahar</dc:creator></item><item><title>Reflections on Rust, and the Sand Castle Metaphor</title><link>https://brandur.org/fragments/rust-reflections</link><description><![CDATA[A month ago, I wrote about how I was frustrated with my progress in Rust. These days, I’m still no expert, but I’ve made progress.]]></description><guid isPermaLink="false">67b88f7c-7b39-43ad-863a-0d03dd180faf</guid><pubDate>Fri, 27 Apr 2018 00:00:00 +0000</pubDate><dc:creator>Brandur Leach</dc:creator></item><item><title>Ask an expert: How do you maintain Rust?</title><link>https://increment.com/programming-languages/maintaining-rust/</link><description><![CDATA[From team structure and annual surveys to RFCs and the release process, a staff research engineer on Mozilla’s Rust team shares what it takes.]]></description><guid isPermaLink="false">76fb9740-07d0-45c8-a6b3-17534f293c54</guid><pubDate>Thu, 26 Apr 2018 19:00:00 +0000</pubDate><dc:creator>Jonathan Turner</dc:creator></item><item><title>Borrowing in async code</title><link>http://aturon.github.io/2018/04/24/async-borrowing/</link><description><![CDATA[The networking working group is pushing hard on async/await notation for Rust, and @withoutboats in particular wrote a fantastic blog series working through the design space. I wanted to talk a little bit about some of the implications of async/await, which may not have been entirely clear. In particular, async/await is not just about avoiding combinators; it completely changes the game for borrowing.]]></description><guid isPermaLink="false">5e0ef28e-278a-48f1-92d1-256a37f76e47</guid><pubDate>Tue, 24 Apr 2018 00:00:00 +0000</pubDate><dc:creator>Aaron Turon</dc:creator></item><item><title>Rust Case Study: Chucklefish Taps Rust to Bring Safe Concurrency to Video Games [pdf]</title><link>https://www.rust-lang.org/pdfs/Rust-Chucklefish-Whitepaper.pdf</link><description><![CDATA[Chucklefish, an independent game studio based in London, publishes hit video games like Stardew Valley and Starbound. Now, the company is developing its next game, code-named Witchbrook, using the Rust programming language instead of C++. Why the switch? Two main reasons: to get better performance on multiprocessor hardware and to have fewer crashes during game play.]]></description><guid isPermaLink="false">49014ace-e742-49f8-887a-8fa7d1b627cc</guid><pubDate>Mon, 23 Apr 2018 17:38:56 +0000</pubDate><dc:creator>The Rust Project Developers</dc:creator></item><item><title>GLib/GIO async operations and Rust futures + async/await</title><link>https://coaxion.net/blog/2018/04/glib-gio-async-operations-and-rust-futures-async-await/</link><description><![CDATA[Unfortunately I was not able to attend the Rust+GNOME hackfest in Madrid last week, but I could at least spend some of my work time at Centricular on implementing one of the things I wanted to work on during the hackfest. The other one, more closely related to the gnome-class work, will be the topic &#8230; <a href="https://coaxion.net/blog/2018/04/glib-gio-async-operations-and-rust-futures-async-await/" class="more-link">Continue reading <span class="screen-reader-text">GLib/GIO async operations and Rust futures + async/await</span></a>]]></description><guid isPermaLink="false">096f02f7-0ce4-41ef-8896-f8209ca126f5</guid><pubDate>Mon, 23 Apr 2018 08:46:32 +0000</pubDate><dc:creator>With the latest GIT version of the Rust bindings for GLib, GTK, etc it is now possible to make use of the Rust futures infrastructure for GIO async operations and various other functions. This should make writing of GNOME, and in general GLib-using, applications in Rust quite a bit more convenient.</dc:creator></item><item><title>BYO Standard: An Explorer&apos;s Guide to Complier Plugins</title><link>https://polysync.io/explorers-guide-to-compiler-plugins</link><description><![CDATA[The Rust programming language provides powerful guarantees around memory and thread safety. It also exposes all the knobs required for implementing custom rules, enabling a project to make additional guarantees and enforce opinions on best practice. Embedded standards are very opinionated about software practices—like using floating point values as loop counters or the number of possible exit points of a function—and Rust’s defaults don’t prevent every runtime panic (for example, recursion that goes too deep and overflows the stack).

For PolySync, a runtime panic means the potential for an unsafe situation on the road, and with that in mind, we’ve explored ways to restrict that potential. Of course, we aren’t the only ones thinking about ways to improve the quality of code at compile time by enforcing the right rules for the job. Active projects like rust-clippy are working to do that too by providing lints to supplement the rustc defaults.

In this post we’ll explore how to enforce a rule by prohibiting a practice we’ve formed an opinion about, the indexing of a vector or an array.]]></description><guid isPermaLink="false">4096f192-ba2d-4a25-b1be-f3e4b0b40b51</guid><pubDate>Sat, 21 Apr 2018 00:00:00 +0000</pubDate><dc:creator>Shea Newton</dc:creator></item><item><title>Why Rust&apos;s error handling is awesome</title><link>http://rantsideasstuff.com/posts/2018/04/20-rust-error-handling-awesome/</link><description><![CDATA[This post is about the process of transforming something you would write as a one-off script in Python (or any other scripting language) into a library including error handling.]]></description><guid isPermaLink="false">ba2b10d2-16a7-4036-8e8f-1fe0d113b0ac</guid><pubDate>Fri, 20 Apr 2018 10:00:00 +0200</pubDate><dc:creator>Zoran Zaric</dc:creator></item><item><title>Dev-tools in 2018</title><link>https://www.ncameron.org/blog/dev-tools-in-2018/</link><description><![CDATA[This is a bit late (how is it the middle of April already?!), but the dev-tools team has lots of exciting plans for 2018 and I want to talk about them! Our goals for 2018 Here's a summary of our goals for the year. Ship it! We want to ship]]></description><guid isPermaLink="false">017d9ce1-f259-4d95-bffc-b3d44dfc8cde</guid><pubDate>Thu, 19 Apr 2018 19:31:53 +0000</pubDate><dc:creator>Nick Cameron</dc:creator></item><item><title>Implementing multiprocessing.pool.ThreadPool from Python in Rust</title><link>https://blog.petrzemek.net/2018/04/16/implementing-multiprocessing-pool-threadpool-from-python-in-rust/</link><description><![CDATA[In this post, we will implement multiprocessing.pool.ThreadPool from Python in Rust. It represents a thread-oriented version of multiprocessing.Pool, which offers a convenient means of parallelizing the execution of a function across multiple input values by distributing the input data across processes. We will use an existing thread-pool implementation and focus on adjusting its interface to match that of multiprocessing.pool.ThreadPool.]]></description><guid isPermaLink="false">447b930e-7350-4ef3-80d4-2ec23a4c5708</guid><pubDate>Mon, 16 Apr 2018 15:14:15 +0000</pubDate><dc:creator>Petr Zemek</dc:creator></item><item><title>Rust pattern: Rooting an Rc handle</title><link>http://smallcultfollowing.com/babysteps/blog/2018/04/16/rust-pattern-rooting-an-rc-handle/</link><description><![CDATA[I’ve decided to do a little series of posts about Rust compiler errors. Each one will talk about a particular error that I got recently and try to explain (a) why I am getting it and (b) how I fixed it. The purpose of this series of posts is partly to explain Rust, but partly just to gain data for myself. I may also write posts about errors I’m not getting – basically places where I anticipated an error, and used a pattern to avoid it. I hope that after writing enough of these posts, I or others will be able to synthesize some of these facts to make intermediate Rust material, or perhaps to improve the language itself.]]></description><guid isPermaLink="false">89612f07-abeb-400f-8bf1-0826601e17d1</guid><pubDate>Mon, 16 Apr 2018 00:00:00 -0400</pubDate><dc:creator>Niko Matsakis</dc:creator></item><item><title>A Useful Feature Few Rust Programmers Know About</title><link>http://rickyhan.com/jekyll/update/2018/04/16/the-best-kept-secret-rust-feature.html</link><description><![CDATA[Surprisingly few know about the built-in pretty-printer. In the book, there is only a short passage that mentions {:#?} in passing. It aligns structs and enums based on nested positions and is automatically derived with Debug.]]></description><guid isPermaLink="false">c3057e94-6b2a-4f19-b109-d6f7b17aefbe</guid><pubDate>Mon, 16 Apr 2018 04:00:00 +0000</pubDate><dc:creator>Ricky Han</dc:creator></item><item><title>From Chaos to Order -- Tools and Techniques for Testing TiDB, A Distributed NewSQL Database</title><link>https://pingcap.com/blog/chaos-practice-in-tidb/</link><description><![CDATA[As an open source distributed NewSQL Hybrid Transactional/Analytical Processing (HTAP) database, TiDB contains the most important asset of our customers--their data. One of the fundamental and foremost requirements of our system is to be fault-tolerant. But how do you ensure fault tolerance in a distributed database? This article covers the top fault injection tools and techniques in Chaos Engineering, as well as how to execute Chaos practices in TiDB.]]></description><guid isPermaLink="false">f4d6ff64-87eb-466f-94a6-fbbaa28fab7d</guid><pubDate>Sat, 14 Apr 2018 00:00:00 +0000</pubDate><dc:creator>Siddon Tang</dc:creator></item><item><title>Rust CLI Survey Results</title><link>https://github.com/rust-lang-nursery/cli-wg/blob/master/survey-results/Readme.md</link><description><![CDATA[Over the month of March 2018, we've been accepting responses to the Rust CLI Survey. This survey was designed to give us some areas of focus, according to the community, for the CLI Working Group (CLI-WG).

One of the goals of Rust 2018 is to make writing command line applications in Rust as frictionless (and fun!) as possible. And we are super excited to say: we've received 1,045 responses! The results, while varied, paint a pretty clear picture for tangible goals.]]></description><guid isPermaLink="false">b92200f5-9ac0-4104-9b0d-f444c55aceb8</guid><pubDate>Thu, 12 Apr 2018 22:26:15 +0000</pubDate><dc:creator>Rust CLI Working Group</dc:creator></item><item><title>Down a Rusty Rabbit Hole</title><link>https://manishearth.github.io/blog/2018/04/12/down-a-rusty-rabbit-hole/</link><description><![CDATA[Last week I fell down a rather interesting rabbit hole in Rust, which was basically me discovering a series of quirks of the Rust compiler/language, each one leading to the next when I asked “why?”]]></description><guid isPermaLink="false">ba7af9ee-e916-4d65-b7b2-c6afa2477ade</guid><pubDate>Thu, 12 Apr 2018 00:00:00 +0000</pubDate><dc:creator>Manish Goregaokar</dc:creator></item><item><title>The Challenge of Using C in Safety-Critical Applications [pdf]</title><link>https://polysync.io/s/The-Challenge-of-Using-C-in-Safety-Critical-Applications.pdf</link><description><![CDATA[Software errors in safety-critical systems can have severe consequences: property-loss, environmental devastation, injury, or death. Despite the severity of these risks, software continues to be written for safety-critical applications in languages that permit common classes of failures, such as undefined behavior, state corruption, and unexpected termination. One such language is C. Language standards that define allowable subsets (e.g. MISRA) and static analysis tools are often used in an attempt to ameliorate these failures by detecting them in the program code before they result in a critical issue at runtime. These traditional methods are ultimately insufficient when it comes to providing ahead-of-time assurances about safe runtime behavior for safety-critical applications. Alternative approaches must be considered.]]></description><guid isPermaLink="false">30fe522c-e827-436a-bd52-40314d80e95b</guid><pubDate>Wed, 11 Apr 2018 08:54:41 +0000</pubDate><dc:creator>Shea Newton, Nathan Aschbache</dc:creator></item><item><title>Why would I use divergent functions?</title><link>https://medium.com/@yangnana11/rust-why-would-i-use-divergent-functions-d9dec59071bc</link><description><![CDATA[Rust has some special syntax for ‘diverging functions’, which are functions that do not return.]]></description><guid isPermaLink="false">2238849b-fcc8-4bd4-9828-66637c22f9af</guid><pubDate>Wed, 11 Apr 2018 08:54:41 +0000</pubDate><dc:creator>Yang Nana</dc:creator></item><item><title>Rust all-hands (dev-tools stuff)</title><link>https://www.ncameron.org/blog/rust-all-hands-dev-tools-stuff/</link><description><![CDATA[Last week (sigh, the week before last now) we held an 'all-hands' event in Berlin. It was a great event - fantastic to meet so many Rust people in real life and really energising to see how much is being planned and implemented. In this post I want to summarise some of the important dev-tools stuff that happened. Our planning and notes from some meetings is in the dev-tools team repo.]]></description><guid isPermaLink="false">d506eda8-cab3-4046-b0b7-3c16fd1bc53d</guid><pubDate>Wed, 11 Apr 2018 02:18:18 +0000</pubDate><dc:creator>Nick Cameron</dc:creator></item><item><title>A Shifty Riddle</title><link>http://llogiq.github.io/2018/04/11/shift.html</link><description><![CDATA[When I finally implemented opportunistic mutations in mutagen, everything seemed fine until my co-maintainer gnieto found a problem. Code failed to compile with the mutagen plugin, something that should never happen as long as the code in question compiles without the plugin. We not only broke the code – we broke the build.]]></description><guid isPermaLink="false">68f328f0-50d5-4152-aa9a-f5ab3c69f397</guid><pubDate>Wed, 11 Apr 2018 00:00:00 +0000</pubDate><dc:creator>Llogiq</dc:creator></item><item><title>Instance Identity in C++ and Rust</title><link>https://jrvanwhy.github.io/instance-identity/</link><description><![CDATA[A document describing how (in my opinion) C++’s and Rust’s definitions of object instance differ.]]></description><guid isPermaLink="false">a38c18ee-88ab-46dd-994c-2c4e4d288d4c</guid><pubDate>Tue, 10 Apr 2018 21:04:09 +0000</pubDate><dc:creator>Johnathan Van Why</dc:creator></item><item><title>Dark Side Of Ergonomics</title><link>https://vorner.github.io/2018/04/08/Dark-side-of-ergonomics.html</link><description><![CDATA[Despite having an experience with wide range of computer languages, including C++ and Haskell (both strong influences to Rusts design), I found Rust hard to learn. Sometimes I grind my teeth about something the compiler doesn’t let me do. Despite that, I didn’t put ergonomics as a wish in any poll. In fact, if I was to take a poll right now, I’d probably be against further ergonomics initiatives.]]></description><guid isPermaLink="false">d1d6e382-3b80-431e-ba08-5cbe1ccebce2</guid><pubDate>Sun,  8 Apr 2018 00:00:00 +0000</pubDate><dc:creator>Michal &apos;vorner&apos; Vaner</dc:creator></item><item><title>Async &amp; Await in Rust: a full proposal</title><link>https://boats.gitlab.io/blog/post/2018-04-06-async-await-final/</link><description><![CDATA[I’m really excited to announce the culmination of much of our work over the last four months: a pair of RFCs for supporting async & await notation in Rust. This will be very impactful for Rust in the network services space. The change is proposed as two RFCs:
 RFC #2394: which adds async & await notation to the language. RFC #2395: which moves a part of the futures library into std to support that syntax.]]></description><guid isPermaLink="false">7fbe9c06-2e4a-4da4-aea0-45b4828f6687</guid><pubDate>Fri,  6 Apr 2018 00:00:00 +0000</pubDate><dc:creator>boats</dc:creator></item><item><title>The Rust Team All Hands in Berlin: a Recap</title><link>https://blog.rust-lang.org/2018/04/06/all-hands.html</link><description><![CDATA[Last week we held an “All Hands” event in Berlin, which drew more than 50 people involved in 15 different Rust Teams or Working Groups, with a majority being volunteer contributors. This was the first such event, and its location reflects the current concentration of team members in Europe. The week was a smashing success which we plan to repeat on at least an annual basis.]]></description><guid isPermaLink="false">5eca0d0a-81f6-4804-869f-32ed307adb9f</guid><pubDate>Fri,  6 Apr 2018 00:00:00 +0000</pubDate><dc:creator>Aaron Turon</dc:creator></item><item><title>Cargo, Xargo, and Rustup</title><link>http://aturon.github.io/2018/04/06/rustup-xargo/</link><description><![CDATA[Another topic of discussion at the Berlin Rust All Hands was the long-term story around Cargo, Xargo, and Rustup. The latter two tools are both involved in managing your Rust toolchain, with Xargo allowing you to build custom stds and Rustup managing pre-built artifacts for mainstream targets. Xargo is most commonly used for cross-compiling to less common platforms, but can also be used to customize the standard library on mainstream platforms.]]></description><guid isPermaLink="false">277652ec-bbeb-454c-85da-766438600d47</guid><pubDate>Fri,  6 Apr 2018 00:00:00 +0000</pubDate><dc:creator>Aaron Turon</dc:creator></item><item><title>Why put Rust in our Python Monitoring agent?</title><link>http://blog.scoutapp.com/articles/2018/04/10/why-put-rust-in-our-python-monitoring-agent</link><description><![CDATA[Prior to adding Python performance monitoring, we'd written monitoring agents for Ruby and Elixir. Our Ruby and Elixir agents had duplicated much of their code between them, and we didn't want to add a third copy of the agent-plumbing code. The overlapping code included things like JSON payload format, SQL statement parsing, temporary data storage and compaction, and a number of internal business logic components.

This plumbing code is about 80% of the agent code! Only 20% is the actual instrumentation of application code.

So, starting with Python, our goal became "how do we prevent more duplication". In order to do that, we decided to split the agent into two components. A language agent and a core agent. The language agent is the Python component, and the core agent is a standalone executable that contains most of the shared logic.]]></description><guid isPermaLink="false">12f71ab8-809a-45a6-8e95-fd98a92e7f60</guid><pubDate>Thu,  5 Apr 2018 07:46:00 -0400</pubDate><dc:creator>Chris</dc:creator></item><item><title>Sound and ergonomic specialization for Rust</title><link>http://aturon.github.io/2018/04/05/sound-specialization/</link><description><![CDATA[Specialization holds the dubious honor of being among the oldest post-1.0 features remaining in unstable limbo. That’s for good reason, though: until recently, we did not know how to make it sound.]]></description><guid isPermaLink="false">e01d9c09-e66d-4fea-94e3-95db24137dd6</guid><pubDate>Thu,  5 Apr 2018 00:00:00 +0000</pubDate><dc:creator>Aaron Turon</dc:creator></item><item><title>Writing the Perfect &apos;Collect&apos; Trait</title><link>https://mtak-blog.github.io/the_perfect_collect_trait</link><description><![CDATA[I’ve been spending some time thinking about garbage collection in rust. I know, shame on me, it’s a systems language, we hate garbage collection, but… even in a systems programming language, garbage collection is still pretty damn useful.]]></description><guid isPermaLink="false">4812042b-1d2a-4171-9a77-d2f0a0c44b91</guid><pubDate>Thu,  5 Apr 2018 00:00:00 +0000</pubDate><dc:creator>mtak-blog</dc:creator></item><item><title>Custom tasks in Cargo</title><link>http://aturon.github.io/2018/04/05/workflows/</link><description><![CDATA[One of the big requests from the Domain Working Groups for Rust 2018 is a richer feature set for framework- or domain-specific workflows in Cargo. At the simplest level, that might look like project templates – the ability to direct cargo new to start with a custom template defined in crates.io. That’s already enough to get you cooking with frameworks like QuiCLI, which today involve a fixed set of initial scaffolding that you can fill in.]]></description><guid isPermaLink="false">cb113ba3-eaa8-40e1-8ff8-a8b710bf89db</guid><pubDate>Thu,  5 Apr 2018 00:00:00 +0000</pubDate><dc:creator>Aaron Turon</dc:creator></item><item><title>A Formal Look at Pinning</title><link>https://www.ralfj.de/blog/2018/04/05/a-formal-look-at-pinning.html</link><description><![CDATA[Recently, a new API for “pinned references” has landed as a new unstable feature in the standard library. The purpose of these references is to express that the data at the memory it points to will not, ever, be moved elsewhere. Others have written about why this is important in the context of async IO. The purpose of this post is to take a closer, more formal look at that API: We are going to take a stab at extending the RustBelt model of types with support for pinning.]]></description><guid isPermaLink="false">8379ada9-43de-4764-88b1-aa3d24b114fd</guid><pubDate>Thu,  5 Apr 2018 00:00:00 +0200</pubDate><dc:creator>Ralf Jung</dc:creator></item><item><title>Rust memory safety revolution</title><link>https://anixe.pl/content/news/rust_memory_safety_revolution</link><description><![CDATA[This introduction is written for people, who are programmers, but don’t know Rust or are at the very beginning of learning it. It’s easier to understand for readers who know C, C++ or other language with manually managed memory as well as some with garbage collector. It’s a high-level introduction intended to present core Rust concepts and encourage further learning. It’s not a tutorial, there is no Hello Rust in the end.]]></description><guid isPermaLink="false">4eb3e72f-dec7-445e-9cbe-5464f3df1ceb</guid><pubDate>Tue,  3 Apr 2018 00:00:00 +0000</pubDate><dc:creator>Igor Żuk</dc:creator></item><item><title>Corner Cutting vs. Productivity</title><link>https://llogiq.github.io/2018/04/03/corners.html</link><description><![CDATA[I recently got into a discussion with another very knowledgeable Rustacean, who (I paraphrase) claimed that Rust is about adding just enough roadblocks to keep you from cutting corners. This is a nice metaphor because it explains a lot: Rust may feel more cumbersome, because it won’t let you cut corners. On the other hand, once it compiles, many classes of errors will already have been taken care of, so your code will usually work as expected (or if you’re new to Rust, unexpectedly well).]]></description><guid isPermaLink="false">0dd3a72c-b43f-449a-92f3-fd25f164d224</guid><pubDate>Tue,  3 Apr 2018 00:00:00 +0000</pubDate><dc:creator>Llogiq</dc:creator></item><item><title>Why We&apos;re Betting on Rust</title><link>https://www.uptime.ventures/blog/2018/04/why-were-betting-on-rust/</link><description><![CDATA[Considering how the state of our art is ever changing, I re-evaluate which tools belong in my box of gizmos each year as well. In the past, I’ve employed nginx as a high-performance cache and proxy, but it has been largely edged out by Envoy, which touts a hybrid non-blocking event model and has become wildly successful after being released in 2016. That very same principle, event-driven I/O, is the same reason I chose Node.js for most of the APIs I’ve developed since 2011. Even if practices change, we retain successful engineering models.

Beginning late last year, as I sketched our founding mission and initial product offerings, I also decided to select a new primary language that could handle most of our primary development tasks. After writing mostly JavaScript and compile-to-JS languages for half a decade, I longed for something more.]]></description><guid isPermaLink="false">680e9488-98e3-4a44-b462-761cf817ca10</guid><pubDate>Mon,  2 Apr 2018 00:00:00 +0000</pubDate><dc:creator>Nicholas Young</dc:creator></item><item><title>Rust: First impressions from a C++ developer</title><link>http://templated-thoughts.blogspot.com.au/2018/03/rust-first-impressions-from-c-developer.html</link><description><![CDATA[I started learning Rust 2 weeks back (yay!!) whenever I got free time. And all the time that I spent  learning it has been worthwhile. This is not going to be a deep technical post, but just my impressions about Rust from where I come from (C++).]]></description><guid isPermaLink="false">5941ab41-5269-4401-9978-f6f389922443</guid><pubDate>Sat, 31 Mar 2018 00:43:00 -0700</pubDate><dc:creator>Arun Muralidharan</dc:creator></item><item><title>You can&apos;t Rust that</title><link>http://lucumr.pocoo.org/2018/3/31/you-cant-rust-that/</link><description><![CDATA[The last year has been fun because I could build a lot for really nice stuff for Sentry in Rust and for the first time the development experience was without bigger roadblocks. While we have been using Rust before it now feels different because the ecosystem is so much more stable and we ran less against language or tooling issues.

However talking to people new to Rust (and even brainstorming APIs with coworkers) it's hard to get rid of the feeling that Rust can be a mind bending adventure and that the best way to have a stress free experience is knowing upfront what you cannot (or should not attempt to) do. Knowing that certain things just cannot be done helps putting your mind back back on the right track.

So here are things not to do in Rust and what to do instead which I think should be better known.]]></description><guid isPermaLink="false">980f0166-c073-42bc-a1df-7dab36421e10</guid><pubDate>Sat, 31 Mar 2018 00:00:00 +0000</pubDate><dc:creator>Armin Ronacher</dc:creator></item><item><title>Writing My Final Year Project in Rust</title><link>http://mattyhall.github.io/posts/writing-my-final-year-project-in-rust.html</link><description><![CDATA[As part of my final year in university I have had to undertake a project and then write a twenty page paper on it. I ended up being assigned one on a type of machine learning algorithm called boosting. This wasn't my first choice unfortunately, so I decided I'd try to make it interesting for myself by implementing it in Rust. Rust was, and still is, quite immature when it comes to machine learning - as Are We Learning Yet? confirms. I thought it would be an interesting challenge to write some machine learning algorithms in a language that has yet to be used too much for this field.]]></description><guid isPermaLink="false">e497ecb9-788c-476e-bb28-c1746fbff940</guid><pubDate>Fri, 30 Mar 2018 23:00:00 +0000</pubDate><dc:creator>Matthew Hall</dc:creator></item><item><title>I&apos;ve just learned Rust and I think I&apos;m in love</title><link>https://rskupnik.github.io/I-learned-rust-and-I-think-Im-in-love</link><description><![CDATA[I’ve decided to learn some Rust recently while working on the Stanford’s experimental course on operating systems. Here’s a list of things that I think are great about it.]]></description><guid isPermaLink="false">79ebe691-fe8b-46ea-806c-996919b730ca</guid><pubDate>Fri, 30 Mar 2018 00:00:00 +0000</pubDate><dc:creator>Radosław Skupnik</dc:creator></item><item><title>Removing Connection State In mob</title><link>http://hermanradtke.com/2018/03/29/removing-connection-state-from-mob.html</link><description><![CDATA[I started writing mob, an multi-echo server using mio, in 2015. I coded mob into a mostly working state and then left it mostly alone, only updating it to work with the latest stable mio. Recently, I started looking at the code again and had the urge to improve it. In a previous post, I talked about managing the state of connections in mob. In this post, I will walk through what I did to remove the need to track connection state. I wanted to remove the state because the implementation required an O(n) operation every tick of the mio event loop. It also added a fair amount of complexity to the code.]]></description><guid isPermaLink="false">d14f3e75-4047-441e-a67b-fc0de042845a</guid><pubDate>Thu, 29 Mar 2018 00:00:00 +0000</pubDate><dc:creator>Herman J. Radtke III</dc:creator></item><item><title>Announcing Rust 1.25</title><link>https://blog.rust-lang.org/2018/03/29/Rust-1.25.html</link><description><![CDATA[The Rust team is happy to announce a new version of Rust, 1.25.0. The last few releases have been relatively minor, but Rust 1.25 contains a bunch of stuff!]]></description><guid isPermaLink="false">2cadbd86-48ec-4fab-95bb-5959818d5747</guid><pubDate>Thu, 29 Mar 2018 00:00:00 +0000</pubDate><dc:creator>The Rust Core Team</dc:creator></item><item><title>Cargo got some new tricks, but is it still correct!?</title><link>https://www.reddit.com/r/rust/comments/87ss76/cargo_got_some_new_tricks_but_is_it_still_correct/</link><description><![CDATA[I have been working with @alexcrichton to improve the resolver in Cargo.]]></description><guid isPermaLink="false">04fdf0c8-05ab-46f3-b72d-c7e88eb6dc9b</guid><pubDate>Wed, 28 Mar 2018 15:25:46 +0000</pubDate><dc:creator>Eh2406</dc:creator></item><item><title>Dataframes: Traits, Enums, Generics, and Dynamic Typing</title><link>https://blog.hwc.io/posts/dataframe1/</link><description><![CDATA[I’m attempting to build a dataframe in Rust. I implemented a pattern using traits, generics, and enums in conjunction to deal with columns of different datatypes while allowing runtime reflection for accessing the data stored in a column.]]></description><guid isPermaLink="false">e5b4d06d-c604-42fa-9329-e4bec9f44cfd</guid><pubDate>Wed, 28 Mar 2018 09:57:53 -0400</pubDate><dc:creator>hwc</dc:creator></item><item><title>Reliable Systems Series: Model-Based Testing</title><link>https://medium.com/@tylerneely/reliable-systems-series-model-based-property-testing-e89a433b360</link><description><![CDATA[This is the first article in a series on techniques I’ve found useful for making my projects more reliable. These techniques are used in the distributed systems, database, automotive, embedded, and aerospace fields, but if you build services, user interfaces, or generally anything stateful, I think you will find something useful along the way.]]></description><guid isPermaLink="false">dac3ce68-bfe5-4774-8b89-fb4351d53445</guid><pubDate>Wed, 28 Mar 2018 12:52:27 +0000</pubDate><dc:creator>Tyler Neely</dc:creator></item><item><title>Closures 101</title><link>http://mttyng.com/closures-101/</link><description><![CDATA[Closures are an interesting CS concept and one that will frequently come up in interviews. I know I've been asked, and have asked, questions about closures for frontend (Javascript) positions numerous times. And in all honesty they're a difficult concept to define, especially when you're under the scrutiny of an interviewer. In this post I'd like to show how Rust leverages the concept of closures and why they might be used. But first, we need to discuss the concept of scope because it is so important for the full understanding of closures.]]></description><guid isPermaLink="false">d4574214-e1ca-4fe8-858b-b5c9c64046ab</guid><pubDate>Sun, 25 Mar 2018 00:00:00 +0000</pubDate><dc:creator>Matt</dc:creator></item></channel></rss>