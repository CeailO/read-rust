<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/"><channel><title>Read Rust - Language</title><link>https://readrust.net/</link><description>Language posts on Read Rust</description><item><title>The Temptation of Unsafe</title><link>https://inejge.github.io/blog/2019/07/18/The-Temptation-of-Unsafe.html</link><description><![CDATA[Recently, another round of discussion concerning the use of Rust’s unsafe features in the Actix web framework happened, or rather erupted, on Reddit, even more heated and acrimonious than the first time around. (I am not linking to any of the threads, as I believe that they don’t need any more exposure. Use your favorite search engine.) This proves, if more proof is needed, that people hold passionate beliefs about the matter.]]></description><guid isPermaLink="false">a0f3d2bb-e52e-440b-809f-169497494769</guid><pubDate>Thu, 18 Jul 2019 00:00:00 +0000</pubDate><dc:creator>inejge</dc:creator></item><item><title>Perils of Constructors</title><link>https://matklad.github.io/2019/07/16/perils-of-constructors.html</link><description><![CDATA[One of my favorite blog posts about Rust is Things Rust Shipped Without by Graydon Hoare. To me, footguns that don’t exist in a language are usually more important than expressiveness. In this slightly philosophical essay, I want to tell about a missing Rust feature I especially like: constructors.]]></description><guid isPermaLink="false">85b61a6b-91ab-4194-a236-43a690cc3f2f</guid><pubDate>Tue, 16 Jul 2019 00:00:00 +0300</pubDate><dc:creator>Aleksey Kladov</dc:creator></item><item><title>&quot;What The Hardware Does&quot; is not What Your Program Does: Uninitialized Memory</title><link>https://www.ralfj.de/blog/2019/07/14/uninit.html</link><description><![CDATA[This post is about uninitialized memory, but also about the semantics of highly optimized “low-level” languages in general. I will try to convince you that reasoning by “what the hardware does” is inherently flawed when talking about languages such as Rust, C or C++. These are not low-level languages. I have made this point before in the context of pointers; this time it is going to be about uninitialized memory.]]></description><guid isPermaLink="false">3161bc30-9df4-4273-8ff7-301ea0426d9f</guid><pubDate>Sun, 14 Jul 2019 00:00:00 +0000</pubDate><dc:creator>Ralf Jung</dc:creator></item><item><title>What Is Rust&apos;s unsafe?</title><link>https://nora.codes/post/what-is-rusts-unsafe/</link><description><![CDATA[I’ve seen a lot of misconceptions around what the unsafe keyword means for the utility and validity of Rust and its marketing as a “safe systems language”. The truth is a lot more complicated than a single pithy tweet can possibly sum up, unfortunately; here it is as I see it.

Basically, the unsafe keyword does not turn off the advanced type system that keeps Rust code honest. It only allows a few select “superpowers”, like dereferencing raw pointers. It is used to implement safe abstractions over a fundamentally unsafe world so that the majority of Rust code can use those abstractions and avoid memory unsafety.]]></description><guid isPermaLink="false">a05e51b1-ea5d-4365-949c-80c0c3e48d54</guid><pubDate>Fri, 12 Jul 2019 10:00:00 -0700</pubDate><dc:creator>Leonora Tindall</dc:creator></item><item><title>Testable Component Design in Rust</title><link>http://iextendable.com/2019/07/12/testable-component-design-in-rust/</link><description><![CDATA[I consider myself an advanced beginner in Rust. There is still much I’m wrapping my head around–and I still get caught off guard by the “move” and “mutability” rules Rust enforces. However, in keeping with my personal emphasis, I’ve devoted my efforts to learning how to create automated tests in Rust. The below guidelines are not exhaustive, but represent my learning so far. Feedback is welcome!]]></description><guid isPermaLink="false">20553a37-476d-45bb-8180-3de54aa932cd</guid><pubDate>Fri, 12 Jul 2019 13:57:01 +0000</pubDate><dc:creator>Chris McKenzie</dc:creator></item><item><title>AiC: Unbounded queues and lang design</title><link>http://smallcultfollowing.com/babysteps/blog/2019/07/10/aic-unbounded-queues-and-lang-design/</link><description><![CDATA[I have been thinking about how language feature development works in Rust1. I wanted to write a post about what I see as one of the key problems: too much concurrency in our design process, without any kind of “back-pressure” to help keep the number of “open efforts” under control. This setup does enable us to get a lot of things done sometimes, but I believe it also leads to a number of problems.

Although I don’t make any proposals in this post, I am basically advocating for changes to our process that can help us to stay focused on a few active things at a time. Basically, incorporating a notion of capacity such that, if we want to start something new, we either have to finish up with something or else find a way to grow our capacity.]]></description><guid isPermaLink="false">6d02baa8-8fcd-45fa-9f96-d36a635a2379</guid><pubDate>Wed, 10 Jul 2019 00:00:00 -0400</pubDate><dc:creator>Niko Matsakis</dc:creator></item><item><title>Async-await status report #2</title><link>http://smallcultfollowing.com/babysteps/blog/2019/07/08/async-await-status-report-2/</link><description><![CDATA[I wanted to give an update on the status of the “async-await foundations” working group. This post aims to cover three things: the “async await MVP” that we are currently targeting; how that fits into the bigger picture; and how you can help, if you’re so inclined;]]></description><guid isPermaLink="false">815aa1ce-d98e-484c-8dbf-a91fce9a4167</guid><pubDate>Mon,  8 Jul 2019 00:00:00 -0400</pubDate><dc:creator>Niko Matsakis</dc:creator></item><item><title>Method for Emulating Higher-Kinded Types in Rust</title><link>https://gist.github.com/edmundsmith/855fcf0cb35dd467c29a9350481f0ecf</link><description><![CDATA[I've been fiddling about with an idea lately, looking at how higher-kinded types can be represented in such a way that we can reason with them in Rust here and now, without having to wait a couple years for what would be a significant change to the language and compiler.

There have been multiple discussions on introducing higher-ranked polymorphism into Rust, using Haskell-style Higher-Kinded Types (HKTs) or Scala-looking Generalised Associated Types (GATs). The benefit of higher-ranked polymorphism is to allow higher-level, richer abstractions and pattern expression than just the rank-1 polymorphism we have today.]]></description><guid isPermaLink="false">55481592-1914-40bc-a2be-f7be9702c5c7</guid><pubDate>Sun,  7 Jul 2019 20:47:09 +0000</pubDate><dc:creator>Edmund Smith</dc:creator></item><item><title>Rust vs C++ - Implementing a Neural Network</title><link>http://nicktasios.nl/posts/rust-vs-c%2B%2B-implementing-a-neural-network.html</link><description><![CDATA[I first learned Rust back in 2014, before it was stable. Rust is definitely a very interesting language so I have decided to revisit it by programming a simple neural network. For comparison, I also implemented the network in C++, the language I'm looking to replace.]]></description><guid isPermaLink="false">649aefcc-0d0c-4e1c-b2d2-337d3110c606</guid><pubDate>Sat,  6 Jul 2019 19:18:48 +0200</pubDate><dc:creator>Nick Tasios</dc:creator></item><item><title>Functional Programming Jargon in Rust</title><link>https://functional.works-hub.com/learn/functional-programming-jargon-in-rust-1b555</link><description><![CDATA[Github Repository: https://github.com/JasonShin/functional-programming-jargon.rsFunctional programming (FP) provides many advantages, and its popula...]]></description><guid isPermaLink="false">3d786e81-3097-48f1-aea9-9a86473f6957</guid><pubDate>Fri,  5 Jul 2019 00:00:00 +0000</pubDate><dc:creator>Jason Shin</dc:creator></item><item><title>Cargo --offline ✈️</title><link>https://www.ncameron.org/blog/cargo-offline/</link><description><![CDATA[Rust 1.36 is released on the 4th July and includes a bunch of new stuff. This blog post is about one newly stable feature in Cargo: --offline.]]></description><guid isPermaLink="false">4ab235dc-fc27-4dfe-aefc-1bcc16a23199</guid><pubDate>Thu,  4 Jul 2019 08:13:57 +0000</pubDate><dc:creator>Nick Cameron</dc:creator></item><item><title>Rust std study series: alloc</title><link>https://ehsanmkermani.com/2019/07/03/rust-std-study-series-alloc/</link><description><![CDATA[Let’s get deep into std::alloc! The very basic need for any program to compile and execute is having access to either physical memory or virtual memory. An allocator is responsible for providing such an access. You can think of an allocator as a service, taking some sort of requests and either giving back a (pointer) to block of memory or some errors. In Rust, a request is a Layout i.e. some meta-data about how the memory we want is supposed to take up the space.]]></description><guid isPermaLink="false">a11e4440-7ad1-4e28-95d7-db6cc8a4544b</guid><pubDate>Thu,  4 Jul 2019 00:20:38 +0000</pubDate><dc:creator>Ehsan M. Kermani</dc:creator></item><item><title>Announcing Rust 1.36.0</title><link>https://blog.rust-lang.org/2019/07/04/Rust-1.36.0.html</link><description><![CDATA[This release brings many changes, including the stabilization of the Future trait, the alloc crate, the MaybeUninit<T> type, NLL for Rust 2015, a new HashMap<K, V> implementation, and --offline support in Cargo. Read on for a few highlights, or see the detailed release notes for additional information.]]></description><guid isPermaLink="false">75040309-d3a6-4941-a8d1-28c6f8bdfc19</guid><pubDate>Thu,  4 Jul 2019 00:00:00 +0000</pubDate><dc:creator>The Rust Release Team</dc:creator></item><item><title>Status of rust-analyzer: Achievements and Open Collective</title><link>https://ferrous-systems.com/blog/rust-analyzer-status-opencollective/</link><description><![CDATA[rust-analyzer is an experimental compiler frontend for the Rust programming language. The ultimate goal for this project is to provide the perfect IDE experience for Rust, with all IDE features working flawlessly while editing code. This post talks about what happened to rust-analyzer in between the all-hands and today, discusses future plans, and also announces the rust-analyzer Open Collective.]]></description><guid isPermaLink="false">09564ee8-19af-4b03-95c4-b231ffd7f24f</guid><pubDate>Mon,  1 Jul 2019 22:00:00 +0000</pubDate><dc:creator>Aleksey Kladov</dc:creator></item><item><title>Rust modules vs files</title><link>https://amos.me/blog/2019/rust-modules-vs-files/</link><description><![CDATA[A while back, I asked on Twitter what people found confusing in Rust, and one of the top topics was “how the module system maps to files”. I remember struggling with that a lot when I first started Rust, so I’ll try to explain it in a way that makes sense to me.]]></description><guid isPermaLink="false">ec53084d-522d-4916-90b2-c8adda4b75f2</guid><pubDate>Mon,  1 Jul 2019 00:00:00 +0000</pubDate><dc:creator>amos</dc:creator></item><item><title>One Program Written in Python, Go, and Rust</title><link>http://www.nicolas-hahn.com/python/go/rust/programming/2019/07/01/program-in-python-go-rust/</link><description><![CDATA[This is a subjective, primarily developer-ergonomics-based comparison of the three languages from the perspective of a Python developer, but you can skip the prose and go to the code samples, the performance comparison if you want some hard numbers, the takeaway for the tl;dr, or the Python, Go, and Rust diffimg implementations.]]></description><guid isPermaLink="false">a7b2c09d-06ca-4ae2-89c2-70bf78282396</guid><pubDate>Mon,  1 Jul 2019 00:00:00 +0000</pubDate><dc:creator>Nicolas Hahn</dc:creator></item><item><title>Sharing references between Python and Rust</title><link>https://raphaelgomes.dev/blog/articles/2019-07-01-sharing-references-between-python-and-rust.html</link><description><![CDATA[In 2018, the Mercurial project decided to use Rust to improve performance and maintainability of previous high-performance code. We have faced some interesting challenges when bridging the Python implementation with the new Rust code, and this is one that I have not found any literature about.]]></description><guid isPermaLink="false">38abc54a-6b27-48ec-8789-363ead337d8a</guid><pubDate>Mon,  1 Jul 2019 00:00:00 +0000</pubDate><dc:creator>Raphaël Gomès</dc:creator></item><item><title>Writing a small ray tracer in Rust and Zig</title><link>https://nelari.us/post/raytracer_with_rust_and_zig/</link><description><![CDATA[The two languages that I spent most of my time daydreaming about writing code in are Rust and Zig. Would the lack of features in Zig make me more or less productive than with Rust’s feature overload? Which language is more enjoyable to use for writing a small, self-contained computer graphics project?  To find out, I decided to implement the same simple project in both languages: a small ray tracer, following the book Ray Tracing in One Weekend.]]></description><guid isPermaLink="false">6e2a2811-942b-4e62-b173-6d2b0d3e0acd</guid><pubDate>Thu, 27 Jun 2019 20:00:00 +0200</pubDate><dc:creator>Johann Muszynski</dc:creator></item><item><title>Non-Lexical Lifetimes arrives for everyone</title><link>http://blog.pnkfx.org/blog/2019/06/26/breaking-news-non-lexical-lifetimes-arrives-for-everyone/</link><description><![CDATA[It has been literally years since I last posted to this blog. I have been doing a bunch of Rust compiler work. One big feature has been deployed: Non-Lexical Lifetimes (hereafter denoted “NLL”).

The motivation for this blog post: The next version of Rust, 1.36, is going to have NLL turned on for the 2015 edition. Going forward, all editions of Rust will now use NLL.]]></description><guid isPermaLink="false">d682ecb5-9935-4073-8865-f5a66f2a65f5</guid><pubDate>Wed, 26 Jun 2019 12:54:29 +0200</pubDate><dc:creator>Felix S. Klock II</dc:creator></item><item><title>Understanding Closures in Rust</title><link>https://medium.com/swlh/understanding-closures-in-rust-21f286ed1759</link><description><![CDATA[Summary: Closures are a combination of a function pointer (fn) and a context. A closure with no context is just a function pointer. A closure which has an immutable context belongs to Fn. A closure which has a mutable context belongs to FnMut. A closure that owns its context belongs to FnOnce.]]></description><guid isPermaLink="false">c39c6210-76a8-46f1-ab2d-b6f1be909232</guid><pubDate>Wed, 26 Jun 2019 10:27:58 +0000</pubDate><dc:creator>Andrew Pritchard</dc:creator></item><item><title>Rust type language - journey to rust</title><link>https://medium.com/journey-to-rust/rust-type-language-48e1c43b1ef4</link><description><![CDATA[Disclaimer: If you are learning Rust, take this with grain of salt. I’m learning Rust too and I may be utterly wrong in my guesses. The more I read and do Rust, the more I realize, that Rust consists of two (three, if macros counts) languages.]]></description><guid isPermaLink="false">4b9faf2d-145a-4deb-909d-ac58ea05bdc8</guid><pubDate>Tue, 25 Jun 2019 14:10:43 +0000</pubDate><dc:creator>George Shuklin</dc:creator></item><item><title>std time</title><link>https://blog.yoshuawuyts.com/std-time/</link><description><![CDATA[Over the past month we've been hard at work to add time support to the Runtime crate. One of the things we've had to think about has been examples. Which means we've had a chance to become intimately familiar with the good and less good parts of the std::time API.

In this post we'll look at the std::time API, and some of the proposed changes to smooth things out a bit. Also disclaimer: I've been involved with these proposals, hehe.]]></description><guid isPermaLink="false">f0491f48-a0cd-4f35-a781-a8907f277e8a</guid><pubDate>Tue, 25 Jun 2019 00:00:00 +0000</pubDate><dc:creator>Yoshua Wuyts</dc:creator></item><item><title>Why we&apos;re using Rust for cloud rendering</title><link>https://www.digitalbridge.com/blog/why-were-using-rust-for-cloud-rendering</link><description><![CDATA[We initially began replacing a small component of our stack using Rust, but it quickly became clear that a larger effort would allow a great reduction in complexity. In the end, all the C, C++, and Python components of the service were rebuilt, with Rust used from task loading through to dispatching GPU operations.]]></description><guid isPermaLink="false">91f9b804-7782-4a78-ade2-e4d8008923cf</guid><pubDate>Mon, 24 Jun 2019 12:07:47 +0000</pubDate><dc:creator>Iain MacIver</dc:creator></item><item><title>My iterator is returning a reference to a reference</title><link>https://blog.tawhidhannan.co.uk/rust/tidbits/rust-double-ref</link><description><![CDATA[Sometimes you mean it. Other times you really don't. It can be a bit of a headscratcher, but is not a particularly complicated situation, just easy to stumble into on a tired afternoon. In the end it all comes down to the ensuring you're being purposeful about what you're iterating over. I'll take a relatively brief dive into what can cause this, and how you can get back to iterating over what you want to iterate over.]]></description><guid isPermaLink="false">cb4c2736-6856-435e-a605-8d7b2155a1c3</guid><pubDate>Sun, 23 Jun 2019 00:00:00 +0000</pubDate><dc:creator>Tawhid Hannan</dc:creator></item><item><title>A Detailed Look at Rust Streams</title><link>https://blog.yoshuawuyts.com/rust-streams/</link><description><![CDATA[As Rust's async story is evolving, so is Rust's streaming story. In this post we'll take a look at how Rust's streaming model works, how to use it effectively, and where things are heading in the future.]]></description><guid isPermaLink="false">7602cf1d-bae1-41bb-bfb8-4d7967af1704</guid><pubDate>Thu, 20 Jun 2019 00:00:00 +0000</pubDate><dc:creator>Yoshua Wuyts</dc:creator></item><item><title>Distributed Systems Training in Rust and Go</title><link>https://tikv.org/blog/talent-training/</link><description><![CDATA[PingCAP is creating a series of training courses on writing distributed systems in Rust and Go. These courses consist of:

Practical Networked Applications in Rust. A series of projects that incrementally develop a single Rust project from the ground up into a high-performance, networked, parallel and asynchronous key/value store. Along the way various real-world and practical Rust development subject matter are explored and discussed.

Distributed Systems in Rust. Adapted from the MIT 6.824 distributed systems coursework, this course focuses on implementing important distributed algorithms, including the Raft consensus algorithm, and the Percolator distributed transaction protocol.]]></description><guid isPermaLink="false">f756eb13-90c3-407a-a304-66e198248d3b</guid><pubDate>Thu, 20 Jun 2019 00:00:00 +0000</pubDate><dc:creator>Brian Anderson</dc:creator></item><item><title>Rust std study series: Interior mutability</title><link>https://ehsanmkermani.com/2019/06/18/rust-std-study-series-interior-mutability/</link><description><![CDATA[Continuing the standard library study, it’s time for Cell<T>!]]></description><guid isPermaLink="false">ca449299-1f7d-493f-9857-b1954e1f371d</guid><pubDate>Tue, 18 Jun 2019 20:27:25 +0000</pubDate><dc:creator>Ehsan M. Kermani</dc:creator></item><item><title>Rust Creator Graydon Hoare Talks About Security, History, and Rust</title><link>https://thenewstack.io/rust-creator-graydon-hoare-talks-about-security-history-and-rust/</link><description><![CDATA[We’re approaching the 9th anniversary of the day Graydon Hoare (and numerous contributors) first revealed to the world the newly-designed Rust programming language. So we thought it’d be a good time to assess our current landscape.

Hoare graciously agreed, sharing his thoughts on everything from the state of systems programming, to the difficulty of defining safety on ever-more complex systems — and whether we’re truly more secure today, or confronting an inherited software mess that will take decades to clean up.]]></description><guid isPermaLink="false">f6b00396-a786-403b-b392-16e784f32241</guid><pubDate>Tue, 18 Jun 2019 13:00:49 +0000</pubDate><dc:creator>David Cassel</dc:creator></item><item><title>Experiment with streams, reading files with futures</title><link>https://chilimatic.hashnode.dev/experiment-with-streams-reading-files-with-futures-cjx1q0gmo001eurs1pt0c27kz</link><description><![CDATA[We were experimenting with streams and I wanted to play around with them as well. There are some tokio implementations for async file reading futuers, but since linux filesystems before kernel 5.1 do not really support non blocking file operations. I thought lets have fun breaking things ourselves. As I mentioned this is not really non blocking I/O esp. since there are two ways to view futures in their current state. ]]></description><guid isPermaLink="false">98e8bcf7-00d1-4f6d-ba28-ea41f2d7b705</guid><pubDate>Tue, 18 Jun 2019 00:00:00 +0000</pubDate><dc:creator>j</dc:creator></item><item><title>A simple plugin interface for the Rust FFI</title><link>http://kmdouglass.github.io/posts/a-simple-plugin-interface-for-the-rust-ffi/</link><description><![CDATA[I present a straight-forward design of a plugin interface using the Rust FFI.]]></description><guid isPermaLink="false">d0496592-58c8-4e56-8cfb-890df49f7b6c</guid><pubDate>Sun, 16 Jun 2019 07:33:33 +0000</pubDate><dc:creator>Kyle M. Douglass</dc:creator></item><item><title>On public API and private implementation</title><link>https://phaazon.net/blog/public-api-private-implementation</link><description><![CDATA[In this blog article, I want to explore a problem I’ve been facing from time to time in luminance. The manual dispatch problem. The idea is simple: you are writing a crate and want to expose an API to people. You want them to know which type they can use with a given operation (let’s call it update). However, the actual implementation of this update function is not performed directly by your API but is deferred to a backend implementation. Some people usually like to do that with several crates; in my case, I really don’t care and let’s think in terms of types / modules instead.]]></description><guid isPermaLink="false">7fc0def8-20e5-4923-922d-33732b5fc86c</guid><pubDate>Thu, 13 Jun 2019 17:05:00 +0000</pubDate><dc:creator>Dimitri Sabadie</dc:creator></item><item><title>A Journey Through Rust Lifetimes</title><link>https://medium.com/@richardanaya/a-journey-through-rust-lifetimes-5a08782c7091</link><description><![CDATA[I wanted to write an article about one aspect of Rust I really put off for a long while — lifetimes. They are one of the hardest parts about Rust to wrap one’s brain around. Many of us are simply not used to a compiler with a paradigm around memory ownership where such things are needed.

Lifetimes help the compiler make your code safer (i.e. less prone to crashing by using unexpected places in memory). Even if we don’t write them in our code, the compiler is smart enough to figure out your lifetimes without you under the covers. They are often times your secret allies, so let's learn a bit about them.]]></description><guid isPermaLink="false">ed6c2d09-739d-476b-b46f-441a1eefc6e3</guid><pubDate>Thu, 13 Jun 2019 00:09:47 +0000</pubDate><dc:creator>Richard Anaya</dc:creator></item><item><title>Bzip2 in Rust: porting the randomization table</title><link>https://people.gnome.org/~federico/blog/bzip2-in-rust-randomization-table.html</link><description><![CDATA[Here is a straightforward port of some easy code. randtable.c has a lookup table with seemingly-random numbers. This table is used by the following macros in bzlib_private.h]]></description><guid isPermaLink="false">05531a2c-35fc-4e51-ad25-77b362b99e03</guid><pubDate>Tue, 11 Jun 2019 14:30:17 -0500</pubDate><dc:creator>Federico Mena Quintero</dc:creator></item><item><title>How do you impl Display for Vec?</title><link>https://medium.com/apolitical-engineering/how-do-you-impl-display-for-vec-b8dbb21d814f</link><description><![CDATA[Or, more generally, how do you implement any trait that is outside of your crate, for a type that is also outside of your crate? Lets create a micro app that helps us explore the problem. We’ll create a simple struct, implement Display for that, then try to implement Display for a Vec of that struct. Once we understand the problem we’ll discuss a simple solution and how to make that solution more idiomatic.]]></description><guid isPermaLink="false">6ca39c1c-1424-4f6f-86c0-8e93f84718c0</guid><pubDate>Mon, 10 Jun 2019 14:03:02 +0000</pubDate><dc:creator>Daniel Mason</dc:creator></item><item><title>How macros make your Rust life easier and generally better</title><link>https://blog.x5ff.xyz/blog/easy-programming-with-rust-macros/</link><description><![CDATA[Let’s explore a topic that has been quite foreign to me for a long time: macros.]]></description><guid isPermaLink="false">170dcb20-7011-4222-afe7-e3eb2298a661</guid><pubDate>Fri,  7 Jun 2019 00:00:00 +0000</pubDate><dc:creator>Claus</dc:creator></item><item><title>Threads in rust</title><link>https://chilimatic.hashnode.dev/threads-in-rust-cjwmbxw9e003pzjs19n7pa0bt</link><description><![CDATA[In our regular hacksession, the current season ;), we are focusing on threading. Concurrency/Multithreading is a really hard topic it has a lot of very specific nomenclature and there are different 'levels' of concurrency one might say. I will start with the nomenclature starting from the programmers / OS perspective.]]></description><guid isPermaLink="false">922ec00d-8aa7-48eb-9344-c1d1eacc44ec</guid><pubDate>Fri,  7 Jun 2019 00:00:00 +0000</pubDate><dc:creator>j</dc:creator></item><item><title>Determining if a Rust Vector has all equal elements</title><link>https://sts10.github.io/2019/06/06/is-all-equal-function.html</link><description><![CDATA[Earlier today, I tooted out a Rust question: How would you write a function to determine if a Vector of integers are all the same, or not. Anyway, the Fediverse is wonderful and full of helpful Rust friends – I ended up getting about a dozen solutions (none exactly the same I don’t think?)]]></description><guid isPermaLink="false">c4166c18-6984-4c64-bda0-68d98d5b3ae7</guid><pubDate>Thu,  6 Jun 2019 22:11:00 +0000</pubDate><dc:creator>Sam Schlinkert</dc:creator></item><item><title>Solutions to the first 20 project euler problems</title><link>https://ngoldbaum.github.io/posts/project-euler/</link><description><![CDATA[I’m getting more and more used to thinking about Rust code in an idiomatic way, but I don’t think I’m comfortable enough to call myself a rustacean yet. To further my goal of oxidizing my brain with rust knowledge, I decided to start working through project euler problems sequentially. I’ve recently finished the first 20 problems and I though I’d share the highlights of what I learned about rust along the way.]]></description><guid isPermaLink="false">30deb171-6751-4af4-9f56-202fe6a78110</guid><pubDate>Thu,  6 Jun 2019 10:23:45 -0400</pubDate><dc:creator>Nathan Goldbaum</dc:creator></item><item><title>Overlapping blanket impls</title><link>https://codesandwich.github.io/overlapping_blanket_impls/</link><description><![CDATA[Rust doesn’t allow multiple impls of a trait on the same type. This rule keeps resolution transparent and reliable. It also has an ugly side effect, that for every trait there can be only 1 blanket impl. Compiler is completely distrustful here. What if somebody somewhere created a structure that implemented both ToString and Clone? Should such combination suddenly be forbidden? What about String and u32? This rule prevents type hierarchy from sliding into minefield of odd rules and breakages on every other dependency update.]]></description><guid isPermaLink="false">37400230-0f89-41d9-a9e4-a0d7460217ab</guid><pubDate>Wed,  5 Jun 2019 12:00:00 +0000</pubDate><dc:creator>CodeSandwich</dc:creator></item><item><title>Understanding Lifetimes</title><link>https://rniczh.github.io/blog/lifetimes-intro/</link><description><![CDATA[In this post, I want to describe the Lifetimes in a different way that what I’m learned from the RFC. Audience: You may already have read the Rust Book. Nice if you took a compiler course.]]></description><guid isPermaLink="false">461ba118-af83-41c6-8afc-42b1d320a826</guid><pubDate>Wed,  5 Jun 2019 00:00:00 +0000</pubDate><dc:creator>Hong-Sheng Zheng</dc:creator></item><item><title>The Typestate Pattern in Rust</title><link>http://cliffle.com/blog/rust-typestate/</link><description><![CDATA[The typestate pattern is an API design pattern that encodes information about an object's run-time state in its compile-time type. This pattern is so easy in Rust that it's almost obvious, to the point that you may have already written code that uses it, perhaps without realizing it. I haven't seen a detailed examination of the nuances of this pattern, so here's my contribution.]]></description><guid isPermaLink="false">7d1887a3-55d1-448d-8643-2a520bfddc41</guid><pubDate>Wed,  5 Jun 2019 00:00:00 +0000</pubDate><dc:creator>Cliff L. Biffle</dc:creator></item><item><title>Bzip2 in Rust - Basic infrastructure and CRC32 computation</title><link>https://people.gnome.org/~federico/blog/bzip2-in-rust-basic-infra.html</link><description><![CDATA[I have started a little experiment in porting bits of the widely-used bzip2/bzlib to Rust. I hope this can serve to refresh bzip2, which had its last release in 2010 and has been nominally unmaintained for years.

I hope to make several posts detailing how this port is done. In this post, I'll talk about setting up a Rust infrastructure for bzip2 and my experiments in replacing the C code that does CRC32 computations.]]></description><guid isPermaLink="false">332be129-192f-46d1-aefc-c3765e5b1b56</guid><pubDate>Thu, 30 May 2019 10:36:19 -0500</pubDate><dc:creator>Federico Mena Quintero</dc:creator></item><item><title>Rust&apos;s custom derives in a hexagonal architecture: Incompatible ideas?</title><link>https://blog.eizinger.io/5835/rust-s-custom-derives-in-a-hexagonal-architecture-incompatible-ideas</link><description><![CDATA[This blog post is a manifestation of a problem that has been floating around in my head for quite a while now. It is about the seemingly incompatible idea of fully embracing Rust's custom derive system in an application that puts a strong focus on a hexagonal architecture.

To discuss this problem, I am going to first write about both concepts individually. Feel free to skip over those sections if you are already familiar with the topics. The blog post finishes off with some ideas on how Rust could be extended to better support these kind of usecases.]]></description><guid isPermaLink="false">d6200716-96c2-4c9c-890d-0047906b7c72</guid><pubDate>Thu, 30 May 2019 00:00:00 +0000</pubDate><dc:creator>Thomas Eizinger</dc:creator></item><item><title>Update on await syntax</title><link>https://boats.gitlab.io/blog/post/await-decision-ii/</link><description><![CDATA[In my previous post I said that the lang team would be making our final decision about the syntax of the await operator in the May 23 meeting. That was last Thursday, and we did reach a decision. In brief, we decided to go forward with the preliminary proposal I outlined earlier: a postfix dot syntax, future.await. For more background, in addition the previous post on my blog, you can read this write up about some of the trade offs from April.]]></description><guid isPermaLink="false">b3ca84bd-3574-43f7-aef3-988cbc6389a4</guid><pubDate>Tue, 28 May 2019 00:00:00 +0000</pubDate><dc:creator>boats</dc:creator></item><item><title>Calling a Go Library from Rust: A Case Study with SQIP</title><link>https://blog.arranfrance.com/post/cgo-sqip-rust/</link><description><![CDATA[A brief run-down of how to wrap a Go library in a CGO FFI to enable its functions to be called by Rust.]]></description><guid isPermaLink="false">ec3d6230-6b29-4459-8a62-c40a8ef08430</guid><pubDate>Mon, 27 May 2019 00:00:00 +0000</pubDate><dc:creator>Arran France</dc:creator></item><item><title>Creating a &apos;paged&apos; Vec in Rust</title><link>https://dev.to/kdrakon/creating-a-paged-vec-in-rust-193l</link><description><![CDATA[In this post I'll show you some code I wrote for paginating over a Vec collection in Rust. I needed this for a CLI tool I wrote which was meant to display all the vector entries retrieved from a remote server. In most cases, I expected to receive a lot of results, so to display them in a terminal efficiently, I couldn't reasonably render them all. I decided I would page the results.]]></description><guid isPermaLink="false">51cdd7b5-fed9-439c-b6f8-c50ee7f93ea2</guid><pubDate>Fri, 24 May 2019 06:36:49 +0000</pubDate><dc:creator>Sean Policarpio</dc:creator></item><item><title>Announcing Rust 1.35.0</title><link>https://blog.rust-lang.org/2019/05/23/Rust-1.35.0.html</link><description><![CDATA[The highlight of this release is the implementation of the FnOnce, FnMut, and Fn closure traits for Box<dyn FnOnce>, Box<dyn FnMut>, and Box<dyn Fn> respectively. Additionally, closures may now be coerced to unsafe function pointers. The dbg! macro introduced in Rust 1.32.0 can now also be called without arguments. Moreover, there were a number of standard library stabilizations. Read on for a few highlights, or see the detailed release notes for additional information.]]></description><guid isPermaLink="false">53c0e6e9-a95e-4509-b70a-74e945e74e92</guid><pubDate>Thu, 23 May 2019 00:00:00 +0000</pubDate><dc:creator>The Rust Release Team</dc:creator></item><item><title>Putting the stack back into Stacked Borrows</title><link>https://www.ralfj.de/blog/2019/05/21/stacked-borrows-2.1.html</link><description><![CDATA[Less than a month ago, I announced Stacked Borrows 2. In particular, I hoped that that version would bring us closer to proper support for two-phase borrows. Turns out I was a bit too optimistic! Last week, @Manishearth asked on Zulip why Miri rejected a certain program, and it turned out that the issue was related to two-phase borrows: in combination with interior mutability, behavior wasn’t always what we wanted it to be. So, I went back to the drawing board and tried to adjust Stacked Borrows.

In the end, I decided to give up on “proper” support for two-phase borrows for now, which I explained here. But I also made some tweaks to Stacked Borrows that affect all accesses (not just two-phase borrows), and that’s what this post is about. I am referring to this as “Stacked Borrows 2.1”.]]></description><guid isPermaLink="false">c12cd1dc-8523-4caf-add8-4ba0322a3cb6</guid><pubDate>Tue, 21 May 2019 00:00:00 +0000</pubDate><dc:creator>Ralf Jung</dc:creator></item><item><title>Here&apos;s My Type, So Initialize Me Maybe (mem::uninitialized is deprecated)</title><link>https://gankro.github.io/blah/initialize-me-maybe/</link><description><![CDATA[Rust's infamous mem::uninitialized method has been deprecated in today's nightly build. Its replacement, MaybeUninit, has been stabilized. If you are using the former, you should migrate to using the latter as soon as possible (probably when it hits stable in 6 weeks). This was done because it was determined that mem::uninitialized was fundamentally broken, and could not be made to work.]]></description><guid isPermaLink="false">bab17ec7-d45f-40fa-963b-10c3085fa7bf</guid><pubDate>Tue, 21 May 2019 00:00:00 +0000</pubDate><dc:creator>Alexis Beingessner</dc:creator></item><item><title>dtolnay/case-studies: Analysis of various tricky Rust code</title><link>https://github.com/dtolnay/case-studies</link><description><![CDATA[This repository showcases some examples of tricky Rust code that I have encountered during my years working with a variety of advanced macro libraries in Rust (my own and others').]]></description><guid isPermaLink="false">4dfd194e-9cc6-4b75-b2f4-8900d8fdebcd</guid><pubDate>Tue, 21 May 2019 00:00:00 +0000</pubDate><dc:creator>David Tolnay</dc:creator></item><item><title>Polyglot Projects</title><link>https://myrrlyn.net/blog/misc/polyglot-projects</link><description><![CDATA[An exploration of how I wrote a C++ binding API for my Rust library.]]></description><guid isPermaLink="false">812b46b0-ec10-45f3-9fc6-4aaa2ae2534e</guid><pubDate>Mon, 20 May 2019 00:00:00 +0000</pubDate><dc:creator>Alexander Payne</dc:creator></item><item><title>Rust In Avast</title><link>https://vorner.github.io/2019/05/19/rust-in-avast.html</link><description><![CDATA[When I joined Avast about a year and a half ago, I did it because of two things:  I wanted to work on interesting problems and I wanted to share the Wisdom of Rust with few more people.

Originally, I was hired because of my experience with writing software for „bigger embedded“ (think a home router or Raspberry PI ‒ it runs Linux kernel, has a shell, but the file system is a bad joke, your libc has bunch of weird bugs features, you really need to think twice not to waste RAM needlessly and you have to cross-compile), low-level networking knowledge and C++.

But I don’t enjoy writing C++ (not speaking about the libc features). And I have other skills I like to practice too. So I would drop an occasional comment about how this or that would be better done in Rust. I’ve done internal courses and workshops about Rust for whoever was interested, in the hope more people would start asking to be allowed to do stuff in Rust and I could participate in such projects.]]></description><guid isPermaLink="false">eedb81ef-265f-4dc2-a1d9-559d2d68594d</guid><pubDate>Sun, 19 May 2019 00:00:00 +0000</pubDate><dc:creator>Michal &apos;vorner&apos; Vaner</dc:creator></item><item><title>Evaluating pipelined rustc compilation</title><link>https://internals.rust-lang.org/t/evaluating-pipelined-rustc-compilation/10199</link><description><![CDATA[Recently landed in nightly is the ability for Cargo to execute rustc in a “pipelined” fashion which has the promise of faster build times across the ecosystem. This support is turned off by default and the Cargo team is interested to gather more data and information about this feature, and that’s where you come in! If you’re interested in faster compiles, we’re interested in getting your feedback on this feature!]]></description><guid isPermaLink="false">64f26c72-e208-4900-90b5-cd1c61ec450b</guid><pubDate>Fri, 17 May 2019 16:09:30 +0000</pubDate><dc:creator>Alex Crichton</dc:creator></item><item><title>Tutorial: Use FlatBuffers in Rust</title><link>https://rwinslow.com/posts/use-flatbuffers-in-rust/</link><description><![CDATA[The FlatBuffers project is an extremely efficient schema-versioned serialization library. In this tutorial, you’ll learn how to use it in Rust.]]></description><guid isPermaLink="false">7d2d904d-78a6-42be-8c41-c1934b975516</guid><pubDate>Fri, 17 May 2019 00:00:00 +0000</pubDate><dc:creator>Robert Winslow</dc:creator></item><item><title>Rust – Arrays? Make chains, not concat!</title><link>https://frehberg.com/2019/05/rust-arrays-make-chains-no-concat/</link><description><![CDATA[f your application needs to iterate over a bunch of items from different sources or arrays, someone with C/C++ background might copy all items into a single vector and iterate this vector. This strategy will cause high costs in terms of allocating heap memory for the consecutive vector buffer. Instead, keep the data where it is, and chain it together to form an iterator over a virtual array. The following Rust code demonstrates the chaining of multiple arrays, forming a single itertator, without any additional allocation of vector buffer in heap. ]]></description><guid isPermaLink="false">009c05c5-89b2-4519-9133-c46988d45a17</guid><pubDate>Thu, 16 May 2019 16:59:10 +0000</pubDate><dc:creator>Frank Rehberger</dc:creator></item><item><title>Cross compiling and statically linking against Rust libraries</title><link>https://medium.com/csis-techblog/cross-compiling-and-statically-linking-against-rust-libraries-2c02ee2c01af</link><description><![CDATA[A few years ago, mainly due to performance reasons, we started rewriting specific back-end services from Python to Rust, with great success. Now, for the sake of ease of development and testing, we are exploring the idea of moving parts of our C/C++ code base to Rust, too.

In order to do so, instead of re-writing everything in one swoop, we decided to try integrating Rust into our existing code base.

Following is a summary of our experiments, and a skeleton for writing a Rust library and calling it from a C/C++ application.]]></description><guid isPermaLink="false">3f754573-640a-4f2c-8c98-bcb1d2727bf9</guid><pubDate>Thu, 16 May 2019 10:29:25 +0000</pubDate><dc:creator>Tiago Seco</dc:creator></item><item><title>Zero Cost Abstractions</title><link>https://boats.gitlab.io/blog/post/zero-cost-abstractions/</link><description><![CDATA[The idea of a zero cost abstraction is very important to certain programming languages, like Rust and C++, which intend to enable users to write programs with excellent performance profiles with relatively little effort. Since this idea is fundamental to the design of Rust and my work, I want to investigate, for a moment, what exactly a zero cost abstraction even is.]]></description><guid isPermaLink="false">0369c538-0c12-4b33-9211-fd410b2c38da</guid><pubDate>Thu, 16 May 2019 00:00:00 +0000</pubDate><dc:creator>boats</dc:creator></item><item><title>Rust - 4+ years later</title><link>https://fnordig.de/2019/05/15/rust-4-years-later/</link><description><![CDATA[A quick tour through my 4+ years with Rust.]]></description><guid isPermaLink="false">e710999e-81b7-433e-a2cd-d1968a619567</guid><pubDate>Wed, 15 May 2019 00:00:00 +0000</pubDate><dc:creator>Jan-Erik Rediger</dc:creator></item><item><title>4 years of Rust</title><link>https://blog.rust-lang.org/2019/05/15/4-Years-Of-Rust.html</link><description><![CDATA[On May 15th, 2015, Rust was released to the world! After 5 years of open development (and a couple of years of sketching before that), we finally hit the button on making the attempt to create a new systems programming language a serious effort!]]></description><guid isPermaLink="false">1bda7394-787a-42d1-9733-2b503a611ffb</guid><pubDate>Wed, 15 May 2019 00:00:00 +0000</pubDate><dc:creator>The Rust Core Team</dc:creator></item><item><title>Creating C/C++ APIs in Rust</title><link>https://karroffel.gitlab.io/post/2019-05-15-rust/</link><description><![CDATA[Rust is an amazing language with an even better ecosystem. Many design decisions of Rust make it a great fit to add new functionality to existing C/C++ systems or gradually replace parts of those systems!

When I tried to make a C++ API for a Rust library, I found that binding from C/C++ to Rust is better documented and has a smoother experience than binding from Rust to C/C++.]]></description><guid isPermaLink="false">6715c2d9-9049-40c2-bc29-cca235bde059</guid><pubDate>Wed, 15 May 2019 00:00:00 +0000</pubDate><dc:creator>Thomas Herzog</dc:creator></item><item><title>Rust – Handling Executables and their Debug-Symbols</title><link>https://frehberg.com/2019/05/rust-handling-executables-and-their-debug-symbols/</link><description><![CDATA[This post is about compiling Rust-code, the executables, the handling of the corresponding debug symbols and core-files. It highlights the importance of debug-symbols for debugging and how to split them of the binary before shipping to customer.]]></description><guid isPermaLink="false">0e504089-5eaf-4cb5-a22d-04bb587e54f9</guid><pubDate>Tue, 14 May 2019 22:24:55 +0000</pubDate><dc:creator>Frank Rehberger</dc:creator></item><item><title>Announcing Rust 1.34.2</title><link>https://blog.rust-lang.org/2019/05/14/Rust-1.34.2.html</link><description><![CDATA[The Error::type_id method was recently stabilized as part of Rust 1.34.0. This point release destabilizes it, preventing any code on the stable and beta channels to implement or use it, awaiting future plans that will be discussed in issue #60784.]]></description><guid isPermaLink="false">294ff4dd-a217-4d15-a378-a2ef10f6aae8</guid><pubDate>Tue, 14 May 2019 00:00:00 +0000</pubDate><dc:creator>The Rust Release Team</dc:creator></item><item><title>Optional parameters in Rust</title><link>http://blog.keiruaprod.fr/2019/05/11/optional-parameters-in-rust/</link><description><![CDATA[Many languages feature “optional” parameters to function arguments: if you provide a value, it will be used, but if you don’t, a default value will be used instead. How to do that in Rust? Well, in Rust you have to provide all the parameters a function requests. You can, however, use “Option”s to do two things: make their usage not mandatory, provide a default value.]]></description><guid isPermaLink="false">a0770f01-6980-48bd-bd23-cdee98b5c16a</guid><pubDate>Sat, 11 May 2019 19:16:47 +0000</pubDate><dc:creator>Clement Keirua</dc:creator></item><item><title>Some Thoughts on Rust&apos;s Async/Await Debate</title><link>https://whitfin.io/some-thoughts-on-rusts-async-await-proposals/</link><description><![CDATA[This post will be an extension of the debates found in the Rust forums, specifically here and here. A lot is being said in those threads and there's a certain amount of duplicated posts that are drowning out potentially valuable information and perspectives. I've written several comments in those debates]]></description><guid isPermaLink="false">6c334d13-f697-4774-8820-3665687ec7a4</guid><pubDate>Thu,  9 May 2019 18:41:38 +0000</pubDate><dc:creator>Isaac Whitfield</dc:creator></item><item><title>Recursive iterators in Rust</title><link>https://amos.me/blog/2019/recursive-iterators-rust/</link><description><![CDATA[I’ve been looking for this blog post everywhere, but it doesn’t exist, so I guess it’s my turn to write about Some Fun with Rust. Let’s say you have a recursive, acyclic data structure. Now let’s say you want to iterate over the values of the root node and all its children, recursively, so that you get the sequence [1, 2, 3, 4, 5, 6, 7].]]></description><guid isPermaLink="false">7d5b4554-d4eb-45b4-9d90-a562f36a4f88</guid><pubDate>Wed,  8 May 2019 00:00:00 +0000</pubDate><dc:creator>amos</dc:creator></item><item><title>Implementing a Interpreted Language in Rust Part 1</title><link>http://nedellis.com/2019/05/08/esta_1/</link><description><![CDATA[We live in a great era for language design. Within the last 5-10 years, several innovative languages have come out and won over the hearts of many developers with a newfound focus on memory safety (Rust), runtime interoperability (JVM: Kotlin, V8: Typescript, BEAM: Elixir), first class concurrency (Go, Pony), dependent types (Idris), Language oriented Programming (Racket) and many more inspired features. In this spirit, I have decided to throw my hat into the ring as well and create my own language for fun.]]></description><guid isPermaLink="false">35a812e7-75c8-4ffe-98b0-0dee390a5a51</guid><pubDate>Wed,  8 May 2019 00:00:00 +0000</pubDate><dc:creator>Ned Ellis</dc:creator></item><item><title>Rust and glibc version</title><link>http://redbeardlab.com/2019/05/07/rust-and-glibc-version/</link><description><![CDATA[The rust compiler dynamically link the executable against the glibc in the system. Hence if you compile your software against a newer version of glibc (say 2.19) that the one available where you run the executable (say in the host is available 2.14) it may not work.

The cleanest one is to don’t dynamically link against glib, indeed is possible to compile a rust binary statically linking musl, to do so is sufficient to compile against the correct target, usually using cargo build --target x86_64-unknown-linux-musl.

Another possibility is to compile in an environment with an “old-enough” version of glibc, this is usually done using docker and indeed there is a whole project that aim to create a set “zero setup” docker images. ]]></description><guid isPermaLink="false">e6de297c-e3b3-40ab-af40-922f95e71444</guid><pubDate>Tue,  7 May 2019 16:33:59 +0000</pubDate><dc:creator>Simone Mosciatti</dc:creator></item><item><title>Rust Patterns: Enums Instead Of Booleans</title><link>http://blakesmith.me/2019/05/07/rust-patterns-enums-instead-of-booleans.html</link><description><![CDATA[As I’ve been writing Rust code more, I’ve noticed how few boolean types I’m using in my code. Instead, I’m using Rust’s powerful enums in 90% of cases where I would have reached for a boolean in another language.]]></description><guid isPermaLink="false">577c30e3-f6b8-4c6f-98a5-020962df3df3</guid><pubDate>Tue,  7 May 2019 00:00:00 +0000</pubDate><dc:creator>Blake Smith</dc:creator></item><item><title>How and why await should be a method afterall</title><link>https://www.hardmo.de/article/2019-05-06-await-method-afterall.md</link><description><![CDATA[Explains in which way the planned `await` resembles a function call and provides reasoning how apparent contradictions in this model can be dispelled.]]></description><guid isPermaLink="false">10bffdde-a5d9-4066-971b-0c155ba8ce2d</guid><pubDate>Mon,  6 May 2019 00:00:00 +0000</pubDate><dc:creator>Andreas Molzer</dc:creator></item><item><title>A final proposal for await syntax</title><link>https://boats.gitlab.io/blog/post/await-decision/</link><description><![CDATA[This is an announcement regarding the resolution of the syntax for the await operator in Rust. This is one of the last major unresolved questions blocking the stabilization of the async/await feature, a feature which will enable many more people to write non-blocking network services in Rust. This post contains information about the timeline for the final decision, a proposal from the language team which is the most likely syntax to be adopted, and the justification for this decision.]]></description><guid isPermaLink="false">b7f70811-6fa2-4bab-b9e2-be4107ec221b</guid><pubDate>Mon,  6 May 2019 00:00:00 +0000</pubDate><dc:creator>withoutboats</dc:creator></item><item><title>Compile-time coprocessor codegen, with Rust macros</title><link>https://guiand.xyz/blog-posts/macro-assembly-codegen.html</link><description><![CDATA[Motivation: The Nintendo 3DS uses an ARM standard peripheral, the CoreLink DMA engine, for copying memory among DRAM and memory-mapped peripherals.

This DMA engine, unlike most other IO devices on the 3DS, actually has its own instruction set where the CPU merely uploads a stream of instructions for the peripheral to execute (other examples of this, on the 3DS, are the DSP audio processor and the PICA graphics chip).

I’d like to compile and run DMA instructions in Rust, in a hopefully ergonomic manner, without needing to use any dynamic memory allocation. This imposes a particular constraint that I need to know the number of instruction bytes at compile time so I can use an appropriately-sized array.]]></description><guid isPermaLink="false">433737c5-300e-4095-82c3-2ca05e51b029</guid><pubDate>Fri,  3 May 2019 00:00:00 +0000</pubDate><dc:creator>Gui Andrade</dc:creator></item><item><title>Risp (Lisp (in (Rust)))</title><link>https://m.stopa.io/risp-lisp-in-rust-90a0dad5b116</link><description><![CDATA[Many years ago, Peter Norvig wrote a beautiful article about creating a lisp interpreter in Python. It’s the most fun tutorial I’ve seen, not just because it teaches you about my favorite language family (Lisp), but because it cuts through to the essence of interpreters, is fun to follow and quick to finish.

Recently, I had some time and wanted to learn Rust. It’s a beautiful systems language, and I’ve seen some great work come out from those who adopt it. I thought, what better way to learn Rust, than to create a lisp interpreter in it?

Hence, Risp — a lisp in rust — was born. In this essay you and I will follow along with Norvig’s Lispy, but instead of Python, we’ll do it in Rust 🙂.]]></description><guid isPermaLink="false">4ce6618d-d773-4260-85c6-639aaf6ec7fc</guid><pubDate>Thu,  2 May 2019 17:44:37 +0000</pubDate><dc:creator>Stepan Parunashvili</dc:creator></item><item><title>How XV uses Panics</title><link>https://medium.com/@chrisvest/how-xv-uses-panics-ba22bd6152a5</link><description><![CDATA[XV is a terminal hex viewer that I am working on. It is the first “real” Rust project that I am working on, coming from a Java background.

Java has exceptions. Both checked exceptions, identified by having the Exception class as a parent class, and unchecked exceptions, which have RuntimeException as a parent class.

Rust does not have exceptions. Rust has panics, which, depending on build-time configurations, are either catch-able when they unwind the stack, or only produce a backtrace, or just immediately aborts the process. This is controlled by the “panic” setting in the “profile” sections of your Cargo.toml file.]]></description><guid isPermaLink="false">0bc705c5-726c-4967-84cc-264f7a6338df</guid><pubDate>Thu,  2 May 2019 16:26:24 +0000</pubDate><dc:creator>Chris Vest</dc:creator></item><item><title>Cargo in 2019</title><link>https://www.ncameron.org/blog/cargo-in-2019/</link><description><![CDATA[I recently published a post detailing a vision for the next few years (hah! Not so recently now, this took a lot longer than expected). Here I'll get into more detail about 2019.]]></description><guid isPermaLink="false">ae1f3c27-6a45-4b49-ac3c-e081adfe52c9</guid><pubDate>Wed,  1 May 2019 22:37:35 +0000</pubDate><dc:creator>Nick Cameron</dc:creator></item><item><title>Extending Python with Rust</title><link>https://medium.com/@p_chhetri/extending-python-with-rust-84e9299d34c1</link><description><![CDATA[Python is a great programming language but sometimes it can be a bit of slowcoach when it comes to performing certain tasks. That’s why developers have been building C/C++ extensions and integrating them with Python to speed up the performance. However, writing these extensions is a bit difficult because these low-level languages are not type-safe, so doesn’t guarantee a defined behavior. This tends to introduce bugs with respect to memory management. Rust ensures memory safety and hence can easily prevent these kinds of bugs.]]></description><guid isPermaLink="false">f759c500-da13-4765-81f1-dd59918b09d1</guid><pubDate>Wed,  1 May 2019 17:37:44 +0000</pubDate><dc:creator>Pradeep Chhetri</dc:creator></item><item><title>World&apos;s First Private Cargo Registry</title><link>https://blog.cloudsmith.io/2019/05/01/worlds-first-private-cargo-registry/</link><description><![CDATA[If you're interested in the possibilities that hosting your own private or internal crates brings, then this is incredibly good news for you: Cloudsmith are proud to provide the World's first commercially available public and private Cargo registry hosting, with ultra-fast and secure delivery of your Rust packages, alongside all of the usual Enterprise-grade features that we provide.]]></description><guid isPermaLink="false">89a6ce72-79b9-477d-a5e5-bd1e6407c3f5</guid><pubDate>Wed,  1 May 2019 12:06:47 +0000</pubDate><dc:creator>Patrick Carey</dc:creator></item><item><title>Stacked Borrows 2</title><link>https://www.ralfj.de/blog/2019/04/30/stacked-borrows-2.html</link><description><![CDATA[Recently, I have significantly updated Stacked Borrows in order to fix some issues with the handling of shared references that were uncovered in the previous version. In this post, I will describe what the new version looks like and how it differs from Stacked Borrows 1. I assume some familiarity with the prior version and will not explain everything from scratch.]]></description><guid isPermaLink="false">f2a55dcd-b163-42ac-8660-311e1cc384d0</guid><pubDate>Tue, 30 Apr 2019 00:00:00 +0000</pubDate><dc:creator>Ralf Jung</dc:creator></item><item><title>My Key Learnings after 30,000 LOC in Rust</title><link>https://medium.com/@jondot/my-key-learnings-after-30-000-loc-in-rust-a553e6403c19</link><description><![CDATA[For me, Rust takes a stroll over the memory lane above and picks and drives home the best experiences from all those languages — which is a]]></description><guid isPermaLink="false">094e167c-f023-449e-9976-247d314fd269</guid><pubDate>Mon, 29 Apr 2019 17:57:26 +0000</pubDate><dc:creator>Dotan Nahum</dc:creator></item><item><title>Comparing the Same Project in Rust, Haskell, C++, Python, Scala and OCaml</title><link>http://thume.ca/2019/04/29/comparing-compilers-in-rust-haskell-c-and-python/</link><description><![CDATA[During my final term at UWaterloo I took the CS444 compilers class with a project to write a compiler from a substantial subset of Java to x86, in teams of up to three people with a language of the group’s choice. This was a rare opportunity to compare implementations of large programs that all did the same thing, written by friends I knew were highly competent, and have a fairly pure opportunity to see what difference design and language choices could make. I gained a lot of useful insights from this. It’s rare to encounter such a controlled comparison of languages, it’s not perfect but it’s much better than most anecdotes people use as the basis for their opinions on programming languages.]]></description><guid isPermaLink="false">fde2b9f7-5ee2-4743-8887-0ae941fc2217</guid><pubDate>Mon, 29 Apr 2019 00:00:00 +0000</pubDate><dc:creator>Tristan Hume</dc:creator></item><item><title>Creating cross-platform Rust terminal apps</title><link>http://www.jonathanturner.org/2019/04/porting-the-pikachu.html</link><description><![CDATA[I’ve been wanting to play around with the cool spinning Pikachu demo everyone was talking about. Sadly, it used termion to do its magic, which meant that unfortunately it wouldn’t work for me. Termion has been a boon for Rust, with lots of folks using it to create terminal applications. Unfortunately, as a Windows user, I know there’s a good chance that if the crate depends on termion that’s the end of the line for me, as termion apps just don’t work in Windows. Surely, I thought, there must be a better way, but I never managed to find one. Enter crossterm.]]></description><guid isPermaLink="false">28c59573-37da-46b6-92c0-f6fbb4a5e613</guid><pubDate>Sat, 27 Apr 2019 00:00:00 +0000</pubDate><dc:creator>Jonathan Turner</dc:creator></item><item><title>Announcing Rust 1.34.1</title><link>https://blog.rust-lang.org/2019/04/25/Rust-1.34.1.html</link><description><![CDATA[This patch release fixes two false positives and a panic when checking macros in Clippy. Clippy is a tool which provides a collection of lints to catch common mistakes and improve your Rust code.]]></description><guid isPermaLink="false">ce78473f-6f58-428d-ba3e-cbbbfc778345</guid><pubDate>Thu, 25 Apr 2019 00:00:00 +0000</pubDate><dc:creator>The Rust Release Team</dc:creator></item><item><title>How Rust Solved Dependency Hell</title><link>https://stephencoakley.com/2019/04/24/how-rust-solved-dependency-hell</link><description><![CDATA[Every once in a while I'll be involved in a conversation about dependency management and versions, often at work, in which the subject of “dependency hell” will come up. If you're not familiar with the term, then I encourage you to look it up. A brief summary might be: "The frustration that comes from dealing with application dependency versions and dependency conflicts". With that in mind, let's get a little technical about dependency resolution.]]></description><guid isPermaLink="false">91b5c36e-a3f8-4cbd-ad0e-cd796ee6ea24</guid><pubDate>Wed, 24 Apr 2019 05:00:00 +0000</pubDate><dc:creator>Stephen Coakley</dc:creator></item><item><title>Rust&apos;s 2019 roadmap</title><link>https://blog.rust-lang.org/2019/04/23/roadmap.html</link><description><![CDATA[Each year the Rust community comes together to set out a roadmap. This year, in addition to the survey, we put out a call for blog posts in December, which resulted in 73 blog posts written over the span of a few weeks. The end result is the recently-merged 2019 roadmap RFC. To get all of the details, please give it a read, but this post lays out some of the highlights.]]></description><guid isPermaLink="false">c66e7e63-ea76-4d35-a15b-0bf56a905b07</guid><pubDate>Tue, 23 Apr 2019 00:00:00 +0000</pubDate><dc:creator>The Rust Core Team</dc:creator></item><item><title>Elements of Rust: style and philosophy</title><link>https://github.com/ferrous-systems/elements-of-rust</link><description><![CDATA[A collection of software engineering techniques for effectively expressing intent with Rust.]]></description><guid isPermaLink="false">bda9c409-db67-4283-aadc-ffb54c3ad00d</guid><pubDate>Mon, 22 Apr 2019 00:00:00 +0000</pubDate><dc:creator>Ferrous Systems </dc:creator></item><item><title>Generic returns in Rust</title><link>https://blog.jcoglan.com/2019/04/22/generic-returns-in-rust/</link><description><![CDATA[After casting around for a new platform to learn recently, I’ve decided to dive into Rust. Being mostly familiar with untyped languages like Ruby and JavaScript, it’s interesting to learn a statically typed language and see how it changes how one writes programs. There’s a common misconception amongst dynamic typing fans that static typing means you write the same programs, they’re just more verbose and come with more restrictions. And while there is certainly a cost to only being allowed to write type-safe programs, a good type system actually lets you write programs you cannot write in dynamic languages. In Rust, generic return values are a good example of this.]]></description><guid isPermaLink="false">036c9563-3d69-4cf8-a59a-718976fded92</guid><pubDate>Mon, 22 Apr 2019 00:00:00 +0000</pubDate><dc:creator>James Coglan</dc:creator></item><item><title>Things I Enjoy in Rust: Error Handling</title><link>https://blog.jonstodle.com/things-i-enjoy-in-rust-error-handling/</link><description><![CDATA[I’ve already talked about how I like how enums are used in Rust. They make it easy to express multiple states and the state’s related data. One place this is excellently utilized is error handling.]]></description><guid isPermaLink="false">8fbc326e-e356-480c-8708-c6b4d8d66719</guid><pubDate>Sun, 21 Apr 2019 12:00:00 +0200</pubDate><dc:creator>Jon Grythe Stødle</dc:creator></item><item><title>Lessons moving from iOS delegates to Rust async</title><link>https://thomask.sdf.org/blog/2019/04/19/lessons-moving-from-ios-delegates-to-rust-async.html</link><description><![CDATA[The majority of my async programming experience is on iOS and let me tell you, life is good. You can easily dispatch work to background threads. You can bring work back to the main thread. You can mark your classes as delegates and when you need to handle some event the OS will use a magic pre-existing thread pool to invoke your method and you can do whatever you like. It works perfectly almost all the time, except for when it doesn’t because of race conditions or it crashes due to concurrency. Life is good.

Rust is less tolerant about the crashing part. While I agree that crashing is bad in principle, avoiding it has significant ramifications for how you can write async code at all. Recently I’ve been finding out what the differences are. Obviously this means I’m more of a noob than an expert, but I’m currently in a good position to point out what the confusing parts are and what the Rust solutions seem to be. (But I’m a noob so take it with a grain of salt.)]]></description><guid isPermaLink="false">0cc3f8b6-7cd9-423f-96f2-569b660e2bf3</guid><pubDate>Fri, 19 Apr 2019 19:30:00 +1000</pubDate><dc:creator>Thomas Karpiniec</dc:creator></item><item><title>Things I Enjoy in Rust: Enums</title><link>https://blog.jonstodle.com/things-i-enjoy-in-rust-enums/</link><description><![CDATA[I’ve been diving into Rust for the last couple of months, after my colleague started talking about it. I’ve been wanting to learn a lower level language, but C++ or something of the like have always seemed too daunting for me to even start.

I’d heard of Rust before, and great things too, but hadn’t set apart time to look into it. I finally took the dive. And boy, am I glad I did.

A lot of people talk about the borrowing system of Rust, or how fast it, or the strict type system. All of which are great things, but it’s not what I’m going to write about here. I’m excited about enums.]]></description><guid isPermaLink="false">675975c8-b21a-4d87-8ac3-7e8c74fd8897</guid><pubDate>Thu, 18 Apr 2019 18:00:00 +0200</pubDate><dc:creator>Jon Grythe Stødle</dc:creator></item><item><title>Learning Parser Combinators With Rust</title><link>https://bodil.lol/parser-combinators/</link><description><![CDATA[This article teaches the fundamentals of parser combinators to people who are already Rust programmers. It assumes no other knowledge, and will explain everything that isn't directly related to Rust, as well as a few of the more unexpected aspects of using Rust for this purpose. It will not teach you Rust if you don't already know it, and, if so, it probably also won't teach you parser combinators very well.]]></description><guid isPermaLink="false">a085423c-ec98-4fff-ba66-7c23926175d9</guid><pubDate>Thu, 18 Apr 2019 00:00:00 +0000</pubDate><dc:creator>Bodil Stokke</dc:creator></item><item><title>Proper Notation for Scalar Multiplication in Rust: Dispatching on the Right-Hand Side of Operators and Rusts&apos;s Orphan Rule</title><link>https://www.jstuber.net/2019/04/17/scalar-multiplication-in-rust/</link><description><![CDATA[The scalar multiplication in a vector space is written kv in math, where k is a scalar value (e.g. a number) and v is a vector. It would be nice to write k * v in programming languages, to stay close to the familiar notation. Object-oriented languages typically only support calling methods on the first argument. But the scalar normally doesn't know about vectors, so it can't easily do that.]]></description><guid isPermaLink="false">524e6489-33da-4635-977c-9d86e839d185</guid><pubDate>Wed, 17 Apr 2019 00:00:00 +0000</pubDate><dc:creator>Jürgen Stuber</dc:creator></item><item><title>Rust Associated Type</title><link>https://medium.com/codechain/rust-associated-type-b0193c22eacd</link><description><![CDATA[Associated Types in Rust are similar to Generic Types; however, Associated Types limit the types of things a user can do, which consequently facilitates code management. Among the Generic Types of traits, types that depend on the type of trait implementation can be expressed by using the Associated Type syntax. By comparing the Associated and Generic Types, you can get a better understanding of Associated Types.]]></description><guid isPermaLink="false">77c8e0ed-ccb6-4f29-8ab7-1e8c3cd5d39d</guid><pubDate>Tue, 16 Apr 2019 10:08:09 +0000</pubDate><dc:creator>Park Juhyung</dc:creator></item><item><title>Rust: beyond the typechecker</title><link>https://blog.merigoux.ovh/en/2019/04/16/verifying-rust.html</link><description><![CDATA[This post will be different from the previous ones, since I’m going to present some of the early results of my work as a PhD student at the Prosecco team in ...]]></description><guid isPermaLink="false">8770e0f9-eca2-4f58-b2f4-7761dbcf81bb</guid><pubDate>Tue, 16 Apr 2019 00:00:00 +0000</pubDate><dc:creator>Denis Merigoux</dc:creator></item><item><title>More than coders</title><link>http://smallcultfollowing.com/babysteps/blog/2019/04/15/more-than-coders/</link><description><![CDATA[Lately, the compiler team has been changing up the way that we work. Our goal is to make it easier for people to track what we are doing and – hopefully – get involved. This is an ongoing effort, but one thing that has become clear immediately is this: the compiler team needs more than coders.]]></description><guid isPermaLink="false">b35d346f-7773-44c5-8db5-4cbe95fb3749</guid><pubDate>Mon, 15 Apr 2019 00:00:00 -0400</pubDate><dc:creator>Niko Matsakis</dc:creator></item><item><title>for await loops (Part I)</title><link>https://boats.gitlab.io/blog/post/for-await-i/</link><description><![CDATA[The biggest unresolved question regarding the async/await syntax is the final syntax for the await operator. There’s been an enormous amount of discussion on this question so far; a summary of the present status of that discussion and the positions within the language team is coming soon. Right now I want to separately focus on one question which impacts that decision but hasn’t been considered very much yet: for loops which process streams.]]></description><guid isPermaLink="false">8c6f2335-8fba-4cb5-9da1-2baba7f59159</guid><pubDate>Mon, 15 Apr 2019 00:00:00 +0000</pubDate><dc:creator>withoutboats</dc:creator></item><item><title>Chess vocabulary in Rust</title><link>https://backscattering.de/chess/vocabulary/</link><description><![CDATA[Recently I've been using Rust to build a server for the new 7-piece Syzygy endgame tablebases. Using Rust was quite enjoyable and I plan to use it for many future projects. This series is intended to order and share my thoughts, and as a primer to discuss some open questions I have.]]></description><guid isPermaLink="false">37ea8a58-93a1-4e5c-b125-d98a250e601c</guid><pubDate>Sun, 14 Apr 2019 00:00:00 +0000</pubDate><dc:creator>Niklas Fiekas</dc:creator></item><item><title>Neat new feature in Rust: iter::from_fn</title><link>https://weblog.latte.ca/blake/tech/rust/makingiterators.html</link><description><![CDATA[Recently Rust has introduced a couple of new features, and the one that caught my eye in particular was std::iter::from_fn, which let’s you make an iterator from a function, which is most of what that macro was trying to do, so I thought I would try to convert the various places I was using the macro to use the new function instead…]]></description><guid isPermaLink="false">c16ea768-9518-4a40-b51d-9c5e978994a2</guid><pubDate>Sat, 13 Apr 2019 20:49:00 +0000</pubDate><dc:creator>Blake Winton</dc:creator></item><item><title>Using Rust Generics to Enforce DB Record State</title><link>https://fy.blackhats.net.au/blog/html/2019/04/13/using_rust_generics_to_enforce_db_record_state.html</link><description><![CDATA[I’m currently working on a (private in 2019, public in july 2019) project which is a NoSQL database writting in Rust. To help us manage the correctness and lifecycle of database entries, I have been using advice from the Rust Embedded Group’s Book. As I have mentioned in the past, state machines are a great way to design code, so let’s plot out the state machine we have for Entries]]></description><guid isPermaLink="false">ad1e9e94-37b0-4328-93d5-216cb58cd905</guid><pubDate>Sat, 13 Apr 2019 00:00:00 +0000</pubDate><dc:creator>firstyear</dc:creator></item><item><title>Building a pub/sub server with Sonr (part 2)</title><link>https://hagsteel.com/posts/building-a-pub-sub-with-sonr-part-2/</link><description><![CDATA[This is the second part in a two part series on writing a pub/sub server in Rust using Sonr. We will jump straight in building the publisher. This is the biggest piece of code so far in this project.]]></description><guid isPermaLink="false">b7836b84-068e-4db1-9c0c-2dea0652626d</guid><pubDate>Thu, 11 Apr 2019 01:00:00 +0100</pubDate><dc:creator>Jonas</dc:creator></item><item><title>Announcing Rust 1.34.0</title><link>https://blog.rust-lang.org/2019/04/11/Rust-1.34.0.html</link><description><![CDATA[The largest feature in this release is the introduction of alternative cargo registries. The release also includes support for ? in documentation tests, some improvements for #[attribute(..)]s, as well as the stabilization of TryFrom. Read on for a few highlights, or see the detailed release notes for additional information.]]></description><guid isPermaLink="false">c652e06d-95e4-4da0-8ce8-a94c007587d7</guid><pubDate>Thu, 11 Apr 2019 00:00:00 +0000</pubDate><dc:creator>The Rust Release Team</dc:creator></item><item><title>Mysteriously Low Hanging Fruit: A Big Improvement To LLD For Rust Debug Builds</title><link>https://robert.ocallahan.org/2019/04/mysteriously-low-hanging-fruit-big.html</link><description><![CDATA[LLD is generally much faster than the GNU ld.bfd and ld.gold linkers, so you would think it has been pretty well optimised. You might then be surprised to discover that a 36-line patch dramatically speeds up linking of Rust debug builds, while also shrinking the generated binaries dramatically, both in simple examples and large real-world projects.]]></description><guid isPermaLink="false">afbe8437-4dca-40c1-b6ab-034fbd57c9cd</guid><pubDate>Thu, 11 Apr 2019 00:00:00 +0000</pubDate><dc:creator>Robert O&apos;Callahan</dc:creator></item></channel></rss>