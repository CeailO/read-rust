<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/"><channel><title>Read Rust - Language</title><link>https://readrust.net/</link><description>Language posts on Read Rust</description><item><title>A Rusty Advent of Code</title><link>https://cprimozic.net/blog/a-rusty-aoc/</link><description><![CDATA[For the first time, I took part in the Advent of Code this year. If you haven't heard of it, it's a daily programming challenge that can be solved in any programming language. Rust was very present in the Advent of Code community with people contributing a ton of Rust-related content. In the daily solutions thread on the /r/aoc subreddit, there were always several Rust solutions posted. Advent of Code really helps show off the things that make Rust shine, demonstrating the power and utility of many community-created crates as well as the language itself.]]></description><guid isPermaLink="false">04d1c753-5242-4aa9-bff7-500a717a62bc</guid><pubDate>Thu, 27 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Casey Primozic</dc:creator></item><item><title>Handling failure in Rust</title><link>https://esimmler.com/handling-failure-in-rust/</link><description><![CDATA[I’ve begun to seriously dig into the Rust programming language. The learning curve is real, but I already appreciate the work they’ve put into ergonomics. I’m writing a simple photo thumbnail endpoint using the Rocket web framework (v0.4) and Image library (v0.20.1). My first pass used a lot of unwrapping to ignore potential errors. A lot can go wrong, even in this “simple” case. Rocket catches any panics thrown by route handlers, so this is about as robust as a naive equivalent in most other languages. However, Rust at least forces us to be explicit and purposeful about when we want to be sloppy. This is great for a first quick and dirty pass, but we can do much better.]]></description><guid isPermaLink="false">0a14c8b2-c25a-4733-9682-e1cc71567cc9</guid><pubDate>Wed, 26 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Erik Simmler</dc:creator></item><item><title>async-io-demo: Rust asynchronous io: from mio to stackless coroutine</title><link>https://github.com/Hexilee/async-io-demo</link><description><![CDATA[2019 is approaching. The rust team keeps their promise about asynchronous IO: async is introduced as keywords, Pin, Future, Poll and await! is introduced into standard library. I have never used rust for asynchronous IO programming earlier, so I almost know nothing about it. However, I would use it for a project recently but couldn't find many documents that are remarkably helpful for newbie of rust asynchronous programming. My purpose of writing this blog is to review and summarize, I will be happy if it can help someone who are interested in rust asynchronous programming.]]></description><guid isPermaLink="false">fe9a3482-44e2-48d3-8728-0a15b4d2fd48</guid><pubDate>Wed, 26 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Li Chenxi</dc:creator></item><item><title>Currying in rust Part 3 (The circle of life ... aka why borrowchecker ... why?!)</title><link>https://hashnode.com/post/currying-in-rust-part-3-the-circle-of-life-aka-why-borrowchecker-why-cjq3z1dd800dknds1sls4dqav</link><description><![CDATA[Today we're going to take a look at the 'pipe' function my friend has written and why all of the sudden lifetimes get important esp. when using references.]]></description><guid isPermaLink="false">bddc8eb0-f2db-4330-87fa-2eca9a68e9e5</guid><pubDate>Tue, 25 Dec 2018 16:35:00 +0000</pubDate><dc:creator>j</dc:creator></item><item><title>On Rust</title><link>https://dehora.net/journal/2018/12/23/on-rust</link><description><![CDATA[Back in 2013, I started a series of posts on programming languages I found interesting. One of the languages I wanted to write about at that time was Rust. As often happens, life got in the way, and it’s only now, in the twilight of 2018 I’m coming round to a long overdue post.]]></description><guid isPermaLink="false">0717e76b-2097-4ee0-87b1-5f6cffadbdf0</guid><pubDate>Sun, 23 Dec 2018 16:34:59 +0000</pubDate><dc:creator>Bill de hÓra</dc:creator></item><item><title>Visualizing Crates.io</title><link>https://8-p.info/visualizing-crates-io/</link><description><![CDATA[Visualizing Rust's growing ecosystem through crates.io, Rust's central package repository.]]></description><guid isPermaLink="false">7dd6ca97-374d-4c01-86fb-f3fed29bb6f6</guid><pubDate>Sun, 23 Dec 2018 12:06:00 +0000</pubDate><dc:creator>Kazuyoshi Kato</dc:creator></item><item><title>Methods for Array Initialization in Rust</title><link>https://www.joshmcguigan.com/blog/array-initialization-rust/</link><description><![CDATA[Arrays in Rust are fixed size, and Rust requires that every element in an array is initialized to a valid value when the array is initialized. The result of these requirements is array initialization in Rust is a much deeper topic then it would seem.]]></description><guid isPermaLink="false">5e9ee3df-617a-4a7c-b8bd-ade701971b10</guid><pubDate>Sat, 22 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Josh Mcguigan</dc:creator></item><item><title>Six years with Rust</title><link>https://words.steveklabnik.com/six-years-with-rust</link><description><![CDATA[This past year was… intense. Rust 1.31 was basically Rust 2.0, at least in the marketing sense. I burned myself out getting the first edition of the book together for Rust 1.0, and I burned myself out getting the edition shipped.

Let’s talk about the bad and the good. Bad first so we end on the high notes.]]></description><guid isPermaLink="false">deb0916b-c8e3-47b1-b957-bfa8015b73ff</guid><pubDate>Fri, 21 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Steve Klabnik</dc:creator></item><item><title>Procedural Macros in Rust 2018</title><link>https://blog.rust-lang.org/2018/12/21/Procedural-Macros-in-Rust-2018.html</link><description><![CDATA[Perhaps my favorite feature in the Rust 2018 edition is procedural macros. Procedural macros have had a long and storied history in Rust (and will continue to have a storied future!), and now is perhaps one of the best times to get involved with them because the 2018 edition has so dramatically improved the experience both defining and using them.

Here I'd like to explore what procedural macros are, what they're capable of, notable new features, and some fun use cases of procedural macros. I might even convince you that this is Rust 2018's best feature as well!]]></description><guid isPermaLink="false">e01f334f-a14e-4a54-b7d7-76c9cc6ccdc7</guid><pubDate>Fri, 21 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Alex Crichton</dc:creator></item><item><title>Creating an empty iterator of a certain type in Rust</title><link>https://www.freedomlayer.org/offst/option-iterator/</link><description><![CDATA[I am working these days on the development of offst's Index server. I needed to implement a basic directed graph structure, allowing to run the BFS algorithm to find routes with a certain amount of capacity. During the work on the Index server I had the problem of wanting to return an empty iterator in an early flow of a function.]]></description><guid isPermaLink="false">3f750cea-55f1-44cf-b965-b3a2803de32b</guid><pubDate>Sat, 15 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Freedomlayer</dc:creator></item><item><title>Rust 2019 - my 2¢</title><link>https://www.reddit.com/r/rust/comments/a5s024/rust_2019_my_2/</link><description><![CDATA[I will not be really original here, but I really hope to see the following features to land on stable in 2019: const generics, async/await, GATs, inherent traits, minimum supported Rust version:]]></description><guid isPermaLink="false">dd6ec508-904b-4cd2-96ca-3df2ed99b074</guid><pubDate>Thu, 13 Dec 2018 20:24:49 +1100</pubDate><dc:creator>u/newpavlov</dc:creator></item><item><title>Yet another Rust 2018 wishlist</title><link>https://www.reddit.com/r/rust/comments/a5q7eb/yet_another_rust_2018_wishlist/</link><description><![CDATA[The 2018 year brought a lot of incredible new features and I'm impressed with all the work that was put in to make the 2018 edition happen. I want to join the other users asking for 2019 to be a year we adjust to all the new changes and focus on cleaning and polishing, not entirely new projects*. For the upcoming year I'd like to see progress on compilation speed and maintenance attention in the library ecosystem.]]></description><guid isPermaLink="false">d4acf845-6f69-4f54-bd37-96d62f83a54c</guid><pubDate>Thu, 13 Dec 2018 15:38:32 +1100</pubDate><dc:creator>u/Saefroch</dc:creator></item><item><title>Bootstrapping Rust</title><link>https://www.gnu.org/software/guix/blog/2018/bootstrapping-rust/</link><description><![CDATA[It has been a long-standing tradition to develop a language far enough to be able to write the language's compiler in the same language, and Rust does the same. Rust is nowadays written in Rust. We've tracked down the earlier Rust versions, which were written in OCaml, and were planning to use these to bootstrap Rust. But in parallel, John Hudge (Mutabah) developed a Rust compiler, called "mrustc", written in C++. mrustc is now good enough to compile Rust 1.19.0. Using mrustc, we were able to build Rust entirely from source with a bootstrap chain]]></description><guid isPermaLink="false">6bf8dccd-51b6-4dcb-a9eb-e38923d28a2c</guid><pubDate>Tue, 11 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Danny Milosavljevic</dc:creator></item><item><title>Existential types in Rust</title><link>https://adelbertc.github.io/posts/2018-12-10-rust-existentials.html</link><description><![CDATA[The Rust project I am working on is a caching layer, currently backed by Redis, and it came to a point where I needed to leverage pipelining. On its own, pipelining is straightforward as the redis crate implements it already. However all notions of a cache in our code are abstracted out behind a trait so we can have alternative implementations, such as an in-memory HashMap-backed implementation.

The problem arises with representing the pipeline in code. It would force any implementation of our cache to Redis’s notion of a pipeline. Not only would this make it difficult to introspect during testing, but it would also be nonsensical for our HashMap-backed cache. My usual answer to this in languages that support higher-kinded types is to use tagless-final algebras, but Rust’s type system currently doesn’t support higher-kinded types1. Fortunately, there is a pretty good alternative that Rust does support: existential types.]]></description><guid isPermaLink="false">4fe3c55c-a091-40c2-ada0-8c5d371afc31</guid><pubDate>Mon, 10 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Adelbert Chang</dc:creator></item><item><title>Rust 2019</title><link>https://vfoley.xyz/rust-2019/</link><description><![CDATA[In 2019, there are three areas where I would like to see the Rust community focus its efforts: Improved compile times, A community effort to review crates, More “80% solutions”.]]></description><guid isPermaLink="false">a02deaa2-0f75-48c6-86ef-f6a314be6355</guid><pubDate>Sun,  9 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Vincent Foley</dc:creator></item><item><title>Inside Rust’s Async Transform</title><link>https://blag.nemo157.com/2018/12/09/inside-rusts-async-transform.html</link><description><![CDATA[As you likely know if you’re reading this post Rust has an upcoming async/await feature being tested in nightly. Because of Rust’s unique features and positioning fully understanding the implementation powering this syntax is very different to understanding other well-known implementations (C# and JavaScript’s being the ones I am familiar with). Instead of thinking of a CPS-like transform where an async function is split into a series of continuations that are chained together via a Future::then method, Rust instead uses a generator/coroutine transform to turn the function into a state machine (C# and probably most JavaScript implementations use a similar transform under the hood, but as far as I’m aware because of the garbage collector these are indistinguishable from the naive CPS transform they are normally described as). For more detail on why Rust is taking this approach you should read eRFC 2033: Experimental Coroutines, that lays out the why’s much better than I could here.

What I’m going to try and provide instead, is a look into how this actually works today. What steps the compiler takes to turn an async fn into a normal function returning a state machine that you could write if you wanted to (but you definitely don’t).]]></description><guid isPermaLink="false">9303577c-bd85-4bfa-9b0c-30685300155c</guid><pubDate>Sun,  9 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Wim Looman</dc:creator></item><item><title>Debugging Cargo Test</title><link>https://www.wihlidal.com/blog/general/2018-12-07-debugging-cargo-test/</link><description><![CDATA[While developing some crates in rust, I ran into a few crashes in certain situations when using these crates from another application. In order to more easily reproduce the problem, and also minimize or eliminate future regressions, I decided to write some unit tests for these issues, and use them to more easily debug the problems… or so I thought!]]></description><guid isPermaLink="false">b9206a7e-5ee3-4336-b756-afab50e9992f</guid><pubDate>Fri,  7 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Graham Wihlidal</dc:creator></item><item><title>Rust 2018 is here… but what is it?</title><link>https://hacks.mozilla.org/2018/12/rust-2018-is-here/</link><description><![CDATA[Starting today, the Rust 2018 edition is in its first release. With this edition, we’ve focused on making Rust developers as productive as they can be. But beyond that, it can be hard to explain exactly what Rust 2018 is.]]></description><guid isPermaLink="false">a9fa887f-3615-45d9-ab2d-d400d30f1039</guid><pubDate>Thu,  6 Dec 2018 16:13:55 +0000</pubDate><dc:creator>Lin Clark</dc:creator></item><item><title> A call for Rust 2019 Roadmap blog posts</title><link>https://blog.rust-lang.org/2018/12/06/call-for-rust-2019-roadmap-blogposts.html</link><description><![CDATA[Starting today and running until of January 15, we’d like to ask the community to write blogposts reflecting on Rust in 2018 and proposing goals and directions for Rust in 2019.]]></description><guid isPermaLink="false">3234baba-f03d-467c-b032-d7d0dec7a12d</guid><pubDate>Thu,  6 Dec 2018 00:00:00 +0000</pubDate><dc:creator>The Rust Community Team</dc:creator></item><item><title> Announcing Rust 1.31 and Rust 2018</title><link>https://blog.rust-lang.org/2018/12/06/Rust-1.31-and-rust-2018.html</link><description><![CDATA[The Rust team is happy to announce a new version of Rust, 1.31.0, and "Rust 2018" as well. Rust is a programming language that empowers everyone to build reliable and efficient software.]]></description><guid isPermaLink="false">18cf1853-dbff-4634-8045-fbcaf36bd4fc</guid><pubDate>Thu,  6 Dec 2018 00:00:00 +0000</pubDate><dc:creator>The Rust Core Team</dc:creator></item><item><title>More on RLS version numbering</title><link>https://www.ncameron.org/blog/more-on-rls-version-numbering/</link><description><![CDATA[In a few days the 2018 edition is going to roll out, and that will include some new framing around Rust's tooling. We've got a core set of developer tools which are stable and ready for widespread use. We're going to have a blog post all about that, but for]]></description><guid isPermaLink="false">2b4ef111-3f3b-416d-b94d-55fe01a94455</guid><pubDate>Tue,  4 Dec 2018 03:00:20 +0000</pubDate><dc:creator>Nick Cameron</dc:creator></item><item><title>How I Wrote a Modern C++ Library in Rust</title><link>https://hsivonen.fi/modern-cpp-in-rust/</link><description><![CDATA[Since version 56, Firefox has had a new character encoding conversion library called encoding_rs. It is written in Rust and replaced the old C++ character encoding conversion library called uconv that dated from early 1999. Initially, all the callers of the character encoding conversion library were C++ code, so the new library, despite being written in Rust, needed to feel usable when used from C++ code. In fact, the library appears to C++ callers as a modern C++ library. Here are the patterns that I used to accomplish that.]]></description><guid isPermaLink="false">823c892a-d7a2-4185-b80f-ba0b47899b25</guid><pubDate>Mon,  3 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Henri Sivonen</dc:creator></item><item><title>Rust Flow, Part Two</title><link>https://myrrlyn.net/blog/misc/rust-flow-part-two</link><description><![CDATA[Rust doesn’t have a language-level concept of generic mutability, which makes “method threading” (which take `self` by some handle, and return it in the same way) hard to write. This article covers how to write in that pattern in a less painful way.]]></description><guid isPermaLink="false">5a0c9b1f-c433-44e6-947e-74076725fc32</guid><pubDate>Thu, 29 Nov 2018 00:00:00 +0000</pubDate><dc:creator>Alexander Payne</dc:creator></item><item><title>A new look for rust-lang.org</title><link>https://blog.rust-lang.org/2018/11/29/a-new-look-for-rust-lang-org.html</link><description><![CDATA[Today, we’d like to announce a beta of the new rust-lang.org. If you go to https://beta.rust-lang.org, you’ll see a preview of the new site.]]></description><guid isPermaLink="false">6afc7e52-af6d-4ecd-a5af-fb9e27a6ccf6</guid><pubDate>Thu, 29 Nov 2018 00:00:00 +0000</pubDate><dc:creator>The Rust Core Team</dc:creator></item><item><title>Rust Quiz</title><link>https://dtolnay.github.io/rust-quiz/</link><description><![CDATA[Test your Rust knowledge with tricky Rust questions.]]></description><guid isPermaLink="false">8c1f73a9-291c-4aa2-9e50-2cf4538f36db</guid><pubDate>Thu, 29 Nov 2018 00:00:00 +0000</pubDate><dc:creator>David Tolnay and Alex Crichton</dc:creator></item><item><title>Rust Language Cheat Sheet</title><link>https://cheats.rs/</link><description><![CDATA[This is the "Rust Language Cheat Sheet". It is for users who: are early Rust professionals (experienced programmers, intermediate Rust users), and prefer visual, example-driven content. Use cases, in order of priority: "identification guide" for unknown or symbolic constructs encountered in code. Provide further reading from easy to advanced (Book to Nomicon). Quick lookup for language related problems. Discover constructs in the language you might not know.]]></description><guid isPermaLink="false">ed652ceb-f7cd-4566-b37c-757f6d089240</guid><pubDate>Wed, 28 Nov 2018 00:00:00 +0000</pubDate><dc:creator>Ralf Biedert</dc:creator></item><item><title>Rust Survey 2018 Results</title><link>https://blog.rust-lang.org/2018/11/27/Rust-survey-2018.html</link><description><![CDATA[Another year means another Rust survey, and this year marks Rust’s third annual survey. This year, the survey launched for the first time in multiple languages. In total 14 languages, in addition to English, were covered. The results from non-English languages totalled 25% of all responses and helped pushed the number of responses to a new record of 5991 responses. Before we begin the analysis, we just want to give a big “thank you!” to all the people who took the time to respond and give us your thoughts. It’s because of your help that Rust will continue to improve year after year.]]></description><guid isPermaLink="false">5ed5c8fa-d94a-44ab-836b-35ee61f1f048</guid><pubDate>Tue, 27 Nov 2018 00:00:00 +0000</pubDate><dc:creator>The Rust Survey Team</dc:creator></item><item><title>Haskell and Rust</title><link>https://www.fpcomplete.com/blog/2018/11/haskell-and-rust</link><description><![CDATA[Learn more about how the Rust programming language shares many of the advantages offered by Haskell such as a strong type system, great tooling, polymorphism, immutability, concurrency, and great software testing methodologies.  Rust is a good choice when you need to squeeze in extra performance.]]></description><guid isPermaLink="false">400c4c0d-78d0-41fe-bd07-c4a720ade708</guid><pubDate>Mon, 26 Nov 2018 17:33:00 +0000</pubDate><dc:creator>Chris Allen</dc:creator></item><item><title>Getting started with nightly async/await support</title><link>https://jsdw.me/posts/rust-asyncawait-preview/</link><description><![CDATA[Following on from my last post, I thought I would look at async/await support in Rust. The async/await support coming to Rust brings with it a much more ergonomic way to work with asynchronous computations. In this post I'll introduce std::future::Future, and run through how to make use of them, and how to interoperate with the current ecosystem which is built around version 0.1 of the futures package.]]></description><guid isPermaLink="false">c1afc363-1078-4dbd-a3e4-e0f05f255d62</guid><pubDate>Mon, 26 Nov 2018 00:00:00 +0000</pubDate><dc:creator>James Wilson</dc:creator></item><item><title>Converting AsyncRead and AsyncWrite to Futures, Sinks and Streams</title><link>https://jsdw.me/posts/rust-futures-tokio/</link><description><![CDATA[Prior to this experience, I had thought that Futures, Sinks and Streams were the smallest building blocks in the world of Tokio, and so I went looking through the Tokio documentation for these things. Actually, all of the fundamental objects to read and write bytes to things implement one or both of AsyncRead and AsyncWrite, but not the Future, Sink or Stream traits. In fact, there are lots of poll_x methods dotted around, so I realised I needed to figure out how to make use of them.]]></description><guid isPermaLink="false">22495ae4-a7be-4899-92ab-ede35669df1b</guid><pubDate>Sun, 25 Nov 2018 00:00:00 +0000</pubDate><dc:creator>James Wilson</dc:creator></item><item><title>Compile Time Feature Flags in Rust</title><link>https://www.worthe-it.co.za/programming/2018/11/18/compile-time-feature-flags-in-rust.html</link><description><![CDATA[Toggling feature flags when you compile for zero runtime cost]]></description><guid isPermaLink="false">24375765-7fa7-4729-8b69-734c409c47fb</guid><pubDate>Sun, 18 Nov 2018 00:00:00 +0000</pubDate><dc:creator>Justin Worthe</dc:creator></item><item><title>Can you Drop it?</title><link>http://optimistictypes.com/can-you-drop-it/</link><description><![CDATA[Resource allocation & the implementation of drop logic in Rust.]]></description><guid isPermaLink="false">18ce3041-0f7a-4bf8-8e5a-ccea2a6c8053</guid><pubDate>Sat, 17 Nov 2018 00:00:00 +0000</pubDate><dc:creator>J Haigh</dc:creator></item><item><title>Programming Servo: A background-hang-monitor</title><link>https://medium.com/programming-servo/programming-servo-a-background-hang-monitor-73e89185ce1</link><description><![CDATA[Let’s say you’re contributing to a system in Rust consisting of a bunch of different components, running in their own threads or processes, for example an engine to make the Web run.

When one of those components seemingly hangs on something, how can you find out what it is hanging on? Maybe a backtrace of what that component is doing at that time would be useful?

That’s easy, for that we have thebacktrace-rs crate, right?

Well, there’s a catch: how do we call Backtrace::new() from a thread that is hanging?]]></description><guid isPermaLink="false">40ed3562-277a-453f-84a6-29ab5314ed0c</guid><pubDate>Fri, 16 Nov 2018 12:30:06 +0000</pubDate><dc:creator>Gregory Terzian</dc:creator></item><item><title>Stacked Borrows Implemented</title><link>https://www.ralfj.de/blog/2018/11/16/stacked-borrows-implementation.html</link><description><![CDATA[Three months ago, I proposed Stacked Borrows as a model for defining what kinds of aliasing are allowed in Rust, and the idea of a validity invariant that has to be maintained by all code at all times. Since then I have been busy implementing both of these, and developed Stacked Borrows further in doing so. This post describes the latest version of Stacked Borrows, and reports my findings from the implementation phase: What worked, what did not, and what remains to be done. There will also be an opportunity for you to help the effort!]]></description><guid isPermaLink="false">4d211c62-3ab3-4db5-a900-94731f798765</guid><pubDate>Fri, 16 Nov 2018 00:00:00 +0000</pubDate><dc:creator>Ralf Jung</dc:creator></item><item><title>Managing Rust Dependencies with Nix, Part I</title><link>https://www.hadean.com/blog/managing-rust-dependencies-with-nix-part-i</link><description><![CDATA[Learn how to integrate Rust Cargo package manager with the Nix package manager.]]></description><guid isPermaLink="false">a4b9f89c-49bd-4910-b1c6-de1c0da5786c</guid><pubDate>Thu, 15 Nov 2018 16:03:00 +0000</pubDate><dc:creator>James Kay</dc:creator></item><item><title>Program Synthesis is Possible in Rust</title><link>http://fitzgeraldnick.com/2018/11/15/program-synthesis-is-possible-in-rust.html</link><description><![CDATA[Program synthesis is the act of automatically constructing a program thatfulfills a given specification. I recently stumbled across Adrian Sampson’s Program Synthesis is Possible blog post. Adrian describes and implements minisynth, a toy program synthesizer that generates constants for holes in a template program when given a specification. What fun! As a way to learn more about program synthesis myself, I ported minisynth to Rust.]]></description><guid isPermaLink="false">e8b911ca-d007-441e-93e3-d8f1f1b89a00</guid><pubDate>Thu, 15 Nov 2018 00:00:00 -0800</pubDate><dc:creator>Nick Fitzgerald</dc:creator></item><item><title>Things Rust doesn’t let you do</title><link>https://medium.com/@GolDDranks/things-rust-doesnt-let-you-do-draft-f596a3c740a5</link><description><![CDATA[A survey of things that Rust doesn’t let you do although arguably safe.]]></description><guid isPermaLink="false">858249f6-6979-48c9-a138-1b7fd2fc9502</guid><pubDate>Mon, 12 Nov 2018 01:34:25 +0000</pubDate><dc:creator>Pyry Kontio</dc:creator></item><item><title>Rust Flow: Function and Method Sequences in Rust</title><link>https://myrrlyn.net/blog/misc/rust-flow</link><description><![CDATA[Rust allows for a very functional style of value “flow” without sacrificing the performance of a more traditionally imperative sequence. Furthermore, the functional flow may offer more clarity about value lifetimes and error handling that the imperative sequence might obscure.]]></description><guid isPermaLink="false">d435191e-e40d-477d-a5ee-908808ee5eee</guid><pubDate>Sun, 11 Nov 2018 14:44:00 +0000</pubDate><dc:creator>Alexander Payne</dc:creator></item><item><title>Truly Zero Cost</title><link>https://vorner.github.io/2018/11/11/truly-zero-cost.html</link><description><![CDATA[I know it is claimed how Rust has zero cost abstractions and such and that all these levels of abstractions will just go away in a release build. But there’s a difference in hearing the theory and seeing it really happen in practice. And I don’t appreciate it because I’d consider it magic, but more because I understand how that is being done and it still looks cool.]]></description><guid isPermaLink="false">c6c90807-5108-434e-9dc0-c5ba8135420d</guid><pubDate>Sun, 11 Nov 2018 00:00:00 +0000</pubDate><dc:creator>Michal &apos;vorner&apos; Vaner</dc:creator></item><item><title>Monadic do notation in Rust: Part I</title><link>https://varkor.github.io/blog/2018/11/10/monadic-do-notation-in-rust-part-i.html</link><description><![CDATA[Following last time, where we saw that, given parameterision over traits (rather than just types), we could implement functors and monads in Rust that supported existing “monad-like” traits like Iterator and Future, I thought it would be interesting to tackle another one of the arguments against monads in Rust.]]></description><guid isPermaLink="false">364d5469-2447-49c8-ab4c-e0b82da96f27</guid><pubDate>Sat, 10 Nov 2018 20:10:56 +0000</pubDate><dc:creator>varkor</dc:creator></item><item><title>After NLL: Moving from borrowed data and the sentinel pattern</title><link>http://smallcultfollowing.com/babysteps/blog/2018/11/10/after-nll-moving-from-borrowed-data-and-the-sentinel-pattern/</link><description><![CDATA[Continuing on with my “After NLL” series, I want to look at another common error that I see and its solution: today’s choice is about moves from borrowed data and the Sentinel Pattern that can be used to enable them.]]></description><guid isPermaLink="false">9dae526e-703d-4726-b68c-92f847e3c85f</guid><pubDate>Sat, 10 Nov 2018 00:00:00 -0500</pubDate><dc:creator>Niko Matsakis</dc:creator></item><item><title>Storing unboxed trait objects in Rust</title><link>https://guiand.xyz/blog-posts/unboxed-trait-objects.html</link><description><![CDATA[This blog post will outline the creation of dynstack, a stack datastructure that stores trait objects unboxed to minimize the number of heap allocations necessary.]]></description><guid isPermaLink="false">c02900f4-a733-4865-980c-3c139ffe0ac8</guid><pubDate>Sat, 10 Nov 2018 00:00:00 +0000</pubDate><dc:creator>Gui Andrade</dc:creator></item><item><title>proc_macro_attribute Revisited</title><link>https://llogiq.github.io/2018/11/10/proc-macro.html</link><description><![CDATA[Recently, the procedural macro interface was somewhat stabilized. OK, there’s still the unstable proc_macro_hygiene feature you have to activate, but at least the registrar and rustc_private are no longer needed.]]></description><guid isPermaLink="false">190265bb-a65b-4acd-99e9-3d6f8a06969c</guid><pubDate>Sat, 10 Nov 2018 00:00:00 +0000</pubDate><dc:creator>Llogiq</dc:creator></item><item><title>How to get the size of Rust types with -Zprint-type-sizes</title><link>https://blog.mozilla.org/nnethercote/2018/11/09/how-to-get-the-size-of-rust-types-with-zprint-type-sizes/</link><description><![CDATA[When optimizing Rust code it’s sometimes useful to know how big a type is, i.e. how many bytes it takes up in memory. std::mem::size_of can tell you, but often you want to know the exact layout as well. For example, an enum might be surprisingly big, in which case you probably will want to know if, for example, there is one variant that is much bigger than the others.]]></description><guid isPermaLink="false">4ace2654-b6a1-4a4a-9917-07f9e12c1ec2</guid><pubDate>Fri,  9 Nov 2018 03:42:40 +0000</pubDate><dc:creator>Nicholas Nethercote</dc:creator></item><item><title>Making progress in await syntax</title><link>https://boats.gitlab.io/blog/post/await-syntax/</link><description><![CDATA[One thing we’ve left as an unresolved question so far in the matter of async/await syntax is the exact final syntax for the await operation. In the current implementation, awaits are written using a compiler plugin:

async fn foo() {
await!(bar());
}

This is not because of any technical limitation: the reason we have done this is that we have not decided on the precise, final syntax for the await operation.]]></description><guid isPermaLink="false">89cf760b-0385-4e81-ad78-45b7eb3b2aa2</guid><pubDate>Thu,  8 Nov 2018 00:00:00 +0000</pubDate><dc:creator>withoutboats</dc:creator></item><item><title>Still in love with Rust</title><link>https://dpc.pw/still-in-love-with-rust</link><description><![CDATA[I think I've discovered Rust somewhere around the year 2012. With time I grew more and more fond of Rust. The language kept evolving in a direction that was my personal sweet spot: a modern C. And at some point I realized I'm in love with Rust. And I still am today, after a couple of years of using it. So let me tell you why is Rust my darling programming language.]]></description><guid isPermaLink="false">c9fdbd06-59fd-444f-b7a9-cd238817a72f</guid><pubDate>Tue,  6 Nov 2018 07:38:10 +0000</pubDate><dc:creator>Dawid Ciężarkiewicz aka `dpc`</dc:creator></item><item><title>A hammer you can only hold by the handle</title><link>https://blog.systems.ethz.ch/blog/2018/a-hammer-you-can-only-hold-by-the-handle.html</link><description><![CDATA[Today we’re looking at the rust borrow checker from a different perspective. As you may know, the borrow checker is designed to safely handle memory allocation and ownership, preventing accessess to invalid memory and ensuring data-race freedom. This is a form of resource management: the borrow checker is tracking who’s in charge of a chunk of memory, and who is currently allowed to read or write to it. In this post, we’ll see how these facilities can be used to enforce higher-level API constraints in your libraries and software. Once you’re familiar with these techniques, we’ll cover how the same principles apply to advanced memory management and handling of other more abstract resources.]]></description><guid isPermaLink="false">495a9412-287b-4baf-af46-007603eff49a</guid><pubDate>Mon,  5 Nov 2018 00:00:00 +0000</pubDate><dc:creator>Andrea Lattuada</dc:creator></item><item><title>A New Way of Thinking</title><link>https://boakye.yiadom.org/rust/new/</link><description><![CDATA[Rust was my language of the year. You know, that thing where programmers set out to learn a new programming language every year. Usually not to be productive at it but to familiarize themselves with current trends in language design, implementation, and paradigms. I had heard a lot of good stuff about Rust and decided late last year to make it my 2018 language. I’m only a few days in but I’ve been smacked by some of what I consider the best ideas in programming I’ve encountered yet.]]></description><guid isPermaLink="false">6e6bbbca-9a60-4c29-a050-1d34f08192ea</guid><pubDate>Sun,  4 Nov 2018 23:59:50 +0000</pubDate><dc:creator>Yaw Boakye</dc:creator></item><item><title>On dealing with owning and borrowing in public interfaces</title><link>https://phaazon.net/blog/on-owning-borrowing-pub-interface</link><description><![CDATA[I’ve been writing on a few examples code lately to add to documentations of some crates of mine. I write a lot of code that creates new objects that need other objects in order to be built. Most of the APIs you can see around tend to love the borrow principle – and I do.]]></description><guid isPermaLink="false">dd822196-d8f4-4764-9727-6096581c035a</guid><pubDate>Sun,  4 Nov 2018 01:30:00 +0000</pubDate><dc:creator>Dimitri Sabadie</dc:creator></item><item><title>Optional Arguments in Rust</title><link>https://hoverbear.org/2018/11/04/optional-arguments/</link><description><![CDATA[When designing an API for your crate one topic which can come is how to handle optional arguments. Let’s explore our Options in Rust!]]></description><guid isPermaLink="false">125dced7-207a-4c36-904b-3d17c903c508</guid><pubDate>Sun,  4 Nov 2018 00:00:00 +0000</pubDate><dc:creator>Andrew Hobden</dc:creator></item><item><title>Higher-Order Functions in Rust</title><link>https://dev.to/deciduously/higher-order-functions-in-rust-287h</link><description><![CDATA[Rust is an imperative language but it provides many tools in the standard library which adhere to a more functional style, like the Iterator trait and its methods like map, for_each, and filter. This is a quick run-down of how to define your own higher-order functions in Rust which can both take closures as parameters and return closures in such a way that you can use the two together.]]></description><guid isPermaLink="false">bfe6aa2d-0dbd-4966-81cc-eebed27ca28d</guid><pubDate>Sat,  3 Nov 2018 00:00:00 +0000</pubDate><dc:creator>Ben Lovy</dc:creator></item><item><title>Anchored and Uniform Paths</title><link>https://boats.gitlab.io/blog/post/anchored-uniform/</link><description><![CDATA[Rust 2018 is almost out the door, but there is one big decision the language team has yet to make. It has to do with the modules and paths system, so of course it is a very easy decision that no one has a strong opinion about. ;-)
In Rust 2018, we’ll be making some big changes to how paths work to try to create a more consistent experience. The “lodestar” (if you will) of these changes is an idea we call “1path:” the idea no matter where you are in your project, whether in a use statement or normal code, a path is interpreted the same way.]]></description><guid isPermaLink="false">7be81fee-ef29-448f-9e03-9be0fc63fbb7</guid><pubDate>Fri,  2 Nov 2018 00:00:00 +0000</pubDate><dc:creator>withoutboats</dc:creator></item><item><title>After NLL: Interprocedural conflicts</title><link>http://smallcultfollowing.com/babysteps/blog/2018/11/01/after-nll-interprocedural-conflicts/</link><description><![CDATA[In my previous post on the status of NLL, I promised to talk about “What is next?” for ownership and borrowing in Rust. I want to lay out the various limitat...]]></description><guid isPermaLink="false">bfd4f2e7-3e44-4383-a144-ae5da7c664fa</guid><pubDate>Thu,  1 Nov 2018 00:00:00 -0400</pubDate><dc:creator>Niko Matsakis</dc:creator></item><item><title>MIR-based borrowck is almost here</title><link>http://smallcultfollowing.com/babysteps/blog/2018/10/31/mir-based-borrowck-is-almost-here/</link><description><![CDATA[Now that the final Rust 2018 Release Candidate has shipped, I thought it would be a good idea to do another update on the state of the MIR-based borrow check (aka NLL). Let’s get the highlights out of the way. Most importantly, Rust 2018 crates will use NLL by default. Once the Rust 2018 release candidate becomes stable, we plan to switch Rust 2015 crates to use NLL as well, but we’re holding off until we have some more experience with people using it in the wild.]]></description><guid isPermaLink="false">3c73e50b-c4cd-43ea-9214-49f711bf3058</guid><pubDate>Wed, 31 Oct 2018 00:00:00 -0400</pubDate><dc:creator>Niko Matsakis</dc:creator></item><item><title>From Rust to beyond: The PHP galaxy</title><link>https://mnt.io/2018/10/29/from-rust-to-beyond-the-php-galaxy/</link><description><![CDATA[This blog post is part of a series explaining how to send Rust beyond earth, into many different galaxies. The galaxy we will explore today is the PHP galaxy. This post will explain what PHP is, how to compile any Rust program to C and then to a PHP native extension.]]></description><guid isPermaLink="false">6bf46601-8824-4e8e-b625-f3b6f9d074da</guid><pubDate>Mon, 29 Oct 2018 10:17:12 +0000</pubDate><dc:creator>Ivan Enderlin</dc:creator></item><item><title>Finding and fixing memory leaks in a Hyper application or &apos;How I Learned to Stop Worrying and Love the Allocator&apos;</title><link>https://blog.1aim.com/2018/10/finding-and-fixing-memory-leaks-in-a-hyper-application-or-how-i-learned-to-stop-worrying-and-love-the-allocator/</link><description><![CDATA[I was doing some initial load testing of the next version our application, so that performance regressions can be tracked, when I noticed something. After only a few seconds of throwing wrk at it, our backend was using 1.3GB of memory, growing at around 50MB/s. Yikes.]]></description><guid isPermaLink="false">1f6655e8-89c4-4e30-91e6-776449b88293</guid><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><dc:creator>Ferdia McKeogh</dc:creator></item><item><title>My release checklist for Rust programs</title><link>https://dev.to/sharkdp/my-release-checklist-for-rust-programs-1m33</link><description><![CDATA[After some practice with three of my Rust projects (fd, hyperfine and bat), my workflow has converged to something that works quite well and avoids many pitfalls that I have walked into in the past. My hope in writing this post is that this process can be useful for others as well. The following is my release checklist for fd, but I have very similar lists for other projects.]]></description><guid isPermaLink="false">e5f786a1-6dd9-427f-8202-03b5a38a7ace</guid><pubDate>Sun, 28 Oct 2018 00:00:00 +0000</pubDate><dc:creator>David Peter</dc:creator></item><item><title>Improving ndarray-csv: Goodbye failure, Hello Extension Traits</title><link>https://paulkernfeld.com/2018/10/27/improving-ndarray-csv.html</link><description><![CDATA[Two weeks ago, I wrote a blog post explaining some design decisions that I made for the ndarray-csv crate. Based on some excellent Reddit comments and GitHub issues from dtolnay, I have amended some of these decisions.]]></description><guid isPermaLink="false">427d9cb0-4562-45c7-b6f0-3defc4df172b</guid><pubDate>Sat, 27 Oct 2018 00:00:00 +0000</pubDate><dc:creator>Paul Kernfeld</dc:creator></item><item><title>Problems Scaling A Large Multi-Crate Rust Project</title><link>https://robert.ocallahan.org/2018/10/problems-scaling-large-multi-crate-rust.html?m=1</link><description><![CDATA[We have 85K lines of Rust code implementing the backend of our Pernosco debugger. To impose some modularity constraints and to reduce build times, from the beginning we organized our code as a large set of crates in a single Cargo workspace in a single Gitlab repository. Currently we have 48 crates. This has mostly worked pretty well but as the number of our crates keeps increasing, we have hit some serious scalability problems.]]></description><guid isPermaLink="false">e64df9c0-3056-4720-837e-670543317c59</guid><pubDate>Thu, 25 Oct 2018 00:00:00 +0000</pubDate><dc:creator>Robert O&apos;Callahan</dc:creator></item><item><title>The Case For Macros</title><link>https://llogiq.github.io/2018/10/25/macros.html</link><description><![CDATA[I know a few Rustaceans who are wary of macros. One privately admitted to hating them with a passion. They are right; macros can make code harder to understand (both for humans and computers, for example many clippy lints have an explicit check to only lint outside of macros), so they should be used with some caution.]]></description><guid isPermaLink="false">451e814b-f0e1-4d88-bdda-9862ab107902</guid><pubDate>Thu, 25 Oct 2018 00:00:00 +0000</pubDate><dc:creator>Llogiq</dc:creator></item><item><title>Announcing Rust 1.30</title><link>https://blog.rust-lang.org/2018/10/25/Rust-1.30.0.html</link><description><![CDATA[The Rust team is happy to announce a new version of Rust, 1.30.0. Rust 1.30 is an exciting release with a number of features: Procedural Macros, Module system improvements, Raw Identifiers, and more.]]></description><guid isPermaLink="false">3db4746e-d5ac-46c7-af24-a25e2db1b7d2</guid><pubDate>Thu, 25 Oct 2018 00:00:00 +0000</pubDate><dc:creator>The Rust Core Team</dc:creator></item><item><title>Rust&apos;s Orphan Rule Is Good, Actually</title><link>https://davidlegare.ghost.io/rusts-orphan-rule/</link><description><![CDATA[The orphan trait rule in Rust is interesting and works impressively well for what it intends to do. While I'm often frustrated by the limitations it imposes, it absolutely succeeds at removing ambiguity in whether or not a trait will be implemented for a type.]]></description><guid isPermaLink="false">c2e61957-0d95-43e3-af09-3173307bf95c</guid><pubDate>Sat, 20 Oct 2018 05:42:04 +0000</pubDate><dc:creator>David LeGare</dc:creator></item><item><title>Towards fearless SIMD</title><link>https://raphlinus.github.io/rust/simd/2018/10/19/fearless-simd.html</link><description><![CDATA[SIMD is a powerful performance technique, and is especially valuable in signal and image processing applications. I will be using it very extensively in my synthesizer, and also it’s increasingly used in xi-editor to optimize string comparisons and similar primitives.]]></description><guid isPermaLink="false">4f32d4ec-419f-4025-b508-3c486ffb059e</guid><pubDate>Fri, 19 Oct 2018 17:03:42 +0000</pubDate><dc:creator>Raph Levien</dc:creator></item><item><title>Is Rust functional?</title><link>https://www.fpcomplete.com/blog/2018/10/is-rust-functional</link><description><![CDATA[Rust is an imperative systems programming language. Why does it have so much attention from functional programming advocates? Is it hiding a functional nature?]]></description><guid isPermaLink="false">b39581e7-2147-4b4a-bfdf-b19141e80d89</guid><pubDate>Thu, 18 Oct 2018 03:02:08 +0000</pubDate><dc:creator>Michael Snoyman</dc:creator></item><item><title>Rust has higher kinded types already... sort of</title><link>https://joshlf.com/post/2018/10/18/rust-higher-kinded-types-already/</link><description><![CDATA[In Rust, a type which takes type parameters (Rc<T>, Vec<T>, HashMap<K, V>, etc) is only a valid type when all type parameters are specified. In other words, Rc, Vec, and HashMap<K> are not types. You can’t have a variable of type Rc. You can’t pass Rc as a parameter to other types. The ability to have such things be actual types is a feature called higher kinded types (HKT).]]></description><guid isPermaLink="false">4c54199d-d367-4525-8202-cba2c82afa3d</guid><pubDate>Thu, 18 Oct 2018 00:00:00 +0000</pubDate><dc:creator>Joshua Liebow-Feeser</dc:creator></item><item><title>Const-fn compile-time SUBLEQ interpreter</title><link>https://www.reddit.com/r/rust/comments/9o6vzo/constfn_compiletime_subleq_interpreter/</link><description><![CDATA[With the minimal subset of const fn becoming stable soon (in the second next Rust version), I wanted to give const fns a try and test what is possible with them. We implemented a compile-time SUBLEQ interpreter which only uses const-fns, which you can find on the playground. Let's walk through the process of building this abomination :)]]></description><guid isPermaLink="false">e7b5dffe-46bb-42a8-a17c-2ede829080ff</guid><pubDate>Mon, 15 Oct 2018 09:10:49 +1100</pubDate><dc:creator>u/oberien</dc:creator></item><item><title>Rust and features discoverability</title><link>https://phaazon.net/blog/rust-features-documentation</link><description><![CDATA[Whatever the project you work on, you should must document your code. There are several situations – let’s call this the First Hypothesis]]></description><guid isPermaLink="false">476c5ab3-1148-4507-b294-8e4c06a188fd</guid><pubDate>Sat, 13 Oct 2018 23:37:00 +0000</pubDate><dc:creator>Dimitri Sabadie</dc:creator></item><item><title>Fixing a Clippy crash</title><link>https://phansch.net/2018/10/10/fixing-a-clippy-crash/</link><description><![CDATA[3 weeks ago I set out to fix a crash in Clippy, this is what I learned along the way. I hope this blog post will be useful for other people diving into Clippy and maybe serve as motivation if things get difficult.]]></description><guid isPermaLink="false">08336620-497d-49b2-9e77-eeb36d26f512</guid><pubDate>Wed, 10 Oct 2018 00:00:00 +0000</pubDate><dc:creator>Philipp Hansch</dc:creator></item><item><title>Rust has a static garbage collector</title><link>https://words.steveklabnik.com/borrow-checking-escape-analysis-and-the-generational-hypothesis</link><description><![CDATA[I’ve often seen people make statements like this one, from the Rust subreddit this morning, "Manual memory management requires more work than garbage collected. Its a trade off of course to be more performant or use lower resources. When and where should Rust be used or not used according to you?". While I don’t completely disagree with this sentiment, it’s also never quite sat right with me. Yes, Rust is a bit harder at the start, but once you get over a hump, I don’t generally find writing Rust to be significantly harder than using a GC’d language. I’ve been trying to figure out why that is.]]></description><guid isPermaLink="false">a3b6b34c-174b-4738-9c06-c9ab251718c4</guid><pubDate>Wed, 10 Oct 2018 00:00:00 +0000</pubDate><dc:creator>Steve Klabnik</dc:creator></item><item><title>Rust and the Three Laws of Informatics</title><link>https://medium.com/@schemouil/rust-and-the-three-laws-of-informatics-4324062b322b</link><description><![CDATA[What are the most important properties of programs, and how much do existing languages help? How is Rust different?]]></description><guid isPermaLink="false">0f56caac-74c9-414c-89d5-fe1cb9a74424</guid><pubDate>Tue,  9 Oct 2018 07:42:09 +0000</pubDate><dc:creator>Simon Chemouil</dc:creator></item><item><title>Notes on Type Layouts and ABIs in Rust</title><link>https://gankro.github.io/blah/rust-layouts-and-abis/</link><description><![CDATA[Over the years I've found myself with a weird amount of knowledge about how types and ABIs in Rust work, and I wanted to write it all down in one place so that... it's written down in one place. Much of this information can or should be found in the Rust Language Reference and the Rustonomicon.]]></description><guid isPermaLink="false">492f5ab9-f95c-480b-8377-dc2f06e836b8</guid><pubDate>Tue,  9 Oct 2018 00:00:00 +0000</pubDate><dc:creator>Alexis Beingessner</dc:creator></item><item><title>Porting C (minimp3) To Rust</title><link>https://wiki.alopex.li/PortingCToRust</link><description><![CDATA[So because it seemed like a good idea at the time, I decided to port the minimp3 library from C to Rust. I want a pure Rust MP3 decoder crate to exist under a permissive license, I wanted to learn a few things about the MP3 file format, and it seemed small enough to do in a single weekend. (In reality it was largely done in about a week.) I’m quite good at Rust, and I’m okay at C (but rusty; hah!), and I know nothing at all about MP3 decoding. So, it was a fun learning experience. It was very interesting seeing how C and Rust’s different feature set changed how the programs were written. minimp3 turned out to be a good choice for this, since it is standalone, pretty well-written C as far as I can tell, does nothing that needs to be unsafe, and small but not trivial. This article is an attempt to organize my thoughts, notes and observations as I went about the project, in the hopes that it will be useful or at least interesting to someone else.]]></description><guid isPermaLink="false">ab2b9642-16a3-4d28-9f8b-5f6938964600</guid><pubDate>Mon,  8 Oct 2018 19:53:10 +0000</pubDate><dc:creator>Simon Heath</dc:creator></item><item><title>Hunting for Bugs in Rust</title><link>https://blog.troutwine.us/2018/10/08/hunting-for-bugs-in-rust/</link><description><![CDATA[Way back in August I announced that I was starting in on "a project to QuickCheck Rust’s standard library data structures", here. And I did! The project is called bughunt-rust and I've been poking at it on weekends since, adjusting my approach based on papers I've been reading, experience gained writing test code and the kind of results I've been getting. This post goes through what I've been up to, where I see the project heading in the near term.]]></description><guid isPermaLink="false">a8939774-cb65-4cca-b7c4-47f8f0249f96</guid><pubDate>Mon,  8 Oct 2018 17:27:54 +0000</pubDate><dc:creator>Brian L. Troutwine</dc:creator></item><item><title>Declarative Rust static analysis</title><link>http://blog.lambdaverse.org/comacro/</link><description><![CDATA[Rust's Macros 2.0 are intuitive: demonstrate a pattern, and the compiler can insert the pattern into your program wherever you want it. Inspired by this syntax, I wondered: Could you “run a macro backwards”—use the same by-example language to describe patterns to search for?]]></description><guid isPermaLink="false">fd7f3d68-5d82-41ba-b841-d11a37e4b98d</guid><pubDate>Sun,  7 Oct 2018 19:23:17 +0000</pubDate><dc:creator>Kaz Wesley</dc:creator></item><item><title>Testing reqwest-based clients</title><link>https://write.as/balrogboogie/testing-reqwest-based-clients</link><description><![CDATA[In this article we will make a small Rust library that uses the reqwest http client library, and see what we can do to adequately test the business logic. We assume you have the Rust toolchain installed, and are at least passingly familiar with programming in Rust.]]></description><guid isPermaLink="false">e34760d5-658d-475a-91eb-c489a649ee86</guid><pubDate>Fri,  5 Oct 2018 20:57:27 +0000</pubDate><dc:creator>balrogboogie</dc:creator></item><item><title>Future directions for cbindgen (rust-ffi)</title><link>http://dreamingofbits.com/post/future-directions-for-cbindgen-rust-ffi/</link><description><![CDATA[There’s been a persistent set of issues we’ve had with cbindgen that have not been solved. They all roughly result from the same problem; cbindgen is a standalone parser of rust code, not a rustc plugin. What this means is that cbindgen doesn’t understand your rust library like the compiler does. We’ve tried to minimize the differences here by making cbindgen smarter, but it’s not obvious that’s the best approach going forward.]]></description><guid isPermaLink="false">351bd1f1-82e3-4b80-882e-9b2aac228c5a</guid><pubDate>Fri,  5 Oct 2018 00:00:00 +0000</pubDate><dc:creator>Ryan Hunt</dc:creator></item><item><title>Default values ..copy that</title><link>https://medium.com/@softprops/default-values-copy-that-ae43831781f3</link><description><![CDATA[When I talk to folks foreign to Rust, I often get asked the question: “Why doesn’t Rust have support for default arguments”. When I first started learning Rust I pondered the same question. Eventually I came to realize that it does, kind of. Rust just takes different approach based on it’s unique design choices, one which I now wish other languages supported.]]></description><guid isPermaLink="false">d7c70ce9-96bc-4518-8e3e-429503883006</guid><pubDate>Thu,  4 Oct 2018 17:06:48 +0000</pubDate><dc:creator>Doug Tangren</dc:creator></item><item><title>Who authors the most popular crates on crates.io?</title><link>https://words.steveklabnik.com/who-authors-the-most-popular-crates-on-crates-io</link><description><![CDATA[I had a question this morning: who authors the most popular crates on crates.io? First, we have to figure out what we mean by “most popular.” My first guess was “top 100 by recent downloads”, so I looked at crates.io. Once I got to 100, I found... | Steve Klabnik | “The most violent element in society is ignorance.” - Emma Goldman]]></description><guid isPermaLink="false">5c9a36df-c260-4d16-87b1-9b7e3107f7b8</guid><pubDate>Thu,  4 Oct 2018 00:00:00 +0000</pubDate><dc:creator>Steve Klabnik</dc:creator></item><item><title>Announcing the Tokio Doc Push (we need you!)</title><link>https://tokio.rs/blog/2018-10-doc-blitz/</link><description><![CDATA[In the past, there has been reoccurring feedback that Tokio is hard to understand. I believe a lack of good documentation plays a significant part. It’s time to fix this problem.

And because Tokio is open source, it is on us (the community) to make this happen! 👏]]></description><guid isPermaLink="false">cbc812fb-b5ff-44cc-ae96-f4a5ae44e7dd</guid><pubDate>Thu,  4 Oct 2018 00:00:00 +0000</pubDate><dc:creator>Carl Lerche</dc:creator></item><item><title>An EFI App a bit rusty</title><link>https://medium.com/@gil0mendes/an-efi-app-a-bit-rusty-82c36b745f49</link><description><![CDATA[After two tweets that I made last week, playing around with UEFI and Rust, some people asked to publish a blog post explaining how to create a UEFI application fully written in Rust and demonstrate all the testing environment.]]></description><guid isPermaLink="false">9128e298-33fe-4f13-a9c7-7ff2361ee2da</guid><pubDate>Sun, 30 Sep 2018 21:56:12 +0000</pubDate><dc:creator>Gil Mendes</dc:creator></item><item><title>Writing Rust NIFs for your Elixir code with the Rustler package</title><link>https://medium.com/@jacob.lerche/writing-rust-nifs-for-your-elixir-code-with-the-rustler-package-d884a7c0dbe3</link><description><![CDATA[There will be times where code will run slow and Erlang/Elixir optimizations will only go so far. BEAM has several ways to interface with foreign code, the fastest way being with a Native Implemented Function (NIF) whose API expects them to be written in C. But speaking frankly, the last time I worked with C involved a lengthy debugging session that boiled down to the lack of type safety, so I’d rather not have to repeat that experience. It’s for this reason that Rust is such a compelling language.]]></description><guid isPermaLink="false">11786513-db52-4fdb-ac03-e4a854b36f2b</guid><pubDate>Fri, 28 Sep 2018 01:54:27 +0000</pubDate><dc:creator>Jacob Lerche</dc:creator></item><item><title>Announcing Rust 1.29.1</title><link>https://blog.rust-lang.org/2018/09/25/Rust-1.29.1.html</link><description><![CDATA[A security vulnerability was found in the standard library where if a large number was passed to str::repeat it could cause a buffer overflow after an integer overflow. If you do not call the str::repeat function you are not affected. This has been addressed by unconditionally panicking in str::repeat on integer overflow.]]></description><guid isPermaLink="false">adea520f-a6b7-43f5-b705-62aefc4c00e6</guid><pubDate>Tue, 25 Sep 2018 00:00:00 +0000</pubDate><dc:creator>The Rust Core Team</dc:creator></item><item><title>rust-on-mobile: Example of creating and running a basic &quot;Hello World&quot; application on iOS</title><link>https://github.com/mtak-/rust-on-mobile/blob/master/examples/ios/example01.md</link><description><![CDATA[This repo is a place where examples can be added of iOS/android projects written entirely/mostly in rust.]]></description><guid isPermaLink="false">0b2520e8-b69d-4edb-91b1-3558494fd0cd</guid><pubDate>Mon, 24 Sep 2018 06:09:32 +0000</pubDate><dc:creator>mtak-</dc:creator></item><item><title>Office Hours #1: Cyclic services</title><link>http://smallcultfollowing.com/babysteps/blog/2018/09/24/office-hours-1-cyclic-services/</link><description><![CDATA[This is a report on the second “office hours”, in which we discussed how to setup a series of services or actors that communicate with one another. This is a classic kind of problem in Rust: how to deal with cyclic data. Usually, the answer is that the cycle is not necessary (as in this case).]]></description><guid isPermaLink="false">0ec2fec4-ed74-4377-b1f5-1e6a5eec6025</guid><pubDate>Mon, 24 Sep 2018 00:00:00 -0400</pubDate><dc:creator>Niko Matsakis</dc:creator></item><item><title>Office Hours #0: Debugging with GDB</title><link>http://smallcultfollowing.com/babysteps/blog/2018/09/21/office-hours-0-debugging-with-gdb/</link><description><![CDATA[This blog post is just going to be a quick summary of the basic workflow of using Rust with gdb on the command line. I’m assuming you are using Linux here, since I think otherwise you would prefer a different debugger. There are probably also nifty graphical tools you can use and maybe even IDE integrations, I’m not sure.]]></description><guid isPermaLink="false">564060f8-e187-4947-80ca-867ed3762d1b</guid><pubDate>Fri, 21 Sep 2018 00:00:00 -0400</pubDate><dc:creator>Niko Matsakis</dc:creator></item><item><title>A Rust FFI adventure in unsafety</title><link>https://travisf.net/capstone-rs-unsafety-adventure</link><description><![CDATA[This blog post covers my adventure in fixing a bug in the Rust bindings for the Capstone C library, a disassembly library that supports several CPU architectures. The capstone-rs crate attempts to provide a Rusty, object-oriented interface. You do not necessarily need previous experience in C code or foreign function (FFI) bindings to understand this blog post. I will cover some of the steps I used to debug this problem. Hopefully, readers can learn from my mistakes.]]></description><guid isPermaLink="false">a2d3880c-1803-4f4d-8345-b46f2d056985</guid><pubDate>Fri, 21 Sep 2018 00:00:00 +0000</pubDate><dc:creator>Travis Finkenauer</dc:creator></item><item><title>Trying to tackle the orphans problem</title><link>https://phaazon.net/blog/orphans-problem</link><description><![CDATA[In this blog entry, I want to explore a specific problem of orphans and how I decided to solve it in a crate of mine. The problem is the following: Given a crate that has a given responsibility, how can someone add an implementation of a given trait without having to use a type wrapper or augment the crate’s scope?]]></description><guid isPermaLink="false">0e8e1d2a-729c-41b0-953f-e14de11b8c59</guid><pubDate>Thu, 20 Sep 2018 12:30:00 +0000</pubDate><dc:creator>Dimitri Sabadie</dc:creator></item><item><title>How we integrate Rust with C#</title><link>https://blog.getseq.net/rust-at-datalust-how-we-integrate-rust-with-csharp/</link><description><![CDATA[Seq is a log server that's built using a few programming languages; we have a storage engine called Flare written in Rust, and a server application written in C#. Our language stack is something I've talked about previously.

Between Rust and C# we have a foreign function interface (FFI) that lets us call out to Rust code from within the .NET runtime. In this post I'd like to explore our approach to FFI between Seq and its storage engine using the API for reading log events as a reference.]]></description><guid isPermaLink="false">63b188d7-d82f-425d-9d07-a17d7fdc43f8</guid><pubDate>Tue, 18 Sep 2018 23:15:06 +0000</pubDate><dc:creator>Ashley Mannix</dc:creator></item><item><title>Falling in love with Rust</title><link>http://dtrace.org/blogs/bmc/2018/09/18/falling-in-love-with-rust/</link><description><![CDATA[We are living in a Golden Age of software, one that will produce artifacts that will endure for generations. Of course, it can be hard to hold such heady thoughts when we seem to be up to our armpits in vendored flotsam, flooded by sloppy abstractions hastily implemented. Among current languages, only Rust seems to share this aspiration for permanence, with a perspective that is decidedly larger than itself.]]></description><guid isPermaLink="false">7f5b5694-9cda-4692-8cbe-42458122faff</guid><pubDate>Tue, 18 Sep 2018 22:31:51 +0000</pubDate><dc:creator>Bryan Cantrill</dc:creator></item><item><title>Lockout, Part 2: And nary a function to be found</title><link>https://exphp.github.io/2018/09/18/lockout-part-2.html</link><description><![CDATA[This is part of a blog series on working towards an intuitive mental model for lifetimes in Rust. When I tried to sit myself down and really, really write down an in-depth example… I realized that there was no two ways about it. Before you can learn to appreciate why lifetimes exist, you must learn what life would be like without them. And in order to do that, well…]]></description><guid isPermaLink="false">b78327e0-5dc5-4187-be6b-9e06204b4631</guid><pubDate>Tue, 18 Sep 2018 19:00:00 +0000</pubDate><dc:creator>Michael Lamparski</dc:creator></item><item><title>Lockout, Part 1: Everything you know about lifetimes is wrong</title><link>https://exphp.github.io/2018/09/17/lockout-part-1.html</link><description><![CDATA[This is part of a blog series on a new way to look at lifetimes in Rust's type system. I hope to cover some advanced aspects of lifetimes that are seldom discussed in the open, and my goal is ultimately to help convey new intuitions about how to use them correctly.]]></description><guid isPermaLink="false">6c1f472d-337d-48c0-96d3-807afe8e58e3</guid><pubDate>Mon, 17 Sep 2018 01:00:00 +0000</pubDate><dc:creator>Michael Lamparski</dc:creator></item><item><title>Ownership Explained with Python</title><link>https://paulkernfeld.com/2018/09/16/ownership-explained-with-python.html</link><description><![CDATA[It’s not immediately obvious that calling min(squares) modifies squares. If squares were a list or even a range, we would be able to call min and max on it with no problem. It would be nice if the language prevented us from trying to use something twice that can only be used once. Almost all modern languages, both statically and dynamically typed, will fail at runtime in these situations.]]></description><guid isPermaLink="false">0f587c1a-da0e-46d2-bee3-3a3cc6fc5352</guid><pubDate>Sun, 16 Sep 2018 00:00:00 +0000</pubDate><dc:creator>Paul Kernfeld</dc:creator></item><item><title>Function composition in Rust using a custom smart pointer</title><link>https://bsoptei.github.io/</link><description><![CDATA[Still drunk with the power of function composition, I started to play around with the technique in Rust, a language I've been experimenting with. Rust is a low-level language with a strict compiler that saves you from doing dangerous things. Furthermore, Rust is a functional language. It has several concepts and features inspired by Haskell (read more) and Scala for example. The design of Rust makes it highly expressive and attractive.]]></description><guid isPermaLink="false">b5f32e7e-843c-40cf-8c6c-126bc74e6c4e</guid><pubDate>Sat, 15 Sep 2018 00:00:00 +0000</pubDate><dc:creator>Balázs Söptei</dc:creator></item><item><title>You can&apos;t &quot;turn off the borrow checker&quot; in Rust</title><link>https://words.steveklabnik.com/you-can-t-turn-off-the-borrow-checker-in-rust</link><description><![CDATA[Every once in a while, someone will talk about unsafe in Rust, and how it “turns off the borrow checker.” I think this framing leads to misconceptions about unsafe and how it interacts with safe code. Here’s some code that causes a borrow checker... | Steve Klabnik | “The most violent element in society is ignorance.” - Emma Goldman]]></description><guid isPermaLink="false">a64aef93-521d-414e-ae6e-853f147b1180</guid><pubDate>Fri, 14 Sep 2018 00:00:00 +0000</pubDate><dc:creator>Steve Klabnik</dc:creator></item><item><title>Rust Associated Type</title><link>https://medium.com/codechain/rust-associated-type-2281dbf98229</link><description><![CDATA[Associated Types in Rust are similar to Generic Types; however, Associated Types limit the types of things a user can do, which consequently facilitates code management. Among the Generic Types of traits, types that depend on the type of trait implementation can be expressed by using the Associated Type syntax. By comparing the Associated and Generic Types, you can get a better understanding of Associated Types.]]></description><guid isPermaLink="false">001f1e0d-3927-4e39-800e-68324a02887a</guid><pubDate>Thu, 13 Sep 2018 06:50:57 +0000</pubDate><dc:creator>Seung Woo Kim</dc:creator></item><item><title>Announcing Rust 1.29</title><link>https://blog.rust-lang.org/2018/09/13/Rust-1.29.html</link><description><![CDATA[The Rust team is happy to announce a new version of Rust, 1.29.0. The two most significant things in this release aren’t even language features: they’re new abilities that Cargo has grown, and they’re both about lints: cargo fix can automatically fix your code that has warnings. cargo clippy is a bunch of lints to catch common mistakes and improve your Rust code.]]></description><guid isPermaLink="false">dc9c068f-0a7f-4a31-aec2-f30b51066b89</guid><pubDate>Thu, 13 Sep 2018 00:00:00 +0000</pubDate><dc:creator>The Rust Core Team</dc:creator></item><item><title>Parallelizing PNG, part 8: Rust macros for constant specialization</title><link>https://brionv.com/log/2018/09/12/parallelizing-png-part-8-rust-macros-for-constant-specialization/</link><description><![CDATA[In my last posts I covered profiling and some tips for optimizing inner loops in Rust code while working on a multithreaded PNG encoder. Rust’s macro system is another powerful tool for simplifying your code, and sometimes awesomeizing your performance…]]></description><guid isPermaLink="false">bec949a2-4c38-4646-ae0b-1d8638c506a6</guid><pubDate>Wed, 12 Sep 2018 15:26:54 +0000</pubDate><dc:creator>Brion Vibber</dc:creator></item><item><title>How we organize a complex Rust codebase</title><link>https://blog.getseq.net/rust-at-datalust-how-we-organize-a-complex-rust-codebase/</link><description><![CDATA[At Datalust we’ve been busy building Flare: a storage engine for our log server, Seq, written in the Rust programming language. This post is a point-in-time look at how we've approached building this fairly complex piece of software in Rust in 2018. I’d like to share a few]]></description><guid isPermaLink="false">6313ebb2-076c-449b-8fb1-372c9b025168</guid><pubDate>Tue, 11 Sep 2018 22:26:05 +0000</pubDate><dc:creator>Ashley Mannix</dc:creator></item><item><title>From Rust to beyond: The C galaxy</title><link>https://mnt.io/2018/09/11/from-rust-to-beyond-the-c-galaxy/</link><description><![CDATA[This blog post is part of a series explaining how to send Rust beyond earth, into many different galaxies. The galaxy we will explore today is the C galaxy. This post will explain what C is (shortly), how to compile any Rust program in C in theory, and how to do that practically with our Rust parser from the Rust side and the C side. We will also see how to test such a binding.]]></description><guid isPermaLink="false">35458bae-bc62-40d7-ac3d-2dcd8ab1f469</guid><pubDate>Tue, 11 Sep 2018 07:49:07 +0000</pubDate><dc:creator>Ivan Enderlin</dc:creator></item><item><title>Unit Type Params</title><link>https://leshow.github.io/post/unit_type_pattern/</link><description><![CDATA[I always enjoy reading blogs about patterns or tricks people have picked up writing Rust. I’ve seen this a few times but not read about it anywhere.

I’ve been doing class assignments from Operating Systems cs140e. I highly recommend this class if you know a bit of Rust and would like to try writing some lower level code. The class involves building bits of an OS for the raspberry pi.]]></description><guid isPermaLink="false">f712f29b-efed-4c75-a4a0-8523fa0b6d52</guid><pubDate>Mon, 10 Sep 2018 12:28:03 -0400</pubDate><dc:creator>Evan Cameron</dc:creator></item></channel></rss>