<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/"><channel><title>Read Rust - Language</title><link>https://readrust.net/</link><description>Language posts on Read Rust</description><item><title>Rust in production at Figma</title><link>https://blog.figma.com/rust-in-production-at-figma-e10a0ec31929</link><description><![CDATA[How Mozilla’s new language dramatically improved our server-side performance.]]></description><guid isPermaLink="false">d9100be3-bb0c-4ea5-9aff-3fa3b7946b12</guid><pubDate>Wed,  2 May 2018 15:14:00 +0000</pubDate><dc:creator>Evan Wallace</dc:creator></item><item><title>rustref - memorable Rust reference links</title><link>https://rustref.com/</link><description><![CDATA[This contains shorthand URLs for navigating to Rust documentation.]]></description><guid isPermaLink="false">fce158e9-2134-4c57-bbc8-67483dc0b0d8</guid><pubDate>Fri, 27 Apr 2018 20:12:36 +0000</pubDate><dc:creator>Mackenzie Hauck</dc:creator></item><item><title>Mutagen – More opportunities</title><link>https://llogiq.github.io/2018/05/01/moreop.html</link><description><![CDATA[Recently I gave a talk at our Rust Meetup about mutagen, and I also showed how our opportunistic mutations work (I however left out that gnarly thing about shifts, but in my defense I was short on time). That got me thinking whether we always do the right thing elsewhere.]]></description><guid isPermaLink="false">4539d16d-f909-4fff-9eda-dc6763fa7a3b</guid><pubDate>Tue,  1 May 2018 00:00:00 +0000</pubDate><dc:creator>Llogiq</dc:creator></item><item><title>Dataframes: Traits, Enums, Generics, and Dynamic Typing</title><link>https://blog.hwc.io/posts/dataframe1/</link><description><![CDATA[I’m attempting to build a dataframe in Rust. I implemented a pattern using traits, generics, and enums in conjunction to deal with columns of different datatypes while allowing runtime reflection for accessing the data stored in a column.]]></description><guid isPermaLink="false">e5b4d06d-c604-42fa-9329-e4bec9f44cfd</guid><pubDate>Wed, 28 Mar 2018 09:57:53 -0400</pubDate><dc:creator>hwc</dc:creator></item><item><title>Adventures in Rust</title><link>https://dev.to/tmr232/adventures-in-rust-56fc</link><description><![CDATA[A tale of my time in Rust-land]]></description><guid isPermaLink="false">803b6bf7-0cde-4a49-9e63-a117e95de2c0</guid><pubDate>Fri, 27 Apr 2018 00:00:00 +0000</pubDate><dc:creator>Tamir Bahar</dc:creator></item><item><title>Installing Rust Offline</title><link>https://hatsunearu.github.io/2018/04/29/rust-offline/</link><description><![CDATA[I wanted to use Rust on an offline Linux system, but it seemed like there isn’t a nice guide to install Rust and some popular packages all in one go (like Anaconda, though what I describe here is much more ghetto), so I decided to summarize the procedure to install the Rust toolchain and some popular libraries all in one go on a system with no internet access.]]></description><guid isPermaLink="false">1d371a92-135a-4456-aca8-5537c9d53c81</guid><pubDate>Sun, 29 Apr 2018 14:00:00 +0000</pubDate><dc:creator>hatsunearu</dc:creator></item><item><title>How to speed up the Rust compiler in 2018</title><link>https://blog.mozilla.org/nnethercote/2018/04/30/how-to-speed-up-the-rust-compiler-in-2018/</link><description><![CDATA[18 months ago I wrote about some work I did to speed up the Rust compiler (rustc). I’ve recently taken this work up again. Also, in the meantime rustc’s build system has been replaced and its benchmark suite has been overhauled. So it’s a good time for an update.]]></description><guid isPermaLink="false">1c59d8b2-c755-4f10-859e-4847be81bc4c</guid><pubDate>Mon, 30 Apr 2018 04:13:45 +0000</pubDate><dc:creator>Nicholas Nethercote</dc:creator></item><item><title>Borrowing in async code</title><link>http://aturon.github.io/2018/04/24/async-borrowing/</link><description><![CDATA[The networking working group is pushing hard on async/await notation for Rust, and @withoutboats in particular wrote a fantastic blog series working through the design space. I wanted to talk a little bit about some of the implications of async/await, which may not have been entirely clear. In particular, async/await is not just about avoiding combinators; it completely changes the game for borrowing.]]></description><guid isPermaLink="false">5e0ef28e-278a-48f1-92d1-256a37f76e47</guid><pubDate>Tue, 24 Apr 2018 00:00:00 +0000</pubDate><dc:creator>Aaron Turon</dc:creator></item><item><title>An alias-based formulation of the borrow checker</title><link>http://smallcultfollowing.com/babysteps/blog/2018/04/27/an-alias-based-formulation-of-the-borrow-checker/</link><description><![CDATA[Ever since the Rust All Hands, I’ve been experimenting with an alternative formulation of the Rust borrow checker. The goal is to find a formulation that overcomes some shortcomings of the current proposal while hopefully also being faster to compute. I have implemented a prototype for this analysis. It passes the full NLL test suite and also handles a few cases – such as #47680 – that the current NLL analysis cannot handle. However, the performance has a long way to go (it is currently slower than existing analysis). That said, I haven’t even begun to optimize yet, and I know I am doing some naive and inefficient things that can definitely be done better; so I am still optimistic we’ll be able to make big strides there.]]></description><guid isPermaLink="false">282a816f-1c0b-4efc-9939-0674020ee1ef</guid><pubDate>Fri, 27 Apr 2018 00:00:00 -0400</pubDate><dc:creator>Niko Matsakis</dc:creator></item><item><title>Reflections on Rust, and the Sand Castle Metaphor</title><link>https://brandur.org/fragments/rust-reflections</link><description><![CDATA[A month ago, I wrote about how I was frustrated with my progress in Rust. These days, I’m still no expert, but I’ve made progress.]]></description><guid isPermaLink="false">67b88f7c-7b39-43ad-863a-0d03dd180faf</guid><pubDate>Fri, 27 Apr 2018 00:00:00 +0000</pubDate><dc:creator>Brandur Leach</dc:creator></item><item><title>Rust Case Study: Chucklefish Taps Rust to Bring Safe Concurrency to Video Games [pdf]</title><link>https://www.rust-lang.org/pdfs/Rust-Chucklefish-Whitepaper.pdf</link><description><![CDATA[Chucklefish, an independent game studio based in London, publishes hit video games like Stardew Valley and Starbound. Now, the company is developing its next game, code-named Witchbrook, using the Rust programming language instead of C++. Why the switch? Two main reasons: to get better performance on multiprocessor hardware and to have fewer crashes during game play.]]></description><guid isPermaLink="false">49014ace-e742-49f8-887a-8fa7d1b627cc</guid><pubDate>Mon, 23 Apr 2018 17:38:56 +0000</pubDate><dc:creator>The Rust Project Developers</dc:creator></item><item><title>Ask an expert: How do you maintain Rust?</title><link>https://increment.com/programming-languages/maintaining-rust/</link><description><![CDATA[From team structure and annual surveys to RFCs and the release process, a staff research engineer on Mozilla’s Rust team shares what it takes.]]></description><guid isPermaLink="false">76fb9740-07d0-45c8-a6b3-17534f293c54</guid><pubDate>Thu, 26 Apr 2018 19:00:00 +0000</pubDate><dc:creator>Jonathan Turner</dc:creator></item><item><title>GLib/GIO async operations and Rust futures + async/await</title><link>https://coaxion.net/blog/2018/04/glib-gio-async-operations-and-rust-futures-async-await/</link><description><![CDATA[Unfortunately I was not able to attend the Rust+GNOME hackfest in Madrid last week, but I could at least spend some of my work time at Centricular on implementing one of the things I wanted to work on during the hackfest. The other one, more closely related to the gnome-class work, will be the topic &#8230; <a href="https://coaxion.net/blog/2018/04/glib-gio-async-operations-and-rust-futures-async-await/" class="more-link">Continue reading <span class="screen-reader-text">GLib/GIO async operations and Rust futures + async/await</span></a>]]></description><guid isPermaLink="false">096f02f7-0ce4-41ef-8896-f8209ca126f5</guid><pubDate>Mon, 23 Apr 2018 08:46:32 +0000</pubDate><dc:creator>With the latest GIT version of the Rust bindings for GLib, GTK, etc it is now possible to make use of the Rust futures infrastructure for GIO async operations and various other functions. This should make writing of GNOME, and in general GLib-using, applications in Rust quite a bit more convenient.</dc:creator></item><item><title>Rust memory safety revolution</title><link>https://anixe.pl/content/news/rust_memory_safety_revolution</link><description><![CDATA[This introduction is written for people, who are programmers, but don’t know Rust or are at the very beginning of learning it. It’s easier to understand for readers who know C, C++ or other language with manually managed memory as well as some with garbage collector. It’s a high-level introduction intended to present core Rust concepts and encourage further learning. It’s not a tutorial, there is no Hello Rust in the end.]]></description><guid isPermaLink="false">4eb3e72f-dec7-445e-9cbe-5464f3df1ceb</guid><pubDate>Tue,  3 Apr 2018 00:00:00 +0000</pubDate><dc:creator>Igor Żuk</dc:creator></item><item><title>Dev-tools in 2018</title><link>https://www.ncameron.org/blog/dev-tools-in-2018/</link><description><![CDATA[This is a bit late (how is it the middle of April already?!), but the dev-tools team has lots of exciting plans for 2018 and I want to talk about them! Our goals for 2018 Here's a summary of our goals for the year. Ship it! We want to ship]]></description><guid isPermaLink="false">017d9ce1-f259-4d95-bffc-b3d44dfc8cde</guid><pubDate>Thu, 19 Apr 2018 19:31:53 +0000</pubDate><dc:creator>Nick Cameron</dc:creator></item><item><title>BYO Standard: An Explorer&apos;s Guide to Complier Plugins</title><link>https://polysync.io/explorers-guide-to-compiler-plugins</link><description><![CDATA[The Rust programming language provides powerful guarantees around memory and thread safety. It also exposes all the knobs required for implementing custom rules, enabling a project to make additional guarantees and enforce opinions on best practice. Embedded standards are very opinionated about software practices—like using floating point values as loop counters or the number of possible exit points of a function—and Rust’s defaults don’t prevent every runtime panic (for example, recursion that goes too deep and overflows the stack).

For PolySync, a runtime panic means the potential for an unsafe situation on the road, and with that in mind, we’ve explored ways to restrict that potential. Of course, we aren’t the only ones thinking about ways to improve the quality of code at compile time by enforcing the right rules for the job. Active projects like rust-clippy are working to do that too by providing lints to supplement the rustc defaults.

In this post we’ll explore how to enforce a rule by prohibiting a practice we’ve formed an opinion about, the indexing of a vector or an array.]]></description><guid isPermaLink="false">4096f192-ba2d-4a25-b1be-f3e4b0b40b51</guid><pubDate>Sat, 21 Apr 2018 00:00:00 +0000</pubDate><dc:creator>Shea Newton</dc:creator></item><item><title>Why Rust&apos;s error handling is awesome</title><link>http://rantsideasstuff.com/posts/2018/04/20-rust-error-handling-awesome/</link><description><![CDATA[This post is about the process of transforming something you would write as a one-off script in Python (or any other scripting language) into a library including error handling.]]></description><guid isPermaLink="false">ba2b10d2-16a7-4036-8e8f-1fe0d113b0ac</guid><pubDate>Fri, 20 Apr 2018 10:00:00 +0200</pubDate><dc:creator>Zoran Zaric</dc:creator></item><item><title>Rust pattern: Rooting an Rc handle</title><link>http://smallcultfollowing.com/babysteps/blog/2018/04/16/rust-pattern-rooting-an-rc-handle/</link><description><![CDATA[I’ve decided to do a little series of posts about Rust compiler errors. Each one will talk about a particular error that I got recently and try to explain (a) why I am getting it and (b) how I fixed it. The purpose of this series of posts is partly to explain Rust, but partly just to gain data for myself. I may also write posts about errors I’m not getting – basically places where I anticipated an error, and used a pattern to avoid it. I hope that after writing enough of these posts, I or others will be able to synthesize some of these facts to make intermediate Rust material, or perhaps to improve the language itself.]]></description><guid isPermaLink="false">89612f07-abeb-400f-8bf1-0826601e17d1</guid><pubDate>Mon, 16 Apr 2018 00:00:00 -0400</pubDate><dc:creator>Niko Matsakis</dc:creator></item><item><title>Implementing multiprocessing.pool.ThreadPool from Python in Rust</title><link>https://blog.petrzemek.net/2018/04/16/implementing-multiprocessing-pool-threadpool-from-python-in-rust/</link><description><![CDATA[In this post, we will implement multiprocessing.pool.ThreadPool from Python in Rust. It represents a thread-oriented version of multiprocessing.Pool, which offers a convenient means of parallelizing the execution of a function across multiple input values by distributing the input data across processes. We will use an existing thread-pool implementation and focus on adjusting its interface to match that of multiprocessing.pool.ThreadPool.]]></description><guid isPermaLink="false">447b930e-7350-4ef3-80d4-2ec23a4c5708</guid><pubDate>Mon, 16 Apr 2018 15:14:15 +0000</pubDate><dc:creator>Petr Zemek</dc:creator></item><item><title>A Useful Feature Few Rust Programmers Know About</title><link>http://rickyhan.com/jekyll/update/2018/04/16/the-best-kept-secret-rust-feature.html</link><description><![CDATA[Surprisingly few know about the built-in pretty-printer. In the book, there is only a short passage that mentions {:#?} in passing. It aligns structs and enums based on nested positions and is automatically derived with Debug.]]></description><guid isPermaLink="false">c3057e94-6b2a-4f19-b109-d6f7b17aefbe</guid><pubDate>Mon, 16 Apr 2018 04:00:00 +0000</pubDate><dc:creator>Ricky Han</dc:creator></item><item><title>From Chaos to Order -- Tools and Techniques for Testing TiDB, A Distributed NewSQL Database</title><link>https://pingcap.com/blog/chaos-practice-in-tidb/</link><description><![CDATA[As an open source distributed NewSQL Hybrid Transactional/Analytical Processing (HTAP) database, TiDB contains the most important asset of our customers--their data. One of the fundamental and foremost requirements of our system is to be fault-tolerant. But how do you ensure fault tolerance in a distributed database? This article covers the top fault injection tools and techniques in Chaos Engineering, as well as how to execute Chaos practices in TiDB.]]></description><guid isPermaLink="false">f4d6ff64-87eb-466f-94a6-fbbaa28fab7d</guid><pubDate>Sat, 14 Apr 2018 00:00:00 +0000</pubDate><dc:creator>Siddon Tang</dc:creator></item><item><title>Instance Identity in C++ and Rust</title><link>https://jrvanwhy.github.io/instance-identity/</link><description><![CDATA[A document describing how (in my opinion) C++’s and Rust’s definitions of object instance differ.]]></description><guid isPermaLink="false">a38c18ee-88ab-46dd-994c-2c4e4d288d4c</guid><pubDate>Tue, 10 Apr 2018 21:04:09 +0000</pubDate><dc:creator>Johnathan Van Why</dc:creator></item><item><title>Rust CLI Survey Results</title><link>https://github.com/rust-lang-nursery/cli-wg/blob/master/survey-results/Readme.md</link><description><![CDATA[Over the month of March 2018, we've been accepting responses to the Rust CLI Survey. This survey was designed to give us some areas of focus, according to the community, for the CLI Working Group (CLI-WG).

One of the goals of Rust 2018 is to make writing command line applications in Rust as frictionless (and fun!) as possible. And we are super excited to say: we've received 1,045 responses! The results, while varied, paint a pretty clear picture for tangible goals.]]></description><guid isPermaLink="false">b92200f5-9ac0-4104-9b0d-f444c55aceb8</guid><pubDate>Thu, 12 Apr 2018 22:26:15 +0000</pubDate><dc:creator>Rust CLI Working Group</dc:creator></item><item><title>Down a Rusty Rabbit Hole</title><link>https://manishearth.github.io/blog/2018/04/12/down-a-rusty-rabbit-hole/</link><description><![CDATA[Last week I fell down a rather interesting rabbit hole in Rust, which was basically me discovering a series of quirks of the Rust compiler/language, each one leading to the next when I asked “why?”]]></description><guid isPermaLink="false">ba7af9ee-e916-4d65-b7b2-c6afa2477ade</guid><pubDate>Thu, 12 Apr 2018 00:00:00 +0000</pubDate><dc:creator>Manish Goregaokar</dc:creator></item><item><title>The Challenge of Using C in Safety-Critical Applications [pdf]</title><link>https://polysync.io/s/The-Challenge-of-Using-C-in-Safety-Critical-Applications.pdf</link><description><![CDATA[Software errors in safety-critical systems can have severe consequences: property-loss, environmental devastation, injury, or death. Despite the severity of these risks, software continues to be written for safety-critical applications in languages that permit common classes of failures, such as undefined behavior, state corruption, and unexpected termination. One such language is C. Language standards that define allowable subsets (e.g. MISRA) and static analysis tools are often used in an attempt to ameliorate these failures by detecting them in the program code before they result in a critical issue at runtime. These traditional methods are ultimately insufficient when it comes to providing ahead-of-time assurances about safe runtime behavior for safety-critical applications. Alternative approaches must be considered.]]></description><guid isPermaLink="false">30fe522c-e827-436a-bd52-40314d80e95b</guid><pubDate>Wed, 11 Apr 2018 08:54:41 +0000</pubDate><dc:creator>Shea Newton, Nathan Aschbache</dc:creator></item><item><title>Why would I use divergent functions?</title><link>https://medium.com/@yangnana11/rust-why-would-i-use-divergent-functions-d9dec59071bc</link><description><![CDATA[Rust has some special syntax for ‘diverging functions’, which are functions that do not return.]]></description><guid isPermaLink="false">2238849b-fcc8-4bd4-9828-66637c22f9af</guid><pubDate>Wed, 11 Apr 2018 08:54:41 +0000</pubDate><dc:creator>Yang Nana</dc:creator></item><item><title>Rust all-hands (dev-tools stuff)</title><link>https://www.ncameron.org/blog/rust-all-hands-dev-tools-stuff/</link><description><![CDATA[Last week (sigh, the week before last now) we held an 'all-hands' event in Berlin. It was a great event - fantastic to meet so many Rust people in real life and really energising to see how much is being planned and implemented. In this post I want to summarise some of the important dev-tools stuff that happened. Our planning and notes from some meetings is in the dev-tools team repo.]]></description><guid isPermaLink="false">d506eda8-cab3-4046-b0b7-3c16fd1bc53d</guid><pubDate>Wed, 11 Apr 2018 02:18:18 +0000</pubDate><dc:creator>Nick Cameron</dc:creator></item><item><title>A Shifty Riddle</title><link>http://llogiq.github.io/2018/04/11/shift.html</link><description><![CDATA[When I finally implemented opportunistic mutations in mutagen, everything seemed fine until my co-maintainer gnieto found a problem. Code failed to compile with the mutagen plugin, something that should never happen as long as the code in question compiles without the plugin. We not only broke the code – we broke the build.]]></description><guid isPermaLink="false">68f328f0-50d5-4152-aa9a-f5ab3c69f397</guid><pubDate>Wed, 11 Apr 2018 00:00:00 +0000</pubDate><dc:creator>Llogiq</dc:creator></item><item><title>Writing My Final Year Project in Rust</title><link>http://mattyhall.github.io/posts/writing-my-final-year-project-in-rust.html</link><description><![CDATA[As part of my final year in university I have had to undertake a project and then write a twenty page paper on it. I ended up being assigned one on a type of machine learning algorithm called boosting. This wasn't my first choice unfortunately, so I decided I'd try to make it interesting for myself by implementing it in Rust. Rust was, and still is, quite immature when it comes to machine learning - as Are We Learning Yet? confirms. I thought it would be an interesting challenge to write some machine learning algorithms in a language that has yet to be used too much for this field.]]></description><guid isPermaLink="false">e497ecb9-788c-476e-bb28-c1746fbff940</guid><pubDate>Fri, 30 Mar 2018 23:00:00 +0000</pubDate><dc:creator>Matthew Hall</dc:creator></item><item><title>Dark Side Of Ergonomics</title><link>https://vorner.github.io/2018/04/08/Dark-side-of-ergonomics.html</link><description><![CDATA[Despite having an experience with wide range of computer languages, including C++ and Haskell (both strong influences to Rusts design), I found Rust hard to learn. Sometimes I grind my teeth about something the compiler doesn’t let me do. Despite that, I didn’t put ergonomics as a wish in any poll. In fact, if I was to take a poll right now, I’d probably be against further ergonomics initiatives.]]></description><guid isPermaLink="false">d1d6e382-3b80-431e-ba08-5cbe1ccebce2</guid><pubDate>Sun,  8 Apr 2018 00:00:00 +0000</pubDate><dc:creator>Michal &apos;vorner&apos; Vaner</dc:creator></item><item><title>Async &amp; Await in Rust: a full proposal</title><link>https://boats.gitlab.io/blog/post/2018-04-06-async-await-final/</link><description><![CDATA[I’m really excited to announce the culmination of much of our work over the last four months: a pair of RFCs for supporting async & await notation in Rust. This will be very impactful for Rust in the network services space. The change is proposed as two RFCs:
 RFC #2394: which adds async & await notation to the language. RFC #2395: which moves a part of the futures library into std to support that syntax.]]></description><guid isPermaLink="false">7fbe9c06-2e4a-4da4-aea0-45b4828f6687</guid><pubDate>Fri,  6 Apr 2018 00:00:00 +0000</pubDate><dc:creator>boats</dc:creator></item><item><title>Sound and ergonomic specialization for Rust</title><link>http://aturon.github.io/2018/04/05/sound-specialization/</link><description><![CDATA[Specialization holds the dubious honor of being among the oldest post-1.0 features remaining in unstable limbo. That’s for good reason, though: until recently, we did not know how to make it sound.]]></description><guid isPermaLink="false">e01d9c09-e66d-4fea-94e3-95db24137dd6</guid><pubDate>Thu,  5 Apr 2018 00:00:00 +0000</pubDate><dc:creator>Aaron Turon</dc:creator></item><item><title>Writing the Perfect &apos;Collect&apos; Trait</title><link>https://mtak-blog.github.io/the_perfect_collect_trait</link><description><![CDATA[I’ve been spending some time thinking about garbage collection in rust. I know, shame on me, it’s a systems language, we hate garbage collection, but… even in a systems programming language, garbage collection is still pretty damn useful.]]></description><guid isPermaLink="false">4812042b-1d2a-4171-9a77-d2f0a0c44b91</guid><pubDate>Thu,  5 Apr 2018 00:00:00 +0000</pubDate><dc:creator>mtak-blog</dc:creator></item><item><title>Custom tasks in Cargo</title><link>http://aturon.github.io/2018/04/05/workflows/</link><description><![CDATA[One of the big requests from the Domain Working Groups for Rust 2018 is a richer feature set for framework- or domain-specific workflows in Cargo. At the simplest level, that might look like project templates – the ability to direct cargo new to start with a custom template defined in crates.io. That’s already enough to get you cooking with frameworks like QuiCLI, which today involve a fixed set of initial scaffolding that you can fill in.]]></description><guid isPermaLink="false">cb113ba3-eaa8-40e1-8ff8-a8b710bf89db</guid><pubDate>Thu,  5 Apr 2018 00:00:00 +0000</pubDate><dc:creator>Aaron Turon</dc:creator></item><item><title>The Rust Team All Hands in Berlin: a Recap</title><link>https://blog.rust-lang.org/2018/04/06/all-hands.html</link><description><![CDATA[Last week we held an “All Hands” event in Berlin, which drew more than 50 people involved in 15 different Rust Teams or Working Groups, with a majority being volunteer contributors. This was the first such event, and its location reflects the current concentration of team members in Europe. The week was a smashing success which we plan to repeat on at least an annual basis.]]></description><guid isPermaLink="false">5eca0d0a-81f6-4804-869f-32ed307adb9f</guid><pubDate>Fri,  6 Apr 2018 00:00:00 +0000</pubDate><dc:creator>Aaron Turon</dc:creator></item><item><title>Cargo, Xargo, and Rustup</title><link>http://aturon.github.io/2018/04/06/rustup-xargo/</link><description><![CDATA[Another topic of discussion at the Berlin Rust All Hands was the long-term story around Cargo, Xargo, and Rustup. The latter two tools are both involved in managing your Rust toolchain, with Xargo allowing you to build custom stds and Rustup managing pre-built artifacts for mainstream targets. Xargo is most commonly used for cross-compiling to less common platforms, but can also be used to customize the standard library on mainstream platforms.]]></description><guid isPermaLink="false">277652ec-bbeb-454c-85da-766438600d47</guid><pubDate>Fri,  6 Apr 2018 00:00:00 +0000</pubDate><dc:creator>Aaron Turon</dc:creator></item><item><title>A Formal Look at Pinning</title><link>https://www.ralfj.de/blog/2018/04/05/a-formal-look-at-pinning.html</link><description><![CDATA[Recently, a new API for “pinned references” has landed as a new unstable feature in the standard library. The purpose of these references is to express that the data at the memory it points to will not, ever, be moved elsewhere. Others have written about why this is important in the context of async IO. The purpose of this post is to take a closer, more formal look at that API: We are going to take a stab at extending the RustBelt model of types with support for pinning.]]></description><guid isPermaLink="false">8379ada9-43de-4764-88b1-aa3d24b114fd</guid><pubDate>Thu,  5 Apr 2018 00:00:00 +0200</pubDate><dc:creator>Ralf Jung</dc:creator></item><item><title>Corner Cutting vs. Productivity</title><link>https://llogiq.github.io/2018/04/03/corners.html</link><description><![CDATA[I recently got into a discussion with another very knowledgeable Rustacean, who (I paraphrase) claimed that Rust is about adding just enough roadblocks to keep you from cutting corners. This is a nice metaphor because it explains a lot: Rust may feel more cumbersome, because it won’t let you cut corners. On the other hand, once it compiles, many classes of errors will already have been taken care of, so your code will usually work as expected (or if you’re new to Rust, unexpectedly well).]]></description><guid isPermaLink="false">0dd3a72c-b43f-449a-92f3-fd25f164d224</guid><pubDate>Tue,  3 Apr 2018 00:00:00 +0000</pubDate><dc:creator>Llogiq</dc:creator></item><item><title>Why We&apos;re Betting on Rust</title><link>https://www.uptime.ventures/blog/2018/04/why-were-betting-on-rust/</link><description><![CDATA[Considering how the state of our art is ever changing, I re-evaluate which tools belong in my box of gizmos each year as well. In the past, I’ve employed nginx as a high-performance cache and proxy, but it has been largely edged out by Envoy, which touts a hybrid non-blocking event model and has become wildly successful after being released in 2016. That very same principle, event-driven I/O, is the same reason I chose Node.js for most of the APIs I’ve developed since 2011. Even if practices change, we retain successful engineering models.

Beginning late last year, as I sketched our founding mission and initial product offerings, I also decided to select a new primary language that could handle most of our primary development tasks. After writing mostly JavaScript and compile-to-JS languages for half a decade, I longed for something more.]]></description><guid isPermaLink="false">680e9488-98e3-4a44-b462-761cf817ca10</guid><pubDate>Mon,  2 Apr 2018 00:00:00 +0000</pubDate><dc:creator>Nicholas Young</dc:creator></item><item><title>Removing Connection State In mob</title><link>http://hermanradtke.com/2018/03/29/removing-connection-state-from-mob.html</link><description><![CDATA[I started writing mob, an multi-echo server using mio, in 2015. I coded mob into a mostly working state and then left it mostly alone, only updating it to work with the latest stable mio. Recently, I started looking at the code again and had the urge to improve it. In a previous post, I talked about managing the state of connections in mob. In this post, I will walk through what I did to remove the need to track connection state. I wanted to remove the state because the implementation required an O(n) operation every tick of the mio event loop. It also added a fair amount of complexity to the code.]]></description><guid isPermaLink="false">d14f3e75-4047-441e-a67b-fc0de042845a</guid><pubDate>Thu, 29 Mar 2018 00:00:00 +0000</pubDate><dc:creator>Herman J. Radtke III</dc:creator></item><item><title>Reliable Systems Series: Model-Based Testing</title><link>https://medium.com/@tylerneely/reliable-systems-series-model-based-property-testing-e89a433b360</link><description><![CDATA[This is the first article in a series on techniques I’ve found useful for making my projects more reliable. These techniques are used in the distributed systems, database, automotive, embedded, and aerospace fields, but if you build services, user interfaces, or generally anything stateful, I think you will find something useful along the way.]]></description><guid isPermaLink="false">dac3ce68-bfe5-4774-8b89-fb4351d53445</guid><pubDate>Wed, 28 Mar 2018 12:52:27 +0000</pubDate><dc:creator>Tyler Neely</dc:creator></item><item><title>Rust: First impressions from a C++ developer</title><link>http://templated-thoughts.blogspot.com.au/2018/03/rust-first-impressions-from-c-developer.html</link><description><![CDATA[I started learning Rust 2 weeks back (yay!!) whenever I got free time. And all the time that I spent  learning it has been worthwhile. This is not going to be a deep technical post, but just my impressions about Rust from where I come from (C++).]]></description><guid isPermaLink="false">5941ab41-5269-4401-9978-f6f389922443</guid><pubDate>Sat, 31 Mar 2018 00:43:00 -0700</pubDate><dc:creator>Arun Muralidharan</dc:creator></item><item><title>You can&apos;t Rust that</title><link>http://lucumr.pocoo.org/2018/3/31/you-cant-rust-that/</link><description><![CDATA[The last year has been fun because I could build a lot for really nice stuff for Sentry in Rust and for the first time the development experience was without bigger roadblocks. While we have been using Rust before it now feels different because the ecosystem is so much more stable and we ran less against language or tooling issues.

However talking to people new to Rust (and even brainstorming APIs with coworkers) it's hard to get rid of the feeling that Rust can be a mind bending adventure and that the best way to have a stress free experience is knowing upfront what you cannot (or should not attempt to) do. Knowing that certain things just cannot be done helps putting your mind back back on the right track.

So here are things not to do in Rust and what to do instead which I think should be better known.]]></description><guid isPermaLink="false">980f0166-c073-42bc-a1df-7dab36421e10</guid><pubDate>Sat, 31 Mar 2018 00:00:00 +0000</pubDate><dc:creator>Armin Ronacher</dc:creator></item><item><title>I&apos;ve just learned Rust and I think I&apos;m in love</title><link>https://rskupnik.github.io/I-learned-rust-and-I-think-Im-in-love</link><description><![CDATA[I’ve decided to learn some Rust recently while working on the Stanford’s experimental course on operating systems. Here’s a list of things that I think are great about it.]]></description><guid isPermaLink="false">79ebe691-fe8b-46ea-806c-996919b730ca</guid><pubDate>Fri, 30 Mar 2018 00:00:00 +0000</pubDate><dc:creator>Radosław Skupnik</dc:creator></item><item><title>Thoughts on Rust, a few thousand lines in</title><link>https://rcoh.me/posts/things-learned-first-thousand-lines-of-rust/</link><description><![CDATA[To say my first foray into Rust was a frustrating struggle would be an understatement. I picked a terrible first project that left me neck deep in Rust’s trickiest areas right off the bat. I was excited to try again. A few years ago I wrote Sumoshell, a CLI App for log analysis. I’d wanted to improve it for a while, so porting it to Rust seemed like a nice way to kill two birds with one stone.]]></description><guid isPermaLink="false">4a0c4c01-2597-4688-ac99-2726bb1a3505</guid><pubDate>Sat, 24 Mar 2018 12:56:00 -0700</pubDate><dc:creator>Russell Cohen</dc:creator></item><item><title>Memory Safety and Lifetimes in Rust</title><link>https://balu.github.io/lifetimes.html</link><description><![CDATA[A program is memory-safe if in any possible execution of the program , all expressions e in the program that refer to an object of type T resolve to an object of type T that has been initialized and not yet deallocated.

There are different ways to guarantee memory safety for all programs. One is to restrict the programming language and disallow pointers. But, this forces most programs to make unnecessary copies of data. Another strategy, called garbage collection, embeds a garbage collector with every program. The garbage collector periodically looks for objects in memory that cannot be accessed from the program and reclaims this memory. The drawbacks of this are the overhead of garbage collection and that deallocation of memory is no longer under the control of the programmer.]]></description><guid isPermaLink="false">dc304d16-2ec3-45b1-833b-a9536c1a7d95</guid><pubDate>Mon, 26 Feb 2018 18:52:22 +0000</pubDate><dc:creator>Balagopal Komarath</dc:creator></item><item><title>Announcing Rust 1.25</title><link>https://blog.rust-lang.org/2018/03/29/Rust-1.25.html</link><description><![CDATA[The Rust team is happy to announce a new version of Rust, 1.25.0. The last few releases have been relatively minor, but Rust 1.25 contains a bunch of stuff!]]></description><guid isPermaLink="false">2cadbd86-48ec-4fab-95bb-5959818d5747</guid><pubDate>Thu, 29 Mar 2018 00:00:00 +0000</pubDate><dc:creator>The Rust Core Team</dc:creator></item><item><title>Cargo got some new tricks, but is it still correct!?</title><link>https://www.reddit.com/r/rust/comments/87ss76/cargo_got_some_new_tricks_but_is_it_still_correct/</link><description><![CDATA[I have been working with @alexcrichton to improve the resolver in Cargo.]]></description><guid isPermaLink="false">04fdf0c8-05ab-46f3-b72d-c7e88eb6dc9b</guid><pubDate>Wed, 28 Mar 2018 15:25:46 +0000</pubDate><dc:creator>Eh2406</dc:creator></item><item><title>Closures 101</title><link>http://mttyng.com/closures-101/</link><description><![CDATA[Closures are an interesting CS concept and one that will frequently come up in interviews. I know I've been asked, and have asked, questions about closures for frontend (Javascript) positions numerous times. And in all honesty they're a difficult concept to define, especially when you're under the scrutiny of an interviewer. In this post I'd like to show how Rust leverages the concept of closures and why they might be used. But first, we need to discuss the concept of scope because it is so important for the full understanding of closures.]]></description><guid isPermaLink="false">d4574214-e1ca-4fe8-858b-b5c9c64046ab</guid><pubDate>Sun, 25 Mar 2018 00:00:00 +0000</pubDate><dc:creator>Matt</dc:creator></item><item><title>Atomics ☢ and memory ordering</title><link>https://vorner.github.io/2018/03/25/Atomics.html</link><description><![CDATA[Taming multiple threads is a mess. Not only many things can happen all at once, but what you wrote in the code isn’t exactly what happens in the CPU. To gain some more performance, the compiler cheats if it thinks nobody is watching. It can reorder instructions or throw some of them out if they look useless. The same happens in the hardware. Furthermore, there isn’t just one RAM, but each memory location can live in different caches at each time and some of them are private to each CPU. It would not make do to publish all the local changes to one’s cache right away.]]></description><guid isPermaLink="false">eef1f270-fb75-475a-b10c-8e3813990362</guid><pubDate>Sun, 25 Mar 2018 00:00:00 +0000</pubDate><dc:creator>Michal &apos;vorner&apos; Vaner</dc:creator></item><item><title>Refactoring some repetitive code to a Rust macro</title><link>https://people.gnome.org/~federico/blog/refactoring-some-repetitive-code-to-a-macro.html</link><description><![CDATA[I have started porting the code in librsvg that parses SVG's CSS properties from C to Rust. Many properties have symbolic values. StrokeLinejoin is the first property that I ported. First I had to write a little bunch of machinery to allow CSS properties to be kept in Rust-space instead of the main C structure that holds them (upcoming blog post about that). But for now, I just want to show how this boiled down to a macro after refactoring.]]></description><guid isPermaLink="false">ad4ba620-3dae-4618-abc7-e245c97369d3</guid><pubDate>Fri, 23 Mar 2018 11:01:30 -0600</pubDate><dc:creator>Federico Mena Quintero</dc:creator></item><item><title>Mutating Rust: Under Cover</title><link>https://llogiq.github.io/2018/03/25/cover.html</link><description><![CDATA[Any mutation testing tool worth its salt uses coverage to restrict the number of tests to run. mutagen is no exception, of course, so once we had a test runner, we wanted to extend it with coverage-based testing.]]></description><guid isPermaLink="false">bf2c60f0-b2be-44c4-ba38-dce0f5b2e041</guid><pubDate>Sun, 25 Mar 2018 00:00:00 +0000</pubDate><dc:creator>Llogiq</dc:creator></item><item><title>A look at Tokio: how this asynchronous event handler works (Russian)</title><link>https://habrahabr.ru/company/bitfury/blog/351824/</link><description><![CDATA[И для чего он используется в фреймворке для приватных блокчейнов Exonum Tokio — это фреймворк для разработки сетевых масштабируемых приложений на Rust,...]]></description><guid isPermaLink="false">9e02b413-b1dd-42a3-a970-2d7b89354c0c</guid><pubDate>Thu, 22 Mar 2018 16:46:00 +0000</pubDate><dc:creator>Алина Тестова</dc:creator></item><item><title>Python Idioms in Rust</title><link>http://benjamincongdon.me/blog/2018/03/23/Python-Idioms-in-Rust/</link><description><![CDATA[I’ve been going through a period of programming language wanderlust over the past couple months. Recently, I’ve been quite interested in Rust. Coming from Python, I’ve found a lot of Rust’s language features to be quite powerful.]]></description><guid isPermaLink="false">6cf2d39d-3ea9-4af4-b9c7-a368be610189</guid><pubDate>Fri, 23 Mar 2018 12:23:22 +0000</pubDate><dc:creator>Benjamin Congdon</dc:creator></item><item><title>From python to Go to Rust: an opinionated journey</title><link>http://tech.allo-media.net/point/of/view/2018/03/22/from-python-to-go-to-rust.html</link><description><![CDATA[When looking for a new backend language, I naturally went from Python to the new cool kid: Go. But after only one week of Go, I realised that Go was only half of a progress. Better suited to my needs than Python, but too far away from the developer experience I was enjoying when doing Elm in the frontend. So I gave Rust a try.]]></description><guid isPermaLink="false">93eaac73-c49e-4d21-8d11-f9ca7e40721c</guid><pubDate>Thu, 22 Mar 2018 09:00:00 +0100</pubDate><dc:creator>Allo-Media</dc:creator></item><item><title>Async/Await VI: 6 weeks of great progress</title><link>https://boats.gitlab.io/blog/post/2018-03-20-async-vi/</link><description><![CDATA[It’s hard to believe its been almost 6 weeks since the last post I made about async/await in Rust. So much has happened that these last several weeks have flown by. We’ve made exceptionally good progress on solving the problem laid out in the first post of this series, and I want to document it all for everyone.
Future and the pinning API Last month I wrote an RFC called “Standard library API for immovable types”.]]></description><guid isPermaLink="false">afdcd322-eab4-4363-be76-cecaa050e867</guid><pubDate>Tue, 20 Mar 2018 00:00:00 +0000</pubDate><dc:creator>boats</dc:creator></item><item><title>Type-directed metaprogramming in Rust</title><link>http://willcrichton.net/notes/type-directed-metaprogramming-in-rust/</link><description><![CDATA[I explore how to use Rust compiler internals to metaprogram Rust using information from the typechecker, e.g. to automatically insert garbage-collection into Rust code, and discuss the benefits and drawbacks of this approach.]]></description><guid isPermaLink="false">8bd1d21c-79d1-4470-9d49-907c26ab0057</guid><pubDate>Sun, 18 Mar 2018 00:00:00 +0000</pubDate><dc:creator>Will Crichton</dc:creator></item><item><title>Putting bors on a PIP</title><link>http://aturon.github.io/2018/03/19/bors/</link><description><![CDATA[We have a problem: the average queue of ready-to-test PRs to the main Rust repo has been steadily growing for a year. And at the same time, the likelihood of merge conflicts is also growing, as we include more submodules and Cargo dependencies that require updates to Cargo.lock.]]></description><guid isPermaLink="false">03cf26ef-4e0f-4124-91ec-064467299583</guid><pubDate>Mon, 19 Mar 2018 00:00:00 +0000</pubDate><dc:creator>Aaron Turon</dc:creator></item><item><title>Rust Lifetimes or: How I Learned to Stop Free-ing and Love the Borrow</title><link>http://mttyng.com/rust-lifetimes-or-how-i-learned-to-stop-free-ing-and-love-the-borrow/</link><description><![CDATA[To me one of the initial shocks of learning Rust was figuring out lifetimes. As a frontend-by-day developer I don't come face-to-face with the 'Double free' and 'Use after free' problems all that often. Actually, it could be easily argued that my backend-brethren don't really either or, for that matter, anyone who's typically dealing with a garbage collected language. I'm looking over at you JS, Java, and Ruby devs. I'd bet most neckbea.. *cough, excuse me, C developers are comfortable with these issues but alas, I am not. As such, lifetimes were kinda difficult to wrap my head around but I think I get them a little better now so let me try to explain.]]></description><guid isPermaLink="false">908c4bee-bf00-4e80-8136-9282eb8de6f6</guid><pubDate>Fri,  9 Mar 2018 00:00:00 +0000</pubDate><dc:creator>Matt</dc:creator></item><item><title>What&apos;s a where clause?</title><link>http://mttyng.com/whats-a-where-clause/</link><description><![CDATA[I've been trying to get a hang of some of the more advanced, and weird, concepts of Rust. With any new language it's a little difficult to know where to begin. How do you throw yourself into the deep-end of something without knowing where the deep-end is?]]></description><guid isPermaLink="false">1fe95cfd-488a-41a5-adca-a44d8f79c679</guid><pubDate>Tue, 20 Feb 2018 00:00:00 +0000</pubDate><dc:creator>Matt</dc:creator></item><item><title>How Rust Implements Tagged Unions</title><link>http://patshaughnessy.net/2018/3/15/how-rust-implements-tagged-unions</link><description><![CDATA[The Rust compiler implements tagged unions, which prevent you from crashing your program by initializing a union with one variant and accessing it with another. Rust uses enum to improve on both C enums and C unions at the same time.]]></description><guid isPermaLink="false">f5ba053a-1bbb-465d-a430-55bd0a1d357a</guid><pubDate>Thu, 15 Mar 2018 03:00:00 +0000</pubDate><dc:creator>Pat Shaughnessy</dc:creator></item><item><title>Deciding if two types are equal</title><link>https://llogiq.github.io/2018/03/15/types.html</link><description><![CDATA[mutagen until recently suffered a bug that rendered both the return input and the interchange arguments mutation inapplicable.

To explain, the former mutation compares each input type with the return type and allows code to return inputs of the same type, if any, while the latter compares input arguments’ types and exchanges two equally-typed inputs.]]></description><guid isPermaLink="false">81e14040-a499-4802-9d1b-c58deeb2be79</guid><pubDate>Thu, 15 Mar 2018 00:00:00 +0000</pubDate><dc:creator>Llogiq</dc:creator></item><item><title>A Comparison Between Rust and Erlang</title><link>https://www.infoq.com/articles/rust-erlang-comparison</link><description><![CDATA[This article will focus on a comparison between Erlang and Rust, detailing their similarities and differences. It may be interesting to both Erlang developers looking into Rust and Rust developers looking into Erlang. A final section will detail more about each of the language capabilities and shortcomings and argue for the possibility of leveraging both languages' strengths in the same project.]]></description><guid isPermaLink="false">eabc9692-30cf-4511-89f4-9068b46aadd8</guid><pubDate>Tue, 13 Mar 2018 00:00:00 +0000</pubDate><dc:creator> Krishna Kumar Thokala</dc:creator></item><item><title>How to use external crates with macros in Rust</title><link>https://medium.com/@kimond/how-to-use-external-crates-with-our-macros-in-rust-6dfe025351e0</link><description><![CDATA[A simple approach to use external crates with our macros in Rust.]]></description><guid isPermaLink="false">24afdde0-ef13-4e26-b39e-b2f9d52ab901</guid><pubDate>Wed, 14 Mar 2018 12:45:30 +0000</pubDate><dc:creator>Kim Desrosiers</dc:creator></item><item><title>mutagen: Pattern Boldness</title><link>http://llogiq.github.io/2018/03/13/patterns.html</link><description><![CDATA[At the moment, mutagen only considers top-level idents in function arguments (e.g.foo(x: X, y: Y)), but function arguments are actually patterns, so we could have foo((x, y): (X, Y)) or bar(Bar { bla, bazz } : Bar). For now, this means we have no type information for either of those examples.]]></description><guid isPermaLink="false">962abf61-6061-4e8d-90b1-1d3ba90d5e1d</guid><pubDate>Tue, 13 Mar 2018 00:00:00 +0000</pubDate><dc:creator>Llogiq</dc:creator></item><item><title>Rust&apos;s 2018 Roadmap</title><link>https://blog.rust-lang.org/2018/03/12/roadmap.html</link><description><![CDATA[Each year the Rust community comes together to set out a roadmap. This year, in addition to the survey, we put out a call for blog posts in December, which resulted in 100 blog posts written over the span of a few weeks. The end result is the recently-merged 2018 roadmap RFC.]]></description><guid isPermaLink="false">4ed8ee1b-6f71-4ac5-b7e5-142509562231</guid><pubDate>Mon, 12 Mar 2018 00:00:00 +0000</pubDate><dc:creator>The Rust Core Team</dc:creator></item><item><title>Should You Learn Rust?</title><link>https://vorner.github.io/2018/03/11/Should-you-learn-rust.html</link><description><![CDATA[Oftentimes, I see a variant of this question posted or asked somewhere. In general, most of the times I think the answer is „Yes“, but maybe for reasons other than you’d think at first.]]></description><guid isPermaLink="false">90d39fbf-c75d-4943-9069-4b65d11b1be9</guid><pubDate>Sun, 11 Mar 2018 00:00:00 +0000</pubDate><dc:creator>Michal &apos;vorner&apos; Vaner</dc:creator></item><item><title>The Union of Parallel Universes</title><link>https://quietmisdreavus.net/code/2018/03/09/the-union-of-parallel-universes/</link><description><![CDATA[Rustdoc has a pretty powerful feature that feels pretty unknown. It doesn’t help that it’s currently restricted by a nightly feature gate, but it’s still cool enough that I want to talk about it.]]></description><guid isPermaLink="false">bd4b8e12-dd4d-4bf8-b553-f5f912ec4e87</guid><pubDate>Fri,  9 Mar 2018 14:30:00 -0600</pubDate><dc:creator>QuietMisdreavus</dc:creator></item><item><title>Exploring Function Overloading</title><link>http://casualhacks.net/blog/2018-03-10/exploring-function-overloading/</link><description><![CDATA[Overloading is the ability to create multiple functions of the same name with different implementations.

Rust has no traditional overloading, you cannot define two methods with the same name. The compiler will complain that you have a duplicate definition regardless of the different argument types.]]></description><guid isPermaLink="false">db7ea4c5-14ae-4a9d-9bf4-a314c20225f7</guid><pubDate>Sat, 10 Mar 2018 00:00:00 +0900</pubDate><dc:creator>Casper</dc:creator></item><item><title>Redefining Failure</title><link>https://epage.github.io/blog/2018/03/redefining-failure/</link><description><![CDATA[I recently got the chance to redo the error handling in two different crates I help maintain. For liquid, I decided to write the error types by hand rather than use something like error-chain. In the case of assert_cli, I decided to finally give failure a try.]]></description><guid isPermaLink="false">0d2f8636-6f6c-42f3-8159-beac5a856009</guid><pubDate>Fri,  9 Mar 2018 03:08:23 +0000</pubDate><dc:creator>Ed Page</dc:creator></item><item><title>Coping with Mutable State in Multiple Threads with Rust</title><link>https://medium.com/@KevinHoffman/coping-with-mutable-state-in-multiple-threads-with-rust-9059c83b6c01</link><description><![CDATA[One of the value propositions most frequently lauded by Rust developers is its freedom from data races. The compiler will literally not allow you to build code that could ever produce a situation where two threads can mutate the same data.]]></description><guid isPermaLink="false">8da41ef1-4c51-4269-bec3-fc377a0f387f</guid><pubDate>Mon,  5 Mar 2018 17:42:58 +0000</pubDate><dc:creator>Kevin Hoffman</dc:creator></item><item><title>Getting A Handle On Things</title><link>https://eno.space/blog/2018/03/Getting-a-handle-on-things</link><description><![CDATA[Today we will take a very simple intrusive linked list written in Rust and make it safe. Kind of, anyway.

Before we start making something safe we need an unsafe thing to make safe. Let’s not pretend that what we are doing here is the least bit useful, let us instead do it just for the fun of it. (What we are doing actually is useful, the explanation of which this margin is too narrow to contain.)]]></description><guid isPermaLink="false">79704e4b-5e9f-4366-84a8-53d5a3431e2f</guid><pubDate>Sat,  3 Mar 2018 00:00:00 +0100</pubDate><dc:creator>@u0060</dc:creator></item><item><title>Compiling Cargo crates natively with Meson</title><link>https://nibblestew.blogspot.com.au/2018/03/compiling-cargo-crates-natively-with.html</link><description><![CDATA[Recently we have been having discussions about how Rust and Meson should work together, especially for mixed language projects. One thing which multiple people have told me (over a time span of several years, actually) is that Rust is Special in that everyone uses crates for everything. Thus there is no point in having any sort of Rust support, the only true way is to blindly call Cargo and have it do everything exactly the way it wants to.

This seems like a reasonable recommendation so I did what every reasonable person would do and accepted this as is.

But then curiosity takes hold of you and you start to wonder. Is that really the case?]]></description><guid isPermaLink="false">0c9a85c5-9017-4922-b07a-050f36b8db84</guid><pubDate>Sun,  4 Mar 2018 05:35:00 -0800</pubDate><dc:creator>Jussi</dc:creator></item><item><title>Encheapening Cernan Internal Metrics</title><link>http://blog.troutwine.us/2017/08/31/encheapening-cernan-internal-metrics/</link><description><![CDATA[In the new 0.7.x series of cernan we stumbled on a neat, cheap approach for making internal metrics available inside a rust codebase, an approach that has legs in other projects, I'd say. This is going to be a quick note describing what cernan is, what we were doing before and how our current approach works.]]></description><guid isPermaLink="false">85925a6b-30c1-4c0f-8caf-b6ccd9e3e19c</guid><pubDate>Sun,  4 Mar 2018 00:00:00 +0000</pubDate><dc:creator>Brian L. Troutwine</dc:creator></item><item><title>Why Rust Has Macros</title><link>https://kasma1990.gitlab.io/2018/03/04/why-rust-has-macros/</link><description><![CDATA[When I recently told a coworker that Rust has macros, his first reaction was that this was bad. Previously I would have had the same reaction, but a part of what learning Rust has taught me is that macros don’t need to be bad. This post exists to help explain why that is, by diving into what problems macros solve, with a brief look at their downsides as well. In other words, this post is not a technical deep dive on how macros work, but focuses on the use cases for macros, and doesn’t require much knowledge about Rust to follow.]]></description><guid isPermaLink="false">c59a9688-62e5-4919-8687-e5ff82c3c5a3</guid><pubDate>Sun,  4 Mar 2018 00:00:00 +0000</pubDate><dc:creator>Kasper Andersen</dc:creator></item><item><title>Serializing awkward data with serde</title><link>http://zork.net/~st/jottings/Serializing_awkward_data_with_serde.html</link><description><![CDATA[Recently I’ve been writing Rust code to work with a third-party data source in TOML format. In other languages I’d just load the data with some standard TOML library and have my program rummage through it, but I’ve been hearing lovely things about the Rust serialization library serde, so I figured I’d try it out.]]></description><guid isPermaLink="false">95bd2ff7-1a99-4092-931a-b17d782282d3</guid><pubDate>Sun,  4 Mar 2018 07:43:09 +0000</pubDate><dc:creator>Screwtape</dc:creator></item><item><title>Making a Brainf*ck to C Compiler in Rust</title><link>https://medium.com/@CanHasCommunism/making-a-brainf-ck-to-c-compiler-in-rust-10f0c01a282d</link><description><![CDATA[Let’s make a tokenizer and code generator to understand the basics behind tiny compilers.]]></description><guid isPermaLink="false">39d1ac9b-501b-46c3-b2e6-68f2d4aabe1d</guid><pubDate>Sat,  3 Mar 2018 18:13:20 +0000</pubDate><dc:creator>Aesl</dc:creator></item><item><title>Opportunistic Mutations</title><link>https://llogiq.github.io/2018/03/03/opportune.html</link><description><![CDATA[As you may know, my current mutagen project deals with mutation testing in Rust. However, as I remarked, Rust’s famed flexibility leaves us little room to do mutations while keeping the type checker happy. For example, other mutation testing frameworks can mutate x + y to x - y.

This is an interesting mutation, because it’s so easy to do in languages like Java, which have full type information available at the bytecode level and so hard to do in Rust, because the std::ops traits make everything so hecking flexible.]]></description><guid isPermaLink="false">2f386775-d0a5-474b-a9de-c14af7453c40</guid><pubDate>Sat,  3 Mar 2018 00:00:00 +0000</pubDate><dc:creator>Llogiq</dc:creator></item><item><title>Stopping a Rust worker</title><link>https://matklad.github.io/2018/03/02/stopping-a-rust-worker.html</link><description><![CDATA[This is a small post about a specific pattern for cancellation in the Rust programming language. The pattern is simple and elegant, but it’s rather difficult to come up with it by yourself.]]></description><guid isPermaLink="false">407d3ba2-d0af-4121-b13a-468b1f0f66cd</guid><pubDate>Fri,  2 Mar 2018 20:11:50 +0000</pubDate><dc:creator>Aleksey Kladov</dc:creator></item><item><title>Docker Multi-Stage Build</title><link>https://blog.jawg.io/docker-multi-stage-build/</link><description><![CDATA[On June 13, 2017 took place the Paris Container Day. They unveiled a new docker feature: multi-stage build. That's the subject of this article.]]></description><guid isPermaLink="false">ab076ead-649f-47ff-8fa2-a7c243ba3dca</guid><pubDate>Thu,  1 Mar 2018 14:00:00 +0000</pubDate><dc:creator>Jones Magloire</dc:creator></item><item><title>Object Shadowing for Serialization of Complex Types</title><link>https://commiebstrd.github.io/rustlang/serde/json/2018/03/01/object-shadowing.html</link><description><![CDATA[Presently, I’m busy writing a capture the flag (CTF) scoreboard, it requires rather complex structures and relationships with other internal objects. Being a security event, I’d also like to maintain explicit control of user data. While serialization in Rust has come a significant way, leveraging auto-generation presents some issues.]]></description><guid isPermaLink="false">257617e2-c1fe-44c7-9cb9-7c07495b96ec</guid><pubDate>Thu,  1 Mar 2018 05:00:00 +0000</pubDate><dc:creator>Spenser Reinhardt</dc:creator></item><item><title>Add examples to your Rust libraries</title><link>http://xion.io/post/code/rust-examples.html</link><description><![CDATA[When you’re writing a library for other programs to depend on, it is paramount to think how the developers are going to use it in their code.

The best way to ensure they have a pleasant experience is to put yourself in their shoes. Forget the internal details of your package, and consider only its outward interface. Then, come up with a realistic use case and just implement it.

In other words, you should create complete, end-to-end, and (somewhat) usable example applications.]]></description><guid isPermaLink="false">ca98f7f9-8927-48e9-8028-15e81f20f8a6</guid><pubDate>Wed, 28 Feb 2018 08:37:00 +0100</pubDate><dc:creator>Karol Kuczmarski</dc:creator></item><item><title>My Rust Dockerfile</title><link>https://blog.sedrik.se/posts/my-docker-setup-for-rust/</link><description><![CDATA[Lets deploy small docker images for Rust]]></description><guid isPermaLink="false">d001ce02-fbfb-4a08-8389-0f713b09bf72</guid><pubDate>Mon, 26 Feb 2018 00:00:00 +0000</pubDate><dc:creator>Fredrik Park</dc:creator></item><item><title>Writing a doubly linked list in Rust is easy</title><link>https://www.reddit.com/r/rust/comments/7zsy72/writing_a_doubly_linked_list_in_rust_is_easy/</link><description><![CDATA[This is a response to the recently submitted blog post titled Why Writing a Linked List in (safe) Rust is So Damned Hard. The post on Reddit was even more dramatic: Why Writing a Linked List in Rust is Basically Impossible.

I see exaggarated claims like these very often - and strongly disagree. Writing a doubly linked list in Rust is not hard - in fact, it's fairly easy! The best strategy, in my opinion, is creating a vector for allocating nodes and using indices instead of pointers. This strategy is often overlooked, getting a 'honorauble mention' at best.]]></description><guid isPermaLink="false">cec6c9fd-a92b-4f5a-8d9b-9b84c263c48f</guid><pubDate>Sat, 24 Feb 2018 00:35:43 +0000</pubDate><dc:creator>/u/stjepang</dc:creator></item><item><title>Reasoning with Types in Rust</title><link>https://aaronweiss.us/posts/2018-02-26-reasoning-with-types-in-rust.html</link><description><![CDATA[Rust is a modern programming language which is marketed primarily on the basis of its very nice type system, and I’d like to tell you about how you can use this type system to reason about your programs in interesting ways. Most of the time when its type system is discussed, the focus is on its guarantee of data race freedom and ability to enable so-called fearless concurrency (and rightfully so—this is a place where Rust truly shines!). Today, I have a different focus in mind, characterized perhaps most succinctly as follows:]]></description><guid isPermaLink="false">5e572868-98d0-4944-b897-14cca13a39a4</guid><pubDate>Mon, 26 Feb 2018 00:00:00 +0000</pubDate><dc:creator>Aaron Weiss</dc:creator></item><item><title>Pushing Rust To 2019</title><link>https://medium.com/@dumindu/pushing-rust-to-2019-9616d82172d3</link><description><![CDATA[Some of these suggestions are not entirely new and have been added as posts/ comments on /r/rust, Github threads. But I believe better listing down all in a one place, because now we are in the correct time even I am bit late.]]></description><guid isPermaLink="false">0493daa3-4abb-46eb-82de-e75daea4bbac</guid><pubDate>Fri, 23 Feb 2018 15:44:16 +0000</pubDate><dc:creator>Dumindu Madunuwan</dc:creator></item><item><title>How doctests get made</title><link>https://quietmisdreavus.net/code/2018/02/23/how-the-doctests-get-made/</link><description><![CDATA[One of rustdoc’s greatest features is the ability to take code samples within your documentation and run them like tests. This ensures that all your samples stay up to date with your library’s API changes. However, there are some steps that need to happen to massage these “doctests” into something that can be compiled and run like a regular program.]]></description><guid isPermaLink="false">516e4eaf-1ce1-49be-a457-a471e9f97329</guid><pubDate>Fri, 23 Feb 2018 16:00:00 -0600</pubDate><dc:creator>QuietMisdreavus</dc:creator></item><item><title>Rust Typestates</title><link>https://yoric.github.io/post/rust-typestate/</link><description><![CDATA[A long time ago, the Rust language was a language with typestate. Officially, typestates were dropped long before Rust 1.0. In this entry, I’ll get you in on the worst kept secret of the Rust community: Rust still has typestates.]]></description><guid isPermaLink="false">450ba7fc-c3ea-4af5-bda4-06842f062de8</guid><pubDate>Thu, 22 Feb 2018 15:15:55 +0100</pubDate><dc:creator>David Teller</dc:creator></item><item><title>Why Writing a Linked List in Rust is Basically Impossible [in safe Rust]</title><link>https://rcoh.me/posts/rust-linked-list-basically-impossible/</link><description><![CDATA[Before I start this post, let me preface it by saying that I’m not an experienced Rustacean by any means. Errata and corrections are appreciated. This post is aimed at helping other fledgling rust-learners avoid my mistake. First, by helping Rust learners pick good introductory projects that will fit naturally in idiomatic rust. Second, by helping Rust learners start building Rust-friendly design intuition. I’d heard about Rust and it’s inscrutable borrow checker for years, but after reading a few blog posts about compiler error improvements, I figured it might be user-friendly enough to give it a try.]]></description><guid isPermaLink="false">45772a5b-1f22-4db9-9eee-f888c0c82660</guid><pubDate>Tue, 20 Feb 2018 08:55:56 -0800</pubDate><dc:creator>Russell Cohen</dc:creator></item><item><title>Rust for Cross-Language System Libraries</title><link>https://libpasta.github.io/blog/bindings/</link><description><![CDATA[We have been building libpasta as a simple, usable solution to password hashing and migration. The goal for libpasta is to be a cross-platform, cross-language system library. libpasta is written in Rust, exports a C-style API, and builds to a static/shared library. Most languages support calling external libraries through foreign function interfaces (FFIs), and the end result can be seen in the documentation where each language has access to the libpasta functionality.]]></description><guid isPermaLink="false">3dc17991-d359-4205-917a-80b37a564b37</guid><pubDate>Wed, 21 Feb 2018 00:00:00 +0000</pubDate><dc:creator>libpasta</dc:creator></item><item><title>Snips Uses Rust to Build an Embedded Voice Assistant</title><link>https://blog.mozilla.org/blog/2018/02/21/snips-uses-rust-build-embedded-voice-assistant/</link><description><![CDATA[The team at Paris-based Snips has created a voice assistant that can be embedded in a single device or used in a home network to control lights, thermostat, music, and more. You can build a home hub on a Raspberry Pi and ask it for a weather report, to play your favorite song, or to brew up a double espresso. Manufacturers like Keecker are adding Snips’ technology to products like multimedia home robots. And Snips works closely with leaders across the value chain, like NVIDIA, EBV, and Analog Devices, in order to voice-enable an increasingly wider range of device types, from speakers to home automation systems to cars.]]></description><guid isPermaLink="false">8e33c7c4-2788-418b-8e47-ca8990ae0d38</guid><pubDate>Wed, 21 Feb 2018 12:34:56 -0800</pubDate><dc:creator>Judy DeMocker</dc:creator></item><item><title>Using macro to generate generic docs?</title><link>https://blog.guillaume-gomez.fr/articles/2018-02-19+Using+macro+to+generate+generic+docs%3F</link><description><![CDATA[We were recently able to finally make the docs for integer primitive types much more accurate (thanks to @antoyo!). Now, the code examples match the type for which they're written. No more i32 examples for i128 (I think you got the idea at this point)! Now, I think a few people might be interested by the method we used to achieve such a result so let's talk about it.]]></description><guid isPermaLink="false">c078b1d0-a902-42c5-84d0-5d262146e64c</guid><pubDate>Mon, 19 Feb 2018 00:00:00 +0000</pubDate><dc:creator>Guillaume Gomez</dc:creator></item><item><title>Ferrous Oxide For Jaguars And Incremented Crocodiles</title><link>https://eno.space/blog/2018/02/Ferrous-oxide-for-jaguars-and-incremented-crocodiles</link><description><![CDATA[Caveat lector: the primary purpose of the article is to introduce a reader proficient in one of the popular object-oriented languages how not to program in Rust. While each feature of the language will be briefly introduced where it is used, no great efforts will be made to explain the feature in detail. Links to the Rust book should provide that.]]></description><guid isPermaLink="false">5ecd2c77-20dd-4fd5-84a7-6c8e2364ebde</guid><pubDate>Thu, 15 Feb 2018 00:00:00 +0100</pubDate><dc:creator>@u0060</dc:creator></item><item><title>Rust things I miss in C</title><link>https://people.gnome.org/~federico/blog/rust-things-i-miss-in-c.html</link><description><![CDATA[Librsvg feels like it is reaching a tipping point, where suddenly it seems like it would be easier to just port some major parts from C to Rust than to just add accessors for them. Also, more and more of the meat of the library is in Rust now. I'm switching back and forth a lot between C and Rust these days, and C feels very, very primitive these days.]]></description><guid isPermaLink="false">6d0e61c5-087e-48dc-abd8-ded4f3e43a8a</guid><pubDate>Sun, 18 Feb 2018 21:26:04 -0600</pubDate><dc:creator>Federico Mena Quintero</dc:creator></item><item><title>Sorting in Rust: Selection, Insertion, and Counting Sort</title><link>https://medium.com/@spyr1014/sorting-in-rust-selection-insertion-and-counting-sort-2c4d3575e364</link><description><![CDATA[Sorting is an invaluable skill and often covered early in a computer science curriculum. Have you ever tried to look up a friends phone number in an unsorted list!? You’d have to look at every single entry. Sorting creates all sorts of ways to access data quicker.]]></description><guid isPermaLink="false">f77cc701-eca9-4b85-a450-dd10c1766966</guid><pubDate>Sun, 18 Feb 2018 23:57:10 +0000</pubDate><dc:creator>Andrew Jakubowicz</dc:creator></item><item><title>Borrow cycles in Rust: arenas v.s. drop-checking</title><link>https://exyr.org/2018/rust-arenas-vs-dropck/</link><description><![CDATA[Ownership and borrowing are the fundamentals of data structures in Rust. However, both taking owneship of a value (moving it) or taking a reference to it can only happen after the value was created. This ordering seems to prevent having any cycle in a data structure, even though that’s sometimes useful or necessary. For example in a web page’s content tree, from any DOM node, one can easily access (if any) its first and last child, previous and next sibling, (so children of a node form a doubly-linked list) and parent. Some other applications might need to manipulate arbitrary graphs in their full generality.]]></description><guid isPermaLink="false">ff94e8a6-c203-4cbe-af46-8f99e2896dd8</guid><pubDate>Sat, 17 Feb 2018 00:00:00 +0000</pubDate><dc:creator>Simon Sapin</dc:creator></item><item><title>&quot;The Expressive C++17 Coding Challenge (in Rust)&quot; Revisited</title><link>http://words.steveklabnik.com/the-expressive-c-17-coding-challenge-in-rust-revisited</link><description><![CDATA[In October of last year, I wrote a post, “The Expressive C++17 Coding Challenge (in Rust)”. For various reasons, it got brought up again in the D world, and seb has written a new post. It’s good, you should check it out! However, it links to my gist, not my blog post. As I said back then: I held myself to the same constraints as the original contest; no external packages is a bit painful in Rust, but it’s not too bad. Mostly it would let me eliminate boilerplate while also improving correctness, and making the code a bit shorter. So, that got me thinking: What would this look like if I could use external packages? I took about an hour, and knocked it out. I have two versions to show you today, one where I pay no attention to allocations, and one where it’s zero-allocation.]]></description><guid isPermaLink="false">938457b4-8905-4954-9007-88c80a2c24d6</guid><pubDate>Wed, 14 Feb 2018 10:12:15 -0800</pubDate><dc:creator>Steve Klabnik</dc:creator></item><item><title>Reflecting on ppbert</title><link>https://vfoley.xyz/ppbert/</link><description><![CDATA[I had an itch: I was pretty-printing the BERT-encoded terms that we use in a production system at work and it was very slow. The Erlang shell took more than two minutes to dump the largest file. (It took about 0.1 second to read and parse the file; the rest was spent in io:format.) I decided to scratch that itch: I wrote ppbert, a command-line utility that reads BERT-encoded values and pretty-prints them. I’ve worked sporadically on ppbert for almost a year now, I use it daily at work, I’m happy with it, and I want to write about some of the things I learned during that journey.]]></description><guid isPermaLink="false">28ce1b60-8837-4443-87fb-669bf176db9b</guid><pubDate>Fri,  9 Feb 2018 00:00:00 +0000</pubDate><dc:creator>Vincent Foley</dc:creator></item><item><title>Maximally minimal specialization: always applicable impls</title><link>http://smallcultfollowing.com/babysteps/blog/2018/02/09/maximally-minimal-specialization-always-applicable-impls/</link><description><![CDATA[So aturon wrote this beautiful post about what a good week it has been. In there, they wrote: "Breakthrough #2: @nikomatsakis had a eureka moment and figured out a path to make specialization sound, while still supporting its most important use cases (blog post forthcoming!). Again, this suddenly puts specialization on the map for Rust Epoch 2018". Sheesh I wish they hadn’t written that! Now the pressure is on. Well, here goes nothing =).]]></description><guid isPermaLink="false">c7a9c9d2-8858-4f47-afa3-19ec1f2f6b86</guid><pubDate>Fri,  9 Feb 2018 00:00:00 -0500</pubDate><dc:creator>Niko Matsakis</dc:creator></item><item><title>Closing out an incredible week in Rust</title><link>http://aturon.github.io/2018/02/09/amazing-week/</link><description><![CDATA[This week has been so amazing that I just had to write about it. Here’s a quick list of some of what went down in one week:]]></description><guid isPermaLink="false">325af8a8-af88-4a07-9c8f-16d2865f01f3</guid><pubDate>Fri,  9 Feb 2018 00:00:00 +0000</pubDate><dc:creator>Aaron Turon</dc:creator></item><item><title>Async/Await V: Getting back to the futures</title><link>https://boats.gitlab.io/blog/post/2018-02-08-async-v-getting-back-to-the-futures/</link><description><![CDATA[Two posts ago I proposed a particular interface for shipping self-referential generators this year. Immediately after that, eddyb showed me a better interface, which I described in the next post. Now, to tie everything together, its time to talk about how we can integrate this into the futures ecosystem. Starting point: this Generator API To begin, I want to document the generator API I’ll be using in this post, which is roughly what followed from my previous post:]]></description><guid isPermaLink="false">4924a3b4-b71f-4a15-ae2d-0a77bcb30e98</guid><pubDate>Thu,  8 Feb 2018 00:00:00 +0000</pubDate><dc:creator>boats</dc:creator></item><item><title>Async/Await IV: An Even Better Proposal</title><link>https://boats.gitlab.io/blog/post/2018-02-07-async-iv-an-even-better-proposal/</link><description><![CDATA[I did not plan to write this blog post. I thought that the fourth post in my series would explain how we could go from the generator API in my previous post to a futures API in which you don’t have to heap allocate every async call. But eddyb surprised me, and now I have to revisit the API in the previous post, because we can implement everything we need from immovability with a safe interface afterall.]]></description><guid isPermaLink="false">ac0c5546-f21b-4b47-b4a4-950464472aad</guid><pubDate>Wed,  7 Feb 2018 00:00:00 +0000</pubDate><dc:creator>boats</dc:creator></item><item><title>A vision for portability in Rust</title><link>http://aturon.github.io/2018/02/06/portability-vision/</link><description><![CDATA[TL;DR: This post proposes to deprecate the std facade, instead having a unified std that uses target- and capability-based cfgs to control API availability. Leave comments on internals!]]></description><guid isPermaLink="false">6e3c698d-7f42-43d4-9c08-2ee084945e5c</guid><pubDate>Tue,  6 Feb 2018 00:00:00 +0000</pubDate><dc:creator>Aaron Turon</dc:creator></item><item><title>Rust Lifetimes for the Uninitialised</title><link>http://asquera.de/blog/2018-01-29/rust-lifetimes-for-the-uninitialised/</link><description><![CDATA[Lifetimes are a interesting subject: a lot of people seem to gain a day-to-day familiarity with them, without fully understanding what they are. Maybe, they are truly Rust's Monads. Let's talk about what they are, where you encounter them and then how to get competent with them.]]></description><guid isPermaLink="false">c0b3d7ad-673f-4eb9-aa54-45447d1eafb0</guid><pubDate>Mon, 29 Jan 2018 15:30:00 +0100</pubDate><dc:creator>Florian Gilcher</dc:creator></item><item><title>Introduction to Procedural Macros</title><link>https://tinkering.xyz/posts/introduction-to-proc-macros/</link><description><![CDATA[As a newcomer to Rust, I heard the phrase “procedural macro” thrown around a lot without really understanding what it meant. I figured that I would learn about them if I ever needed them. Well, I’m working on the guts of relm, and a large chunk of it is procedural macros. I’ve learned enough about procedural macros to be dangerous, so I thought I would pass on some knowledge.]]></description><guid isPermaLink="false">f4e99fe5-2dab-418d-9256-813a75036164</guid><pubDate>Sat,  3 Feb 2018 19:36:37 -0500</pubDate><dc:creator>Zach Mitchell</dc:creator></item><item><title>Async/Await III: Moving Forward with Something Shippable</title><link>https://boats.gitlab.io/blog/post/2018-01-30-async-iii-moving-forward/</link><description><![CDATA[In the first post, we looked at the relationship between generators and a more general notion of self-references. In the second post, we narrowed down exactly what problem we need to solve to make generators work, and talked about some solutions that we’ve considered but don’t feel like we could ship in the near future.
In the original post, I promised that I would have a near term solution by the end of this series.]]></description><guid isPermaLink="false">25060712-7d38-4492-991d-a52a9111891c</guid><pubDate>Sun,  4 Feb 2018 00:00:00 +0000</pubDate><dc:creator>boats</dc:creator></item></channel></rss>