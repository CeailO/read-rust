<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/"><channel><title>Read Rust - Web and Network Services</title><link>https://readrust.net/</link><description>Web and Network Services posts on Read Rust</description><item><title>Wasmtime — a small and efficient runtime for WebAssembly &amp; WASI</title><link>https://wasmtime.dev/</link><description><![CDATA[Wasmtime is a standalone wasm-only optimizing runtime for WebAssembly and WASI, using Cranelift. It runs WebAssembly code outside of the Web, and can be used both as a command-line utility or as a library embedded in a larger application.]]></description><guid isPermaLink="false">48b43e12-00d0-4eb5-aff6-b57873cc6533</guid><pubDate>Sat,  9 Nov 2019 08:56:22 +0000</pubDate><dc:creator>Wasmtime Developers</dc:creator></item><item><title>Osgood is a secure, fast, and simple platform for running JavaScript HTTP servers</title><link>https://github.com/IntrinsicLabs/osgood</link><description><![CDATA[Osgood is a secure, fast, and simple platform for running JavaScript HTTP servers. It is written using Rust and V8. Services written today share a common flaw: Being over-privileged. Osgood is an attempt to build a platform from the ground up, one which applies the Principle of Least Privilege at its very core. Osgood requires that policies be written ahead of time describing the I/O requirements of an application. If such an operation hasn't been whitelisted, it will fail. Developers familiar with JavaScript development in the web browser should feel right at home with the APIs provided in Osgood.]]></description><guid isPermaLink="false">6cb73c7e-777a-4c23-b279-4e94c8cf70cf</guid><pubDate>Sat,  9 Nov 2019 03:48:13 +0000</pubDate><dc:creator>Thomas Hunter II</dc:creator></item><item><title>Battle of the Serverless — Part 2: AWS Lambda Cold Start Times</title><link>https://medium.com/@shouldroforion/battle-of-the-serverless-part-2-aws-lambda-cold-start-times-1d770ef3a7dc</link><description><![CDATA[This experiment continues the work done in our pretend suite of microservices exposed via API Gateway to form an API with a code name of Slipspace in a mock company called STG. Slipspace drives are how the ships in the Halo universe travel so quickly to different sectors of the galaxy through something called Slipstream Space, so thought it was cool for a name requiring awesome warp API speeds.]]></description><guid isPermaLink="false">48cf21ce-5244-4667-82c3-9c54bb469bbf</guid><pubDate>Thu,  7 Nov 2019 03:15:40 +0000</pubDate><dc:creator>Mark Fowler</dc:creator></item><item><title>Announcing cfnts: Cloudflare&apos;s implementation of Network Time Security (NTS) in Rust</title><link>https://blog.cloudflare.com/announcing-cfnts/</link><description><![CDATA[Several months ago we announced that we were providing a new public time service. Part of what we were providing was the first major deployment of the new Network Time Security (NTS) protocol, with a newly written implementation of NTS in Rust. In the process, we received helpful advice from the NTP community, especially from the NTPSec and Chrony projects. We’ve also participated in several interoperability events. Now we are returning something to the community: Our implementation, cfnts, is now open source and we welcome your pull requests and issues.]]></description><guid isPermaLink="false">abea3139-f0fb-4680-abbf-1e7f4b368534</guid><pubDate>Thu, 31 Oct 2019 13:00:00 +0000</pubDate><dc:creator>Watson Ladd and Pop Chunhapanya</dc:creator></item><item><title>Dreadbot: A Discord Bot for Magic The Gathering in Rust</title><link>https://bcarrigan.com/2019/10/28/dreadbot/</link><description><![CDATA[There is a wonderful Magic: The Gathering scene here in Durham, NC. Unfortunately, Magic often deserves the trope that it gets of being an expensive hobby. In order to enjoy the game on a budget, myself and a group of locals created a new format: Paper Dreadful. The format is simple: create a 60 card deck with a maximum of 4 of any card (other than basic lands) and the total cost must be $20 or less on that day. The same rule applies with the sideboard, except it must by $5 or less.

The problem here is that Magic cards change in price all the time. What happens if I build a deck and then a card skyrockets in price?]]></description><guid isPermaLink="false">1ca114e3-a283-4b4c-ae16-4d5966e0ffcf</guid><pubDate>Mon, 28 Oct 2019 12:00:00 +0000</pubDate><dc:creator>Brian Carrigan</dc:creator></item><item><title>How to use gRPC with Rust Tonic and PostgreSQL database</title><link>https://www.steadylearner.com/blog/read/How-to-use-gRPC-with-Rust-Tonic-and-Postgresql-database</link><description><![CDATA[In this post, we will learn how to use Rust Tonic gRPC crate. We will learn how to implement CRUD with Postgresql database. The purpose of it is to help you to have the working Rust Tonic code and start your own porject immediately with it.]]></description><guid isPermaLink="false">2948d871-de13-48a8-bc6b-06cdfcf0104e</guid><pubDate>Mon, 28 Oct 2019 00:00:00 +0000</pubDate><dc:creator>Steadylearner</dc:creator></item><item><title>Getting Started with Rust and Apache Kafka</title><link>https://www.confluent.io/blog/getting-started-with-rust-and-kafka</link><description><![CDATA[I’ve written an event sourcing bank simulation in Clojure (a lisp build for Java virtual machines or JVMs) called open-bank-mark, which you are welcome to read about in my previous blog post explaining the story behind this open source example. As a next step, specifically for this article I’ve added SSL and combined some topics together, using the subject name strategy option of Confluent Schema Registry, making it more production like, adding security, and making it possible to put multiple kinds of commands on one topic. We will examine how the application works, and what was needed to change one of the components from Clojure to Rust. We’ll also take a look at some performance tests to see if Rust might be a viable alternative for Java applications using Apache Kafka®.]]></description><guid isPermaLink="false">53422d00-b0d2-4f97-a020-f34636fc9d89</guid><pubDate>Thu, 24 Oct 2019 00:00:00 +0000</pubDate><dc:creator>Gerard Klijs</dc:creator></item><item><title>Programming Servo: shipping message-ports(via a detour into Spectre)</title><link>https://medium.com/programming-servo/programming-servo-shipping-message-ports-via-a-detour-into-spectre-c96683ac0b8</link><description><![CDATA[The thing about contributing to Servo is that you keep learning new things about the Web platform. Personally, I had never used messaging on the web when developing web applications, and I find it a fascinating idea.

Web-messaging enables developers to provide cross-site API’s without having to go through a server, all the while leveraging the client-side security model of the Web. And since it happens on the client, it could be more transparent to the end-user, and probably easier to block if necessary.

Implementing message-ports also raises interesting architectural questions. In an earlier Web(like, in 2017), an API like message-ports could have been implemented with some sort of cross-thread communication. In 2019 however, it’s going to have to go across process. Why? Something known as “Spectre”.]]></description><guid isPermaLink="false">25ecd879-1428-4fd5-8200-e908de68db3b</guid><pubDate>Sun, 20 Oct 2019 04:38:50 +0000</pubDate><dc:creator>Gregory Terzian</dc:creator></item><item><title>SpO₂ the little dynamic monitoring tool</title><link>https://blog.meilisearch.com/spo2-the-little-dynamic-monitoring-tool/</link><description><![CDATA[At Meili, we needed a tool that allows us to monitor our pods, we already have vigil which health checks our front page and backend, but the number of these services is limited. We do not pop new front or backend servers dynamically (for now). When we create new search engines for the user we instanciate a kubernetes pod, we need to monitor the health of this service. Adding each of those URLs by hand in the vigil config file is not a solution.

So we decided that we needed a simple tool, a tool that can accept HTTP requests to register/unregister URLs to health check. We use the new async/await Rust syntax along with tide for the http server, no big deal here.]]></description><guid isPermaLink="false">1f771485-fadd-4dfe-8730-1a4b81a856d0</guid><pubDate>Fri, 18 Oct 2019 15:53:16 +0000</pubDate><dc:creator>Clément Renault</dc:creator></item><item><title>A Tiny, Static, Full-Text Search Engine using Rust and WebAssembly</title><link>https://endler.dev/2019/tinysearch/</link><description><![CDATA[I wrote a basic search module that you can add to your static website. It's very lightweight (around 50kB-100kB gzipped), should work with Hugo, Zola, and Jekyll. Only searching entire words is supported. Try the search box on the left side for a demo. The code is on Github.]]></description><guid isPermaLink="false">bb944334-6ce6-4bbd-9014-d5b4909db91b</guid><pubDate>Thu, 17 Oct 2019 00:00:00 +0000</pubDate><dc:creator>Matthias Endler</dc:creator></item><item><title>Writing an HTTP server in Rust (Part I)</title><link>https://curiosityoverflow.xyz/posts/linda/</link><description><![CDATA[So… You want to write an HTTP server. Well, you’re in luck, The Internet Engineering Task Force (IETF) is here to help us. Whenever they’re not fighting with fiber cables (at least that’s what I imagine they do), they are writing useful specifications for us! Well, first you prepare yourself a big pot of coffee. Once you’re appropriately caffeinated, you read the 57897 word RFC 2616 specification, written by none other, than the IETF. Exciting.]]></description><guid isPermaLink="false">9eea41c1-f070-498f-9db0-0473ae429df7</guid><pubDate>Thu,  3 Oct 2019 15:54:39 +0200</pubDate><dc:creator>NullSense</dc:creator></item><item><title>Tonic: gRPC has come to async/await!</title><link>https://luciofran.co/tonic-grpc-has-come-to-async-await/</link><description><![CDATA[I am pleased to finally announce a crate that I have been working very hard on for the past few months. tonic has finally hit the initial 0.1.0-alpha.1 release! Stable releases will follow in the coming months. Tonic is a gRPC-over-HTTP/2 implementation focused on high performance, interoperability, and flexibility. This library was created to have first class support of async/await and to act as a core building block for production systems written in Rust.]]></description><guid isPermaLink="false">ae789897-c6a9-4ec5-bab4-a1777f9cfc7a</guid><pubDate>Wed,  2 Oct 2019 10:00:00 -0400</pubDate><dc:creator>Lucio Franco</dc:creator></item><item><title>Creating Web App in Rust with Yew</title><link>https://versbinarii.gitlab.io/blog/posts/creating-webapp-with-yew/</link><description><![CDATA[I recently had to create a simple webapplication for a project i was working on. Luckily i was free to choose the technology for that task so i decided that it was great oportunity to try out how applicable is Rust for web development. There is already a bunch of mature web servers available such as Rocket or Actix. However as far as i can tell Yew is the only actual framework that allows you to create the frontend application.]]></description><guid isPermaLink="false">7cc2fd97-9135-44d1-b428-2695aa2991e7</guid><pubDate>Wed,  2 Oct 2019 00:00:00 +0000</pubDate><dc:creator>Kris</dc:creator></item><item><title>Sample REST API in Rust and Go</title><link>https://jmmv.dev/2019/09/rest-api-rust-go.html</link><description><![CDATA[Over the summer, I prototyped a bunch of web apps whose ideas had been floating in my mind for a long time. I spent quite a bit of time learning about REST APIs and, as part of these exercises, implemented skeletons of REST servers in both Go and Rust. The app prototypes have gone nowhere but I thought of sharing the skeletons I built if only to serve as templates for myself in future work. Thus, in this post, I will cover these skeleton demos and I will compare them.]]></description><guid isPermaLink="false">dcbe1901-b9b1-4eec-a44e-d6be0dcdd958</guid><pubDate>Fri, 27 Sep 2019 06:45:40 +0500</pubDate><dc:creator>Julio Merino</dc:creator></item><item><title>Building a front app with Rust (yes you can) and Yew</title><link>https://medium.com/swlh/building-a-front-app-with-rust-yes-you-can-and-yew-11e7835d768f</link><description><![CDATA[JS/TS is killing me. Now that I use Rust everyday, I have to try Yew, a front framework for Rust to create WASM apps, I spotted it long time ago but it wasn’t mature enough for my use case… guess what — now is the time ! The project is still alive and well!  Rust fullstack dev it is.]]></description><guid isPermaLink="false">be17b8c4-fce6-4128-9058-ee35cf5109aa</guid><pubDate>Thu, 12 Sep 2019 12:48:25 +0000</pubDate><dc:creator>Terry Raimondo</dc:creator></item><item><title>Engineering Rust Web Applications</title><link>https://erwabook.com/</link><description><![CDATA[This is a quick & dirty guide to building a web app using an all-rust stack: Diesel as an ORM, Rocket as a web framework, and Seed for the [WebAssembly] frontend. Read this book to learn how to quickly throw together a prototype application, all with your favorite programming language.]]></description><guid isPermaLink="false">e7878bb0-8dbe-40fc-8af3-54d3df4663c1</guid><pubDate>Sun,  1 Sep 2019 00:00:00 +0000</pubDate><dc:creator>Brian St. Pierre</dc:creator></item><item><title>Announcing the first Postgres extension to run WebAssembly</title><link>https://medium.com/wasmer/announcing-the-first-postgres-extension-to-run-webassembly-561af2cfcb1</link><description><![CDATA[It is already possible to run WebAssembly inside C, C++, PHP, Python, Ruby, Go, C#, R. Now it is time to run WebAssembly inside Postgres.]]></description><guid isPermaLink="false">d653d9d3-135e-4c03-b2d4-8869b8972cb2</guid><pubDate>Fri, 30 Aug 2019 07:56:27 +0000</pubDate><dc:creator>Ivan Enderlin</dc:creator></item><item><title>How to use routers in Rust Frontend</title><link>https://www.steadylearner.com/blog/read/How-to-use-routers-in-Rust-Frontend</link><description><![CDATA[In the previous post How to use a modal in Rust, we learnt how to write a simple image modal with Rust frontend. We could find that we can build components visible only in specific conditions. In this post, we will learn how to use routers in Rust frontend with Yew. You will find that it is easy with an example.]]></description><guid isPermaLink="false">4da678ba-45e7-444f-b5da-20e2893bb4d6</guid><pubDate>Tue, 27 Aug 2019 23:46:31 +0000</pubDate><dc:creator>Steadylearner</dc:creator></item><item><title>Picking Rust for web</title><link>https://abe-winter.github.io/wisdom/2019/08/26/rust-for-web.html</link><description><![CDATA[I’ve been staring at this energy efficiency across programming languages table for days. It can’t be right (why is typescript so much worse than javascript?) but a lot of it tracks with things I’ve observed from using these languages IRL. Also this web framework benchmarks project. Bottom line: I’m thinking about using rust as the backend for a small one-person web project. Here’s everything I said to myself while researching reasons not to.]]></description><guid isPermaLink="false">5d8d151f-18fd-4aa2-8a3d-eb5620394f36</guid><pubDate>Mon, 26 Aug 2019 00:00:00 +0000</pubDate><dc:creator>Abe Winter</dc:creator></item><item><title>Building with async/await in Rust</title><link>https://ragona.com/posts/clobber_async_await</link><description><![CDATA[As you might have heard, async/await is coming to Rust soon. This is a big deal. Rust has already has popular crates (tokio, actix) that provide asynchronous concurrency, but the async syntax coming to stable in 1.39 is much, much more approachable. My experience has been that you can produce and reason about application flow much more easily, which has made me significantly more productive when dealing with highly concurrent systems. To kick the tires of this new syntax I dug into the nightly branch, and built a high-performance TCP client called clobber. In this post I'll talk about why I think async/await in Rust is a big deal, and walk you some of the code in clobber.]]></description><guid isPermaLink="false">b577a6bb-429a-454b-8d2b-77175dba68c8</guid><pubDate>Wed, 21 Aug 2019 00:00:00 +0000</pubDate><dc:creator>Ryan Ragona</dc:creator></item><item><title>Rustacean Terminal Chat App in Rust</title><link>https://www.pubnub.com/blog/build-realtime-rust-chat-app-cursive-tui/</link><description><![CDATA[Build a basic chat app with the Rust Programming Language.]]></description><guid isPermaLink="false">e21ad158-7d23-47c3-82a4-0f76f651c6d9</guid><pubDate>Fri,  9 Aug 2019 17:31:52 +0000</pubDate><dc:creator>Samba Diallo</dc:creator></item><item><title>OAuth Requests, APIs, Diesel, and Sessions</title><link>https://rust.graystorm.com/2019/08/09/oauth-requests-apis-diesel-and-sessions/</link><description><![CDATA[I start to get sessions working by POSTs OAuth requests to an API endpoint and create accounts using Diesel to talk to the database.]]></description><guid isPermaLink="false">c0646818-a5c6-4739-8146-179b69af4d2f</guid><pubDate>Fri,  9 Aug 2019 13:26:43 +0000</pubDate><dc:creator>Jeff Culverhouse</dc:creator></item><item><title>Curve Fitting in the Browser using Rust+wasm in Angular</title><link>https://medium.com/@domie_domie/curve-fitting-in-the-browser-using-rust-wasm-in-angular-f9120ad89ac0</link><description><![CDATA[Playing around with Rust+WebAssembly and wrote a little crate to perform Levenberg-Marquardt fits. Brief comparison of SciPy & Rust fitting.]]></description><guid isPermaLink="false">cf49cd41-eb0a-4331-a092-3869573c5824</guid><pubDate>Tue,  6 Aug 2019 16:14:56 +0000</pubDate><dc:creator>Dominique Dresen</dc:creator></item><item><title>Rust Web App Session Management with AWS</title><link>https://rust.graystorm.com/2019/08/04/rust-web-app-session-management-with-aws/</link><description><![CDATA[I implement Amazon's DynamoDB for my Rust web app session management storage with the Rusoto crate and some deeply nested code.]]></description><guid isPermaLink="false">31d06e7f-96a6-4fe8-9a5a-18b20416250e</guid><pubDate>Sun,  4 Aug 2019 17:35:17 +0000</pubDate><dc:creator>Jeff Culverhouse</dc:creator></item><item><title>Practical Networked Applications in Rust, Part 2: Networked Key-Value Store</title><link>https://arveknudsen.com/posts/practical-networked-applications-in-rust/module-2/</link><description><![CDATA[Welcome to the second installation in my series on taking the Practical Networked Applications in Rust course, kindly provided by the PingCAP company, where you develop a networked and multithreaded/asynchronous key-value store in the amazing Rust language. In the previous, and initial, post I implemented the course module of making the fundamental key-value store functionality, based around the Bitcask algorithm, which would only allow for local usage on your own computer. In the second module of my course work, I add networking functionality, dividing the application into a client/server architecture so that clients can connect to servers across the network.]]></description><guid isPermaLink="false">09df4bbd-96fe-49af-8811-407f98c3108e</guid><pubDate>Sun,  4 Aug 2019 01:00:00 +0200</pubDate><dc:creator>Arve Knudsen</dc:creator></item><item><title>Low-level TCP server in Rust with MIO</title><link>https://sergey-melnychuk.github.io/2019/08/01/rust-mio-tcp-server/</link><description><![CDATA[It is time to get acquainted with Metal IO, low-level cross-platform abstraction over epoll/kqueue written in Rust. In this article I will show and explain how to write simple single-threaded asynchronous TCP server, then teach it to mock HTTP protocol, and then benchmark it with ab/wrk. The results are about to be impressive.]]></description><guid isPermaLink="false">94dd1a96-2b38-4556-bb32-5064f803e5b6</guid><pubDate>Thu,  1 Aug 2019 22:25:42 +0000</pubDate><dc:creator>Sergey Melnychuk</dc:creator></item><item><title>Practical Networked Applications in Rust, Part 1: Non-Networked Key-Value Store</title><link>https://arveknudsen.com/posts/practical-networked-applications-in-rust/module-1/</link><description><![CDATA[The PingCAP company, makers of the TiDB NewSQL database and the TiKV key-value store, have kindly made publicly available, as well as open-sourced, a set of training courses that they call the "PingCAP Talent Plan". These courses train programmers in writing distributed systems in the Go and Rust languages. They are originally intended by PingCAP to train students, new employees and new contributors to TiDB and TiKV and focus as such on subjects relevant to those projects, but are still appropriate to anyone with an interest in learning to make distributed systems in Go and/or Rust.]]></description><guid isPermaLink="false">faca5f20-8895-4d5b-850c-d2a8b4149876</guid><pubDate>Tue, 23 Jul 2019 13:00:00 +0200</pubDate><dc:creator>Arve Knudsen</dc:creator></item><item><title>How to write Full Stack Rust code</title><link>https://www.steadylearner.com/blog/read/How-to-write-Full-Stack-Rust-code</link><description><![CDATA[In the previous post How to modulize your Rust Frontend, we learnt how to use impl, functions and Yew components. They help you to find errors and organize your Rust frontend project. In this post, we will include server side code with ws-rs. It will help us to build complete Rust Full Stack chat app similar to what we made at How to start Rust Chat App.]]></description><guid isPermaLink="false">ca7ab50b-0ea0-4d8f-9f38-74945bc33900</guid><pubDate>Mon, 22 Jul 2019 00:00:00 +0000</pubDate><dc:creator>Steadylearner</dc:creator></item><item><title>How to modulize your Rust Frontend</title><link>https://www.steadylearner.com/blog/read/How-to-modulize-your-Rust-Frontend</link><description><![CDATA[In the previous post How to use markdown with Rust Frontend, we learnt how to render markdown in Rust frontend and include CSS files from your previous frontend project. You can use a text, image, video, markdown or any HTML elements you want for your Rust frontend. In this post, we will learn how to modulize your Rust Yew frontend app. It will be easy after you learn how to use impl, function, and components for that.]]></description><guid isPermaLink="false">5784cd2f-f28c-4746-8c85-c39ee718c4a0</guid><pubDate>Fri, 19 Jul 2019 00:00:00 +0000</pubDate><dc:creator>Steadylearner</dc:creator></item><item><title>Announcing Ballista - Distributed Compute with Rust, Apache Arrow, and Kubernetes</title><link>https://andygrove.io/2019/07/announcing-ballista/</link><description><![CDATA[After taking a break from working on Arrow and DataFusion for a couple of months to focus on some deliverables at work, I have now started a new PoC project to have a second attempt at building a distributed platform with Rust, and this time around I have the advantage of already having some foundational pieces in place, namely Arrow and DataFusion. I have also been gaining experience with Kubernetes recently and I could clearly see how this would simplify the creation of a distributed platform. The pieces really are starting to fall into place.

The new project is called Ballista and is a fast moving PoC taking a top down approach to building a distributed platform.]]></description><guid isPermaLink="false">f47a9bfe-394d-44b0-a4b1-683976a2cee2</guid><pubDate>Tue, 16 Jul 2019 00:00:00 +0000</pubDate><dc:creator>Andy Grove</dc:creator></item><item><title>Rust in one of the biggest music festival Atlas Weekend 2019</title><link>https://www.reddit.com/r/rust/comments/cdg5b4/rust_in_the_on_of_the_biggest_music_festival/</link><description><![CDATA[I'm happy to announce, that we've just finished one of the biggest European music festival Atlas Weekend which took place in Kyiv, Ukraine. As a year ago, backend for technical purposes of festival is written with Rust: Tickets exchange, entrance control, powerful user management with distributed configurable permissions, backstage pass, control of security workers, their work time, cars entrance, warehouse system for rfid bracelets with full history and control of each rfid. This year we registered more than 6000 workers, each of them has full info tied to bracelet: name, phone, photo, available permissions, time to access festival.]]></description><guid isPermaLink="false">0026c42e-9e3b-4a14-96dc-1fe3609e8957</guid><pubDate>Mon, 15 Jul 2019 00:00:00 +0000</pubDate><dc:creator>/u/maxfrai</dc:creator></item><item><title>Rust as the new C. Part 1: building and combining native libs into C API</title><link>http://hotforknowledge.com/2019/07/14/6-rust-the-new-c/</link><description><![CDATA[In this blog series, I will experiment with Rust as a safer and simpler C/C++ replacement. The idea is to combine a couple of C dependencies in Rust, to do some work using the dependencies in Rust and to expose a final API from a Rust library via C ABI. Then I will consume the same exported Rust methods from a number of modern languages/platforms such as C#, Python, Java, Nodejs, R, Go and even back from C/C++.]]></description><guid isPermaLink="false">342aba54-6554-4ec9-9d92-cd93edfbc8a2</guid><pubDate>Sun, 14 Jul 2019 16:12:00 +0300</pubDate><dc:creator>Victor Baybekov</dc:creator></item><item><title>How to use NPM packages with Rust Frontend</title><link>https://www.steadylearner.com/blog/read/How-to-use-NPM-packages-with-Rust-Frontend</link><description><![CDATA[In the previous post full-stack Rust with Yew, we learnt how to prepare minimal files to build a full stack Rust web app. You can do whatever Rust allows with it.]]></description><guid isPermaLink="false">4979dc89-2295-48da-ae2b-cb84dc37fd8c</guid><pubDate>Sun, 14 Jul 2019 00:00:00 +0000</pubDate><dc:creator>Steadylearner</dc:creator></item><item><title>Fullstack Rust with Yew</title><link>https://www.steadylearner.com/blog/read/Fullstack-Rust-with-Yew</link><description><![CDATA[In the previous post How to use Rust Yew, we learnt how to prepare minimal files to build webassembly files with Yew for Rust frontend. We will advance it with some Rust server side code and write a bash file to automate the process.]]></description><guid isPermaLink="false">28d2b0b9-8bfb-4541-b2f5-f84ed2670d56</guid><pubDate>Thu, 11 Jul 2019 00:00:00 +0000</pubDate><dc:creator>Steadylearner</dc:creator></item><item><title>Collecting broadcast UDP packets using async networking in Rust</title><link>https://medium.com/tresorit-engineering/collecting-broadcast-udp-packets-using-async-networking-in-rust-7fd93a631eac</link><description><![CDATA[Creating a simple console application in Rust for fun and profit, including some nice tricks to push async programming to the limits.]]></description><guid isPermaLink="false">66342269-5693-4c70-a15c-917b7818dc07</guid><pubDate>Mon,  8 Jul 2019 10:39:21 +0000</pubDate><dc:creator>Péter Budai</dc:creator></item><item><title>Create Dev&apos;s offline page with Rust and WebAssembly 🦄💡✨</title><link>https://dev.to/sendilkumarn/create-dev-s-offline-page-with-rust-and-webassembly-21gn</link><description><![CDATA[Dev's offline page is fun. Can we do that with Rust and WebAssembly? The answer is yes. Let us do it.]]></description><guid isPermaLink="false">b5b706cb-863b-4856-843d-6a894a7fc280</guid><pubDate>Wed,  3 Jul 2019 23:14:51 +0000</pubDate><dc:creator>Sendil Kumar N</dc:creator></item><item><title>Increase Rust and WebAssembly performance</title><link>https://dev.to/sendilkumarn/increase-rust-and-webassembly-performance-382h</link><description><![CDATA[What are we gonna do? Create a WebAssembly application that takes a string in markdown format and converts that into HTML.]]></description><guid isPermaLink="false">faa1d1ec-2bcd-4363-832a-2e03e35d8124</guid><pubDate>Tue,  2 Jul 2019 00:40:25 +0000</pubDate><dc:creator>Sendil Kumar N</dc:creator></item><item><title>Rust WebAssembly Hello World - Deep Dive with wasm-bindgen and wasm2wat</title><link>https://www.webassemblyman.com/rust_webassembly_hello_world.html</link><description><![CDATA[In this article we are going to create a WebAssembly Hello World program with Rust. You might be thinking that a WebAssembly Hello World tutorial could be found almost everywhere, including one on Mozilla website and rustwasm.github.io.]]></description><guid isPermaLink="false">247efda7-549d-4c38-8af1-733755fc4aa7</guid><pubDate>Tue,  2 Jul 2019 00:00:00 +0000</pubDate><dc:creator>nicole</dc:creator></item><item><title>How to use Rust Yew</title><link>https://www.steadylearner.com/blog/read/How-to-use-Rust-Yew</link><description><![CDATA[In this post, we will prepare development environment for Rust Yew. Then, we will write minimal code with it and learn how to deploy it in your website also.]]></description><guid isPermaLink="false">db9d60ca-f153-4abf-9654-ac53ec91472e</guid><pubDate>Sun, 30 Jun 2019 00:00:00 +0000</pubDate><dc:creator>Steadylearner</dc:creator></item><item><title>Wasm By Example</title><link>https://wasmbyexample.dev/</link><description><![CDATA[A hands-on introduction into WebAssembly ( Wasm ). Containing simple examples and tutorials on how to implement concepts and various tasks using Wasm.]]></description><guid isPermaLink="false">2c73c05a-7fb3-494d-8fb3-896cf3a343b3</guid><pubDate>Wed, 26 Jun 2019 03:28:00 +0000</pubDate><dc:creator>Aaron Turner</dc:creator></item><item><title>Writing a proxy in Rust and why it is the language of the future</title><link>https://medium.com/swlh/writing-a-proxy-in-rust-and-why-it-is-the-language-of-the-future-265d8bf7c6d2</link><description><![CDATA[It’s been a year since I wrote a little proxy with Rust, it is one of my first projects with this language and I learned a lot writing it. To sum up a bit, the main goal of this proxy is to be really simple to use and easy to extend with middlewares. It targets HTTP APIs and can be used in front of a lot of services. This proxy has been used in multiple projects, with microservices architecture and so on…]]></description><guid isPermaLink="false">ae8feddf-191a-444f-9423-e7a3e0b4b356</guid><pubDate>Tue, 25 Jun 2019 14:43:21 +0000</pubDate><dc:creator>Terry Raimondo</dc:creator></item><item><title>Implementing HTSP in Rust</title><link>https://www.rubdos.be/rust/async/programming/2019/06/22/implementing-htsp-in-rust.html</link><description><![CDATA[As with most hobby projects, my htsp-rs implementation became a side-side-side project, and it will probably stay that way. Another property of those hobby projects is that I now-and-then pick them up again, and htsp-rs has come to that point now. The reason for picking it up again is different from the reason of its existence though, and that’s a good thing: it means I have multiple reasons for the crate’s existence. Initially, I wanted it as a back-end for a livestreaming app on SailfishOS. Today, I want it as back-end for mpd’s TVHeadend support.]]></description><guid isPermaLink="false">0770f016-861d-4bc1-9ce0-cad6b6e374f2</guid><pubDate>Sat, 22 Jun 2019 00:00:00 +0000</pubDate><dc:creator>Ruben De Smet</dc:creator></item><item><title>Collaborative Editor in Rust</title><link>https://caolan.org/posts/collaborative_editor_in_rust.html</link><description><![CDATA[I've been experimenting with techniques for collaborative editing in Rust recently and I'd like to share my first functional prototype with you. The demo uses Rust and WebAssembly, and I implemented it using a conflict-free replicated data type (CRDT) based on LOGOOT, which I modified to work with variable-sized strings rather than individual characters or lines.]]></description><guid isPermaLink="false">54d40e7f-c5c5-4c69-86e2-9913c6a88200</guid><pubDate>Fri, 21 Jun 2019 00:00:00 +0000</pubDate><dc:creator>Caolan McMahon</dc:creator></item><item><title>Asyncifying an Actix Web App and Upgrading it to 1.0 - zupzup</title><link>https://zupzup.org/asyncify-rust-webapp/</link><description><![CDATA[In a previous post, we created an Actix 0.7 Web App, which was not fully non-blocking. In this post, we'll become fully non-blocking and upgrade the app to Actix 1.0]]></description><guid isPermaLink="false">a5730863-ff70-4122-8595-81c11ee59697</guid><pubDate>Thu, 20 Jun 2019 00:00:00 +0000</pubDate><dc:creator>Mario Zupan</dc:creator></item><item><title>Makepad, a live Rust authoring tool for 2D vector design, shaders and animation</title><link>https://github.com/makepad/makepad</link><description><![CDATA[The vision is to build a livecoding / design hybrid program, where procedural design and code are fused in one environment. If you have missed 'learnable programming' please check this out: http://worrydream.com/LearnableProgramming/ Makepad aims to fulfill (some) of these ideas using a completely from-scratch renderstack built on the GPU and Rust. It will be like an IDE meets a vector designtool, and had offspring. Direct manipulation of the vectors modifies the code, the code modifies the vectors.

However before we can make this awesome application, we need to build a UI stack. The aim of this toolkit is to be our stepping stone into building a livecoding IDE and designtools that don't suck or fall to pieces along the way.]]></description><guid isPermaLink="false">87146592-5c10-431e-8655-5272eec53ed9</guid><pubDate>Mon, 17 Jun 2019 00:00:00 +0000</pubDate><dc:creator>makepad</dc:creator></item><item><title>Auth Web Microservice with rust using Actix-Web 1.0 - Complete Tutorial</title><link>https://gill.net.in/posts/auth-microservice-rust-actix-web1.0-diesel-complete-tutorial/</link><description><![CDATA[We are going to create a web-server in rust that only deals with user registration and authentication. I will be explaining the steps in each file as we go. The complete project code is here repo. Please take all this with a pinch of salt as I’m a still a noob to rust 😉.]]></description><guid isPermaLink="false">5150f924-ef3f-4327-a3ba-c5f16076a22b</guid><pubDate>Sun,  9 Jun 2019 00:00:00 +0000</pubDate><dc:creator>Harry Gill</dc:creator></item><item><title>Actix - Actor System and Web Framework for Rust</title><link>https://actix.rs/</link><description><![CDATA[Actix web 1.0.0 is released - a small, pragmatic, and extremely fast web framework.]]></description><guid isPermaLink="false">ae6027ab-b71f-4bce-9ab8-e1853aa24030</guid><pubDate>Wed,  5 Jun 2019 15:38:00 +0000</pubDate><dc:creator>Nikolay Kim</dc:creator></item><item><title>Gopher Server in Rust</title><link>https://gkbrk.com/2019/06/gopher-server/</link><description><![CDATA[I find Gopher really cool. I think it’s a really nice way to organize information into trees and hierarchies, and as we all know programmers can’t resist trees. So recently I took an interest in Gopher and started writing my own server.

But recently it’s been gaining traction; so we should provide a decent landscape for new gophers, full of oxidised servers. Since I started using Gopher more often, it’s beneficial for me if there’s more content out there. So I’m writing this blog post to walk you through how to write your own server. We’ll be doing this in Rust.]]></description><guid isPermaLink="false">91ae37e0-3d4f-4c78-879d-47e635f8fbda</guid><pubDate>Sun,  2 Jun 2019 01:00:00 +0100</pubDate><dc:creator>Gokberk Yaltirakli</dc:creator></item><item><title>Creating a Static HTTP Server with Rust – Part 2</title><link>http://concisecoder.io/2019/05/27/creating-a-static-http-server-with-rust-part-2/</link><description><![CDATA[In this series, we are creating a basic static HTTP 1.0 server with Rust. If you haven’t seen Part 1 yet, go do that first. At the end of Part 2, our server will do the following: Read and serve files from a predefined directory on the host server, Generate appropriate HTTP responses to incoming requests, Log information about the response to standard output.]]></description><guid isPermaLink="false">4e723122-0527-43dc-b95b-ff4fd5cd5d28</guid><pubDate>Mon, 27 May 2019 13:25:29 +0000</pubDate><dc:creator>Levi Payne</dc:creator></item><item><title>Programming Servo: Zen and the art of removing blocks from your system</title><link>https://medium.com/@polyglot_factotum/programming-servo-zen-and-the-art-of-removing-blocks-from-your-system-51c1b7d404e3</link><description><![CDATA[It all started with a simple issue, a “quick fix”, or so I thought.]]></description><guid isPermaLink="false">0cc7297b-a14f-443d-a02a-073685c663a3</guid><pubDate>Sun, 26 May 2019 09:41:02 +0000</pubDate><dc:creator>Gregory Terzian</dc:creator></item><item><title>Blockchain-Flavored WASI</title><link>https://medium.com/oasislabs/blockchain-flavored-wasi-50e3612b8eba</link><description><![CDATA[General purpose computation on the blockchain using Web Assembly System Interface (WASI).]]></description><guid isPermaLink="false">fe48ce77-ad77-4983-a08d-1fb9cf951bb1</guid><pubDate>Thu, 23 May 2019 04:07:55 +0000</pubDate><dc:creator>Nick Hynes</dc:creator></item><item><title>Running WebAssembly on the Kernel</title><link>https://medium.com/wasmer/running-webassembly-on-the-kernel-8e04761f1d8e</link><description><![CDATA[This is the story of our journey running Wasmer on the Linux kernel.]]></description><guid isPermaLink="false">ef3c5cdb-f130-4211-83a1-1550ea15d73f</guid><pubDate>Thu, 16 May 2019 22:37:36 +0000</pubDate><dc:creator>Heyang Zhou</dc:creator></item><item><title>How to start a Rust Chat App</title><link>https://www.steadylearner.com/blog/read/How-to-start-Rust-Chat-App</link><description><![CDATA[In this post, we will learn how to build simple chat app in your local machine with Rust and simple JavaScript.]]></description><guid isPermaLink="false">e25cac18-f4ca-4872-babe-c4614327e076</guid><pubDate>Thu, 16 May 2019 00:00:00 +0000</pubDate><dc:creator>Steadylearner</dc:creator></item><item><title>Introducing Packem: a super fast experimental bundler written in Rust</title><link>https://medium.freecodecamp.org/introducing-packem-a-super-fast-experimental-bundler-written-in-rust-e981af875517</link><description><![CDATA[Packem is an experimental precompiled JavaScript module bundler primarily implemented in Rust. It can also handle a variety of other file types like YAML/TOML, fragment shader files and a lot more.]]></description><guid isPermaLink="false">3eb814d5-d467-4e34-ba31-e0a55da4da36</guid><pubDate>Wed, 15 May 2019 16:36:27 +0000</pubDate><dc:creator>Bukhari Muhammad</dc:creator></item><item><title>Creating a Static HTTP Server with Rust - Part 1</title><link>http://concisecoder.io/2019/05/11/creating-a-static-http-server-with-rust-part-1/</link><description><![CDATA[In this series, we will create a basic static HTTP 1.0 server with Rust. At the end of Part 1 of this tutorial, our server will do the following: Listen for and handle TCP connections on a specific port, Accept HTTP 1.0 GET requests, Parse and validate requests for further use, Log incoming requests. We will avoid using libraries that make this trivial (i.e. the http crate) and focus on the fundamentals of how a server works.]]></description><guid isPermaLink="false">25d9490f-05e3-4f5c-a407-19d78b0fb6d4</guid><pubDate>Sat, 11 May 2019 17:17:46 +0000</pubDate><dc:creator>Levi Payne</dc:creator></item><item><title>Unit testing Rust using Chrome</title><link>https://medium.com/visly/unit-testing-rust-using-chrome-b8b93572a91d</link><description><![CDATA[Stretch is a cross-platform Flexbox engine written in Rust. At Visly we are building a design tool for front-end engineers and we needed to ensure components looked the same across web, iOS, and Android without making use of WebViews. This meant replicating the web layout system on mobile.

In this post, I’ll cover the test setup we use in Stretch, how and why we need to generate unit dynamically. I’ll also cover an example of contributing another test to Stretch, and finally I’ll walk through how we also make use of this system for benchmarking.]]></description><guid isPermaLink="false">ffeaa8e5-849b-4924-9c9f-1ac6adc15a8e</guid><pubDate>Mon,  6 May 2019 16:25:41 +0000</pubDate><dc:creator>Emil Sjölander</dc:creator></item><item><title>WebAssembly -Part II.A | Wasm with Rust</title><link>https://medium.com/tech-lah/webassembly-part-ii-a-wasm-with-rust-2356dbc6526e</link><description><![CDATA[This article is more of a how-to on getting up and running with a production-grade web project which incorporates Rust (or any other language for that matter) and WebAssembly into your web pages.]]></description><guid isPermaLink="false">e3fadb7b-df84-47a1-b6ca-47186b2b9418</guid><pubDate>Sun,  5 May 2019 13:27:01 +0000</pubDate><dc:creator>Francisco Vilches</dc:creator></item><item><title>Introducing Lightbeam: An Optimising Streaming WebAssembly Compiler</title><link>http://troubles.md/posts/lightbeam/</link><description><![CDATA[Lightbeam is a new streaming compiler for WebAssembly, designed to produce the best possible assembly while still being fast enough to produce assembly faster than the WebAssembly is received over the wire.]]></description><guid isPermaLink="false">f6902c1c-3975-454f-891e-d39b071d66d4</guid><pubDate>Sat,  4 May 2019 10:10:34 +0100</pubDate><dc:creator>troubles.md</dc:creator></item><item><title>Building Simple APIs with Hyper and Usher</title><link>https://whitfin.io/building-simple-apis-with-hyper-and-usher/</link><description><![CDATA[When writing a web service, I often lean towards using tools that are as minimal as possible. One pretty obvious reason for this is the avoidance of dependencies you either don't want or don't need in your project. Whilst I'm not someone who goes out of their way to avoid dependencies, this is a pain point particularly in Rust because of the cost of building them repeatedly rather than shipping extra interpreted files around (especially if you use "pure" build environments).]]></description><guid isPermaLink="false">728cc414-7e29-41ce-86af-0181095c3ec6</guid><pubDate>Fri,  3 May 2019 16:56:26 +0000</pubDate><dc:creator>Isaac Whitfield</dc:creator></item><item><title>Explained: Futures in Rust for Web Development</title><link>https://dev.to/gruberb/explained-rust-futures-for-web-development-a10</link><description><![CDATA[If you are coming from NodeJS, Futures in Rust don't make much sense. In NodeJS, everything happens asynchronously. Therefore for you to be able to say "Hey, I really need to wait for the answer for this GET HTTP call", you are putting.then() on a Promise, so you can make sure you just execute the code inside the .then() when the HTTP call is finished.

In Rust, everything is blocking and synchronous by default, so you might ask yourself: "Why bothering with the complexity, that's exactly what I wanted in the first place!"]]></description><guid isPermaLink="false">9152c867-9b24-49d0-ac2c-d85775162eb4</guid><pubDate>Thu,  2 May 2019 00:00:00 +0000</pubDate><dc:creator>Bastian Gruber</dc:creator></item><item><title>Hawk: Image Recognition Application using Rust and AWS Services</title><link>https://blog.knoldus.com/hawk-image-recognition-project-using-rust-and-aws-services/</link><description><![CDATA[Rust is one of the newest kid on the block in the modern programming languages. We tried to take advantage of its great features by using it in an Image Recognition blueprint project. This project can be traded with any existing security system deployed at any organization. Hawk uses AWS services integrated with Rust.]]></description><guid isPermaLink="false">dd64813c-9380-4cd5-b689-ae31cd1c0405</guid><pubDate>Wed,  1 May 2019 11:14:44 +0000</pubDate><dc:creator>muditchhabra6125</dc:creator></item><item><title>Using Wasmer for Plugins Part 4</title><link>https://wiredforge.com/blog/wasmer-plugin-pt-4/index.html</link><description><![CDATA[In the last three posts of this series we covered all of the things we would need to use Wasmer as the base for a plugin system. In part one we went over the basics of passing simple data in and out of a web assembly module, in part two we dug deeper into how you might do the same with more complicated data. In the last part we eased the experience of plugin developers by encapsulating all of our work into a library that exports a procedural macro. In this post we are going to explore what it would take to extend an existing plugin system to allow for wasm plugins.]]></description><guid isPermaLink="false">16c5eef8-5844-4408-8ab5-42319757ecef</guid><pubDate>Wed,  1 May 2019 00:00:00 +0000</pubDate><dc:creator>Robert Masen</dc:creator></item><item><title>Gotham - From Start to Heroku</title><link>https://blog.codeship.com/gotham-from-start-to-heroku/</link><description><![CDATA[In this article, we’ll implement and deploy a Gotham full-stack web framework using the Tera template system, Webpack for a complete front-end asset management, a minimal VueJS and CoffeeScript web app and deploy to Heroku. Gotham is a Rust framework which is focused on safety, speed, concurrency and async everything. Webpack is a NodeJS website asset preprocessor and bundler which can let you use any of your favorite front end technologies. Combining these technologies allow for a small footprint on the server, which means saving money on infrastructure, very fast performance in page load for higher visitor retention and the full flexibility of client side code available to you for web design without limitations.]]></description><guid isPermaLink="false">4136ae31-0128-4937-9c8b-91f064c0d8d6</guid><pubDate>Tue, 30 Apr 2019 15:15:20 +0000</pubDate><dc:creator>Daniel P. Clark</dc:creator></item><item><title>Rolling your own Router with Smithy v0.0.3</title><link>https://medium.com/@robert.balicki_2494/rolling-your-own-router-with-smithy-v0-0-3-2de17cdbb49</link><description><![CDATA[Build a WebAssembly application with a hash router using Smithy.]]></description><guid isPermaLink="false">4cc7ac88-4ef9-40fd-b235-bee8151e059d</guid><pubDate>Mon, 29 Apr 2019 15:25:25 +0000</pubDate><dc:creator>Robert Balicki</dc:creator></item><item><title>Simple Chat using Sonr-extras</title><link>https://hagsteel.com/posts/simple-chat/</link><description><![CDATA[Using sonr-extras to build a very basic chat using the provided connection handling objects.]]></description><guid isPermaLink="false">c9e2beae-20d5-4c7a-b8de-01f52b18aec1</guid><pubDate>Wed, 24 Apr 2019 00:00:00 +0200</pubDate><dc:creator>Jonas</dc:creator></item><item><title>Using Wasmer for Plugins Part 3</title><link>https://wiredforge.com/blog/wasmer-plugin-pt-3/index.html</link><description><![CDATA[In the last two posts of this series we covered all of the things we would need to use Wasmer as the base for a plugin system. In part one we went over the basics of passing simple data in and out of a web assembly module, in part two we dug deeper into how you might do the same with more complicated data. In this part we are going to explore how we might ease the experience for people developing plugins for our application.]]></description><guid isPermaLink="false">bd3e3e37-90f2-4941-ba7c-00fdae65bdac</guid><pubDate>Mon, 22 Apr 2019 00:00:00 +0000</pubDate><dc:creator>Robert Masen</dc:creator></item><item><title>Plume: Federated blogging application</title><link>https://github.com/Plume-org/Plume</link><description><![CDATA[Plume is a federated blogging engine, based on ActivityPub. It uses the Rocket framework, and Diesel to interact with the database.]]></description><guid isPermaLink="false">3d938fcd-0108-499a-9929-841d1999db4b</guid><pubDate>Mon, 22 Apr 2019 00:00:00 +0000</pubDate><dc:creator>Plume Developers</dc:creator></item><item><title>Using Wasmer for Plugins Part 2</title><link>https://wiredforge.com/blog/wasmer-plugin-pt-2</link><description><![CDATA[In this post we are going to cover how we could pass more complicated data from the wasm module back to the runner.]]></description><guid isPermaLink="false">899be7d9-392f-4467-aa75-85b2d3e913f7</guid><pubDate>Sat, 20 Apr 2019 00:00:00 +0000</pubDate><dc:creator>Robert Masen</dc:creator></item><item><title>Using Wasmer for Plugins Part 1</title><link>https://wiredforge.com/blog/wasmer-plugin-pt-1</link><description><![CDATA[A few months ago, the Wasmer team announced a Web Assembly (aka wasm) interpreter that could be embedded into rust programs. This is particularly exciting for anyone looking to add plugins to their project and since Rust provides a way to directly compile programs to wasm, it seems like a perfect option. In this series of blog posts we are going to investigate what building a plugin system using wasmer and rust would take.]]></description><guid isPermaLink="false">d11c58e5-419a-4c3e-923d-b2bac810d445</guid><pubDate>Fri, 19 Apr 2019 00:00:00 +0000</pubDate><dc:creator>Robert Masen</dc:creator></item><item><title>Web Development with Rust — 03/x: Create a REST API</title><link>https://dev.to/gruberb/web-development-with-rust-03-x-create-a-rest-api-3i82</link><description><![CDATA[The most common pattern for creating APIs is REST. We will discover how we can build an API in Rust which conforms with the REST pattern.]]></description><guid isPermaLink="false">f2b4f953-be42-4454-b073-1804aa4a8bb6</guid><pubDate>Mon, 15 Apr 2019 00:00:00 +0000</pubDate><dc:creator>Bastian Gruber</dc:creator></item><item><title>Face Detection with Actix Web</title><link>https://cetra3.github.io/blog/face-detection-with-actix-web/</link><description><![CDATA[Last article I wrote about how to use tensorflow with rust. This time we're going to take what we've built on, and serve it as an HTTP API call. As Actix Web is nearing its inevitable 1.0 release, I thought it would be a great time to build something with it.]]></description><guid isPermaLink="false">ea434653-4ba2-47c0-bc91-ba9c521dc419</guid><pubDate>Thu, 11 Apr 2019 00:00:00 +0000</pubDate><dc:creator>cetra3</dc:creator></item><item><title>Rust Actix Web + Magic link authentication</title><link>https://blog.approveapi.com/tutorials/rust-actix-web-approveapi-magic-login-link/</link><description><![CDATA[In this tutorial, we'll create web app using the Rust actix-web framework and implement magic link authentication powered by ApproveAPI's Rust library.]]></description><guid isPermaLink="false">98a6bda4-dcb1-419a-bf9a-6be8f4b88b8b</guid><pubDate>Tue,  9 Apr 2019 00:00:00 +0000</pubDate><dc:creator>Alex Grinman</dc:creator></item><item><title>A Basic Web Application with Rust and Actix-web</title><link>https://zupzup.org/rust-webapp/</link><description><![CDATA[As a first little project in Rust I thought I'd do something familiar, so I created a small web application, which we'll check out in this post.]]></description><guid isPermaLink="false">dcd70897-0b31-4930-b57d-3fc567e64c98</guid><pubDate>Sun,  7 Apr 2019 00:00:00 +0000</pubDate><dc:creator>Mario Zupan</dc:creator></item><item><title>Linkerd v2: How Lessons from Production Adoption Resulted in a Rewrite of the Service Mesh</title><link>https://www.infoq.com/articles/linkerd-v2-production-adoption</link><description><![CDATA[Linkerd 2.0 introduced a substantial rewrite of the widely adopted service mesh, using a split between Go and Rust. In this article, we discuss the lessons learned in the "cauldron of production adoption", and how those lessons became the basis of Linkerd 2.x’s philosophy, design, and implementation.]]></description><guid isPermaLink="false">cbaf5407-81db-4367-9b58-ff9cc668b1a3</guid><pubDate>Fri,  5 Apr 2019 00:00:00 +0000</pubDate><dc:creator>William Morgan</dc:creator></item><item><title>Ocypod: Redis-backed job queue server with an easy to use HTTP interface</title><link>https://ocypod.readthedocs.io/</link><description><![CDATA[Ocypod is a language-agnostic, Redis-backed job queue server with an easy to use HTTP interface. Its focus is on handling and monitoring long running jobs.]]></description><guid isPermaLink="false">4fb7d3bc-05c5-4c23-abaa-70294fa23715</guid><pubDate>Wed,  3 Apr 2019 00:00:00 +0000</pubDate><dc:creator>Dave Challis</dc:creator></item><item><title>WASI example using Rust and Lucet</title><link>https://hermanradtke.com/2019/04/01/wasi-example-using-rust-and-lucet.html</link><description><![CDATA[Lucet is Fastly’s native WebAssembly compiler and runtime. Using the Lucet runtime and Rust’s wasm32-unknown-wasi target, we can create a WASM program that runs on the server.]]></description><guid isPermaLink="false">6d648c86-cd0a-4f11-ac22-af2fe977f6d6</guid><pubDate>Mon,  1 Apr 2019 00:00:00 +0000</pubDate><dc:creator>Herman J. Radtke III</dc:creator></item><item><title>Introducing Smithy — WebAssembly framework for Rust</title><link>https://medium.com/@robert.balicki_2494/introducing-smithy-webassembly-framework-for-rust-679d8fe9c16</link><description><![CDATA[I’m extremely excited to announce the 0.0.2 release of Smithy, a web development framework for Rust! While it is a very pre-alpha version, it should be functional enough for others to start playing around with. Please, get your feet wet and provide feedback.]]></description><guid isPermaLink="false">a1396ee1-4c3f-47c5-b99c-d7af8ea455a0</guid><pubDate>Thu, 28 Mar 2019 22:28:07 +0000</pubDate><dc:creator>Robert Balicki</dc:creator></item><item><title>The Wrangler CLI: Deploying Rust with WASM on Cloudflare Workers</title><link>https://blog.cloudflare.com/introducing-wrangler-cli/</link><description><![CDATA[Today, we're open sourcing and announcing wrangler, a CLI tool for building, previewing, and publishing Rust and WebAssembly Cloudflare Workers. If that sounds like some word salad to you, that's a reasonable reaction.]]></description><guid isPermaLink="false">5643e56a-6a6f-435e-8625-b58ebb5dca22</guid><pubDate>Thu, 28 Mar 2019 16:08:45 +0000</pubDate><dc:creator>Ashley Williams</dc:creator></item><item><title>Announcing Lucet: Fastly’s native WebAssembly compiler and runtime</title><link>https://www.fastly.com/blog/announcing-lucet-fastly-native-webassembly-compiler-runtime</link><description><![CDATA[Today, we are thrilled to announce the open sourcing of Lucet, Fastly’s native WebAssembly compiler and runtime. WebAssembly is a technology created to enable web browsers to safely execute programs at near-native speeds. It has been shipping in the four major browsers since early 2017.]]></description><guid isPermaLink="false">900ee12b-4a68-4987-a635-980b9105da76</guid><pubDate>Thu, 28 Mar 2019 16:00:00 +0000</pubDate><dc:creator>Pat Hickey</dc:creator></item><item><title>Gloo Update: Onion Layers, Timers, and Events</title><link>https://rustwasm.github.io/2019/03/26/gloo-onion-layers.html</link><description><![CDATA[About two weeks ago, we kicked off our effort to collectively build Gloo, a modular toolkit for building fast and reliable Web apps and libraries with Rust and Wasm. We knew we wanted to explicitly cultivate the Rust and Wasm library ecosystem by spinning out reusable, standalone libraries: things that would help you out whether you were writing a green-field Web app in pure-Rust, building your own framework, or surgically inserting some Rust-generated Wasm into an existing JavaScript project. What was still fuzzy, and which we didn’t know yet, was how we were going design and expose these reusable bits.]]></description><guid isPermaLink="false">9ea71842-a6ca-41c6-8384-89c6a05d17cb</guid><pubDate>Tue, 26 Mar 2019 00:00:00 +0000</pubDate><dc:creator>Nick Fitzgerald</dc:creator></item><item><title>Seed: A frontend framework for Rust, via WebAssembly</title><link>https://seed-rs.org/</link><description><![CDATA[I'm distinguishing Seed through clear examples and documentation, and using wasm-bindgen/web-sys internally. I started this project after being unable to get existing frameworks working due to lack of documented examples, and inconsistency between documentation and published versions. My intent is for anyone who's proficient in a frontend framework to get a standalone app working in the browser within a few minutes, using just the quickstart guide.

Seed's different approach to view syntax also distinguishes it: rather than use an HTML-like markup similar to JSX, it uses Rust builtin types, thinly-wrapped by macros that allow flexible composition. This decision will not appeal to everyone, but I think it integrates more naturally with the language.]]></description><guid isPermaLink="false">2da4fac1-5cb0-463b-9654-427f70d25255</guid><pubDate>Tue, 26 Mar 2019 00:00:00 +0000</pubDate><dc:creator>David O&apos;Connor</dc:creator></item><item><title>tarssh: An async Rust SSH tarpit</title><link>https://hur.st/projects/tarssh/</link><description><![CDATA[tarssh is an SSH tarpit — a server that trickles an endlessly repeating introductory banner to clients for as long as it remains connected, in order to expend the resources of attackers. It's based on the same concept as Chris Wellons' Endlessh, a similar service written in C.]]></description><guid isPermaLink="false">9a041284-284c-472d-97c0-0e0cd407bb44</guid><pubDate>Mon, 25 Mar 2019 00:00:00 +0000</pubDate><dc:creator>Thomas Hurst</dc:creator></item><item><title>Web Development with Rust: Deploy your first App</title><link>https://dev.to/gruberb/web-programming-in-rust-02x-deploy-your-first-app-1k05</link><description><![CDATA[If you learn something new, always have an updated version of your project in production. It keeps you motivated. We cover the most common options of how to do this in and with Rust.]]></description><guid isPermaLink="false">6d82f826-46bb-4cb3-ba49-3a18c736f5ab</guid><pubDate>Tue, 19 Mar 2019 20:13:00 +0000</pubDate><dc:creator>Bastian Gruber</dc:creator></item><item><title>Building and augmenting libraries by calling Rust from JavaScript</title><link>https://opensource.com/article/19/3/calling-rust-javascript</link><description><![CDATA[Explore how to use WebAssembly (Wasm) to embed Rust inside JavaScript.]]></description><guid isPermaLink="false">208250d2-7529-4548-b658-0b76353e05de</guid><pubDate>Mon, 18 Mar 2019 03:02:00 -0400</pubDate><dc:creator>Ryan Levick</dc:creator></item><item><title>Fast, Bump-Allocated Virtual DOMs with Rust and Wasm</title><link>https://hacks.mozilla.org/2019/03/fast-bump-allocated-virtual-doms-with-rust-and-wasm/</link><description><![CDATA[Dodrio is a virtual DOM library written in Rust and WebAssembly. It takes advantage of both Wasm’s linear memory and Rust’s low-level control by designing virtual DOM rendering around bump allocation. Preliminary benchmark results suggest it has best-in-class performance.]]></description><guid isPermaLink="false">23efff3a-8be9-443e-bc32-9de200d2e173</guid><pubDate>Thu, 14 Mar 2019 16:54:44 +0000</pubDate><dc:creator>Nick Fitzgerald</dc:creator></item><item><title>Introducing @now/rust</title><link>https://zeit.co/blog/introducing-now-rust</link><description><![CDATA[ZEIT is proud to announce official support for Rust on Now through `@now/rust`. Our mission at ZEIT is to make cloud computing accessible for all. Rust has seen rapid growth in its adoption, and we're proud to be able to support the community.]]></description><guid isPermaLink="false">ad39fd8f-6ca7-499e-bebb-f8a35d3d0a66</guid><pubDate>Tue, 12 Mar 2019 00:00:00 +0000</pubDate><dc:creator>ZEIT</dc:creator></item><item><title>WASP, a Lisp dialect for performant, concise Web Assembly modules</title><link>https://medium.com/@nbaltunian/wasp-a-lisp-dialect-for-performant-concise-web-assembly-modules-29f5f7282b6a</link><description><![CDATA[WASP is ‘a LISP programming language for extremely performant and concise web assembly modules.’ That means that you can use WASP to generate WASM modules.]]></description><guid isPermaLink="false">356cc6f0-1e2a-4060-8b81-df1d1d6cd911</guid><pubDate>Sat,  9 Mar 2019 04:24:29 +0000</pubDate><dc:creator>Noah</dc:creator></item><item><title>Resize images from S3 with AWS Lambda and Rust</title><link>https://matsimitsu.com/blog/2019-03-09-resize-images-from-s3-with-aws-lambda-and-rust/</link><description><![CDATA[Using Rust and AWS Lambda to thumbnail images, cheaply, relablity, and quickly.]]></description><guid isPermaLink="false">3ad2e4d8-ffb5-4dcc-870e-e5c8dae3ca2a</guid><pubDate>Sat,  9 Mar 2019 00:00:00 +0000</pubDate><dc:creator>Robert Beekman</dc:creator></item><item><title>Why should you use Rust in WebAssembly?</title><link>https://opensource.com/article/19/2/why-use-rust-webassembly</link><description><![CDATA[WebAssembly (Wasm) is a technology that has the chance to reshape how we build apps for the browser. Not only will it allow us to build whole new classes of web applications, but it will also allow us to make existing apps written in JavaScript even more performant.

In this article about the state of the Rust and Wasm ecosystem, I'll try to explain why Rust is the language that can unlock the true potential of WebAssembly.]]></description><guid isPermaLink="false">9496d523-3ad4-42ac-a6eb-183ed3d55713</guid><pubDate>Fri, 15 Feb 2019 03:01:00 -0500</pubDate><dc:creator>Ryan Levick</dc:creator></item><item><title>Replacing a hot path in your app&apos;s JavaScript with WebAssembly</title><link>https://developers.google.com/web/updates/2019/02/hotpath-with-wasm</link><description><![CDATA[In my previous articles I talked about how WebAssembly allows you to bring the library ecosystem of C/C++ to the web. One app that makes extensive use of C/C++ libraries is squoosh, our web app that allows you compress images with a variety of codecs that have been compiled from C++ to WebAssembly.

In my experience, most performance problems on the web are caused by forced layout and excessive paint but every now and then an app needs to do a computationally expensive task that takes a lot of time. WebAssembly can help here.]]></description><guid isPermaLink="false">09067d7b-54fc-4555-9e1f-a6622ea5e390</guid><pubDate>Fri, 15 Feb 2019 07:38:00 +0000</pubDate><dc:creator>Surma</dc:creator></item><item><title>Introducing swc (speedy web compiler) 1.0</title><link>https://swc-project.github.io/blog/2019/02/08/Introducing-swc-1.0</link><description><![CDATA[swc(speedy web compiler) is a super-fast javascript to javascript compiler. It can transpile typescript / jsx / ecmascript 2019 to browser-compatible javascript. It's 16x - 20x faster than babel even on single-core synchronous benchmark. Note that actual performance gap is larger because swc works on worker thread while babel works on event loop thread.]]></description><guid isPermaLink="false">a3541593-fc72-40c3-a4b8-7fdad4cab8fe</guid><pubDate>Fri,  8 Feb 2019 00:00:00 +0000</pubDate><dc:creator>DongYoon Kang</dc:creator></item><item><title>Comparing C and Rust network protocol exercises - Ayende @ Rahien</title><link>https://ayende.com/blog/185859-A/comparing-c-and-rust-network-protocol-exercises?Key=bd1ba87d-6e7e-4739-824d-0ca6fc232b05</link><description><![CDATA[Almost by accident, it turned out that I implemented a pretty simple, but non trivial task in both C and Rust and blogged about them. Now that I’m done with both of them, I thought it would be interesting to talk about the differences in the experiences. The Rust version clocks at exactly 400 lines of code and uses 12 external crates. The C version has 911 lines of C code and another 140 lines in headers and depends on libuv and openssl.]]></description><guid isPermaLink="false">756d2f52-51dd-4408-ae79-3b17c02849e3</guid><pubDate>Tue,  5 Feb 2019 00:00:00 +0000</pubDate><dc:creator>Ayende Rahien</dc:creator></item><item><title>Announcing OOProxy, a reverse OpenID and OAuth2 proxy</title><link>https://medium.com/hal24k-techblog/announcing-ooproxy-b041bab2bc85</link><description><![CDATA[At HAL24K, we benefit a lot from open source software. That is why, to contribute back, we’ve started an internal program to open source some of the internal tools and libraries we’ve used to build our platform and machine learning solutions, starting with OOProxy. OOProxy is a reverse OpenID and OAuth2 proxy that we use to protect our HTTP-based machine learning APIs.]]></description><guid isPermaLink="false">d430867d-388e-4cfb-9e42-698d80876f1c</guid><pubDate>Wed, 30 Jan 2019 14:10:08 +0000</pubDate><dc:creator>Tim Stokman</dc:creator></item><item><title>Embedding WebAssembly in your Rust application</title><link>https://medium.com/wasmer/executing-webassembly-in-your-rust-application-d5cd32e8ce46</link><description><![CDATA[Wasmer is a WebAssembly runtime designed to run both standalone and embedded. The crate wasmer-runtime exposes an easy to use and safe api for compiling, creating imports, and calling WebAssembly from your own library. This tutorial goes over how to make a simple wasm application and run it using the wasmer-runtime!]]></description><guid isPermaLink="false">94fdb740-ae30-402f-9dc5-3f98b6a2753a</guid><pubDate>Thu, 24 Jan 2019 17:20:46 +0000</pubDate><dc:creator>Brandon Fish and Lachlan Sneff</dc:creator></item><item><title>Enjoy a slice of QUIC, and Rust!</title><link>https://blog.cloudflare.com/enjoy-a-slice-of-quic-and-rust/</link><description><![CDATA[During last year’s Birthday Week we announced early support for QUIC, the next generation encrypted-by-default network transport protocol designed to secure and accelerate web traffic on the Internet.

We are not quite ready to make this feature available to every Cloudflare customer yet, but while you wait we thought you might enjoy a slice of quiche, our own open-source implementation of the QUIC protocol written in Rust.]]></description><guid isPermaLink="false">2810bb3d-7b68-42f0-ba5f-5c7a5956caf7</guid><pubDate>Tue, 22 Jan 2019 16:26:07 +0000</pubDate><dc:creator>Alessandro Ghedini</dc:creator></item><item><title>Exporting Serde types to TypeScript</title><link>http://timryan.org/2019/01/22/exporting-serde-types-to-typescript.html</link><description><![CDATA[I built my first web application with Rust and WebAssembly back in 2017. At the time, support for compiling Rust with the wasm32-unknown-unknown target had just landed, letting you run Rust code in the browser with few modifications. The downside was that loading and interacting with WebAssembly might require you to explicitly allocate and track memory. You might even need to manually decode UTF-8 strings in JavaScript:]]></description><guid isPermaLink="false">76ad8f41-d0b9-4789-b45a-5cfa550aa7c3</guid><pubDate>Tue, 22 Jan 2019 16:00:00 +0000</pubDate><dc:creator>Tim Ryan</dc:creator></item><item><title>WebGL + Rust: Basic Water Tutorial</title><link>http://www.chinedufn.com/3d-webgl-basic-water-tutorial/</link><description><![CDATA[In this tutorial we’ll discuss the ideas and concepts behind rendering water and then talk through some demo code.]]></description><guid isPermaLink="false">0cba574e-769b-491e-83de-cfa070b1b942</guid><pubDate>Sun,  6 Jan 2019 13:00:00 -0500</pubDate><dc:creator>Chinedu Francis Nwafili</dc:creator></item><item><title>Rust and WebAssembly in 2019</title><link>http://fitzgeraldnick.com/2018/12/14/rust-and-webassembly-in-2019.html</link><description><![CDATA[Compiling Rust to WebAssembly should be the best choice for fast, reliable code for the Web. Additionally, the same way that Rust integrates with C calling conventions and libraries on native targets, Rust should also integrate with JavaScript and HTML5 on the Web. These are the Rust and WebAssembly domain working group’s core values. In 2018, we made it possible to surgically replace performance-sensitive JavaScript with Rust-generated WebAssembly. I propose that we make larger-scale adoption of Rust and WebAssembly practical in 2019.]]></description><guid isPermaLink="false">f12043be-3b2d-4ab3-8ce1-51463ffad905</guid><pubDate>Fri, 14 Dec 2018 00:00:00 -0800</pubDate><dc:creator>Nick Fitzgerald</dc:creator></item><item><title>Async in Rust, circa 2018</title><link>https://rust-lang-nursery.github.io/wg-net/2018/12/13/async-update.html</link><description><![CDATA[Rust 2018 has shipped, and we’re closing in on the end of the year. While we didn’t manage to ship async/await as part of the edition itself, the community has made quite a lot of progress toward that goal. This post summarizes the state of play, and announces the publication of several crates intended to facilitate use of async/await on the nightly ecosystem.]]></description><guid isPermaLink="false">53c9e07b-f4d5-423f-8a84-05e119814fda</guid><pubDate>Thu, 13 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Aaron Turon</dc:creator></item><item><title>Edge programming with Rust and WebAssembly</title><link>https://www.fastly.com/blog/edge-programming-rust-web-assembly</link><description><![CDATA[Take a developer deep dive into Terrarium, our multi-language, browser-based editor and deployment platform at the edge. Learn how to compile Rust programs to WebAssembly right on your local machine, interact with the Terrarium system, and explore some applications we’ve built with it.]]></description><guid isPermaLink="false">78791a3b-395e-4d3b-b091-66aa2fa2c577</guid><pubDate>Wed, 12 Dec 2018 16:00:00 +0000</pubDate><dc:creator>Pat Hickey</dc:creator></item></channel></rss>