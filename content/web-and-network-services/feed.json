{
  "version": "https://jsonfeed.org/version/1",
  "title": "Read Rust - Web and Network Services",
  "home_page_url": "https://readrust.net/",
  "feed_url": "https://readrust.net/web-and-network-services/feed.json",
  "description": "Web and Network Services posts on Read Rust",
  "author": {
    "name": "Wesley Moore",
    "url": "http://www.wezm.net/"
  },
  "items": [
    {
      "id": "cf201dba-76a2-49e1-a4d9-b28093189901",
      "title": "Announcing Linkerd 2.0: from service mesh to service sidecar",
      "content_text": "The 2.0 release of Linkerd brings two very significant changes. First, we’ve completely rewritten Linkerd to be orders of magnitude faster and smaller than Linkerd 1.x. Linkerd 2.0’s data plane is comprised of ultralight Rust proxies which consume around 10mb of RSS and have a p99 latency of <1ms. Linkerd’s minimalist control plane (written in Go) is similarly designed for speed and low resource footprint.",
      "url": "https://blog.linkerd.io/2018/09/18/announcing-linkerd-2-0/",
      "date_published": "2018-09-18T17:00:00+00:00",
      "author": {
        "name": "William Morgan",
        "url": "https://blog.linkerd.io/"
      },
      "tags": [
        "Web and Network Services"
      ]
    },
    {
      "id": "d72f5483-1247-46d8-8764-7ac5ec0fb2d3",
      "title": "Rust and JavaScript Interop ↔️",
      "content_text": "In recent projects of mine, I’ve been using WebAssembly quite a bit. WebAssembly (Wasm) is “a new binary instruction format for a stack based virtual machine” that lets you use languages besides JavaScript to run code on a web page - usually either for performance reasons or to run code you’d like to share across different platforms. In my opinion, the most promising of these languages, due to its lack of a need for a runtime and great tooling is Rust.",
      "url": "https://blog.ryanlevick.com/posts/wasm-bindgen-interop/",
      "date_published": "2018-09-12T00:00:00+00:00",
      "author": {
        "name": "Ryan Levick",
        "url": "https://blog.ryanlevick.com/"
      },
      "tags": [
        "Web and Network Services"
      ]
    },
    {
      "id": "1461a8b4-863b-40c1-bb2d-0ff077d738e1",
      "title": "Rising Tide: building a modular web framework in the open",
      "content_text": "The Network Services Working Group aims to improve the story for web development this year in several respects: by bolstering foundations like async/await, by improving the ecosystem of web-related crates, and by pulling these pieces together into a framework and book called Tide. The name “Tide” refers to “a rising tide lifts all boats”; the intent is to improve sharing, compatibility, and improvements across all web development and frameworks in Rust.",
      "url": "https://rust-lang-nursery.github.io/wg-net/2018/09/11/tide.html",
      "date_published": "2018-09-11T00:00:00+00:00",
      "author": {
        "name": "Aaron Turon",
        "url": "https://rust-lang-nursery.github.io/wg-net/"
      },
      "tags": [
        "Web and Network Services"
      ]
    },
    {
      "id": "850319b3-4515-4f9c-b833-67a391d5ab26",
      "title": "Programming Servo: A generic “worker event-loop”",
      "content_text": "Let’s take a look at how in Rust you can have an algorithm generic over T, where T is further bound by a trait, which itself is generic over one of several parameters.",
      "url": "https://medium.com/programming-servo/programming-servo-a-generic-worker-event-loop-400a6f113a60",
      "date_published": "2018-09-02T07:03:47.310+00:00",
      "author": {
        "name": "Gregory Terzian",
        "url": "https://medium.com/@polyglot_factotum"
      },
      "tags": [
        "Web and Network Services"
      ]
    },
    {
      "id": "e7fbc029-a108-4209-bbf4-9e152701d9a6",
      "title": "Tower Web — Expanding the middleware stack",
      "content_text": "tower-web version 0.2.2 has been released. It comes with a number of new features, which I will talk about in this post. Primarily, the middleware story is starting to come together. I will be expanding some on how middleware fits into Tower and web in general.",
      "url": "https://medium.com/@carllerche/tower-web-expanding-the-middleware-stack-f9bf55bfa109",
      "date_published": "2018-09-07T14:21:28.473+00:00",
      "author": {
        "name": "Carl Lerche",
        "url": "https://medium.com/@carllerche"
      },
      "tags": [
        "Web and Network Services"
      ]
    },
    {
      "id": "715ee4bf-9164-4c58-aa4f-93f088859281",
      "title": "Benchmarking a Rust web application",
      "content_text": "I set out out my goal 9 for Rustnish: Write benchmark code that compares runtime performance of Rustnish against Varnish. Use cargo bench to execute the benchmarks.\n\nThe basic idea of a performance test here is to send many HTTP requests to the web service (the reverse proxy in this case) and measure how fast the responses arrive back. Comparing the results from Rustnish and Varnish should give us an idea if our performance expectations are holding up.",
      "url": "https://klausi.github.io/rustnish/2018/08/31/benchmarking-a-rust-web-application.html",
      "date_published": "2018-08-31T00:00:00+00:00",
      "author": {
        "name": "klausi",
        "url": "https://klausi.github.io/rustnish/"
      },
      "tags": [
        "Web and Network Services",
        "Performance"
      ]
    },
    {
      "id": "ed925df2-a1c7-4125-a27c-7cbda8dbac71",
      "title": "Programming Servo: the makings of a task-queue",
      "content_text": "In Servo, task-sources are implemented via a channel, whose sender is cloned for each specific task-source, and where tasks are messages sent on the channel and containing a closure representing the actual task.",
      "url": "https://medium.com/programming-servo/programming-servo-the-makings-of-a-task-queue-b4138cd246ca",
      "date_published": "2018-08-28T10:11:58.984+00:00",
      "author": {
        "name": "Gregory Terzian",
        "url": "https://medium.com/@polyglot_factotum"
      },
      "tags": [
        "Web and Network Services"
      ]
    },
    {
      "id": "10c577b9-fdf3-4aa3-80dd-78c6e4abb8c7",
      "title": "From Rust to beyond: The ASM.js galaxy",
      "content_text": "The second galaxy that our Rust parser will explore is the ASM.js galaxy. This post will explain what ASM.js is, how to compile the parser into ASM.js, and how to use the ASM.js module with Javascript in a browser. The goal is to use ASM.js as a fallback to WebAssembly when it is not available. I highly recommend to read the previous episode about WebAssembly since they have a lot in common.",
      "url": "https://mnt.io/2018/08/28/from-rust-to-beyond-the-asm-js-galaxy/",
      "date_published": "2018-08-28T07:39:03+00:00",
      "author": {
        "name": "Ivan Enderlin",
        "url": "https://mnt.io/"
      },
      "tags": [
        "Web and Network Services"
      ]
    },
    {
      "id": "a7804e3a-d98b-4135-9d38-e75aeb294961",
      "title": "Oxidizing sourmash: WebAssembly",
      "content_text": "In \"Oxidizing sourmash: Python and FFI\" I described my road to learn Rust, but something that I omitted was that around the same time the WebAssembly support in Rust started to look better and better and was a huge influence in my decision to learn Rust. Reimplementing the sourmash C++ extension in Rust and use the same codebase in the browser sounded very attractive, and now that it was working I started looking into how to use the WebAssembly target in Rust.",
      "url": "https://blog.luizirber.org/2018/08/27/sourmash-wasm/",
      "date_published": "2018-08-27T15:30:00-03:00",
      "author": {
        "name": "Luiz Irber",
        "url": "https://blog.luizirber.org/"
      },
      "tags": [
        "Web and Network Services"
      ]
    },
    {
      "id": "b1b8abb7-362a-4004-8b6c-913ca1c85773",
      "title": "From Rust to beyond: The WebAssembly galaxy",
      "content_text": "The first galaxy that our Rust parser will explore is the WebAssembly (WASM) galaxy. This post will explain what WebAssembly is, how to compile the parser into WebAssembly, and how to use the WebAssembly binary with Javascript in a browser and with NodeJS.",
      "url": "https://mnt.io/2018/08/22/from-rust-to-beyond-the-webassembly-galaxy/",
      "date_published": "2018-08-22T07:46:27+00:00",
      "author": {
        "name": "Ivan Enderlin",
        "url": "https://mnt.io/"
      },
      "tags": [
        "Web and Network Services"
      ]
    },
    {
      "id": "8b803f70-9098-40d0-97af-5cdff0cde756",
      "title": "Programming Servo: Anatomy of a Fetch",
      "content_text": "Today, let’s go through an entire fetch in Servo, starting with an example in JS.",
      "url": "https://medium.com/programming-servo/anatomy-of-a-fetch-8872a5c843cd",
      "date_published": "2018-08-17T22:29:36.264+00:00",
      "author": {
        "name": "Gregory Terzian",
        "url": "https://medium.com/@polyglot_factotum"
      },
      "tags": [
        "Web and Network Services"
      ]
    },
    {
      "id": "1921a96e-ad32-410f-b0a7-c72dc16d3cde",
      "title": "Rust GraphQL webserver with Warp, Juniper and MongoDB",
      "content_text": "Rust's web frameworks ecosystem is in constant change, but recently a new framework called warp came out implementing a new, original way to solve the old problem of transforming a request into a response, and I wanted to give it a try.\n\nAnd, as I use GraphQL massively at work, I also wanted to check how well Juniper implements it. To add some spice, I used MongoDB as a storage engine instead of the ubiquitous and well-supported SQL databases.",
      "url": "http://alex.amiran.it/post/2018-08-16-rust-graphql-webserver-with-warp-juniper-and-mongodb.html",
      "date_published": "2018-08-16T00:00:00+00:00",
      "author": {
        "name": "/dev/random",
        "url": "http://alex.amiran.it/index.html"
      },
      "tags": [
        "Web and Network Services"
      ]
    },
    {
      "id": "0a12242d-a074-40cd-afa5-ec83c41c3865",
      "title": "paste a full featured pastebin written in Rust",
      "content_text": "A sensible, modern pastebin written in Rust",
      "url": "https://paste.gg/",
      "date_published": "2018-07-16T14:42:15+10:00",
      "author": {
        "name": "Kyle Clemens",
        "url": "https://paste.gg/"
      },
      "tags": [
        "Web and Network Services"
      ]
    },
    {
      "id": "e9ddc1eb-5ab9-4f23-8b9a-a41cea991044",
      "title": "Tower Web 0.2 — Now 100% comment attribute free",
      "content_text": "The short version is, Tower Web 0.2 was just released and regular Rust attributes are now used instead of magic comments. The doc comment is replaced with #[get(\"/\")]. This is thanks to Rust macro wizard David Tolnay. I also thought that it would be best to immediately push out 0.2 and then we can all pretend 0.1 didn’t happen.",
      "url": "https://medium.com/@carllerche/tower-web-0-2-now-100-comment-attribute-free-3ed0633e47e5",
      "date_published": "2018-08-14T16:22:13.075+00:00",
      "author": {
        "name": "Carl Lerche",
        "url": "https://medium.com/@carllerche"
      },
      "tags": [
        "Web and Network Services",
        "Crates"
      ]
    },
    {
      "id": "3bdf428b-c38a-4964-a8f2-a4e0106bd5d1",
      "title": "Ray Tracing: WebAssembly vs JavaScript",
      "content_text": "For the past few months I've been toying about with WebAssembly. The examples I've built using WebAssembly were very simple and could easily have been written in JavaScript with perfectly adequate performance. This got me thinking it's about time I make something to really shows where WebAssembly shines. This led me down the path of thinking about very compute-demanding applications. An obvious example is 3d graphics rendering. Even a small scene like the ones I've been creating involve computing millions of vector dot product calculations per second. This kind of CPU-intensive application seemed right up the street of WebAssembly.",
      "url": "http://matt-harrison.com/raytracing-webassembly-vs-javascript/",
      "date_published": "2018-08-12T14:09:42+00:00",
      "author": {
        "name": "Matt Harrison",
        "url": "http://matt-harrison.com/"
      },
      "tags": [
        "Web and Network Services",
        "Games and Graphics"
      ]
    },
    {
      "id": "47f615b2-5fe1-45a1-b760-9bff19237836",
      "title": "Syntax diagram generator",
      "content_text": "This is a demonstration of a pure-rust library to generate syntax diagrams for macro_rules!().Diagrams are generated fully automatically from rust-source as Scalable Vector Graphics, using customizable CSS for layout.",
      "url": "https://lukaslueg.github.io/macro_railroad_wasm_demo/",
      "date_published": "2018-08-12T15:04:11+00:00",
      "author": {
        "name": "lukaslueg",
        "url": "https://github.com/lukaslueg"
      },
      "tags": [
        "Web and Network Services"
      ]
    },
    {
      "id": "ea6c2f82-fb04-49be-be31-307284eedba4",
      "title": "Tower Web — A new web framework for Rust",
      "content_text": "I previously announced Tower and mentioned that a web framework was in the works. It took longer than I had hoped (as it sometimes does with software), but today, I am opening up Tower Web.\n\nTower Web is an asynchronous HTTP web framework that focuses on removing boilerplate. It is built on top of Tokio, Hyper, and of course Tower. It works today on stable Rust.",
      "url": "https://medium.com/@carllerche/tower-web-a-new-web-framework-for-rust-e2912856851b",
      "date_published": "2018-08-09T17:46:17.217+00:00",
      "author": {
        "name": "Carl Lerche",
        "url": "https://medium.com/@carllerche"
      },
      "tags": [
        "Web and Network Services"
      ]
    },
    {
      "id": "85ab7e93-7bbc-43ef-be5f-5decca1b4651",
      "title": "Introducing PrrrStack, Pt. 2",
      "content_text": "In the first article of this series, we created a RestAPI for our application using Postgres, Rust, and Rocket. For the second half, we’ll be using React to create the front end.",
      "url": "https://medium.com/@ccrsh/introducing-prrrstack-pt-2-24704b5763b2",
      "date_published": "2018-07-09T12:35:32.505+00:00",
      "author": {
        "name": "Crash Springfield",
        "url": "https://medium.com/@ccrsh"
      },
      "tags": [
        "Web and Network Services"
      ]
    },
    {
      "id": "55adde79-edfa-433f-8c4f-40f2baee7cd9",
      "title": "warp",
      "content_text": "Over the past several months, I’ve been working a web framework in Rust. I wanted to make use of the new hyper 0.12 changes, so the framework is just as fast, is asynchronous, and benefits from all the improvements found powering Linkerd. More importantly, I wanted there to be a reason for making a new framework; it couldn’t just be yet another framework with the only difference being I’ve written it. Instead, the way this framework is used is quite different than many that exist. In doing so, it expresses a strong opinion, which might not match your previous experiences, but I believe it manages to do something really special.\n\nI’m super excited to reveal warp, a joint project with @carllerche.",
      "url": "http://seanmonstar.com/post/176530511587/warp",
      "date_published": "2018-08-01T00:00:00+00:00",
      "author": {
        "name": "Sean McArthur",
        "url": "http://seanmonstar.com/"
      },
      "tags": [
        "Web and Network Services",
        "Crates"
      ]
    },
    {
      "id": "6204efce-b9b3-4225-ae6b-5fc74f441d5f",
      "title": "Is WebAssembly the return of Java Applets & Flash?",
      "content_text": "For this post, I’m going to make three comparisons: to Flash, to Java Applets, and occasionally to PNaCL. Secondly, this post is going to focus on the web use-case for WebAssembly, even though the previous post was about non-web uses. We’ll make that comparison in the next post. Finally, this post is kind of like eating tapas, there’s a bunch of little sections.",
      "url": "https://words.steveklabnik.com/is-webassembly-the-return-of-java-applets-flash",
      "date_published": "2018-07-26T00:03:00+00:00",
      "author": {
        "name": "Steve Klabnik",
        "url": "https://words.steveklabnik.com/"
      },
      "tags": [
        "Web and Network Services"
      ]
    },
    {
      "id": "b3d696eb-a5d0-4118-a7b0-328623d35555",
      "title": "A static web app in Rust",
      "content_text": "A three day tour of Yew and WASM with Rust",
      "url": "https://bluejekyll.github.io/blog/rust/2018/07/22/static-web-app-rust.html",
      "date_published": "2018-07-22T07:00:00+00:00",
      "author": {
        "name": "Benjamin Fry",
        "url": "https://bluejekyll.github.io/blog/"
      },
      "tags": [
        "Web and Network Services"
      ]
    },
    {
      "id": "7f8cf89b-0cca-43c6-a660-3780bd2cdf72",
      "title": "Writing a front-end WebAssembly framework in Rust: lessons learned",
      "content_text": "Over the past few months, I’ve been writing Smithy, a very work-in-progress front-end WebAssembly framework written in Rust.\n\nMy goal for Smithy is to enable you to use idiomatic Rust to write front-end code. This has costs: for example worrying about lifetimes and using Rc<RefCell<State>> to share state. But this also has the potential to give you the safety guarantees that the Rust compiler provides when writing browser code!",
      "url": "https://medium.com/@robert.balicki_2494/writing-a-front-end-webassembly-framework-in-rust-lessons-learned-7cc48ed27d96",
      "date_published": "2018-07-30T12:46:05.428+00:00",
      "author": {
        "name": "Robert Balicki",
        "url": "https://medium.com/@robert.balicki_2494"
      },
      "tags": [
        "Web and Network Services"
      ]
    },
    {
      "id": "a928dd6a-2db7-4366-bd96-74134b4094b8",
      "title": "How much of npm can you break?",
      "content_text": "The idea was simple, choose a package and recursively traverse npm to find all of the packages that depend upon it, after all the npm website offers a ‘Dependents’ tab on a package’s page. I had not anticipated the issues that made this an interesting technical problem.",
      "url": "https://mrandri19.github.io/2018/06/24/how-much-of-npm-will-you-break.html",
      "date_published": "2018-06-24T00:00:00+00:00",
      "author": {
        "name": "Andrea Cognolato",
        "url": "https://mrandri19.github.io/blog"
      },
      "tags": [
        "Web and Network Services"
      ]
    },
    {
      "id": "95c003ee-6a87-45cb-abd3-491bd965d65c",
      "title": "Announcing the js-sys crate!",
      "content_text": "The js-sys crate contains raw #[wasm_bindgen] bindings to all the global APIs guaranteed to exist in every JavaScript environment by the ECMAScript standard. It does not contain bindings to any Web- or Node-specific APIs. With the js-sys crate, we can work with Objects, Arrays, Functions, Maps, Sets, etc… without writing the #[wasm_bindgen] imports by hand.",
      "url": "https://rustwasm.github.io/2018/07/26/announcing-the-js-sys-crate.html",
      "date_published": "2018-07-26T00:00:00+00:00",
      "author": {
        "name": "rustwasm",
        "url": "https://rustwasm.github.io/"
      },
      "tags": [
        "Web and Network Services"
      ]
    },
    {
      "id": "a95c25cb-0553-42ee-a81a-4a9cedce53e8",
      "title": "Rust + actix-web power Atlas Weekend music festival",
      "content_text": "We've just finished music festival Atlas Weekend which took place in Kyiv, Ukraine. This year there were for about 450,000 visitors during 6 days. I'm glad to announce that Rust and actix-web are used as a backend for main technical purposes of festival.",
      "url": "https://www.reddit.com/r/rust/comments/8xdsx5/rust_actixweb_in_the_on_of_the_biggest_music/",
      "date_published": "2018-07-10T03:16:52+10:00",
      "author": {
        "name": "/u/maxfrai",
        "url": "https://www.reddit.com/user/maxfrai"
      },
      "tags": [
        "Web and Network Services"
      ]
    },
    {
      "id": "861a1228-9bbd-4d34-b08d-40b191f19abd",
      "title": "The Return of: Can Rust speed up your Azure Functions?",
      "content_text": "A couple of weeks back I started using WASM on Azure’s FaaS (serverless/Functions as a Services) and unexpectedly the Rust version of my simple Monte Carlo estimation was considerably slower than its JavaScript counterpart. Clearly this needs more exploring! This time around the challenges will be harder and more practical. Let’s see how WASM and JavaScript perform.",
      "url": "https://blog.x5ff.xyz/blog/azure-functions-wasm-rust-2/",
      "date_published": "2018-06-25T00:00:00+00:00",
      "author": {
        "name": "Claus",
        "url": "https://blog.x5ff.xyz/blog"
      },
      "tags": [
        "Web and Network Services"
      ]
    },
    {
      "id": "863992ef-fc2b-4235-a8bd-206d55fd416f",
      "title": "actix – a basic TCP client",
      "content_text": "In our last post about actix we introduced you to the Rust programming language and the actix actor framework. This week we will build a basic TCP client with actix.",
      "url": "https://simplabs.com/blog/2018/06/27/actix-tcp-client.html",
      "date_published": "2018-06-27T00:00:00+00:00",
      "author": {
        "name": "Tobias Bieniek",
        "url": "https://simplabs.com/blog/"
      },
      "tags": [
        "Web and Network Services"
      ]
    },
    {
      "id": "a16772c9-e5d4-4e73-8bec-934d8ae183c5",
      "title": "A web application completely in Rust",
      "content_text": "My latest software architectural experiment is to write a complete real-world web application in Rust with as less as boilerplate as possible. Within this post I want to share my findings with you to answer the question on how much web Rust actually is.",
      "url": "https://medium.com/@saschagrunert/a-web-application-completely-in-rust-6f6bdb6c4471",
      "date_published": "2018-07-07T19:58:43.445+00:00",
      "author": {
        "name": "Sascha Grunert",
        "url": "https://medium.com/@saschagrunert"
      },
      "tags": [
        "Web and Network Services"
      ]
    },
    {
      "id": "7d6ed3b9-1295-4331-879f-514cbff7e5ba",
      "title": "Our Vision for wasm-bindgen",
      "content_text": "The last blog post laid out the Rust and WebAssembly domain working group’s overall vision for Rust and WebAssembly. In this blog post, we will dive into the details of wasm-bindgen, the future we envision for it, and how you can help us build that future.",
      "url": "https://rustwasm.github.io/2018/07/02/vision-for-wasm-bindgen.html",
      "date_published": "2018-07-02T00:00:00+00:00",
      "author": {
        "name": "rustwasm",
        "url": "https://rustwasm.github.io/"
      },
      "tags": [
        "Web and Network Services"
      ]
    },
    {
      "id": "c700cc05-51d7-4599-b545-37f4db96f347",
      "title": "Fullstack React: Rust, React and WebAssembly",
      "content_text": "A tutorial on how to compile Rust to WebAssembly and integrate it into a React application",
      "url": "https://www.fullstackreact.com/articles/rust-react-and-web-assembly/",
      "date_published": "2018-07-03T00:00:00+00:00",
      "author": {
        "name": "Anders Pitman",
        "url": "http://anderspitman.net/"
      },
      "tags": [
        "Web and Network Services"
      ]
    },
    {
      "id": "fc0e0a2b-6cec-420d-803c-2ac8770fc9e8",
      "title": "Introducing PrrrStack",
      "content_text": "This is the first part in a two-part introductory series to PRRR Stack (Postgres, Rust, Rocket, React) application.",
      "url": "https://medium.com/@ccrsh/introducing-prrrstack-d617ff518ba6",
      "date_published": "2018-07-02T13:09:58.154+00:00",
      "author": {
        "name": "Crash Springfield",
        "url": "https://medium.com/@ccrsh"
      },
      "tags": [
        "Web and Network Services"
      ]
    },
    {
      "id": "9497ed78-6b59-4dd0-b1f8-725ca3c628d2",
      "title": "Programming Servo: an HTTP cache",
      "content_text": "In our previous post, we saw how combining channels with an event-loop could be a useful technique to ‘drive’ the concurrent logic of your system, and it was hinted at that shared mutable state might be more complicated. A good example of such ‘shared mutable state’ in Servo is the HTTP cache.",
      "url": "https://medium.com/programming-servo/programming-servo-an-http-cache-edb52a7f267f",
      "date_published": "2018-06-29T04:33:13.453+00:00",
      "author": {
        "name": "Gregory Terzian",
        "url": "https://medium.com/@polyglot_factotum"
      },
      "tags": [
        "Web and Network Services"
      ]
    },
    {
      "id": "f8a137b7-ce7d-4553-bcec-6170350dc1f2",
      "title": "Rust with Rocket + Elm running on Heroku",
      "content_text": "I had this goal of making a web app that was very fast, stable and easy to deploy. This is what I was hoping to accomplish: strongly typed server-side and client-side languages (Rust & Elm respectively), push-button deployments to the cloud with free hosting initially, and sub-second response times for API calls and page loads. With this setup, I think I'm well on my way to accomplishing each of these.",
      "url": "http://ethanfrei.com/posts/rust-with-rocket-elm-running-on-heroku.html",
      "date_published": "2018-06-24T00:00:00+00:00",
      "author": {
        "name": "Ethan Frei",
        "url": "http://ethanfrei.com/"
      },
      "tags": [
        "Web and Network Services",
        "DevOps and Deployment"
      ]
    },
    {
      "id": "faf1a345-9eaf-4d00-a7f7-9fa3afaa51ac",
      "title": "Better HTTP Upgrades with hyper",
      "content_text": "Better HTTP Upgrades with hyper It’s been possible to handle HTTP Upgrades (like Websockets) in hyper if you made use of the low-level APIs in the server and client, but it wasn’t especially nice to...",
      "url": "http://seanmonstar.com/post/175280388657/better-http-upgrades-with-hyper",
      "date_published": "2018-06-26T00:00:00+00:00",
      "author": {
        "name": "Sean McArthur",
        "url": "http://seanmonstar.com/"
      },
      "tags": [
        "Web and Network Services",
        "Crates"
      ]
    },
    {
      "id": "645c96b0-5f66-4c4d-a8ee-d145298bc63d",
      "title": "Project Ice Puzzle",
      "content_text": "This game was coded in Rust and is playable in web browsers by means of WebAssembly, WebGL and Howler.js. The software I developed is partly open source in the form of Gate, which is the Rust library that powers this game and can power other similar games. Special thanks to the tools I used to create assets: Gimp, FL Studio and BFXR.",
      "url": "http://www.matthewmichelotti.com/games/project_ice_puzzle/",
      "date_published": "2018-06-25T00:00:00+00:00",
      "author": {
        "name": "Matthew Michelotti",
        "url": "http://www.matthewmichelotti.com/"
      },
      "tags": [
        "Web and Network Services",
        "Games and Graphics"
      ]
    },
    {
      "id": "33738eab-7a95-4e28-b819-f22f8362100e",
      "title": "Our Vision for Rust and WebAssembly",
      "content_text": "Rust and WebAssembly can combine in many delightful ways. To consolidate our efforts and have the largest, most-positive impact we can, the Rust and WebAssembly domain working group is focusing on one vision:\n\nSurgically inserting Rust compiled to WebAssembly should be the best choice for speeding up the most performance-sensitive JavaScript code paths. Do not throw away your existing code base, because Rust plays well with others. Regardless of whether you are a Rust or Web developer, your natural workflow shouldn’t change because Rust compiled to wasm integrates seamlessly into your preferred tools.\n\nThis blog post will expand on these aspirations and describe where we stand in relation to them right now. In a series of follow up posts, we will talk about the next steps for each major component of the Rust and WebAssembly ecosystem.",
      "url": "https://rustwasm.github.io/2018/06/25/vision-for-rust-and-wasm.html",
      "date_published": "2018-06-25T00:00:00+00:00",
      "author": {
        "name": "rustwasm",
        "url": "https://rustwasm.github.io/"
      },
      "tags": [
        "Web and Network Services"
      ]
    },
    {
      "id": "87c1e68b-e1e6-44d5-be4b-212eb2bdc88f",
      "title": "Streaming gRPC with Rust",
      "content_text": "Lately I’ve been working on a side project that involves aggregating the indexes of media libraries and allowing one library to “lend” a file to another. For example, I might use this system if I want my home tower to “lend” a file to my laptop before I get on a plane. I’ll be committing my work-in-progress on this project to github shortly (just want to get an MVP working first and do some refactoring), but I thought I would take a step back for a moment and share my thoughts on one aspect of this project: gRPC. In particular: gRPC streaming.",
      "url": "https://medium.com/@KevinHoffman/streaming-grpc-with-rust-d978fece5ef6",
      "date_published": "2018-06-20T17:43:39.699+00:00",
      "author": {
        "name": "Kevin Hoffman",
        "url": "https://medium.com/@KevinHoffman"
      },
      "tags": [
        "Web and Network Services"
      ]
    },
    {
      "id": "4ebce195-067c-45fa-be45-7c589426953b",
      "title": "Writing a Web API Client in Rust (Part 3)",
      "content_text": "The 3rd of a multi-part series where we build a small REST client for the Marvel Comics Web API using Rust. This time we focus on how to use the hyper and futures crates to make HTTP requests to a Web API, then use serde to parse JSON data from the response.",
      "url": "https://theomn.com/rust-web-api-client-part-03/",
      "date_published": "2018-06-17T00:00:00+00:00",
      "author": {
        "name": "Owen Nelson",
        "url": "https://theomn.com/"
      },
      "tags": [
        "Web and Network Services"
      ]
    },
    {
      "id": "36eccf86-2b85-4ffc-b7e7-7af422cb10ac",
      "title": "Conspiracies, Dissemination, and REST APIs",
      "content_text": "Welcome to the third post in a series where I share my experience learning Rust. I’m building out a conspiracy theories API to help me get more familiar with Rust and have a little fun. Since I am new to Rust, I welcome all feedback, especially from developers who have been using Rust for quite some time. Leave a comment below or send your feedback via Twitter. Now it’s time to draw the blackout curtains, put on your foil-lined hat on and start serving up conspiracies from a REST API.",
      "url": "https://medium.com/@rippinrobr_66849/3-conspiracies-dissemination-and-rest-apis-41858f8d9850",
      "date_published": "2018-06-14T12:28:03.863+00:00",
      "author": {
        "name": "Rob Rowe",
        "url": "https://medium.com/@rippinrobr_66849"
      },
      "tags": [
        "Web and Network Services"
      ]
    },
    {
      "id": "a9263a5d-5853-4f5b-8556-28d18dda0f7d",
      "title": "actix – an actor framework for the Rust programming language",
      "content_text": "The “actor model” is the main primitive that powers the Erlang programming language and its descendant, Elixir. It describes a programming model that simplifies the development of concurrent and multi-threaded applications or even applications that run distributed on multiple machines.\n\nThe complexity of actors is relatively low, and that is because the complexity is usually hidden in the actor frameworks that are used to run these types of primitives in the end. One example of such an actor framework is actix, which we will have a closer look at now.",
      "url": "https://simplabs.com/blog/2018/06/11/actix.html",
      "date_published": "2018-06-11T00:00:00+00:00",
      "author": {
        "name": "Tobias Bieniek",
        "url": "https://simplabs.com/blog/"
      },
      "tags": [
        "Web and Network Services"
      ]
    },
    {
      "id": "70c7595e-f384-40d3-a8c9-9f00466fe5d5",
      "title": "Actix::From(Rocket)",
      "content_text": "I was inspired by Nick’s post to migrate my code from Rocket to Actix. I have also been nagged by recent struggles with the nightly compiler and its compatibility with all the other crates that I use and other the platforms that I use; my code runs on 32⁄64 bit arm and 32⁄64 bit x86. When I started using Rocket around a year ago, the nightly compiler was just as stable as the stable compiler, but things have changed as rust is a growing eco system.\n\nFor me, once the differences below were addressed, porting the code was relatively straightforward. The vast majority of my code remained the same.",
      "url": "https://noyez.gitlab.io/post/2018-06-11-rocket-to-actix/",
      "date_published": "2018-06-11T00:00:00+00:00",
      "author": {
        "name": "noyez",
        "url": "https://noyez.gitlab.io/"
      },
      "tags": [
        "Web and Network Services"
      ]
    },
    {
      "id": "86c89dda-a4f0-45bd-a0d0-616b8d687957",
      "title": "Writing a Simple Github Webhook Responder With actix-web",
      "content_text": "Creating a simple web service for automating Travis builds across repositories using actix-web and Github webhooks.",
      "url": "http://danielwelch.github.io/rust-web-service.html",
      "date_published": "2018-05-31T11:05:00-04:00",
      "author": {
        "name": "Daniel Welch",
        "url": "http://danielwelch.github.io/"
      },
      "tags": [
        "Web and Network Services"
      ]
    },
    {
      "id": "9bf3f488-ace2-43b6-9f6b-3071241f7ed2",
      "title": "hyper v0.12",
      "content_text": "Today sees the release of hyper v0.12.0, a fast and correct HTTP library for the Rust language.\n\nThis release adds support for several new features, while taking the opportunity to fix some annoyances, and improve the extreme speeds!",
      "url": "http://seanmonstar.com/post/174480374517/hyper-v012",
      "date_published": "2018-06-01T00:00:00+00:00",
      "author": {
        "name": "Sean McArthur",
        "url": "http://seanmonstar.com/"
      },
      "tags": [
        "Web and Network Services",
        "Crates"
      ]
    },
    {
      "id": "d7340b81-5e94-4123-b830-c5cbbfa154d2",
      "title": "HTTP Crate with URL Support & a Simple HTTP Client",
      "content_text": "While the http crate generally has a great API I have been unsatisfied how it handles URLs. To create a HTTP request a full URL is needed with a scheme (http/https), authority (example.org) and a path (/search?q=rust) but http does enforce this and allows you to only state the path. This means both clients and servers are either unable to determine protocol and and authority information or have to do this manually.",
      "url": "https://pyfisch.org/blog/http-with-url/",
      "date_published": "2018-06-01T00:00:00+00:00",
      "author": {
        "name": "Pyfisch",
        "url": "https://pyfisch.org/blog/"
      },
      "tags": [
        "Web and Network Services",
        "Crates"
      ]
    },
    {
      "id": "342c3a2c-88a7-4e26-a6ea-97c3257daf2d",
      "title": "Mix Rust Code (WebAssembly) with Vue Component",
      "content_text": "In this tutorials, we will try mixing Rust code with Javascript by compiling Rust code as .wasm then use it in Vue Component.",
      "url": "https://busy.org/@drsensor/mix-rust-code-webassembly-with-vue-component-basic",
      "date_published": "2018-05-24T19:01:00+00:00",
      "author": {
        "name": "drsensor",
        "url": "https://busy.org/@drsensor"
      },
      "tags": [
        "Web and Network Services"
      ]
    },
    {
      "id": "e67229c7-9d09-49e8-9558-ca8e89a53d4f",
      "title": "Snowhash in Rust with WASM",
      "content_text": "A little while ago I came across this Snowflake generator. It’s a project by Raph Levein that takes a hash string and uses it to procedurally generate a unique snowflake. He explains that the original motivation was as a cryptographically secure visual hash, so that people would reliably be able to tell by visual inspection whether two hashes were identical. I thought that was a pretty cool idea.",
      "url": "https://joshleeb.com/posts/rust-wasm-snowhash/",
      "date_published": "2018-05-22T00:00:00+00:00",
      "author": {
        "name": "Josh Leeb-du Toit",
        "url": "https://joshleeb.com/posts"
      },
      "tags": [
        "Web and Network Services"
      ]
    },
    {
      "id": "4b44fb81-4b16-4681-a09a-a93cb82ccbc0",
      "title": "Wicked Fast Web Servers in Rust",
      "content_text": "I write code for the web every day, and as such, I naturally wanted to find a web server that I could write some beautiful code in Rust with. There are a few options out there, Actix, Rocket, but none of them are quite as simple and succinct as KoaJS for node. As such, I wanted to write something as simple as Koa and as performant as a Rust framework, and I did. With that, I give you Thruster, an elegant, performant, web server written in Rust.",
      "url": "https://medium.com/@MertzAlertz/wicked-fast-web-servers-in-rust-4947688426bc",
      "date_published": "2018-05-22T23:26:19.855+00:00",
      "author": {
        "name": "Pete Mertz",
        "url": "https://medium.com/@MertzAlertz"
      },
      "tags": [
        "Web and Network Services"
      ]
    },
    {
      "id": "502f20f5-50e1-4741-a852-2c65ef867bba",
      "title": "Writing a Web API Client in Rust (Part 2)",
      "content_text": "The 2nd of a multi-part series where we build a small REST client for the Marvel Comics Web API using Rust. This time we focus on how to use the hyper and futures crates to make HTTP requests to a Web API, then use serde to parse JSON data from the response.",
      "url": "https://theomn.com/rust-web-api-client-part-02/",
      "date_published": "2018-05-19T00:00:00+00:00",
      "author": {
        "name": "Owen Nelson",
        "url": "https://theomn.com/"
      },
      "tags": [
        "Web and Network Services"
      ]
    },
    {
      "id": "35d0dec8-e4fb-4be0-b87c-ed5dd39056b8",
      "title": "Migrating to Actix Web from Rocket for Stability",
      "content_text": "I previously wrote an article back in November 2017: Replacing Elasticsearch with Rust and SQLite. In it, I needed to create a few HTTP endpoints that ingested JSON, perform a database lookup, and return JSON. Very simple. No query / path parameters, authentication, authorization, H2, or TLS. I didn’t understand how stability was such an important feature. I was familiar with needing new versions of the nightly compiler to stay current with clippy and rustfmt, but it was a blindspot when it came to dependencies.",
      "url": "https://nbsoftsolutions.com/blog/migrating-to-actix-web-from-rocket-for-stability",
      "date_published": "2018-05-21T00:00:00+00:00",
      "author": {
        "name": "Nick Babcock",
        "url": "https://nbsoftsolutions.com/"
      },
      "tags": [
        "Web and Network Services"
      ]
    },
    {
      "id": "f993c9a2-3b8e-455b-ad6e-354051f38863",
      "title": "Creating a Rusty Rocket fuelled with Diesel",
      "content_text": "Here I go with my first post that fully focuses on Rust. After spending a few months doing a bit here and there I decided to just dive right in as I was going through the Rust book at too slow a pace to keep myself interested. So, in this post I decided to write about setting up a simple REST API which is something that I have done in Java plenty of times but with Rust it is a different story.",
      "url": "https://lankydanblog.com/2018/05/20/creating-a-rusty-rocket-fuelled-with-diesel/",
      "date_published": "2018-05-20T17:53:11+00:00",
      "author": {
        "name": "Dan Newton",
        "url": "https://lankydanblog.com/"
      },
      "tags": [
        "Web and Network Services"
      ]
    },
    {
      "id": "58fff202-4974-4db4-93ef-ad074e609a70",
      "title": "A Small Rust API with Actix",
      "content_text": "I had the need for a very small API for this website. So small, in fact, that only one endpoint was required. I've been doing a lot of development in Rust lately, so naturally Rust seemed like a good candidate to build this API in. I also wanted to try out a newer Rust web framework called Actix web. It claims to be a \"small, pragmatic, and extremely fast rust web framework\", which sounded perfect for what I needed.",
      "url": "https://stevezeidner.com/blog/rust-actix-api/",
      "date_published": "2018-05-10T00:00:00+00:00",
      "author": {
        "name": "Steve Zeidner",
        "url": "https://stevezeidner.com/blog"
      },
      "tags": [
        "Web and Network Services"
      ]
    },
    {
      "id": "7f406b9a-226a-4498-b708-59b14401a9af",
      "title": "Making microservices in Rust",
      "content_text": "This is a small idea that I have been wanting to put together for quite some time now and finally have managed to get the time and most importantly experience in Rust to finally try something a little more than just small projects. One area that I think Rust is really making a decent headway in in the web domain, which I am assuming is likely due to its origin from Firefox. So I wanted to see if I could put together a really basic CRUD micro-service doing the ever so original TODO functionality.",
      "url": "https://maccoda.github.io/rust-web-frameworks/",
      "date_published": "2018-05-01T00:00:00+00:00",
      "author": {
        "name": "Dylan Maccora",
        "url": "https://maccoda.github.io/"
      },
      "tags": [
        "Web and Network Services"
      ]
    },
    {
      "id": "2cf6bb87-842b-4d53-906d-6036d7e3eaf5",
      "title": "Can Rust speed up your Azure Functions?",
      "content_text": "Using Rust on Microsoft Azure Functions with web assembly",
      "url": "https://blog.x5ff.xyz/blog/azure-functions-wasm-rust/",
      "date_published": "2018-04-30T00:00:00+00:00",
      "author": {
        "name": "Claus",
        "url": "https://blog.x5ff.xyz/blog"
      },
      "tags": [
        "Web and Network Services"
      ]
    },
    {
      "id": "91fb984c-4084-4b2c-84e5-ebda94169657",
      "title": "WASM+Rust Tutorial",
      "content_text": "A project used for a meetup talk about getting started with rust & wasm",
      "url": "https://freemasen.github.io/wasm_tutorial/",
      "date_published": "2018-05-03T07:30:00+10:00",
      "author": {
        "name": "Robert Masen",
        "url": "https://github.com/FreeMasen"
      },
      "tags": [
        "Getting Started",
        "Web and Network Services"
      ]
    },
    {
      "id": "64356c91-6a6c-40d2-acd9-cbde11eaace4",
      "title": "Using LLVM from Rust, to generate WebAssembly",
      "content_text": "Hopefully this post helps jumpstart those who want to use LLVM from Rust. I also include how one could use this to generate WebAssembly, but the first part of this post is target platform agnostic.",
      "url": "https://medium.com/@jayphelps/using-llvm-from-rust-to-generate-webassembly-93e8c193fdb4",
      "date_published": "2018-04-29T00:49:36.802+00:00",
      "author": {
        "name": "Jay Phelps",
        "url": "https://medium.com/@jayphelps"
      },
      "tags": [
        "Web and Network Services"
      ]
    },
    {
      "id": "2925c583-7c70-400d-8f50-f8c06b3dc0fb",
      "title": "How does dynamic dispatch work in WebAssembly?",
      "content_text": "C, C++, and Rust all have some capability for dynamic dispatch: function pointers, virtual methods, and trait objects. On native targets like x86, all these forms compile down into a jump to a dynamic address. What do these forms compile down into when targeting WebAssembly?",
      "url": "http://fitzgeraldnick.com/2018/04/26/how-does-dynamic-dispatch-work-in-wasm.html",
      "date_published": "2018-04-26T00:00:00-07:00",
      "author": {
        "name": "Nick Fitzgerald",
        "url": "http://fitzgeraldnick.com/"
      },
      "tags": [
        "Web and Network Services"
      ]
    },
    {
      "id": "43c290f5-4178-431d-9874-5e24cde01299",
      "title": "Hello wasm-pack!",
      "content_text": "wasm-pack is a tool for assembling and packaging Rust crates that target WebAssembly. These packages can be published to the npm Registry and used alongside other packages. This means you can use them side-by-side with JS and other packages, and in many kind of applications, be it a Node.js server side app, a client-side application bundled by Webpack, or any other sort of application that uses npm dependencies. You can find wasm-pack on crates.io and GitHub.",
      "url": "https://hacks.mozilla.org/2018/04/hello-wasm-pack/",
      "date_published": "2018-04-18T14:54:13+00:00",
      "author": {
        "name": "Ashley Williams",
        "url": "https://hacks.mozilla.org/"
      },
      "tags": [
        "Web and Network Services"
      ]
    },
    {
      "id": "69dd67c0-ef9b-4a6c-9a60-2de96c36113a",
      "title": "How To Optimize JavaScript Code with Rust Part 1",
      "content_text": "In the first part of this Rust series, we’re going to walk through setting up Rust, writing Rust code, exporting the code, and using the code in our Node environment. By the end of this article, you’ll see how painless marrying Rust with JavaScript is.",
      "url": "https://codeburst.io/how-to-optimize-javascript-code-with-rust-part-1-20f00885608f",
      "date_published": "2018-04-16T12:04:37.323+00:00",
      "author": {
        "name": "Raji Ayinla",
        "url": "https://codeburst.io/@rajiayinla858"
      },
      "tags": [
        "Web and Network Services"
      ]
    },
    {
      "id": "d65aaebc-e17b-421b-86e8-1cc9c63a0408",
      "title": "Writing An NES Emulator with Rust and WebAssembly",
      "content_text": "I wrote the NES emulator with Rust and WebAssembly to learn Rust. It’s not perfect and have some audio bugs, but it’s good enough to play Super Mario bros.",
      "url": "https://medium.com/@bokuweb17/writing-an-nes-emulator-with-rust-and-webassembly-d64de101c49d",
      "date_published": "2018-04-11T14:30:56.719+00:00",
      "author": {
        "name": "bokuweb",
        "url": "https://medium.com/@bokuweb17"
      },
      "tags": [
        "Games and Graphics",
        "Web and Network Services"
      ]
    },
    {
      "id": "fc25e5f3-66d9-429d-8ca8-c1882a5083d6",
      "title": "JavaScript Interop with WebAssembly",
      "content_text": "In my last post I provided an introduction to WebAssembly — what is it, why do we care, and what does it look like? In this post, I’d like to explore a little bit of the inner workings of how we can communicate between Rust (wasm) and JavaScript. As I mentioned in the last post, WebAssembly is neither JavaScript nor some strongly-typed dialect. It is a standalone, compiled, portable binary. How you send data into and get data out of that binary involves some subtle nuances about how WebAssembly works.",
      "url": "https://medium.com/@KevinHoffman/javascript-interop-with-webassembly-2c69a3db19e9",
      "date_published": "2018-04-12T14:14:05.684+00:00",
      "author": {
        "name": "Kevin Hoffman",
        "url": "https://medium.com/@KevinHoffman"
      },
      "tags": [
        "Web and Network Services"
      ]
    },
    {
      "id": "a89cb196-c162-4c49-b1d5-642547265f39",
      "title": "The case for deadlines",
      "content_text": "Rust aims to be the foundation of fast and robust software. A thorn in that side is the choice of timeout-centric APIs for I/O and multithreading. I posit this was a bad choice and it needs to be remedied as soon as possible before more APIs proliferate this (possibly accidental) design decision.",
      "url": "https://gist.github.com/alkis/9510a840f1965185ab0a02cb59761dd8",
      "date_published": "2018-04-10T06:28:29+00:00",
      "author": {
        "name": "Alkis Evlogimenos",
        "url": "https://gist.github.com/alkis"
      },
      "tags": [
        "Web and Network Services"
      ]
    },
    {
      "id": "61846190-2e41-4590-95c0-172d767aacc1",
      "title": "Getting Yew to work with Rust on ‘Bash on Ubuntu on Windows’",
      "content_text": "Yew is a new web framework written in Rust that takes concepts from React JS and Elm. It takes the two web libraries I love and combines them with the new language I love — Rust. I wrote this article because I haven’t found a lot of documentation online on how to get the Yew examples running, and I’m sure there will be people that will run into the same problems I did. I wrote this in hopes that it helps someone out there.",
      "url": "https://medium.com/@raymondsiu/getting-yew-to-work-with-rust-on-bash-on-ubuntu-on-windows-in-windows-10-790a006e6805",
      "date_published": "2018-04-08T23:14:01.202+00:00",
      "author": {
        "name": "Raymond Siu",
        "url": "https://medium.com/@raymondsiu"
      },
      "tags": [
        "Web and Network Services"
      ]
    },
    {
      "id": "9c6d2c06-5031-414d-b743-850c4ddebdc3",
      "title": "Cloudflare Argo Tunnel with Rust+Raspberry Pi",
      "content_text": "Serving content from a Rust web server running on a Raspberry Pi from your home to the world, with a Cloudflare Argo Tunnels.",
      "url": "https://blog.cloudflare.com/cloudflare-argo-tunnel-with-rust-and-raspberry-pi/",
      "date_published": "2018-04-06T14:00:00+00:00",
      "author": {
        "name": "Steven Pack",
        "url": "https://blog.cloudflare.com/"
      },
      "tags": [
        "Web and Network Services"
      ]
    },
    {
      "id": "8c1bc2c9-1eeb-4a19-ac6b-d11e2a7c6f63",
      "title": "Welcome to this week in Rust and WebAssembly!",
      "content_text": "Hello and welcome to the first issue of This Week in Rust and WebAssembly! Rust is a systems language pursuing the trifecta: safety, concurrency, and speed. WebAssembly is designed as a portable target for compilation of high-level languages like C, C++, and Rust, enabling deployment on the web for client and server applications. This is a weekly summary of its progress and community.",
      "url": "https://rustwasm.github.io/2018/04/05/welcome-to-this-week-in-rust.html",
      "date_published": "2018-04-05T00:00:00+00:00",
      "author": {
        "name": "Sendil Kumar N",
        "url": "https://rustwasm.github.io/"
      },
      "tags": [
        "Web and Network Services"
      ]
    },
    {
      "id": "0ea6b48d-d3a3-4969-a053-37d6e697de85",
      "title": "Announcing Tower — A library for writing robust network services with Rust",
      "content_text": "Tower is a library for writing robust network services with Rust. It is being built in service of the Conduit proxy, which is using the Tokio ecosystem to build the world’s smallest, fastest, most secure network proxy. Tower will also provide a batteries included experience for implementing HTTP and gRPC services.",
      "url": "https://medium.com/@carllerche/announcing-tower-a-library-for-writing-robust-network-services-with-rust-67273f052c40",
      "date_published": "2018-04-06T19:40:38.816+00:00",
      "author": {
        "name": "Carl Lerche",
        "url": "https://medium.com/@carllerche"
      },
      "tags": [
        "Web and Network Services"
      ]
    },
    {
      "id": "fc550900-512d-4f82-b40a-25a8ef86d513",
      "title": "Using Rust Modules in JavaScript/Web Development (Part 3/ 3) [NodeJS]",
      "content_text": "Please read the Part 1 of the series here :",
      "url": "https://medium.com/@atulanand94/using-rust-modules-for-javascript-web-development-part-3-3-nodejs-7c71e4ae23fe",
      "date_published": "2018-04-03T14:29:28.389+00:00",
      "author": {
        "name": "Atul",
        "url": "https://medium.com/@atulanand94"
      },
      "tags": [
        "Web and Network Services"
      ]
    },
    {
      "id": "14922be0-52bc-4711-9fc1-aeec98e39c1d",
      "title": "Making a 100% Statically-Linked, Single-File Web App with React and Rust",
      "content_text": "This tutorial will cover the basics of creating a minimal React app which can be deployed as a statically-linked Rust binary. What this accomplishes is having all of your code, including HTML, JavaScript, CSS, and Rust, packaged into a single file that will run on pretty much any 64-bit Linux system, regardless of the kernel version or installed libraries.",
      "url": "https://anderspitman.net/2018/04/04/static-react-rust-webapp/",
      "date_published": "2018-04-04T21:21:00+00:00",
      "author": {
        "name": "Anders Pitman",
        "url": "https://anderspitman.net/"
      },
      "tags": [
        "Web and Network Services"
      ]
    },
    {
      "id": "37aa0f60-d86c-446d-848c-52b45777ae2c",
      "title": "Using Rust Modules in JavaScript/Web Development (Part 2 / 3) [Webpack]",
      "content_text": "Part 1 of the post was primarily concerned with integrating rust modules with JavaScript with the help of wasm. But that involved a lot of manual procedures. Another more streamlined way is using webpack.",
      "url": "https://medium.com/@atulanand94/using-rust-modules-for-javascript-web-development-part-2-7a86eaec5ee9",
      "date_published": "2018-04-03T10:15:39.331+00:00",
      "author": {
        "name": "Atul",
        "url": "https://medium.com/@atulanand94"
      },
      "tags": [
        "Web and Network Services"
      ]
    },
    {
      "id": "98f65a4a-8501-45e4-bda8-48d5d01306ba",
      "title": "Improving GStreamer performance with tokio",
      "content_text": "For one of our customers at Centricular we were working on a quite interesting project. Their use-case was basically to receive an as-high-as-possible number of audio RTP streams over UDP, transcode them, and then send them out via UDP again. Due to how GStreamer usually works, they were running into some performance issues.\n\nThis blog post will describe the first set of improvements that were implemented for this use-case, together with a minimal benchmark and the results. My colleague Mathieu will follow up with one or two other blog posts with the other improvements and a more full-featured benchmark.\n\nThe short version is that CPU usage decreased by about 65-75%, i.e. allowing 3-4x more streams with the same CPU usage. Also parallelization works better and usage of different CPU cores is more controllable, allowing for better scalability. And a fixed, but configurable number of threads is used, which is independent of the number of streams.",
      "url": "https://coaxion.net/blog/2018/04/improving-gstreamer-performance-on-a-high-number-of-network-streams-by-sharing-threads-between-elements-with-rusts-tokio-crate/",
      "date_published": "2018-04-05T15:21:06+00:00",
      "author": {
        "name": "Sebastian Dröge",
        "url": "https://coaxion.net/blog/"
      },
      "tags": [
        "Web and Network Services",
        "Performance"
      ]
    },
    {
      "id": "0cb16bc7-daff-4747-81e5-d4455d33fc43",
      "title": "HTTP upgrades with hyper",
      "content_text": "The newest release of hyper includes some lower-level connection APIs for both the server and client. Notably, this allows using hyper send and receive HTTP upgrade requests. The most popular of these is Websockets.",
      "url": "http://seanmonstar.com/post/172531530657/http-upgrades-with-hyper",
      "date_published": "2018-04-02T14:34:53-07:00",
      "author": {
        "name": "Sean McArthur",
        "url": "http://seanmonstar.com/"
      },
      "tags": [
        "Web and Network Services",
        "Crates"
      ]
    },
    {
      "id": "229aab36-08f5-4288-a9df-c804ad6c2b56",
      "title": "Using Rust Modules in JavaScript/Web Development (Part 1 / 3) [Plain JS]",
      "content_text": "One of the promising reasons I started learning rust is that it can be used to build modules for web using web-assembly. This blog post will cover how you can build a rust module and use it as regular package in the JavaScript environment. Remember rust is not meant to replace JS. I see it as complementary add-on to the places where JS is comparatively slower (heavy computations).",
      "url": "https://medium.com/@atulanand94/using-rust-modules-for-javascript-web-development-part-i-e6dec27df7b2",
      "date_published": "2018-04-03T06:22:23.753+00:00",
      "author": {
        "name": "Atul",
        "url": "https://medium.com/@atulanand94"
      },
      "tags": [
        "Web and Network Services"
      ]
    },
    {
      "id": "d110dc0e-7a78-42c3-8326-5b5ec58f8875",
      "title": "JavaScript to Rust and Back Again: A wasm-bindgen Tale",
      "content_text": "Recently we’ve seen how WebAssembly is incredibly fast to compile, speeding up JS libraries, and generating even smaller binaries. We’ve even got a high-level plan for better interoperability between the Rust and JavaScript communities, as well as other web programming languages. As alluded to in that previous post, I’d like to dive into more detail about a specific component, wasm-bindgen.",
      "url": "https://hacks.mozilla.org/2018/04/javascript-to-rust-and-back-again-a-wasm-bindgen-tale/",
      "date_published": "2018-04-04T14:58:40+00:00",
      "author": {
        "name": " Alex Crichton",
        "url": "https://hacks.mozilla.org/"
      },
      "tags": [
        "Web and Network Services"
      ]
    },
    {
      "id": "d14f3e75-4047-441e-a67b-fc0de042845a",
      "title": "Removing Connection State In mob",
      "content_text": "I started writing mob, an multi-echo server using mio, in 2015. I coded mob into a mostly working state and then left it mostly alone, only updating it to work with the latest stable mio. Recently, I started looking at the code again and had the urge to improve it. In a previous post, I talked about managing the state of connections in mob. In this post, I will walk through what I did to remove the need to track connection state. I wanted to remove the state because the implementation required an O(n) operation every tick of the mio event loop. It also added a fair amount of complexity to the code.",
      "url": "http://hermanradtke.com/2018/03/29/removing-connection-state-from-mob.html",
      "date_published": "2018-03-29T00:00:00+00:00",
      "author": {
        "name": "Herman J. Radtke III",
        "url": "http://hermanradtke.com/"
      },
      "tags": [
        "Language",
        "Web and Network Services"
      ]
    },
    {
      "id": "07825eb3-aaab-46c5-b7e4-680857d73750",
      "title": "Rust + Node.js are awesome!",
      "content_text": "Blazing fast, low requirements, computationally intensive operations on Node.js using Rust",
      "url": "https://itnext.io/rust-node-js-are-awesome-a50d63411773",
      "date_published": "2018-03-27T21:50:20.148+00:00",
      "author": {
        "name": "Benjamín Calderón",
        "url": "https://itnext.io/@benjcal"
      },
      "tags": [
        "Web and Network Services",
        "Performance"
      ]
    },
    {
      "id": "9f012379-d71a-4c45-b9db-12c4871070e7",
      "title": "Touring a Fast, Safe, and Complete(ish) Web Service in Rust",
      "content_text": "For years now, I’ve been having a crisis of faith in interpreted languages. They’re fast and fun to work in at small scale, but when you have a project that gets big, their attractive veneer quickly washes away. A big Ruby or JavaScript (just to name a few) program in production is a never ending game of whack-a-mock – you fix one problem only to find a new one somewhere else. No matter how many tests you write, or how well-disciplined your team, any new development is sure to introduce a stream of bugs that will need to be shored up over the course of months or years.\n\nCentral to the problem are the edges. People will reliably do a good job of building and testing the happy paths, but as humans we’re terrible at considering the edge conditions, and it’s those edges and corners that cause trouble over the years that a program is in service.",
      "url": "https://brandur.org/rust-web",
      "date_published": "2018-03-27T14:45:57+00:00",
      "author": {
        "name": "Brandur Leach",
        "url": "https://brandur.org"
      },
      "tags": [
        "Web and Network Services"
      ]
    },
    {
      "id": "e32bb679-4afa-48d9-ab51-d589a590348e",
      "title": "Building a Restful CRUD API with Rust",
      "content_text": "Since my initial Node/Rust REST comparison, I’ve wanted to follow up with a comprehensive guide for getting simple CRUD operations up and running in Rust.",
      "url": "https://medium.com/sean3z/building-a-restful-crud-api-with-rust-1867308352d8",
      "date_published": "2018-03-19T04:29:33.114+00:00",
      "author": {
        "name": "Sean Wragg",
        "url": "https://medium.com/@sean3z"
      },
      "tags": [
        "Web and Network Services"
      ]
    },
    {
      "id": "dae19f32-236c-4329-b26d-e6c47b2631d3",
      "title": "Multicasting in Rust",
      "content_text": "A brief post to help others multicast in Rust",
      "url": "https://bluejekyll.github.io/blog/rust/2018/03/18/multicasting-in-rust.html",
      "date_published": "2018-03-18T07:00:00+00:00",
      "author": {
        "name": "Benjamin Fry",
        "url": "https://bluejekyll.github.io/blog/"
      },
      "tags": [
        "Web and Network Services"
      ]
    },
    {
      "id": "44e96573-f8b3-4577-8a76-1cbc8a65ec8b",
      "title": "Building a DNS server in Rust",
      "content_text": "With the combined goal of gaining a deep understanding of DNS, of doing something interesting with Rust, and of scratching some of my own itches, I originally set out to implement my own DNS server. This document is not a truthful chronicle of that journey, but rather an idealized version of it, without all the detours I ended up taking. We'll gradually implement a full DNS server, starting from first principles.",
      "url": "https://github.com/EmilHernvall/dnsguide",
      "date_published": "2018-03-16T00:00:00+00:00",
      "author": {
        "name": "Emil Hernvall",
        "url": "https://github.com/EmilHernvall"
      },
      "tags": [
        "Web and Network Services"
      ]
    },
    {
      "id": "39f186f6-b177-43e6-9b4c-7ffe689926e7",
      "title": "Parc3l: Combining Three.js, Rust, and WebAssembly!",
      "content_text": "WebAssembly has been interesting me lately, specifically the prospect of doing arithmetically-intensive operations with it, not unlike the fantastic physics engine Emscripten port Ammo.js. Compiling something like that is out of the scope of this little post (but should be getting easier!), and I’ve left some links at the bottom so you can clear more about WebAssembly if you’re interested.",
      "url": "https://medium.com/@cwervo/parc3l-combining-three-js-rust-and-webassembly-c1e643ef7681",
      "date_published": "2018-03-12T14:34:23.064+00:00",
      "author": {
        "name": "Andres Cuervo",
        "url": "https://medium.com/@cwervo"
      },
      "tags": [
        "Web and Network Services"
      ]
    },
    {
      "id": "bf12d6fd-0aea-4d74-b3a7-02a538d210d3",
      "title": "Making WebAssembly better for Rust & for all languages",
      "content_text": "To be a useful as a web language, Rust needs to work well with the JavaScript ecosystem. We have some work to do to get there, and fortunately that work ...",
      "url": "https://hacks.mozilla.org/2018/03/making-webassembly-better-for-rust-for-all-languages/",
      "date_published": "2018-03-14T15:02:52+00:00",
      "author": {
        "name": "Lin Clark",
        "url": "http://code-cartoons.com/"
      },
      "tags": [
        "Web and Network Services"
      ]
    },
    {
      "id": "4d94c5ba-199d-44c2-9148-7a6bbff699d0",
      "title": "Crashing a Rust Hyper server with a Denial of Service attack",
      "content_text": "I’m writing a reverse proxy in Rust using Hyper and I want to measure performance a bit to know if I’m doing something terribly wrong. By doing that I discovered a Denial of Service vulnerability in Hyper when IO errors are not properly handled. Note that a workaround has been released in the meantime in Hyper 0.11.20, more background info can be found in this Hyper issue.",
      "url": "https://klausi.github.io/rustnish/2018/03/11/crashing-a-rust-hyper-server-with-a-denial-of-service-attack.html",
      "date_published": "2018-03-11T00:00:00+00:00",
      "author": {
        "name": "Klaus Purer",
        "url": "https://klausi.github.io/rustnish/"
      },
      "tags": [
        "Web and Network Services"
      ]
    },
    {
      "id": "e03aa0e5-bb05-48f0-a4a4-0796d14d1115",
      "title": "Writing a Simple IPFS Crawler",
      "content_text": "IPFS is a peer-to-peer protocol that allows you to access and publish content in a decentralized fashion. It uses hashes to refer to files. Short of someone posting hashes on a website, discoverability of content is pretty low. In this article, we’re going to write a very simple crawler for IPFS.\nIt’s challenging to have a traditional search engine in IPFS because content rarely links to each other. But there is another way than just blindly following links like a traditional crawler.",
      "url": "https://gkbrk.com/2018/03/writing-a-simple-ipfs-crawler/",
      "date_published": "2018-03-12T00:00:00+00:00",
      "author": {
        "name": "Gökberk Yaltıraklı",
        "url": "https://gkbrk.com/"
      },
      "tags": [
        "Web and Network Services"
      ]
    },
    {
      "id": "dd5790e1-ff4e-4f61-9a8b-05ea774a2e89",
      "title": "Writing servers with Tokio",
      "content_text": "I’ve been writing a small toy project with Tokio in my spare time’s spare time. I’ll write more about it at a later date. What I’ve found writing it, though, is that there is a specific pattern to writing servers, both UDP and TCP (and presumably others) in Tokio, and it’s not super obvious at first glance. So here it is.",
      "url": "https://blog.passcod.name/2018/mar/07/writing-servers-with-tokio",
      "date_published": "2018-03-07T09:35:30+00:00",
      "author": {
        "name": "Félix Saparelli",
        "url": "https://blog.passcod.name/"
      },
      "tags": [
        "Web and Network Services"
      ]
    },
    {
      "id": "776dd5f1-c6d0-48da-8e0a-6fcae00fb923",
      "title": "Writing a Microservice in Rust",
      "content_text": "Let me begin this article on Writing a Microservice in Rust by talking about C++. I’ve been a reasonably active member of the C++ community for quite a while now, attending and contributing talks to conferences, following the development and evangelism of the language’s more modern features and of course writing lots of it. C++ is a language that gives its users very fine-grained control over all aspects of the program they are writing, at the cost of a steep learning curve and a large body of knowledge required to write effective C++. However, C++ is also a very old language, conceived by Bjarne Stroustrup in 1985, and thus caries a lot of technical debt even into modern standards.",
      "url": "http://www.goldsborough.me/rust/web/tutorial/2018/01/20/17-01-11-writing_a_microservice_in_rust/",
      "date_published": "2018-01-20T00:00:00+00:00",
      "author": {
        "name": "Peter Goldsborough",
        "url": "http://www.goldsborough.me/"
      },
      "tags": [
        "Web and Network Services"
      ]
    },
    {
      "id": "26bc7432-d561-4e1f-8cf2-2c30b8ac63ab",
      "title": "Speed Without Wizardry",
      "content_text": "Vyacheslav Egorov, who goes by mraleph on the Web, wrote a response to my article “Oxidizing Source Maps with Rust and WebAssembly” titled “Maybe you don’t need Rust and WASM to speed up your JS”.\n\nThe “Oxidizing” article recounts my experience integrating Rust (compiled to WebAssembly) into the source-map JavaScript library. Although the JavaScript implementation was originally authored in idiomatic JavaScript style, as we profiled and implemented speed improvements, the code became hard to read and maintain. With Rust and its zero-cost abstractions, we found that there was no trade-off between performance and clean code.",
      "url": "http://fitzgeraldnick.com/2018/02/26/speed-without-wizardry.html",
      "date_published": "2018-02-26T00:00:00-08:00",
      "author": {
        "name": "Nick Fitzgerald",
        "url": "http://fitzgeraldnick.com/"
      },
      "tags": [
        "Web and Network Services"
      ]
    },
    {
      "id": "22d134e6-ddc6-4571-965c-4b6e72a544eb",
      "title": "Recently, for a Rusty Web",
      "content_text": "It’s been a few months since I shifted my focus full time to Rust, and in that time, we’ve gotten a lot of work done! I wanted to update you here what all that is, since it’s spread around on multiple repositories.",
      "url": "http://seanmonstar.com/post/171170905822/recently-for-a-rusty-web",
      "date_published": "2018-02-22T00:00:00+00:00",
      "author": {
        "name": "Sean McArthur",
        "url": "http://seanmonstar.com/"
      },
      "tags": [
        "Web and Network Services"
      ]
    },
    {
      "id": "9b97498f-3ffb-4c89-8973-c2beb5e0140e",
      "title": "Porting Rust to WebAssembly",
      "content_text": "I recently spent some effort trying to make reproto run in a browser. Here I want to outline the problems I encountered and how I worked around them. I will also provide a number of suggestions for how things might be improved for future porters.",
      "url": "https://udoprog.github.io/rust/2018-02-19/porting-rust-to-wasm.html",
      "date_published": "2018-02-19T00:00:00+00:00",
      "author": {
        "name": "John-John Tedro",
        "url": "https://udoprog.github.io/"
      },
      "tags": [
        "Web and Network Services"
      ]
    },
    {
      "id": "0af4c90e-74b2-438d-aaed-798c9f6e900a",
      "title": "Fanta: An opinionated framework for web development in rust",
      "content_text": "Fanta is a web framework that aims for developers to be productive and consistent across projects and teams. Its goals are to be: Opinionated, Fast, and Intuitive. Based heavily off of the work here: https://github.com/tokio-rs/tokio-minihttp",
      "url": "https://github.com/trezm/Fanta",
      "date_published": "2018-02-14T18:44:00+11:00",
      "author": {
        "name": "Peter Mertz",
        "url": "https://github.com/trezm"
      },
      "tags": [
        "Tools and Applications",
        "Web and Network Services"
      ]
    },
    {
      "id": "86b2dfcd-a01d-47e1-acb8-2ddbca20db62",
      "title": "Gameland intro, reimplemented in Rust for WebAssembly",
      "content_text": "My nice brother Johannes Ridderstedt sent me some old files a few weeks ago (in late 2017), stuff that he had preserved from an age-old computer of ours. One of these was the file named gameland.zip (not published yet, but I might put it up here some day.) I managed to get this running, and liked what I saw (you'll find the YouTube link to it further down on this page.) Around this time I was reading a bit about WebAssembly which I think will redefine and help reshape the web as we see it today. I was also looking at the Hello, Rust web page, and the \"FizzleFade effect using a Feistel network\" page in particular.",
      "url": "http://perlun.eu.org/en/programming/gameland/",
      "date_published": "2018-02-13T07:44:00+11:00",
      "author": {
        "name": "Per Lundberg",
        "url": "http://perlun.eu.org/en/"
      },
      "tags": [
        "Games and Graphics",
        "Web and Network Services"
      ]
    },
    {
      "id": "bbc46982-1321-4e4e-8d9f-344963341c21",
      "title": "Event Sourcing with Aggregates in Rust",
      "content_text": "Everyone loves event sourcing, right up until the moment they have to implement it. At that moment all the wonderful whiteboard drawings…",
      "url": "https://medium.com/@KevinHoffman/event-sourcing-with-aggregates-in-rust-4022af41cf67",
      "date_published": "2018-02-12T15:11:08.708+00:00",
      "author": {
        "name": "Kevin Hoffman",
        "url": "https://medium.com/@KevinHoffman"
      },
      "tags": [
        "Web and Network Services"
      ]
    },
    {
      "id": "2b698c99-99e0-4fad-8716-b58dbd9c255c",
      "title": "Deploying A Rust Server to Google App Engine with Travis CI & Docker",
      "content_text": "I woke up this morning with one goal: to convert my website (morgangallant.com) into a Rust web server. I have been a long time fan of…",
      "url": "https://medium.com/@gallantmrgn/deploying-rust-server-to-google-app-engine-with-travis-ci-docker-b80acfce2ce5",
      "date_published": "2018-02-11T00:07:43.579+00:00",
      "author": {
        "name": "Morgan A. Gallant",
        "url": "https://medium.com/@gallantmrgn"
      },
      "tags": [
        "Web and Network Services",
        "DevOps and Deployment"
      ]
    },
    {
      "id": "6b542e90-1f02-4368-90e4-a1931ccf1935",
      "title": "A Wee Allocator for WebAssembly",
      "content_text": "Introducing wee_alloc. wee_alloc is a work-in-progress memory allocator designed for WebAssembly. It has a tiny code size footprint, compiling down to only a kilobyte of .wasm code.",
      "url": "http://fitzgeraldnick.com/2018/02/09/wee-alloc.html",
      "date_published": "2018-02-09T00:00:00-08:00",
      "author": {
        "name": "Nick Fitzgerald",
        "url": "http://fitzgeraldnick.com/"
      },
      "tags": [
        "Web and Network Services"
      ]
    },
    {
      "id": "e6347974-c84a-438a-924a-52ef37f6c99a",
      "title": "I rewrote a Nintendo emulator with Rust / WebAssembly (Japanese)",
      "content_text": "概要 以前、JSで書いた(ファミコンのエミュレータを書いた - undefined)ファミコンのエミュレータをRustで書き直してみた。 また、技術的な内容はQiitaの方にも書いているので興味のある方は参照してみてください。(まだ Hello, World!までしか書けてませんが。) qiita.com もともとファミコンのエミュレータって新しい言語を習得するのにちょうどいい題材だったりするのでは、って話しからスタートしてて、よくわからないのでJSで書いてみて、ようやくRustで一通りは実装できた感じ。まだバグや未実装（音声周りやマッパー）も多いんですが、ひとまずはお腹いっぱいな感じ。 成果…",
      "url": "http://blog.bokuweb.me/entry/2018/02/08/101522",
      "date_published": "2018-02-08T10:15:22+09:00",
      "author": {
        "name": "bokuweb",
        "url": "http://blog.bokuweb.me/"
      },
      "tags": [
        "Web and Network Services"
      ]
    },
    {
      "id": "434c400b-b4ac-49c9-87fa-db2a8b5f1ba7",
      "title": "DataFusion: Big Data Platform for Rust",
      "content_text": "DataFusion is an open-source Big Data platform implemented in the Rust programming language with a similar programming style to Apache Spark.",
      "url": "https://www.datafusion.rs/",
      "date_published": "2018-02-04T16:51:47+00:00",
      "author": {
        "name": "Andy Grove",
        "url": "https://www.datafusion.rs/"
      },
      "tags": [
        "Tools and Applications",
        "Web and Network Services"
      ]
    },
    {
      "id": "5c8f0581-5b1d-485b-852c-83c0deef73d5",
      "title": "Rust and WebAssembly with Turtle - /var/blog",
      "content_text": "In this post, I'll walk through a few of the highlights of getting Turtle, a Rust library for creating animated drawings, to run in the browser with WebAssembly.",
      "url": "https://varblog.org/blog/2018/01/08/rust-and-webassembly-with-turtle/",
      "date_published": "2018-01-08T09:54:00-06:00",
      "author": {
        "name": "Marshall Pierce",
        "url": "https://varblog.org/"
      },
      "tags": [
        "Web and Network Services"
      ]
    }
  ]
}