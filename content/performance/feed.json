{
  "version": "https://jsonfeed.org/version/1",
  "title": "Read Rust - Performance",
  "home_page_url": "https://readrust.net/",
  "feed_url": "https://readrust.net/performance/feed.json",
  "description": "Performance posts on Read Rust",
  "author": {
    "name": "Wesley Moore",
    "url": "http://www.wezm.net/"
  },
  "items": [
    {
      "id": "da6bf82a-304e-42bd-9209-fbb8ee975fcd",
      "title": "Improving SmallVec's speed by 60% and why that shouldn't matter to you",
      "content_text": "smallvec is a library by the Servo team for reducing the number of allocations for dynamic arrays in the case that most of those arrays are below a certain size. Because malloc is fast, for many cases it’s actually slower to use SmallVec than just using Vec because the one-time cost of the initial allocation is dwarfed by the lifetime cost of SmallVec’s increased complexity. You can see that switching to Vec actually improves speed on many of SmallVec’s own benchmarks.",
      "url": "http://troubles.md/posts/improving-smallvec/",
      "date_published": "2018-05-17T14:44:51+02:00",
      "author": {
        "name": "troubles.md",
        "url": "http://troubles.md/"
      },
      "tags": [
        "Performance"
      ]
    },
    {
      "id": "f676f9eb-ea74-4dc5-a393-1f23a7886678",
      "title": "Dropping drops",
      "content_text": "Recently, a benchmark made it to the top of /r/programming, featuring Rust among other languages, and I was a bit surprised to see that the idiomatic Rust program was not competitive with the best-tuned C++ solution. The benchmark implements a binary tree, and the C++ solution leverages raw pointers while Rust would use an Option<Box<Node>> to represent its tree. Since Option knows that Box is non-nullable, it should compile down to a raw pointer. Quickly inspecting the Rust and C++ versions would not let me find where the performance difference came from.",
      "url": "https://barrielle.cedeela.fr/research_page/dropping-drops.html",
      "date_published": "2018-05-17T00:00:00+02:00",
      "author": {
        "name": "Vincent Barrielle",
        "url": "https://barrielle.cedeela.fr/research_page/category/blog.html"
      },
      "tags": [
        "Performance"
      ]
    },
    {
      "id": "51352c9c-dac9-4e94-a90f-5e953057a01a",
      "title": "Porting Rust Benchmarks To Criterion",
      "content_text": "A few weeks ago, I set out to convert bytecount’s benchmarks to criterion, a statistics-driven benchmarking framework started by Jorge Aparicio and maintained by Brook Heisler.\n\nBefore, bytecount used bencher for its benchmarks, which is a straight port of the unstable, nightly-only std::test benchmark framework, extended to work with stable Rust. This was a great benefit compared to std::test, because now we could benchmark on all Rust versions (stable, beta, nightly, some specific version) without needing to fear regressions.",
      "url": "https://llogiq.github.io/2018/05/18/criterion.html",
      "date_published": "2018-05-18T00:00:00+00:00",
      "author": {
        "name": "Llogiq",
        "url": "http://llogiq.github.io/"
      },
      "tags": [
        "Performance"
      ]
    },
    {
      "id": "a9218983-121e-4d4f-a02f-fd30cb6cf9b2",
      "title": "The Rust compiler is getting faster",
      "content_text": "TL;DR: The Rust compiler has gotten 1.06x–4x faster over the past month.",
      "url": "https://blog.mozilla.org/nnethercote/2018/05/17/the-rust-compiler-is-getting-faster/",
      "date_published": "2018-05-17T04:08:48+00:00",
      "author": {
        "name": "Nicholas Nethercote",
        "url": "https://blog.mozilla.org/nnethercote/"
      },
      "tags": [
        "Performance"
      ]
    },
    {
      "id": "2027caf9-9c4c-4e62-b4f3-2c43ff70590b",
      "title": "Optimising CTree and strs",
      "content_text": "Once upon a time, I wrote an interpreter for Stratego Core in Rust, which I named strs. Stratego Core is the core language that Stratego is compiled to before the compiler goes further (to Java, or previously to C). A core language is an intermediate representation that is a subset of the surface language.\n\nWhile I optimised that interpreter quite a bit, I noticed that the CTree (Stratego Core Abstract Syntax Tree) that the compiler spit out for me to interpret was very unoptimised. Therefore one the plans I described at the end of the blog post was a little tool for Copy Propagation on CTree files. This post is about that tool, and the optimisations in the interpreter that made it obsolete again.",
      "url": "http://blog.jeffsmits.net/compsci/2018/05/08/optimising-stratego-core/",
      "date_published": "2018-05-08T00:00:00+00:00",
      "author": {
        "name": "Jeff Smits",
        "url": "http://blog.jeffsmits.net/"
      },
      "tags": [
        "Performance"
      ]
    },
    {
      "id": "97a47f42-b32a-45df-8473-892b94367048",
      "title": "How a Rust upgrade more than tripled the speed of my code",
      "content_text": "I’d like to share a quick story about the sheer power of LLVM and the benefits of using higher-level languages over assembly.",
      "url": "http://troubles.md/posts/the-power-of-compilers/",
      "date_published": "2018-05-11T16:07:31+02:00",
      "author": {
        "name": "troubles.md",
        "url": "http://troubles.md/"
      },
      "tags": [
        "Performance"
      ]
    },
    {
      "id": "d18e865c-71c2-4c7e-85ff-7d84e1999055",
      "title": "Performance experiments with matrix multiplication",
      "content_text": "One of Rust’s design goals is to be fast. That actually needs two distinct things from the language. First, is it shouldn’t introduce too much (preferably zero) overhead for its abstractions and be fast out of the box. Many people coming from the high level languages (python, javascript, …) find this to be the case ‒ just type the program, compile it (with --release) and it’s reasonable fast. The other, no less important, is allowing the programmer to tweak some knobs when trying to squeeze a bit more speed out of the program.\n\nI’ve decided to test the second a bit and see how far I could go. I’ve chosen matrix multiplication as a case study, for several reasons. I’ve played with it before (in my master’s thesis), it’s relatively simple and the effects of optimizing it can be great. For simplicity, I’ve decided to multiply only square matrices with power-of-two sizes, but these restrictions can be lifted in a real implementation without significantly loosing performance ‒ only the code gets somewhat more complex and hairy.",
      "url": "https://vorner.github.io/2018/05/12/Mat-perf.html",
      "date_published": "2018-05-12T00:00:00+00:00",
      "author": {
        "name": "Michal 'vorner' Vaner",
        "url": "https://vorner.github.io/"
      },
      "tags": [
        "Performance"
      ]
    },
    {
      "id": "0a6c62ed-f16b-4b57-8ff1-3984e08f204e",
      "title": "How fast can we compile Rust hello world?",
      "content_text": "Seeing Nick Nethercote’s blog post about speeding up the compiler, I started wondering just how fast could a Rust compiler be? How fast could we compile a simple example? How fast can we compile a Rust hello world?",
      "url": "http://www.jonathanturner.org/2018/05/how-fast-can-we-compile-rust-hello-world.html",
      "date_published": "2018-05-03T00:00:00+00:00",
      "author": {
        "name": "Jonathan Turner",
        "url": "http://www.jonathanturner.org/"
      },
      "tags": [
        "Performance"
      ]
    },
    {
      "id": "1c59d8b2-c755-4f10-859e-4847be81bc4c",
      "title": "How to speed up the Rust compiler in 2018",
      "content_text": "18 months ago I wrote about some work I did to speed up the Rust compiler (rustc). I’ve recently taken this work up again. Also, in the meantime rustc’s build system has been replaced and its benchmark suite has been overhauled. So it’s a good time for an update.",
      "url": "https://blog.mozilla.org/nnethercote/2018/04/30/how-to-speed-up-the-rust-compiler-in-2018/",
      "date_published": "2018-04-30T04:13:45+00:00",
      "author": {
        "name": "Nicholas Nethercote",
        "url": "https://blog.mozilla.org/nnethercote/"
      },
      "tags": [
        "Language",
        "Performance"
      ]
    },
    {
      "id": "d412d980-cc59-4a0b-ab9e-19100f3b8927",
      "title": "Faster Bulletproofs with Ristretto & AVX2",
      "content_text": "A few months ago, Bünz, Bootle, Boneh, Poelstra, Wuille, and Maxwell published Bulletproofs, which dramatically improves proof performance both in terms of proof size and verification time. In addition, it allows proving a much wider class of statements than just range proofs.\n\nAt Chain, we (Henry de Valence, Cathie Yun and Oleg Andreev) have been working on a pure-Rust Bulletproofs implementation, whose initial version we are publishing today, together with a set of notes.",
      "url": "https://blog.chain.com/faster-bulletproofs-with-ristretto-avx2-29450b4490cd",
      "date_published": "2018-04-13T19:21:27.639+00:00",
      "author": {
        "name": "Chain",
        "url": "https://blog.chain.com/@chaininc"
      },
      "tags": [
        "Tools and Applications",
        "Performance"
      ]
    },
    {
      "id": "b93c9682-4e53-4a7f-a39b-79d57b2b4737",
      "title": "New sysinfo version (huge performance improvements!)",
      "content_text": "This new version comes with great performance improvements. We're talking about 3x faster on macos, 2x faster on linux and 3x faster on windows (the benchmarks are at the end of the post).",
      "url": "https://blog.guillaume-gomez.fr/articles/2018-04-09+New+sysinfo+version+%28huge+performance+improvements%21%29",
      "date_published": "2018-04-09T00:00:00+00:00",
      "author": {
        "name": "Guillaume Gomez",
        "url": "https://blog.guillaume-gomez.fr/"
      },
      "tags": [
        "Performance",
        "Tools and Applications"
      ]
    },
    {
      "id": "98f65a4a-8501-45e4-bda8-48d5d01306ba",
      "title": "Improving GStreamer performance with tokio",
      "content_text": "For one of our customers at Centricular we were working on a quite interesting project. Their use-case was basically to receive an as-high-as-possible number of audio RTP streams over UDP, transcode them, and then send them out via UDP again. Due to how GStreamer usually works, they were running into some performance issues.\n\nThis blog post will describe the first set of improvements that were implemented for this use-case, together with a minimal benchmark and the results. My colleague Mathieu will follow up with one or two other blog posts with the other improvements and a more full-featured benchmark.\n\nThe short version is that CPU usage decreased by about 65-75%, i.e. allowing 3-4x more streams with the same CPU usage. Also parallelization works better and usage of different CPU cores is more controllable, allowing for better scalability. And a fixed, but configurable number of threads is used, which is independent of the number of streams.",
      "url": "https://coaxion.net/blog/2018/04/improving-gstreamer-performance-on-a-high-number-of-network-streams-by-sharing-threads-between-elements-with-rusts-tokio-crate/",
      "date_published": "2018-04-05T15:21:06+00:00",
      "author": {
        "name": "Sebastian Dröge",
        "url": "https://coaxion.net/blog/"
      },
      "tags": [
        "Web and Network Services",
        "Performance"
      ]
    },
    {
      "id": "3052579c-dccc-46b8-8d93-bbecfa493992",
      "title": "Speeding Up 'dwarfdump' With Rust",
      "content_text": "Writing a debugger for C++ on Linux, you spend a lot of time examining pretty-printed DWARF debug information using tools like readelf, objdump or dwarfdump. Unfortunately this can be quite slow.\n\nI decided to try to speed dwarfdump up. TL;DR: I reduced the dump time from 506s to 26s by fixing some simple issues and taking advantage of Rust \"fearless parallelism\". I think there are interesting opportunities for speeding up many kinds of command-line tools using Rust and parallelism.",
      "url": "https://robert.ocallahan.org/2018/03/speeding-up-dwarfdump-with-rust.html",
      "date_published": "2018-03-29T14:44:00+13:00",
      "author": {
        "name": "Robert O'Callahan",
        "url": "https://robert.ocallahan.org/"
      },
      "tags": [
        "Performance"
      ]
    },
    {
      "id": "07825eb3-aaab-46c5-b7e4-680857d73750",
      "title": "Rust + Node.js are awesome!",
      "content_text": "Blazing fast, low requirements, computationally intensive operations on Node.js using Rust",
      "url": "https://itnext.io/rust-node-js-are-awesome-a50d63411773",
      "date_published": "2018-03-27T21:50:20.148+00:00",
      "author": {
        "name": "Benjamín Calderón",
        "url": "https://itnext.io/@benjcal"
      },
      "tags": [
        "Web and Network Services",
        "Performance"
      ]
    },
    {
      "id": "655ac748-e1e9-4fa4-b12a-2dc7c2e88fa7",
      "title": "Building a fast Electron app with Rust",
      "content_text": "When I built Finda, I wanted it to be fast — specifically, to respond to all user input within 16 milliseconds.\n\nGiven this goal, you might be surprised to learn that Finda is built with Electron, a framework that’s often decried for being the opposite of fast.",
      "url": "https://keminglabs.com/blog/building-a-fast-electron-app-with-rust/",
      "date_published": "2018-03-18T00:00:00+11:00",
      "author": {
        "name": "Kevin J. Lynagh",
        "url": "https://keminglabs.com/blog/"
      },
      "tags": [
        "Tools and Applications",
        "Performance"
      ]
    },
    {
      "id": "0ebef41d-c7b1-424a-a120-ebf1098bbe38",
      "title": "Three Algorithm Optimizations Outside [Place], [Other place]",
      "content_text": "Recently, I came across an ad for a job that had a precondition for application: it required you to first solve a ✨programming challenge✨:",
      "url": "https://medium.com/@urschrei/three-algorithm-optimizations-outside-place-other-place-294de5a68f27",
      "date_published": "2018-02-28T17:12:42.361+00:00",
      "author": {
        "name": "Steph",
        "url": "https://medium.com/@urschrei"
      },
      "tags": [
        "Performance"
      ]
    },
    {
      "id": "5e5df82f-aba3-4832-bbe6-e995b2e544ef",
      "title": "Criterion.rs v0.2 - a statistics-driven benchmarking library for Rust",
      "content_text": "Criterion.rs is a statistics-driven benchmarking library for Rust. It provides precise measurements of changes in the performance of benchmarked code, and gives strong statistical confidence that apparent performance changes are real and not simply noise. Clear output, a simple API and reasonable defaults make it easy to use even for developers without a background in statistics. Unlike the benchmarking harness provided by Rust, Criterion.rs can be used with stable versions of the compiler.",
      "url": "https://bheisler.github.io/post/criterion-rs-0-2/",
      "date_published": "2018-02-05T07:00:00-06:00",
      "author": {
        "name": "Brook Heisler",
        "url": "https://bheisler.github.io/"
      },
      "tags": [
        "Performance",
        "Crates"
      ]
    },
    {
      "id": "1ccb8993-1118-4eb4-a1fb-0c6146948662",
      "title": "Benchmark of different Async approaches in Rust",
      "content_text": "The story about Rust’s async is still a bit in flux. There’s a bunch of libraries with their pros and cons and different approaches. Even I’m a bit to blame for that, as I’m writing one of my own, called Corona.",
      "url": "https://vorner.github.io/async-bench.html",
      "date_published": "2018-02-03T11:16:55+00:00",
      "author": {
        "name": "Michal 'vorner' Vaner",
        "url": "https://vorner.github.io/"
      },
      "tags": [
        "Performance"
      ]
    },
    {
      "id": "e1a29851-ab4c-4739-a41f-56e9c783f5e4",
      "title": "Faster Progress Report 2",
      "content_text": "faster began as a yak shave, created to aid base💯 in its quest to become the fastest meme on Github. Writing an explicit AVX2-accelerated version of base💯's encoder and decoder, then realizing I'd have to do the same thing again to see the speedups on my Ivy Bridge desktop, pushed me to make this library. Months later, it has blossomed into its own project, and has eclipsed base💯 in both popularity and promise.",
      "url": "https://adamniederer.com/blog/faster-pr-2.html",
      "date_published": "2018-01-28T22:14:41+00:00",
      "author": {
        "name": "Adam Niederer",
        "url": "https://adamniederer.com/blog/blog.html"
      },
      "tags": [
        "Performance",
        "Crates"
      ]
    }
  ]
}