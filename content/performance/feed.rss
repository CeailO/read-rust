<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/"><channel><title>Read Rust - Performance</title><link>https://readrust.net/</link><description>Performance posts on Read Rust</description><item><title>Faster Bulletproofs with Ristretto &amp; AVX2</title><link>https://blog.chain.com/faster-bulletproofs-with-ristretto-avx2-29450b4490cd</link><description>A few months ago, BÃ¼nz, Bootle, Boneh, Poelstra, Wuille, and Maxwell published Bulletproofs, which dramatically improves proof performance both in terms of proof size and verification time. In addition, it allows proving a much wider class of statements than just range proofs.

At Chain, we (Henry de Valence, Cathie Yun and Oleg Andreev) have been working on a pure-Rust Bulletproofs implementation, whose initial version we are publishing today, together with a set of notes.</description><guid isPermaLink="false">d412d980-cc59-4a0b-ab9e-19100f3b8927</guid><pubDate>Fri, 13 Apr 2018 19:21:27 +0000</pubDate><dc:creator>Chain</dc:creator></item><item><title>New sysinfo version (huge performance improvements!)</title><link>https://blog.guillaume-gomez.fr/articles/2018-04-09+New+sysinfo+version+%28huge+performance+improvements%21%29</link><description>This new version comes with great performance improvements. We&apos;re talking about 3x faster on macos, 2x faster on linux and 3x faster on windows (the benchmarks are at the end of the post).</description><guid isPermaLink="false">b93c9682-4e53-4a7f-a39b-79d57b2b4737</guid><pubDate>Mon,  9 Apr 2018 00:00:00 +0000</pubDate><dc:creator>Guillaume Gomez</dc:creator></item><item><title>Improving GStreamer performance with tokio</title><link>https://coaxion.net/blog/2018/04/improving-gstreamer-performance-on-a-high-number-of-network-streams-by-sharing-threads-between-elements-with-rusts-tokio-crate/</link><description>For one of our customers at Centricular we were working on a quite interesting project. Their use-case was basically to receive an as-high-as-possible number of audio RTP streams over UDP, transcode them, and then send them out via UDP again. Due to how GStreamer usually works, they were running into some performance issues.

This blog post will describe the first set of improvements that were implemented for this use-case, together with a minimal benchmark and the results. My colleague Mathieu will follow up with one or two other blog posts with the other improvements and a more full-featured benchmark.

The short version is that CPU usage decreased by about 65-75%, i.e. allowing 3-4x more streams with the same CPU usage. Also parallelization works better and usage of different CPU cores is more controllable, allowing for better scalability. And a fixed, but configurable number of threads is used, which is independent of the number of streams.</description><guid isPermaLink="false">98f65a4a-8501-45e4-bda8-48d5d01306ba</guid><pubDate>Thu,  5 Apr 2018 15:21:06 +0000</pubDate><dc:creator>Sebastian DrÃ¶ge</dc:creator></item><item><title>Speeding Up &apos;dwarfdump&apos; With Rust</title><link>https://robert.ocallahan.org/2018/03/speeding-up-dwarfdump-with-rust.html</link><description>Writing a debugger for C++ on Linux, you spend a lot of time examining pretty-printed DWARF debug information using tools like readelf, objdump or dwarfdump. Unfortunately this can be quite slow.

I decided to try to speed dwarfdump up. TL;DR: I reduced the dump time from 506s to 26s by fixing some simple issues and taking advantage of Rust &quot;fearless parallelism&quot;. I think there are interesting opportunities for speeding up many kinds of command-line tools using Rust and parallelism.</description><guid isPermaLink="false">3052579c-dccc-46b8-8d93-bbecfa493992</guid><pubDate>Thu, 29 Mar 2018 14:44:00 +1300</pubDate><dc:creator>Robert O&apos;Callahan</dc:creator></item><item><title>Rust + Node.js are awesome!</title><link>https://itnext.io/rust-node-js-are-awesome-a50d63411773</link><description>Blazing fast, low requirements, computationally intensive operations on Node.js using Rust</description><guid isPermaLink="false">07825eb3-aaab-46c5-b7e4-680857d73750</guid><pubDate>Tue, 27 Mar 2018 21:50:20 +0000</pubDate><dc:creator>BenjamÃ­n CalderÃ³n</dc:creator></item><item><title>Building a fast Electron app with Rust</title><link>https://keminglabs.com/blog/building-a-fast-electron-app-with-rust/</link><description>When I built Finda, I wanted it to be fast â€” specifically, to respond to all user input within 16 milliseconds.

Given this goal, you might be surprised to learn that Finda is built with Electron, a framework thatâ€™s often decried for being the opposite of fast.</description><guid isPermaLink="false">655ac748-e1e9-4fa4-b12a-2dc7c2e88fa7</guid><pubDate>Sun, 18 Mar 2018 00:00:00 +1100</pubDate><dc:creator>Kevin J. Lynagh</dc:creator></item><item><title>Three Algorithm Optimizations Outside [Place], [Other place]</title><link>https://medium.com/@urschrei/three-algorithm-optimizations-outside-place-other-place-294de5a68f27</link><description>Recently, I came across an ad for a job that had a precondition for application: it required you to first solve a âœ¨programming challengeâœ¨:</description><guid isPermaLink="false">0ebef41d-c7b1-424a-a120-ebf1098bbe38</guid><pubDate>Wed, 28 Feb 2018 17:12:42 +0000</pubDate><dc:creator>Steph</dc:creator></item><item><title>Criterion.rs v0.2 - a statistics-driven benchmarking library for Rust</title><link>https://bheisler.github.io/post/criterion-rs-0-2/</link><description>Criterion.rs is a statistics-driven benchmarking library for Rust. It provides precise measurements of changes in the performance of benchmarked code, and gives strong statistical confidence that apparent performance changes are real and not simply noise. Clear output, a simple API and reasonable defaults make it easy to use even for developers without a background in statistics. Unlike the benchmarking harness provided by Rust, Criterion.rs can be used with stable versions of the compiler.</description><guid isPermaLink="false">5e5df82f-aba3-4832-bbe6-e995b2e544ef</guid><pubDate>Mon,  5 Feb 2018 07:00:00 -0600</pubDate><dc:creator>Brook Heisler</dc:creator></item><item><title>Benchmark of different Async approaches in Rust</title><link>https://vorner.github.io/async-bench.html</link><description>The story about Rustâ€™s async is still a bit in flux. Thereâ€™s a bunch of libraries with their pros and cons and different approaches. Even Iâ€™m a bit to blame for that, as Iâ€™m writing one of my own, called Corona.</description><guid isPermaLink="false">1ccb8993-1118-4eb4-a1fb-0c6146948662</guid><pubDate>Sat,  3 Feb 2018 11:16:55 +0000</pubDate><dc:creator>Michal &apos;vorner&apos; Vaner</dc:creator></item><item><title>Faster Progress Report 2</title><link>https://adamniederer.com/blog/faster-pr-2.html</link><description>faster began as a yak shave, created to aid baseðŸ’¯ in its quest to become the fastest meme on Github. Writing an explicit AVX2-accelerated version of baseðŸ’¯&apos;s encoder and decoder, then realizing I&apos;d have to do the same thing again to see the speedups on my Ivy Bridge desktop, pushed me to make this library. Months later, it has blossomed into its own project, and has eclipsed baseðŸ’¯ in both popularity and promise.</description><guid isPermaLink="false">e1a29851-ab4c-4739-a41f-56e9c783f5e4</guid><pubDate>Sun, 28 Jan 2018 22:14:41 +0000</pubDate><dc:creator>Adam Niederer</dc:creator></item></channel></rss>