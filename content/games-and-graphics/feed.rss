<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/"><channel><title>Read Rust - Games and Graphics</title><link>https://readrust.net/</link><description>Games and Graphics posts on Read Rust</description><item><title>Writing a GPU-Accelerated Path Tracer in Rust - Part 3</title><link>https://bheisler.github.io/post/writing-gpu-accelerated-path-tracer-part-3/</link><description><![CDATA[Hello! Welcome to my third and final post on my GPU-accelerated Path Tracer in Rust. In the last post, we implemented all of the logic necessary to build a true path tracer. Problem is, even on the GPU it’s terrifically slow. This post is (mostly) about fixing that.

But first, we need to fix a bug or two, because I goofed. *sad trombone*

Step -1: Fixing Bugs /u/anderslanglands on Reddit pointed out that, since I’m using Cosine-weighted Importance Sampling, I need to do some extra math to avoid biasing the results.]]></description><guid isPermaLink="false">0b53c7ea-570b-4595-b8eb-2f62d8e9cb96</guid><pubDate>Thu, 19 Jul 2018 18:30:00 -0600</pubDate><dc:creator>Brook Heisler</dc:creator></item><item><title>Flocking in Rust with Piston</title><link>https://blog.shine.rocks/posts/flocking-in-rust-with-piston/</link><description><![CDATA[Wikipedia states that flocking is a behavior exhibited when a group of birds, called a flock, are foraging or in flight. Flocking simulation are basically softwares which simulate this flocking behavior of birds. The original algorithm is developed by Craig Reynolds in 1986.]]></description><guid isPermaLink="false">a65d9a08-fc44-4976-b2ad-82b934b7961f</guid><pubDate>Sun, 15 Jul 2018 00:00:00 +0000</pubDate><dc:creator>Htet Aung Shine</dc:creator></item><item><title>Writing a GPU-Accelerated Path Tracer in Rust - Part 2</title><link>https://bheisler.github.io/post/writing-gpu-accelerated-path-tracer-part-2/</link><description><![CDATA[Hello, and welcome to part two of my series on writing a GPU-accelerated path tracer in Rust. I’d meant to have this post up sooner, but nothing ruins my productivity quite like Games Done Quick. I’m back now, though, so it’s time to turn the GPU ray-tracer from the last post into a real path tracer.

Tracing Paths As mentioned last time, Path Tracing is an extension to Ray Tracing which attempts to simulate global illumination.]]></description><guid isPermaLink="false">289bc607-7039-4931-838e-0451ee67e488</guid><pubDate>Thu, 12 Jul 2018 19:00:00 -0600</pubDate><dc:creator>Brook Heisler</dc:creator></item><item><title>The Cheddar shading language</title><link>https://phaazon.net/blog/cheddar-0.1</link><description><![CDATA[Cheddar is a GLSL superset language. What it means is that most of the GLSL constructs and syntax you’re used to is valid in Cheddar – not all of it; most of it. Cheddar adds a set of features that I think are lacking to GLSL. Among them: Some non-valid GLSL constructions made valid in Cheddar to ease the writing of certain shader stages; A more functional approach to programming shaders on the GPU; Structures, types and GLSL-specific constructs sharing; Imports and modules with live reloading and transitive dependencies.]]></description><guid isPermaLink="false">5579acfe-3441-4097-9476-863e348858f5</guid><pubDate>Mon,  9 Jul 2018 01:00:00 +0000</pubDate><dc:creator>Dimitri Sabadie</dc:creator></item><item><title>Tiny Planets</title><link>http://www.mattkeeter.com/projects/planets/</link><description><![CDATA[In the past few years, I've heard a lot about Rust. As someone that hacks on computer graphics and low-level infrastructure libraries, it seems relevant to my interests. I decided to make a small demo – of a procedural planet generator – and see how it went.]]></description><guid isPermaLink="false">306a1044-e3e5-4a20-b4df-6577fa6eadf5</guid><pubDate>Thu,  5 Jul 2018 02:45:00 +0000</pubDate><dc:creator>Matt Keeter</dc:creator></item><item><title>Let&apos;s code with the Roguelike tutorial - Part 2 - Entities and the map</title><link>https://www.yosenspace.com/posts/lets-code-roguelike-tutorial-part2-entities-map.html</link><description><![CDATA[As I mentioned in the last post, until I got a better handle on the off screen console code, I temporarily made all the Rust bindings call out to the default root console. Now that there's a bit of discussion on how the off screen consoles work, it's time to refactor the code to enable their use. ]]></description><guid isPermaLink="false">5489d43b-5cbb-4f2b-964e-1aacba277cd6</guid><pubDate>Wed,  4 Jul 2018 07:53:00 +0000</pubDate><dc:creator>Yosen</dc:creator></item><item><title>Scripting Language Cleanup</title><link>https://www.anthropicstudios.com/2018/06/30/language-cleanup/</link><description><![CDATA[When we built the original Monsters and Sprites demo, we only had 9 days to get it working before the Playcrafting expo we had signed up for, so we had to cut a lot of corners. Since then I’ve been doing bug fixes and working on a lot of miscellaneous engine/language features that I either couldn’t get done in time for the demo, or didn’t realize were important until I started building it. We’ve made a few game updates since then (we now have sound!), but this post is specifically going to explore some language updates I’ve made.]]></description><guid isPermaLink="false">3b8f7264-75f2-4483-bb45-16770a899291</guid><pubDate>Sat, 30 Jun 2018 00:00:00 +0000</pubDate><dc:creator>Mason Remaley</dc:creator></item><item><title>NES Emulator, Part 2: I sort of know what I’m doing</title><link>https://medium.com/@ltriant/nes-emulator-part-2-i-sort-of-know-what-im-doing-f64d5e61caed</link><description><![CDATA[In my first post about my journey to the center of the NES, I was at the point where I was still working on the CPU; implementing new addressing modes and instructions as I made my way through the nestest ROM. Well, I finally finished the CPU, including a handful of the illegal opcodes. The last of the illegal opcodes just need some placeholders, because, as I understand it, very few games use them.]]></description><guid isPermaLink="false">13dc5703-c3a5-4c10-b3a5-aa53c382c940</guid><pubDate>Fri, 29 Jun 2018 02:24:51 +0000</pubDate><dc:creator>Luke Triantafyllidis</dc:creator></item><item><title>Project Ice Puzzle</title><link>http://www.matthewmichelotti.com/games/project_ice_puzzle/</link><description><![CDATA[This game was coded in Rust and is playable in web browsers by means of WebAssembly, WebGL and Howler.js. The software I developed is partly open source in the form of Gate, which is the Rust library that powers this game and can power other similar games. Special thanks to the tools I used to create assets: Gimp, FL Studio and BFXR.]]></description><guid isPermaLink="false">645c96b0-5f66-4c4d-a8ee-d145298bc63d</guid><pubDate>Mon, 25 Jun 2018 00:00:00 +0000</pubDate><dc:creator>Matthew Michelotti</dc:creator></item><item><title>Optimising path tracing: the last 10%</title><link>https://bitshifter.github.io/blog/2018/06/20/the-last-10-percent/</link><description><![CDATA[In my last post on optimising my Rust path tracer with SIMD I had got withing 10% of my performance target, that is Aras’s C++ SSE4.1 path tracer. From profiling I had determined that the main differences were MSVC using SSE versions of sinf and cosf and differences between Rayon and enkiTS thread pools. The first thing I tried was implement an SSE2 version of sin_cos based off of Julien Pommier’s code that I found via a bit of googling. This was enough to get my SSE4.1 implementation to match the performance of Aras’s SSE4.1 code. I had a slight advantage in that I just call sin_cos as a single function versus separate sin and cos functions, but meh, I’m calling my performance target reached.

The other part of this post is about Rust’s runtime and compile time CPU feature detection and some wrong turns I took along the way.]]></description><guid isPermaLink="false">495d9d83-2572-43cb-8f9d-c5c404ab83fe</guid><pubDate>Wed, 20 Jun 2018 00:00:00 +0000</pubDate><dc:creator>bitshifter</dc:creator></item><item><title>Let&apos;s Talk About Vector Graphics (In Rust)</title><link>https://nical.github.io/posts/rustfest-paris-01.html</link><description><![CDATA[I gave a talk about lyon at RustFest Paris. This post is the introduction of the talk, wherein I introduce vector graphics and try to get the audience somewhat excited about it. Things will get technical in the follow-up posts.]]></description><guid isPermaLink="false">edd88db5-3f05-4171-9159-de17a3a4db8a</guid><pubDate>Mon, 18 Jun 2018 00:00:00 +0200</pubDate><dc:creator>Nical</dc:creator></item><item><title>Running Rust on the GPU with Accel</title><link>https://bheisler.github.io/post/rust-on-the-gpu-with-accel/</link><description><![CDATA[For the past month or so, I’ve been working on a follow-up to my series on Writing a Raytracer in Rust. This time around, I’ll be talking about writing a GPU-accelerated Path Tracer. As always, I’m writing it in Rust - including the GPU kernel code. Compiling Rust for GPUs at this point is difficult and error-prone, so I thought it would be good to start with some documentation on that aspect of the problem before diving into path tracing.]]></description><guid isPermaLink="false">e62fbda5-e357-4870-a483-9dcf833b31ad</guid><pubDate>Thu, 14 Jun 2018 19:00:00 -0600</pubDate><dc:creator>Brook Heisler</dc:creator></item><item><title>Gfx, windows, and resizing</title><link>https://falseidolfactory.com/2018/05/28/gfx-windows-and-resizing.html</link><description><![CDATA[These early posts will mostly be me trying to work out how to use gfx-rs. I was previously using glium which is fantastic, but is sadly no longer being developed. So my choices are: Learn Vulkan, Use raw OpenGL bindings, Use gfx.

I opted to use the current released version (v0.17.1) but it’s currently undergoing a significant rearchitecture so I may move to that whenever it releases.]]></description><guid isPermaLink="false">9f6686d4-a03b-4420-82b0-e2c66b8b5e11</guid><pubDate>Mon, 28 May 2018 00:00:00 +0100</pubDate><dc:creator>Mistodon</dc:creator></item><item><title>Ray Tracing in a Weekend in Rust</title><link>https://bitshifter.github.io/blog/2018/04/29/rust-ray-tracer-in-one-weekend/</link><description><![CDATA[I was inspired to work through Peter Shirley’s Ray Tracing in a Weekend mini book (for brevity RTIAW) but I wanted to write it in Rust instead of the C++ that’s used in the book. I found out about the book via @aras_p’s blog series about a toy path tracer he’s been building.]]></description><guid isPermaLink="false">b7e3c6ef-7be3-4f63-b8ad-04affb29716c</guid><pubDate>Sun, 29 Apr 2018 00:00:00 +0000</pubDate><dc:creator>bitshifter</dc:creator></item><item><title>Rust Case Study: Chucklefish Taps Rust to Bring Safe Concurrency to Video Games [pdf]</title><link>https://www.rust-lang.org/pdfs/Rust-Chucklefish-Whitepaper.pdf</link><description><![CDATA[Chucklefish, an independent game studio based in London, publishes hit video games like Stardew Valley and Starbound. Now, the company is developing its next game, code-named Witchbrook, using the Rust programming language instead of C++. Why the switch? Two main reasons: to get better performance on multiprocessor hardware and to have fewer crashes during game play.]]></description><guid isPermaLink="false">49014ace-e742-49f8-887a-8fa7d1b627cc</guid><pubDate>Mon, 23 Apr 2018 17:38:56 +0000</pubDate><dc:creator>The Rust Project Developers</dc:creator></item><item><title>Taking the long road (Part 2): Rust bindings for a vector similarity search library</title><link>https://medium.com/@e_net4/taking-the-load-road-part-2-rust-bindings-for-a-vector-similarity-search-library-914fbc1ec5ed</link><description><![CDATA[This is part 2 of a story on taking the long road towards Rust bindings to Faiss. You may wish to read part 1 first for a motivation section and a deeper understanding of how I built a plain C API on top of the C++ library.]]></description><guid isPermaLink="false">cacf27d3-9206-414d-b28f-8745eec00a4a</guid><pubDate>Thu, 12 Apr 2018 20:11:12 +0000</pubDate><dc:creator>Eduardo Pinho</dc:creator></item><item><title>Writing An NES Emulator with Rust and WebAssembly</title><link>https://medium.com/@bokuweb17/writing-an-nes-emulator-with-rust-and-webassembly-d64de101c49d</link><description><![CDATA[I wrote the NES emulator with Rust and WebAssembly to learn Rust. It’s not perfect and have some audio bugs, but it’s good enough to play Super Mario bros.]]></description><guid isPermaLink="false">d65aaebc-e17b-421b-86e8-1cc9c63a0408</guid><pubDate>Wed, 11 Apr 2018 14:30:56 +0000</pubDate><dc:creator>bokuweb</dc:creator></item><item><title>Taking the long road (Part 1): bindings for a vector similarity search library</title><link>https://medium.com/@e_net4/taking-the-long-road-part-1-97e6e41f6b05</link><description><![CDATA[Perhaps you have once wondered how search engines such as Google and TinEye enable their users to search for images which are similar to one that you provide, or how they can identify a building from nothing but a picture. Content-based image retrieval (CBIR) is the backbone concept, and provides exciting new ways to search for useful information. While the concept is no longer novel, the requirements imposed on systems for CBIR are ever increasing due to the increasingly larger amounts of data and demand for higher quality of retrieval.]]></description><guid isPermaLink="false">e5d47646-8715-43d3-a39b-23115255a1fe</guid><pubDate>Sat, 31 Mar 2018 15:45:00 +0000</pubDate><dc:creator>Eduardo Pinho</dc:creator></item><item><title>A geometric Rust adventure</title><link>https://eev.ee/blog/2018/03/30/a-geometric-rust-adventure/</link><description><![CDATA[The short version is: I have some shapes. I want to find their intersection.

Really, I want more than that: I want to drop them all on a canvas, intersect everything with everything, and pluck out all the resulting polygons. The input is a set of cookie cutters, and I want to press them all down on the same sheet of dough and figure out what all the resulting contiguous pieces are. And I want to know which cookie cutter(s) each piece came from.

But intersection is a good start.]]></description><guid isPermaLink="false">fe337d8c-3b02-4742-bfd0-59ac89d4234f</guid><pubDate>Fri, 30 Mar 2018 17:17:00 -0700</pubDate><dc:creator>Eevee</dc:creator></item><item><title>Roguelike Tutorial in Rust + tcod</title><link>https://tomassedovic.github.io/roguelike-tutorial/</link><description><![CDATA[Hello! This tutorial will show you how to write a roguelike in the Rust programming language and the libtcod library.]]></description><guid isPermaLink="false">85524257-1035-4e25-b20b-57737d314b55</guid><pubDate>Tue, 13 Mar 2018 18:54:54 +0200</pubDate><dc:creator>Tomas Sedovic</dc:creator></item><item><title>UniverCity - February Change log</title><link>https://thinkof.name/2018/02/28/february-change-log.html</link><description><![CDATA[UniverCity is a university management game being programmed in the Rust programming language. This month was spent mostly on the business side of things, including going through the steam partner process.]]></description><guid isPermaLink="false">ae89c8c8-fd8f-4432-9b21-1a2651142869</guid><pubDate>Wed, 28 Feb 2018 00:00:00 +0000</pubDate><dc:creator>Matthew Collins</dc:creator></item><item><title>The State of Game Development in Rust</title><link>http://www.davideaversa.it/2018/02/state-game-development-rust/</link><description><![CDATA[Game Development is one of the fields in which Rust can gain a lot of traction. Let’s look at the current ecosystem and let’s see what the community has to offer.]]></description><guid isPermaLink="false">7b281b2d-246c-4fec-bdf5-6eb92fbb8a34</guid><pubDate>Mon, 26 Feb 2018 17:37:27 +0000</pubDate><dc:creator>Davide Aversa</dc:creator></item><item><title>Gameland intro, reimplemented in Rust for WebAssembly</title><link>http://perlun.eu.org/en/programming/gameland/</link><description><![CDATA[My nice brother Johannes Ridderstedt sent me some old files a few weeks ago (in late 2017), stuff that he had preserved from an age-old computer of ours. One of these was the file named gameland.zip (not published yet, but I might put it up here some day.) I managed to get this running, and liked what I saw (you'll find the YouTube link to it further down on this page.) Around this time I was reading a bit about WebAssembly which I think will redefine and help reshape the web as we see it today. I was also looking at the Hello, Rust web page, and the "FizzleFade effect using a Feistel network" page in particular.]]></description><guid isPermaLink="false">86b2dfcd-a01d-47e1-acb8-2ddbca20db62</guid><pubDate>Tue, 13 Feb 2018 07:44:00 +1100</pubDate><dc:creator>Per Lundberg</dc:creator></item><item><title>RLSL (Rust -&gt; SPIR-V compiler) Progress report</title><link>https://maikklein.github.io/rlsl-progress-report/</link><description><![CDATA[This is a follow up post. RLSL is a Rust to SPIR-V compiler. SPIR-V is the shading language for Vulkan, similar to other shading languages like GLSL, HLSL but more low level. OpenGL, DX9/11/12, Vulkan, Metal are all graphic APIs that are able to use the GPU to draw pixels on the screen. Those APIs have certain stages that can be controlled by the developer by using the correct shading language.]]></description><guid isPermaLink="false">b8e85b25-1d33-4b69-a3ba-b2cbac2bf62e</guid><pubDate>Fri,  9 Feb 2018 00:00:00 +0000</pubDate><dc:creator>Maik Klein</dc:creator></item><item><title>Adventures in Rust: A Basic 2D Game</title><link>https://a5huynh.github.io/2018/02/02/adventures-in-rust.html</link><description><![CDATA[In an effort to do more fun side projects, I’ve been learning Rust, a wonderful systems programming language developed by the Mozilla Foundation. It’s been a while since I’ve touched a compiled language as my day-to-day often deals with Python and Javascript variants. I was inspired after seeing a lot of interesting articles about Rust usage and decided to dive into learning Rust by creating a very basic 2D game, inspired by the classic Defender arcade game.]]></description><guid isPermaLink="false">c73d7d0b-4f7a-4448-acee-d98dbb499461</guid><pubDate>Fri,  2 Feb 2018 00:00:00 +0000</pubDate><dc:creator>Andrew Huynh</dc:creator></item><item><title>Hairy Stuff</title><link>https://www.janwalter.org/jekyll/rendering/pbrt/2018/02/01/hairy-stuff.html</link><description><![CDATA[Last month I was working on a lot of new test scenes for my Rust implementation of the PBRT renderer. But a big chunk of my time went into implementing the curve shape needed for the geometry of hair, and a material, which implements a hair scattering model.]]></description><guid isPermaLink="false">b8c9dfda-526c-453c-a93b-5c96a207643e</guid><pubDate>Thu,  1 Feb 2018 13:30:00 +0100</pubDate><dc:creator>Jan Walter</dc:creator></item><item><title>Introduction to lyon: 2D vector graphics rendering on the GPU in Rust</title><link>https://nical.github.io/posts/lyon-intro.html</link><description><![CDATA[Lyon is a side-project that I have been working on for quite a while. The goal is to play with rendering 2D vector graphics on the GPU, and it's been a lot of fun so far. I haven't talked a lot about it online (except for a couple of reddit threads a year or two ago) so I figured it would be a good topic to get this blog started.]]></description><guid isPermaLink="false">0cced83f-3736-4917-87a0-408fb4d9f6bb</guid><pubDate>Mon, 22 Jan 2018 00:00:00 +0100</pubDate><dc:creator>Nical</dc:creator></item></channel></rss>