<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/"><channel><title>Read Rust - Games and Graphics</title><link>https://readrust.net/</link><description>Games and Graphics posts on Read Rust</description><item><title>This Month in Raygon 1</title><link>https://github.com/raygon-renderer/readme/blob/master/blogs/month-1.md</link><description><![CDATA[It's been about 51 days since I first announced Raygon, a WIP high-performance CPU path tracer written in the Rust programming language, which will feature state of the art light transport integrators, including path tracing, bidirectional path tracing and VCM.

In this post I'll go over some of the features implemented or improved, and show some recent renders, then talk about the future of Raygon and how you can help.]]></description><guid isPermaLink="false">5d2b3926-5f8e-496f-a438-a26c8ed7dfb7</guid><pubDate>Thu, 17 Oct 2019 00:00:00 +0000</pubDate><dc:creator>Aaron Trent</dc:creator></item><item><title>Ruffle: an Adobe Flash Player emulator written in the Rust</title><link>https://github.com/ruffle-rs/ruffle/blob/master/README.md</link><description><![CDATA[Ruffle is an Adobe Flash Player emulator written in the Rust programming language. Ruffle targets both the desktop and the web using WebAssembly.]]></description><guid isPermaLink="false">15a21264-f2eb-4d31-8f58-700f2382b9e8</guid><pubDate>Tue, 15 Oct 2019 00:00:00 +0000</pubDate><dc:creator>Mike Welsh</dc:creator></item><item><title>OxidizeBot - The high octane Twitch bot</title><link>https://setbac.tv/</link><description><![CDATA[OxidizeBot as an open source Twitch Bot empowering you to focus on what's important. It allows for a richer interaction between you and your chat. From a song request system, to groundbreaking game modes where your viewers can interact directly with you and your game.]]></description><guid isPermaLink="false">ab31d896-cb5c-40a9-bb9f-a496a672239b</guid><pubDate>Thu, 10 Oct 2019 00:00:00 +0000</pubDate><dc:creator>John-John Tedro</dc:creator></item><item><title>LDraw.rs: A library for reading and writing Lego model files for native and web</title><link>https://github.com/segfault87/ldraw.rs</link><description><![CDATA[A library for reading and writing LDraw model files and rendering the model using OpenGL for both native and web!]]></description><guid isPermaLink="false">5f7c6828-7321-4f85-8d17-e80a4c0a44ad</guid><pubDate>Sun,  6 Oct 2019 00:00:00 +0000</pubDate><dc:creator>Park Joon-Kyu</dc:creator></item><item><title>Roguelike Tutorial: Up-to-date and Literate</title><link>https://aimlesslygoingforward.com/blog/2019/10/02/roguelike-tutorial-up-to-date-and-literate/</link><description><![CDATA[This tutorial will show you how to write a roguelike in the Rust programming language and the libtcod library. In this update the Asciidoctor documents were changed to allow generating the final source files at the end of each chapter directly from the tutorial text.]]></description><guid isPermaLink="false">e3c786d5-955b-422a-b426-fcc3639d92c3</guid><pubDate>Wed,  2 Oct 2019 00:00:00 +0000</pubDate><dc:creator>Tomas Sedovic</dc:creator></item><item><title>Project update</title><link>https://gfx-rs.github.io/2019/10/01/update.html</link><description><![CDATA[gfx-rs is a Rust project aiming to make low-level GPU programming portable with low overhead. It’s a single Vulkan-like Rust API with multiple backends that implement it: Direct3D 12/11, Metal, Vulkan, and even OpenGL. wgpu-rs is a Rust project on top of gfx-rs that provides safety, accessibility, and even stronger portability. This is an update that is not aligned to any dates or releases. We just want to share about some of the exciting work that landed recently, which will make it to the next release cycle.]]></description><guid isPermaLink="false">17460b05-a9d9-4c79-801c-2a2e54c5132f</guid><pubDate>Tue,  1 Oct 2019 00:00:00 +0000</pubDate><dc:creator>gfx-rs</dc:creator></item><item><title>rx — a minimalist and extensible pixel editor</title><link>http://cloudhead.io/rx/</link><description><![CDATA[rx is an extensible, modern and minimalist pixel editor implemented in Rust. It's designed to have as little UI as possible, and instead takes inspiration from vi's modal nature and command mode. Compared to other pixel editors, rx aims to be smaller, yet more configurable and extendable. `rx` takes a different approach when it comes to animation as well, which is done with *strips*.]]></description><guid isPermaLink="false">ce52dbf1-c1be-4db1-bdb9-c2ac79ed9b1d</guid><pubDate>Mon, 26 Aug 2019 20:08:25 +0000</pubDate><dc:creator>Alexis Sellier</dc:creator></item><item><title>6 months of game development in Rust</title><link>https://iolivia.me/posts/6-months-of-rust-game-dev/</link><description><![CDATA[If you made it here you might have already read my previous post 24 hours of game development in Rust, but if you haven't, it was basically a short summary of how I started learning rust and decided to make a game with it. I started with a classical OOP/trait architecture that was taking me nowhere really fast, so I switched to ECS and got a minimal prototype working. Fast forward 6 months, I wanted to catch you folks up on where I am and what I've learnt so far.]]></description><guid isPermaLink="false">c5ced679-f825-47f6-b97e-11199ed40973</guid><pubDate>Wed, 21 Aug 2019 00:00:00 +0000</pubDate><dc:creator>Olivia Ifrim</dc:creator></item><item><title>Introducing the Rust Game Development Working Group</title><link>https://rust-gamedev.github.io/2019/08/18/introducing-the-rust-game-development-working-group</link><description><![CDATA[Rust’s combination of low-level control, excellent performance and modern build tools makes it an exciting choice for game developers. The idea of a working group to support this burgeoning community has been proposed many times over the years, and we’re excited to announce that a group has finally been formed!]]></description><guid isPermaLink="false">01b4afb8-222b-4d4f-ad09-443d48231e3f</guid><pubDate>Sun, 18 Aug 2019 00:00:00 +0000</pubDate><dc:creator>Rust GameDev</dc:creator></item><item><title>Photo mosaics with Rust</title><link>https://willdady.com/photo-mosaics-with-rust/</link><description><![CDATA[As I've been learning the Rust programming language lately I thought creating a photo-mosaic generator could be a fun project. I knew a generator like this would require a large set of tile images to sample from. The original plan was for it to only create mosaics from emoji which is how it got it's name emosaic (emoji + mosaic = emosaic) but as I progressed it made more sense to keep in generic and let the user provide their own pool of tile images.]]></description><guid isPermaLink="false">0b1d562c-94e0-49fd-be04-15ea918ed05d</guid><pubDate>Sat, 10 Aug 2019 00:00:00 +0000</pubDate><dc:creator>Will Dady</dc:creator></item><item><title>Amethyst game engine activity Report - July 2019</title><link>https://amethyst.rs/posts/activity-report-july-2019</link><description><![CDATA[If you’re new to Amethyst, now is a great time to get better acquainted with our project, developed by a global collective numbering in the double digits. The engine is settling into more frequent releases, making it easier for gamedevs to keep up with our incremental improvements. We’ve added a second showcase game to teach by example whilst demonstrating what Amethyst is currently capable of. And best of all for the newcomers, we’ve introduced the “2D quickstarter”, a simple game template that gets you up and running with a working Amethyst game as quickly as possible.]]></description><guid isPermaLink="false">60559491-c207-46d3-8ca1-0f9b1615975f</guid><pubDate>Sat, 10 Aug 2019 00:00:00 +0000</pubDate><dc:creator>Erlend Sogge Heggen</dc:creator></item><item><title>Animate code with awoo!</title><link>https://phaazon.net/blog/introducing-awoo</link><description><![CDATA[Lately, I’ve been wanting to re-write demoscene-like applications. Not in the same mood and way as I usually did, though. Instead, I want to build small things for people to play with. A bit like small and easy to use audiovisual experiences (it can be seen as small video games for instance, but focused on the artistic expression as some games do).

The thing is, the kind of program we want generates its own inputs based on, mostly, the speed at which the hardware it’s running on is able to render a complete frame. The faster the more accurate we sample from that continuous function. That is actually quite logical: more FPS means, literally, more images to sample. The difference between two images will get less and less noticeable as the number of FPS rises. That gives you smooth images.

The “challenge” here is to write code to schedule those images. Instead of taking a parameter like the time on the command-line and rendering the corresponding image, we will generate a stream of images and will do different things at different times. Especially in demoscene productions, we want to synchronize what’s on the screen with what’s playing on the audio device.]]></description><guid isPermaLink="false">f40bd89a-d036-4bfd-819a-9f7c128707d9</guid><pubDate>Sun, 28 Jul 2019 11:00:00 +0000</pubDate><dc:creator>Dimitri Sabadie</dc:creator></item><item><title>New tools for 2D game development in Amethyst</title><link>https://amethyst.rs/posts/tools-for-2d-games</link><description><![CDATA[Are you looking to build 2D games with Amethyst? Well, we've got some great news for you! Getting started just became a whole lot easier. There's been 2 recent project releases that we want to tell you more about; encourage you to use them, give us feedback and maybe even contribute!]]></description><guid isPermaLink="false">69f76932-86e3-4ee1-b2ee-f9d986b25389</guid><pubDate>Tue, 16 Jul 2019 00:00:00 +0000</pubDate><dc:creator>happens</dc:creator></item><item><title>RPG Name Generation</title><link>https://www.wihlidal.com/blog/general/2019-07-14-name-generation/</link><description><![CDATA[Role-playing and adventure games often require a considerably high number of names to describe characters, locations, items, events, abilities, etc. Humans are very awful generators of randomness, especially upon request. Writers and designers can come up with a handful of well devised names for important identifiers, but having a human generate 100 character names will likely result in many duplicates or boring derivatives. There are a few approaches to this problem: Pattern substitution of a data set with explicit rule-based probability. Using Markov chains to synthesize new results from a data set. Training a neural network to synthesize new results from a data set.]]></description><guid isPermaLink="false">15701ed9-bc70-4c65-bd7b-616363d7d3d4</guid><pubDate>Sun, 14 Jul 2019 00:00:00 +0000</pubDate><dc:creator>Graham Wihlidal</dc:creator></item><item><title>Javelin project</title><link>https://gfx-rs.github.io/2019/07/13/javelin.html</link><description><![CDATA[We are having fun moving the gfx-rs project forward thanks to the power provided by the Rust language. We are building rich abstractions which expand beyond the gfx-hal API itself and into the internal layers of the backends, structured to be modular and maintainable. We are building high-performance graphics and compute infrastructure that deeply interacts with OS and drivers, thanks to the Rust’s FFI capabilities and the lack of runtime. We do all of this while requiring only a portion of our developers’ time and attention, who work on gfx-rs mostly as a side project. Rust allows us to move forward confidently and quickly, experiment with features as well as land production-quality code.]]></description><guid isPermaLink="false">674ac0a5-a4cc-46f3-84c5-2eb3bdfde2f3</guid><pubDate>Sat, 13 Jul 2019 00:00:00 +0000</pubDate><dc:creator>gfx-rs</dc:creator></item><item><title>How to Emulate a Game Boy: The Book</title><link>https://blog.ryanlevick.com/DMG-01/</link><description><![CDATA[DMG-01 is a guide for how to emulate a Game Boy. Together, we'll explore the insides of one of the world's most beloved computers.]]></description><guid isPermaLink="false">f545777e-e75d-40c5-af12-a6c8b2d962f4</guid><pubDate>Sat, 29 Jun 2019 00:00:00 +0000</pubDate><dc:creator>Ryan Levick</dc:creator></item><item><title>The smooth resize test</title><link>https://raphlinus.github.io/rust/gui/2019/06/21/smooth-resize-test.html</link><description><![CDATA[Today is an exciting point in the evolution of native GUI in Rust. There is much exploration, and a number of promising projects, but I also think we don’t yet know the recipe to make GUI truly great. As I develop my own vision in this space, druid, I hope more that the efforts will learn from each other and that an excellent synthesis will emerge, more so than simply hoping that druid will win.

In my work, I have come across a problem that is as seemingly simple, yet as difficult to get right, as making decent tea: handling smooth window resizing. Very few GUI toolkits get it perfect, with some failing spectacularly. This is true across platforms, though Windows poses special challenges. It’s also pretty easy to test (as opposed to requiring sophisticated latency measurements, which I also plan to develop). I suggest it become one of the basic tests to evaluate a GUI toolkit.]]></description><guid isPermaLink="false">1898399d-d60a-46fc-a3e0-cb8a73fb546e</guid><pubDate>Fri, 21 Jun 2019 19:50:42 +0000</pubDate><dc:creator>Raph Levien</dc:creator></item><item><title>Amethyst 0.11.0 has been released!</title><link>https://amethyst.rs/posts/release-0-11</link><description><![CDATA[Amethyst 0.11.0 comes packed with the Rendy integration & many small additions throughout the engine.]]></description><guid isPermaLink="false">13cf6e76-809f-4987-997d-4cb45a26114d</guid><pubDate>Mon, 17 Jun 2019 00:31:00 +0000</pubDate><dc:creator>Thomas Schaller</dc:creator></item><item><title>5 Year Anniversary</title><link>https://gfx-rs.github.io/2019/06/12/anniversary-5.html</link><description><![CDATA[gfx-rs project started with a simple idea: separate the API-specific logic of interaction with the graphic driver from a Rust application. That idea was brewing in the heads of @kvark and @bjz precisely 5 years ago, when they realized the common goal and kicked off the project. The Rust game dev community at the time consisted of a few prominent projects (like kiss3d, claymore, and q3) driven by individuals. They used gl-rs for rendering with no strong separation between higher levels, built as mostly monolithic systems. Because GL was known to keep the CPU occupied on the owning thread, we wanted to provide a separate thread dedicated to talking to the GPU. We had a lot to learn, some great contributors to meet, and hoped to eventually make Rust ecosystem a better place.]]></description><guid isPermaLink="false">5d2b3bb3-b939-4e5a-851f-31963f805af4</guid><pubDate>Wed, 12 Jun 2019 00:00:00 +0000</pubDate><dc:creator>gfx-rs</dc:creator></item><item><title>Nannou Update - Vulkan, LASERs and more!</title><link>https://nannou.cc/posts/nannou_v0.9</link><description><![CDATA[Nannou is an open source, creative coding framework for Rust. Today marks one of the biggest milestones for the project since its launch - the release of version 0.9. This version is particularly special for our community as it lands the last eight months of progress into master and onto crates.io. While some of us have already been using the work-in-progress 0.9 branch in our personal and commercial work over the past few months, it is a relief to finally be able to land and share the progress with the wider world!]]></description><guid isPermaLink="false">0f7e8d0a-81fa-4f1a-aa4d-418554873fe6</guid><pubDate>Sun,  9 Jun 2019 00:00:00 +0000</pubDate><dc:creator>Nannou team</dc:creator></item><item><title>Release Notes for v0.6.0</title><link>https://www.rs-pbrt.org/blog/v0-6-0-release-notes/</link><description><![CDATA[The biggest change for this release is that I started writing a parser for binary Blender files. There is a blog post, where I talk a bit about that, how to explore binary Blender files, and basically how to reconstruct useful information from their DNA.]]></description><guid isPermaLink="false">42c2c580-96cc-4fc8-9485-b29364da6144</guid><pubDate>Fri,  7 Jun 2019 00:00:00 +0000</pubDate><dc:creator>Jan Douglas Bert Walter</dc:creator></item><item><title>Way of Rhea’s Entity System</title><link>https://www.anthropicstudios.com/2019/06/05/entity-systems/</link><description><![CDATA[Entity systems won by a long shot, so that’s what I’m going to be writing about today. In particular, I’m going to outline the process that lead me to Way of Rhea’s current entity system. Way of Rhea is being built in a custom engine and scripting language written in Rust, but the ideas described should still be applicable elsewhere. Hopefully this writeup will be found helpful, or at least interesting. :)]]></description><guid isPermaLink="false">a47585b4-821e-445c-84dd-003d3b449f7f</guid><pubDate>Wed,  5 Jun 2019 00:00:00 +0000</pubDate><dc:creator>Mason Remaley</dc:creator></item><item><title>Evoli - an official Amethyst showcase game</title><link>https://amethyst.rs/posts/evoli-an-official-amethyst-showcase-game</link><description><![CDATA[Today marks the first stable release of Evoli, an evolution-inspired simulation game made in Amethyst. We’ve successfully completed the MVP spec (and then some) as it was laid out back in February.]]></description><guid isPermaLink="false">b1731301-ca91-4f8c-a66a-48320013705b</guid><pubDate>Sun,  2 Jun 2019 00:00:00 +0000</pubDate><dc:creator>Erlend Sogge Heggen</dc:creator></item><item><title>Writing a Raytracer in Rust: part 3</title><link>https://canmom.github.io/programming/graphics/raytracer/rust-raytracer-part-3</link><description><![CDATA[At long last we get to the point of tracing rays - not entirely as we want.]]></description><guid isPermaLink="false">0924bbc6-ebd8-428e-aec2-3ea31077bf2f</guid><pubDate>Sat,  1 Jun 2019 00:00:00 +0000</pubDate><dc:creator>bryn dickinson</dc:creator></item><item><title>Toward Piston 1.0</title><link>http://blog.piston.rs/2019/06/01/toward-piston-1.0/</link><description><![CDATA[The Piston core is a set of libraries that defines a core abstraction for user inputs, window and event loop. If you take a look at the dependency graph in the README, it might look a bit scary: In this post I will go through each library, explain what it does and describe the status of stability.]]></description><guid isPermaLink="false">f6a4f101-2fc4-4bb8-827c-c1e54d5dc877</guid><pubDate>Sat,  1 Jun 2019 00:00:00 +0000</pubDate><dc:creator>Sven Nilsen</dc:creator></item><item><title>[blend_info] Rust and Blender</title><link>https://www.janwalter.org/jekyll/blender/rust/blendinfo/2019/05/28/blend_info.html</link><description><![CDATA[To explore a bit the Blender binary file format and provide tools to read and use them I started a new repository on Codeberg. Finally I want to read Blender files directly, and render them with my own renderer. But on my way to develop such a thing, there are many other possibilities, e.g. one could convert Blender files to a new file format, which does not only work for Blender and one single renderer, but would allow any Digital Content Creation (DCC) tool to save to, and any renderer to read from. Anyway, that's a complicated topic and let's start far simpler, by exploring Blender's file format. You get the source code of Blender for reverse engineering (create a debug version and single step through file related code with a debugger) and some Rust code (provided by me) to see what I have figured out so far...]]></description><guid isPermaLink="false">c8b3f39e-8427-42db-93fa-ea196b956607</guid><pubDate>Tue, 28 May 2019 00:00:00 +0000</pubDate><dc:creator>Jan Walter</dc:creator></item><item><title>Eight million pixels and counting – A look at pathfinder</title><link>https://nical.github.io/posts/a-look-at-pathfinder.html</link><description><![CDATA[This post is about pathfinder, a GPU vector graphics renderer written in Rust by Patrick Walton as part of his work in the emerging technologies team at Mozilla. Pathfinder can be used to render glyph atlases and larger scenes such as SVG paths. The two use cases are handled a bit differently and in this post I will be focusing on the latter.]]></description><guid isPermaLink="false">cbb3c7f8-1ff0-4a30-b924-08c79542c259</guid><pubDate>Tue, 28 May 2019 00:00:00 +0000</pubDate><dc:creator>Nical</dc:creator></item><item><title>Writing a Raytracer in Rust: part 2</title><link>https://canmom.github.io/programming/graphics/raytracer/rust-raytracer-part-2</link><description><![CDATA[After I posted the previous post, one of my friends remarked, "i like the way there is no raytracing in the first post its just faffing to get a window". This is an entirely accurate diagnosis. But, right now, have a representation of a frame buffer as a container (probably a vector) of pixels, which we can pass to the window to render a frame. Now we need to figure out what we’re drawing to it!

There are a couple of tweaks I need to make to this - a representation of the framebuffer in linear float space, for example. But let’s come back to that. I want to trace rays.]]></description><guid isPermaLink="false">5503b5d1-aef0-4bb5-8d51-c050b3d4fb1e</guid><pubDate>Mon, 27 May 2019 00:00:00 +0000</pubDate><dc:creator>bryn dickinson</dc:creator></item><item><title>Terraform: generate 3-d models of geographic terrain</title><link>https://jaredforsyth.com/posts/intoducing-terraform/</link><description><![CDATA[I just spent the past two weeks building a GUI Rust app to help you generate a 3-d model of terrain from around the world, that can then be used for 3-d printing, rendering, or whatever you like.]]></description><guid isPermaLink="false">27b12f19-d9cb-4ac4-b150-14398ad2f7da</guid><pubDate>Thu, 16 May 2019 00:00:00 +0000</pubDate><dc:creator>Jared Forsyth</dc:creator></item><item><title>Zemeroth v0.5: ggez, WASM, itch.io, visuals, AI, campaign, tests</title><link>https://ozkriff.github.io/2019-05-13--devlog-zemeroth-v0-5/</link><description><![CDATA[Zemeroth is a turn-based hexagonal tactical game written in Rust. You can download precompiled v0.5 binaries for Windows, Linux, and macOS. Also, now you can play an online version (read more about it in the "WebAssembly version" section).]]></description><guid isPermaLink="false">8922aaed-cc0e-482a-8422-d7dceec6dac3</guid><pubDate>Mon, 13 May 2019 00:00:00 +0000</pubDate><dc:creator>Andrey Lesnikov</dc:creator></item><item><title>2D Graphics on Modern GPU</title><link>https://raphlinus.github.io/rust/graphics/gpu/2019/05/08/modern-2d.html</link><description><![CDATA[Is the traditional 2D imaging model nearing the end of its usefulness, or does it have a shiny future in the “modern graphics” world? I spent a week on a research retreat in a cottage in the woods to answer this question, as it shapes the future of UI toolkits. Performant UI must use GPU effectively, and it’s increasingly common to write UI directly in terms of GPU rendering, without a 2D graphics API as in the intermediate layer. Is that the future, or perhaps a mistake?]]></description><guid isPermaLink="false">3ce37cbb-5bdc-4340-a83f-9f402616cd58</guid><pubDate>Wed,  8 May 2019 20:40:42 +0000</pubDate><dc:creator>Raph Levien</dc:creator></item><item><title>Handmade Rust Part 4: Generating Vulkan bindings</title><link>http://stevenlr.com/posts/handmade-rust-4-vulkan-bindings/</link><description><![CDATA[Vulkan is a C API so we’ll need some kind of bindings to be able to use it in Rust. The API is defined in a XML file distributed by Khronos. This file describes the structs, enums, constants, and functions for each version of the API, and all published extensions. The functions can then be loaded from the Vulkan dynamic library and other functions from the API.

However using a raw C API isn’t easy in Rust because it requires using a lot of unsafe code. This is why we’ll also generate builders for all structs so we can for instance fill in pointer/size pairs using slices, but we’ll also generate methods that return Rust’s Results and take in Rust-friendly types like references instead of raw C types. Finally we’ll also generate loaders so we don’t have to manually load the function we need.]]></description><guid isPermaLink="false">48eed32e-7fd2-4d16-9a34-97c9289cc72c</guid><pubDate>Sat,  4 May 2019 18:33:36 +0200</pubDate><dc:creator>Steven Le Rouzic</dc:creator></item><item><title>A Guide to Rust Graphics Libraries in 2019</title><link>https://wiki.alopex.li/AGuideToRustGraphicsLibraries2019</link><description><![CDATA[People on the gamedev channel of the Unofficial Rust Discord were talking about graphics API’s and what goes where and what does what, people were contradicting and correcting each other, the rain of acronyms was falling hard and fast, and it was all getting a bit muddled. So I’m here to attempt to set the record straight. This is intended to provide context for people who want to get into writing graphics stuff (video games, animations, cool visualizations, etc) in Rust and don’t know where to start.]]></description><guid isPermaLink="false">55cb403b-5cda-4f80-8708-f55a3dc66e95</guid><pubDate>Thu,  2 May 2019 00:00:00 +0000</pubDate><dc:creator>Simon Heath</dc:creator></item><item><title>Making Sandspiel</title><link>https://maxbittker.com/making-sandspiel</link><description><![CDATA[Sandspiel is a falling sand game I built in late 2018. I really enjoyed writing this game, and wanted to put into writing some of my goals, design decisions, and learnings from that process.]]></description><guid isPermaLink="false">63ae6a45-4e07-49c9-914d-b9be320cf7a9</guid><pubDate>Tue, 30 Apr 2019 00:00:00 +0000</pubDate><dc:creator>Max Bittker</dc:creator></item><item><title>Iterated Function System fractal visualizer in Rust</title><link>https://github.com/jherman3/ifs_fractal/blob/master/README.md</link><description><![CDATA[This is a toy program to render Iterated Function System fractals with Rust and OpenGL. Glium is used for OpenGL and the GUI is provided by imgui-rs.]]></description><guid isPermaLink="false">8c2f780c-fde4-4064-b179-ddc7deaedc98</guid><pubDate>Wed, 27 Mar 2019 00:00:00 +1100</pubDate><dc:creator>jherman3</dc:creator></item><item><title>Entity Component Systems in Rust</title><link>https://ljcode.org/blog/ecs/</link><description><![CDATA[I realised early on that the heart of the game (engine) was going to be the ECS, and while there are many good Rust written crates for an ECS implementation available, I wanted to write my own as an exercise. And so getting it right (for some definition of right) early on would save me a lot of headaches later on down the track. In this post I'll explain the what/where/how/why and some of the intricacies of using Rust for it.]]></description><guid isPermaLink="false">80cba812-a035-4486-8ec8-14c34c637cfe</guid><pubDate>Tue, 26 Mar 2019 00:00:00 +0000</pubDate><dc:creator>Luke Jones</dc:creator></item><item><title>Portability benchmark of Dolphin Emulator on MacOS</title><link>https://gfx-rs.github.io/2019/03/22/dolphin-macos-performance.html</link><description><![CDATA[gfx-rs is a Rust project aiming to make graphics programming more accessible and portable, focusing on exposing a universal Vulkan-like API. It’s a single Rust API with multiple backends that implement it: Direct3D 12/11, Metal, Vulkan, and even OpenGL. We are also building a Vulkan Portability implementation based on it, which allows non-Rust applications using Vulkan to run everywhere. This post is focused on the Metal backend only.

Previously, we benchmarked Dota2 and were able to run many other applications and engines successfully, including Dolphin Emulator. For Dolphin, we previously focused on visual correctness. After games appeared to render correctly, we shifted our focus to performance to ensure they also render quickly.]]></description><guid isPermaLink="false">0b65aa06-68c5-4d0b-9160-6edb0ca35f34</guid><pubDate>Fri, 22 Mar 2019 00:00:00 +0000</pubDate><dc:creator>gfx-rs</dc:creator></item><item><title>Implementing a NES Emulator in Rust</title><link>http://www.michaelburge.us/2019/03/18/nes-design.html</link><description><![CDATA[Recently, I made an emulator for the Nintendo Entertainment Console(NES) - a game console first released in 1983. In this article, I’ll talk about how I used Rust to develop the emulator. I’ll cover questions like: What features does the emulator support? What games can it play? How did I approach the problem of emulating the NES? Did Rust’s type system or borrow checker interfere? Were there performance issues?]]></description><guid isPermaLink="false">54f59df5-bf2f-46e5-a817-0a31878f7cda</guid><pubDate>Mon, 18 Mar 2019 13:34:00 +0000</pubDate><dc:creator>Michael Burge</dc:creator></item><item><title>Making a basic game UI with imgui and ggez</title><link>http://iolivia.me/posts/imgui-ggez/</link><description><![CDATA[In this post I'll walk you through how you can create game user interface with imgui and ggez. I spent a lot of time trying to make this work for my game (which you can read more about here) and suffered greatly because of the lack of documentation, so I'm writing this so you don't have to!]]></description><guid isPermaLink="false">3afe3b54-7b4e-46a5-90c5-b6a23b5d803f</guid><pubDate>Mon, 11 Mar 2019 00:00:00 +0000</pubDate><dc:creator>Olivia Ifrim</dc:creator></item><item><title>The rise of wgpu: Native WebGPU implementation based on gfx-hal</title><link>https://gfx-rs.github.io/2019/03/06/wgpu.html</link><description><![CDATA[WebGPU is a new graphics/compute API developed by the browser vendors (and Intel) within W3C: The goal is to design a new Web API that exposes these modern technologies in a performant, powerful and safe manner.

Don’t be confused by the “Web” part here - both us (gfx-rs team) and Google are trying to make it feasible to run on native platforms as well. Typically, the Web as a platform has different priorities from native: a lot of focus is placed on the security and portability (in a wider and stronger sense). Coincidentally, these are qualities we are currently missing in the gfx-rs ecosystem: security means safety (in the Rust sense), and portability means that people can use it and run everywhere, without worrying about thousands of potential configurations at run-time, or diverging behavior between platforms due to timing differences or loosely defined behavior.

With these goals in mind, we’d like to announce our new project: wgpu-rs.]]></description><guid isPermaLink="false">861a769a-5c77-4afb-bb9d-b0e05cd3855e</guid><pubDate>Wed,  6 Mar 2019 00:00:00 +0000</pubDate><dc:creator>gfx-rs</dc:creator></item><item><title>Entity component system (ECS) explained with tennis players and courts</title><link>http://iolivia.me/posts/entity-component-system-explained/</link><description><![CDATA[In the last post  I talked about a small game I built in Rust and roughly how far I got in 24 hours. One of the biggest challenges I had was…]]></description><guid isPermaLink="false">df193fd9-bd7c-45bc-bc27-27ba8dee5bbb</guid><pubDate>Sun,  3 Mar 2019 00:00:00 +0000</pubDate><dc:creator>Olivia Ifrim</dc:creator></item><item><title>24 hours of game development in Rust</title><link>http://iolivia.me/posts/24-hours-of-rust-game-dev/</link><description><![CDATA[In this post I'll talk about a small game I've been developing in about 24 hours in total (mostly in a few hour blocks during evenings or weekends). The game is far from finished, but I thought I'd write up about my experience so far, what I've learnt and some interesting observations about building a game from scratch-ish and doing it in Rust.]]></description><guid isPermaLink="false">38d6b47d-bd95-4566-af44-c30769c1e149</guid><pubDate>Fri,  1 Mar 2019 00:00:00 +0000</pubDate><dc:creator>Olivia Ifrim</dc:creator></item><item><title>Procedural Generation with Wave Function Collapse</title><link>https://gridbugs.org/wave-function-collapse/</link><description><![CDATA[Wave Function Collapse is a procedural generation algorithm which produces images by arranging a collection of tiles according to rules about which tiles may be adjacent to each other tile, and relatively how frequently each tile should appear. The algorithm maintains, for each pixel of the output image, a probability distribution of the tiles which may be placed there. It repeatedly chooses a pixel to “collapse” - choosing a tile to use for that pixel based on its distribution. WFC gets its name from quantum physics. The goal of this post is to build an intuition for how and why the WFC algorithm works.]]></description><guid isPermaLink="false">2c967b7c-6987-45ae-96b1-776ee6c51011</guid><pubDate>Thu, 21 Feb 2019 00:00:00 +0000</pubDate><dc:creator>Stephen Sherratt</dc:creator></item><item><title>Updates about my work on native-Rust GUI, text layout, splines, markdown parsing, and more</title><link>https://raphlinus.github.io/personal/2019/02/20/more-small-updates.html</link><description><![CDATA[This post is actually a collection of updates about pretty big things, but the writeup is small. Several will be expanded into larger blog posts - if there are any that you are especially eager to see, please tweet at me and I’ll give the topic priority.]]></description><guid isPermaLink="false">ea353a56-0b7b-4025-a410-0e479c39950a</guid><pubDate>Wed, 20 Feb 2019 17:02:42 +0000</pubDate><dc:creator>Raph Levien</dc:creator></item><item><title>My Tour of Rust – Day 4 – Ray Tracing Part 2</title><link>https://rushtonality.com/2019/02/15/my-tour-of-rust-day-4-ray-tracing-part-2/</link><description><![CDATA[Learning Rust through the porting of the code from Peter Shirley's Ray Tracing in a Weekend. Focused on Polymorphism, Ownership and Traits in Rust.]]></description><guid isPermaLink="false">54a69419-caf9-408f-bd41-ab6ee7897b92</guid><pubDate>Fri, 15 Feb 2019 20:13:45 +0000</pubDate><dc:creator>Stephen Rushton</dc:creator></item><item><title>Writing a Rust Roguelike for the Desktop and the Web</title><link>https://aimlesslygoingforward.com/blog/2019/02/09/writing-a-rust-roguelike-for-the-desktop-and-the-web/</link><description><![CDATA[I want to participate in this year's 7 Day Roguelike Challenge. If you've looked around this blog, you know the language is going to be Rust. But for the 7DRL, I'd really love if people could play it in the browser. What follows is a little guide to get you to a small playable proof of concept that can build native Windows, macOS and Linux executables but also runs in the browser via WebAssembly.]]></description><guid isPermaLink="false">df83e971-50b8-474a-8ecf-dd9a2b213972</guid><pubDate>Sat,  9 Feb 2019 18:13:52 +0000</pubDate><dc:creator>Tomas Sedovic</dc:creator></item><item><title>What is Happening in Piston 7</title><link>http://blog.piston.rs/2019/02/08/what-is-happening-7/</link><description><![CDATA[This blog post is a brief summary of what happened the past 8 months in the Piston project.]]></description><guid isPermaLink="false">7ace680c-a527-42f6-9eeb-dc4fd680aa53</guid><pubDate>Fri,  8 Feb 2019 00:00:00 +0000</pubDate><dc:creator>Sven Nilsen</dc:creator></item><item><title>Packaging a game for Windows, Mac, and Linux with Rust.</title><link>https://agmprojects.com/blog/packaging-a-game-for-windows-mac-and-linux-with-rust</link><description><![CDATA[Building a cross platform game for desktop operating systems in Rust is fairly doable without needing much platform specific code. Glutin is a Rust alternative to SDL for handling window creation & input. GFX handles most of the graphics API abstraction for you. You still write the shaders, but I was able to just use OpenGL and get it working on Windows 10, MacOS, and Ubuntu.]]></description><guid isPermaLink="false">8a353b9f-bb7e-40d7-a5ab-fd5372ad76f4</guid><pubDate>Sat,  2 Feb 2019 23:53:56 +0000</pubDate><dc:creator>Aaron McLeod</dc:creator></item><item><title>A bot for Starcraft in Rust, C or any other language</title><link>https://habr.com/en/post/436254/</link><description><![CDATA[StarCraft: Brood War. This game means so much to me! And to many of you, I guess. So much, that I wonder if I should even give a link to its page on Wikipedia or not.

Once Halt sent me PM and offered to learn Rust. Like any ordinary people, we decided to start with hello world writing a dynamic library for Windows that could be loaded into StarCraft's address space and manage units.]]></description><guid isPermaLink="false">aded8d9a-b1d5-47b6-aa28-fcee947cbfb1</guid><pubDate>Thu, 17 Jan 2019 10:15:00 +0000</pubDate><dc:creator>Roman Proskuryakov</dc:creator></item><item><title>OpenMoonstone v0.2 released</title><link>http://leastsignificant.blogspot.com/2019/01/openmoonstone-v02-released.html?m=1</link><description><![CDATA[OpenMoonstone is a open source reimplementation of Moonstone: A Hard Day's Knight following along the lines of projects like OpenTTD and OpenXcom. You can try it out https://github.com/joetsoi/OpenMoonstone]]></description><guid isPermaLink="false">6bd951b0-06dc-445a-9e68-ea9c56b18e37</guid><pubDate>Wed, 16 Jan 2019 19:34:00 +0000</pubDate><dc:creator>least significant</dc:creator></item><item><title>After Hours Game Development</title><link>https://alexene.github.io/2019/01/15/After-hours-game-development.html</link><description><![CDATA[In my spare time I am working on a dwarf colony management game that’s written in rust. I started this project about one year ago and since it has reached this milestone and I didn’t abandon it I think it’s a good time to look at the curent status.]]></description><guid isPermaLink="false">83f4f369-b8cd-43ba-a61f-87a1654e64a9</guid><pubDate>Tue, 15 Jan 2019 00:00:00 +0000</pubDate><dc:creator>Alexandru Ene</dc:creator></item><item><title>Introducing Ammolite: A work-in-progress rendering engine with focus on VR/AR</title><link>https://metaview.link/articles/introducing-ammolite.html</link><description><![CDATA[Welcome to the inaugural article of the metaview project. metaview is an effort to create a universal platform for VR/AR applications similarly to how the web browser is a platform for web applications. For more information about metaview and its goals, see About. This article covers ammolite, a work-in-progress rendering engine with focus on VR/AR.]]></description><guid isPermaLink="false">f0ba6ba2-b32e-4d88-a8e4-a1e33f099387</guid><pubDate>Sat, 12 Jan 2019 00:00:00 +0000</pubDate><dc:creator>Jakub Hlusička </dc:creator></item><item><title>The State Of GGEZ 2019</title><link>https://wiki.alopex.li/TheStateOfGGEZ2019</link><description><![CDATA[ggez is a lightweight portable game framework in Rust, inspired by LÖVE. I do most of the actual maintenance and planning behind it, and I’ve been sort of in and out of contact this year, so I thought I’d write up a little thing about the present and future of the project. I remembered that at the beginning of last year I wrote GgezOnWasm, but only remembered a little of what went into it, so I went back and read it. And then got hives from the stress of all the promises I’ve made. So, I feel justified in being a bit slow with working on ggez lately.]]></description><guid isPermaLink="false">3ea00e75-be59-40b9-bdc5-e7a783044422</guid><pubDate>Thu, 10 Jan 2019 00:00:00 +0000</pubDate><dc:creator>Simon Heath</dc:creator></item><item><title>Year of wlroots</title><link>http://way-cooler.org/blog/2019/01/09/year-of-wlroots.html</link><description><![CDATA[ wlroots is a hip new Wayland compositor framework that Way Cooler has been using for about a year now. I’m going to go ahead and declare 2019 the year of wlroots. Most of the work was done in 2018, but this year is when major compositors will begin to use it. Currently the only usable Wayland compositor that uses wlroots is sway, which is fast approaching a stable 1.0. However there is a long list of startup compositors (including Way Cooler) that are using wlroots. At least some of them are expected to come into their own as alternatives to traditional X11 based systems this year, and it’s all thanks to wlroots.]]></description><guid isPermaLink="false">3b8b78a8-dd56-425a-86f5-886e7341a8c4</guid><pubDate>Wed,  9 Jan 2019 00:00:00 +0000</pubDate><dc:creator>Preston Carpenter</dc:creator></item><item><title>WebGL + Rust: Basic Water Tutorial</title><link>http://www.chinedufn.com/3d-webgl-basic-water-tutorial/</link><description><![CDATA[In this tutorial we’ll discuss the ideas and concepts behind rendering water and then talk through some demo code.]]></description><guid isPermaLink="false">0cba574e-769b-491e-83de-cfa070b1b942</guid><pubDate>Sun,  6 Jan 2019 13:00:00 -0500</pubDate><dc:creator>Chinedu Francis Nwafili</dc:creator></item><item><title>Followups</title><link>https://raphlinus.github.io/curves/graphics/2019/01/04/followups.html</link><description><![CDATA[Here are some followups on previous blog postings. Including, Arclength, and 2D graphics.]]></description><guid isPermaLink="false">9cccb5d4-edfb-483f-ab75-0b099242fd69</guid><pubDate>Fri,  4 Jan 2019 16:54:42 +0000</pubDate><dc:creator>Raph Levien</dc:creator></item><item><title>Using Rust for Gamedev</title><link>https://medium.com/@michelotti.matthew/using-rust-for-gamedev-2f60b0e4cc5c</link><description><![CDATA[I’ve recently created a new website and finished an online game named Adventures of Pascal Penguin. One of the most unique things about this game is that it was written in Rust and runs in web browsers thanks to WebAssembly. WebAssembly has only been mainstream for about a year or so, so not many games have been created like this. I want to share a little about my journey with Rust: how I started with it and how I got to this point.]]></description><guid isPermaLink="false">4fda94a2-d93a-4d1d-8ffe-e171600b13ce</guid><pubDate>Fri,  4 Jan 2019 06:15:37 +0000</pubDate><dc:creator>Matthew Michelotti</dc:creator></item><item><title>Russian AI Cup 2018</title><link>https://blog.kuviman.com/2019/01/01/russian-ai-cup-2018.html</link><description><![CDATA[Russian AI Cup — annual IT-oriented competition initiative, organized by Mail.Ru Group and Codeforces. Last year we started using Rust compiled to WebAssembly to show the games on web. This time, we went even further, and the game itself is now written in Rust. So, now web player, local game runner and testing suite is actually same application with same source code. This means that you can, among other things, play the game in browser, which was not possible before.]]></description><guid isPermaLink="false">3f5071e6-1c55-42fc-ac93-8b1d70958d25</guid><pubDate>Tue,  1 Jan 2019 00:00:00 +0000</pubDate><dc:creator>kuviman</dc:creator></item><item><title>This Year in Gfx-rs - 2018</title><link>https://gfx-rs.github.io/2018/12/27/this-year.html</link><description><![CDATA[In 2018 the project left the nursery and entered the adolescence period...]]></description><guid isPermaLink="false">9a6530f2-df83-41a2-b9fe-c2408eabbe0f</guid><pubDate>Thu, 27 Dec 2018 00:00:00 +0000</pubDate><dc:creator>gfx-rs</dc:creator></item><item><title>CFG Game: Put your CS skills to good use and craft burgers</title><link>http://rickyhan.com/jekyll/update/2018/12/03/make-burgers-context-free-grammar.html</link><description><![CDATA[This past weekend I made a game for Ludum Dare 43. Tools used: Aseprite, quicksilver. Inspired by Zachtronics. It is written in Rust and compiled to WebAssembly.]]></description><guid isPermaLink="false">5493161b-6e7d-4b81-887f-af80a0d2c410</guid><pubDate>Mon,  3 Dec 2018 04:37:02 +0000</pubDate><dc:creator>Ricky Han</dc:creator></item><item><title>Announcing RustaCUDA v0.1.0</title><link>https://bheisler.github.io/post/announcing-rustacuda/</link><description><![CDATA[In my post on GPGPU in Rust, I declared that I intended to work on improving the state of CUDA support in Rust. Since then, I’ve been mostly radio-silent. I’m pleased to announce that I have actually been working on something, and I’ve finally published that something.
RustaCUDA RustaCUDA is a new wrapper crate for the CUDA driver API. It allows the programmer to allocate and free GPU memory, copy data to and from the GPU, load CUDA modules and launch kernels, all with a mostly-safe, programmer-friendly, Rust-y interface.]]></description><guid isPermaLink="false">05addab4-8c30-4a75-9221-e156ea5d319c</guid><pubDate>Sat,  1 Dec 2018 15:00:00 -0600</pubDate><dc:creator>Brook Heisler</dc:creator></item><item><title>Amethyst Foundation Created</title><link>https://www.amethyst.rs/blog/non-profit-announce/</link><description><![CDATA[The Amethyst team has some special announcements. A non-profit foundation has been formed and a new community forums site has been created.]]></description><guid isPermaLink="false">1e18d220-093b-46bd-b260-640ed3d74deb</guid><pubDate>Fri, 23 Nov 2018 00:00:00 +0000</pubDate><dc:creator>Moxinilian (Théo Degioanni)</dc:creator></item><item><title>Synthesizing Structures with immense</title><link>https://paytonturnage.com/writing/2018-11-17-synthesizing-structures-with-immense/</link><description><![CDATA[I wrote a nightly Rust library called immense for synthesizing 3D structures with simple composable rules, inspired by Structure Synth. In the docs I cover the basics, and in this article I’ll go over making a mesh from start to finish.]]></description><guid isPermaLink="false">04284ee3-1ace-4204-bb2f-e2d27249c8c2</guid><pubDate>Sat, 17 Nov 2018 12:09:00 +0000</pubDate><dc:creator>Payton Turnage</dc:creator></item><item><title>Rust And Game Development</title><link>https://alexene.github.io/2018/11/15/Rust-and-game-development.html</link><description><![CDATA[Rust is excellent for performance crucial applications that run on multi-processor architectures and these two aspects are also critical for game development. Rust has already seen a bunch of interest from games developers like Chucklefish, Embark Studios, Ready at Dawn, etc. - but in order to really excel I’d love to organize some structured efforts to improve the ecosystem and I think it would be great if the 2019 roadmap will include game development.]]></description><guid isPermaLink="false">dabab963-1e9e-4b55-bb85-d0173a1db54a</guid><pubDate>Thu, 15 Nov 2018 00:00:00 +0000</pubDate><dc:creator>Alexandru Ene</dc:creator></item><item><title>Pyro - A fast, small and documented Entity Component System</title><link>https://maikklein.github.io/pyro-ecs/</link><description><![CDATA[In contrast to many other ECS, iteration in Pyro is fully linear. Different combinations of components always live in the same storage. The advantage is that iteration is always fully linear and no cache is wasted. The storage behind the scene is a SoA storage.]]></description><guid isPermaLink="false">092a372d-fa4a-48e7-8382-c85069e9a425</guid><pubDate>Tue, 30 Oct 2018 00:00:00 +0000</pubDate><dc:creator>Maik Klein</dc:creator></item><item><title>2d graphics in Rust discussion - A look at GPU memory management</title><link>https://nical.github.io/posts/rust-2d-graphics-02.html</link><description><![CDATA[In this post I'll write about an piece of the low level details of an hypothetical rust 2d graphics crate built on top of gfx-hal. Gfx provides a vulkan-like interface implemented on top of vulkan, d3d12, metal or flavors of OpenGL. just like the previous post this is in the context of recent discussions about a 2d graphics crate in rust.]]></description><guid isPermaLink="false">7141c453-0f38-4d85-a3bd-f01abc08ad77</guid><pubDate>Sun, 28 Oct 2018 00:00:00 +0200</pubDate><dc:creator>Nical</dc:creator></item><item><title>Release of glsl-quasiquote-0.2 with support for GLSL pragmas</title><link>https://phaazon.net/blog/glsl-quasiquote-0.2</link><description><![CDATA[glsl-quasiquote-0.2 was released early this morning. This new version provides a more stable public API. Two major changes: The glsl_str! proc-macro would have only survived the 0.1 version. It’s now deprecated and will be removed soon. The glsl! proc-macro now supports GLSL pragmas (both #version and #extension).]]></description><guid isPermaLink="false">0367445a-ecf2-4c7a-9829-1b38d731036c</guid><pubDate>Mon, 22 Oct 2018 02:00:00 +0000</pubDate><dc:creator>Dimitri Sabadie</dc:creator></item><item><title>Rust Mesh Optimizer</title><link>https://www.wihlidal.com/blog/pipeline/2018-10-20-rust-mesh-optimizer/</link><description><![CDATA[When triangle meshes are rendered by a GPU, there are pipeline stages that need to load and process vertex and index data. The efficiency of this process will depend on the layout of the data, and how the GPU is designed. There is an excellent library from Arseny Kapoulkine called meshoptimizer, which provides a variety of algorithms for optimizing geometry for the GPU.]]></description><guid isPermaLink="false">ec7874f9-e0a0-453b-b723-bdcb56e8ad09</guid><pubDate>Sat, 20 Oct 2018 00:00:00 +0000</pubDate><dc:creator>Graham Wihlidal</dc:creator></item><item><title>Amethyst is growing; news on ongoing projects</title><link>https://www.amethyst.rs/blog/dev-news-10-2018/</link><description><![CDATA[We want to share some of the progress being made on Amethyst! As we've had a lot of expansion, we've also revamped the way we manage the project and we have some very interesting new features being worked on.]]></description><guid isPermaLink="false">7abf3b08-b87f-4bd1-a4f4-4d79f4216413</guid><pubDate>Sun, 14 Oct 2018 00:00:00 +0000</pubDate><dc:creator>Moxinilian (Théo Degioanni)</dc:creator></item><item><title>Following up on the 2d graphics in Rust discussion</title><link>https://nical.github.io/posts/rust-2d-graphics-01.html</link><description><![CDATA[Ralph Levien recently published A crate I want: 2d graphics on his blog, which started some interesting discussions on reddit. At the same time there is a nascent discussion on the draw2d repository (which doesn't have any code at this point) about a potential 2d graphics crate.]]></description><guid isPermaLink="false">3d3a61ed-ff74-4407-b508-0c7405b8c653</guid><pubDate>Sun, 14 Oct 2018 00:00:00 +0200</pubDate><dc:creator>Nical</dc:creator></item><item><title>A crate I want: 2d graphics</title><link>https://raphlinus.github.io/rust/graphics/2018/10/11/2d-graphics.html</link><description><![CDATA[The Rust ecosystem has lot of excellent crates, and many more new ones being published. I believe one is missing, though, and I’d really like to see it happen: a cross-platform abstraction for 2D graphics. In this post I will set out what I want.]]></description><guid isPermaLink="false">63fef91b-3a2c-4b05-9fad-bc5a80bd1733</guid><pubDate>Thu, 11 Oct 2018 22:44:03 +0000</pubDate><dc:creator>Raph Levien</dc:creator></item><item><title>Game Dev From Zero - Part 1: Hello</title><link>https://hashnode.com/post/game-dev-from-zero-part-1-hello-rust-lang-cjn3brwto001jv7s2e533bdfc</link><description><![CDATA[With this article, I want to introduce you to game development. I want to give you a little tour of where to start, how to explore possibilities and revive my journey a little bit at the same time. I will try to construct different games from the ground up while writing this article, so you can experience game-dev live.]]></description><guid isPermaLink="false">9a9651de-466e-411e-9449-c1d6878ffba0</guid><pubDate>Thu, 11 Oct 2018 00:00:00 +0000</pubDate><dc:creator>Marco Alka</dc:creator></item><item><title>Gfx-hal Tutorial part 2: Vertex buffers</title><link>https://falseidolfactory.com/2018/10/09/gfx-hal-part-2-vertex-buffers.html</link><description><![CDATA[For the last two parts of this tutorial, all we’ve had to look at on-screen is a single blueish triangle. In this part, we want to display a more complex shape, with more variation in color. To do this, we’ll have to stop hard-coding our triangle mesh in the vertex shader. (And start hard-coding it in the source code!)]]></description><guid isPermaLink="false">1ac9419e-3a15-4c2e-961d-20160f9ef6e9</guid><pubDate>Tue,  9 Oct 2018 00:00:00 +0000</pubDate><dc:creator>Mistodon</dc:creator></item><item><title>GLSL quasiquoting in Rust!</title><link>https://phaazon.net/blog/glsl-quasiquoting</link><description><![CDATA[glsl-quasiquote-0.1 was released today! The crate provides you with two macros: glsl! and glsl_str!. Both are procedural macros that requires a nightly compiler and the proc_macro_non_items feature. They will both output a TranslationUnit, that represents a whole shader AST.]]></description><guid isPermaLink="false">4a3da20e-11fb-4868-9aa1-593f62439bd9</guid><pubDate>Fri,  5 Oct 2018 19:00:00 +0000</pubDate><dc:creator>Dimitri Sabadie</dc:creator></item><item><title>The Undergarden, a text adventure in Rust: 2 - Objects</title><link>https://www.cattlegrid.info/the-undergarden-text-adventure-rust-2-objects</link><description><![CDATA[In this second blog post I’m showing how I implemented objects - things the player can interact with - for a text adventure written in Rust. As usual, the full code is available on GitHub.]]></description><guid isPermaLink="false">22538446-2c14-4b71-bd82-46c2db0371a1</guid><pubDate>Thu,  4 Oct 2018 04:51:00 +0000</pubDate><dc:creator>Michele Beltrame</dc:creator></item><item><title>Porting My CUDA Path Tracer to ptx-builder/linker</title><link>https://bheisler.github.io/post/ptx-builder-and-linker/</link><description><![CDATA[A bunch of stuff has happened since I published my post on The State of GPGPU in Rust. Most importantly, Denys Zariaiev (@denzp) released his work on a custom linker for Rust CUDA kernels, and a build.rs helper crate to make it easier to use.
These two crates eliminate many of the problems I referred to in my previous post. The linker solves most of the “invalid PTX file” problems, while the ptx-builder crate does all of the magic that Accel was doing behind the scenes.]]></description><guid isPermaLink="false">abd3f1ce-8faf-4c92-a8d3-20c34e41af97</guid><pubDate>Mon,  1 Oct 2018 19:00:00 -0600</pubDate><dc:creator>Brook Heisler</dc:creator></item><item><title>Rust RPG: Introductory Tutorial of Rust, Unit Testing, and Continuous Integration with a Roguelike</title><link>https://medium.com/@cameron.manavian/rust-rpg-introductory-tutorial-of-rust-unit-testing-and-continuous-integration-with-a-roguelike-b7b86e90855c</link><description><![CDATA[We’re going to walk through a Rust application that I’ve built, which is essentially a basic Roguelike in most regards.]]></description><guid isPermaLink="false">ec683955-b4c5-426c-858d-f180fde10abb</guid><pubDate>Fri, 28 Sep 2018 13:46:04 +0000</pubDate><dc:creator>Cameron Manavian</dc:creator></item><item><title>The Undergarden, a text adventure in Rust: 1 - Sections</title><link>https://www.cattlegrid.info/the-undergarden-text-adventure-rust-1-sections</link><description><![CDATA[I’m attempting to write a (very simple, at least initally) text adventure in Rust, so I’m going to share progress on my blog starting today. This first post is about the sections, that to day is the rooms of a house for example.]]></description><guid isPermaLink="false">c0b70c5d-190f-4c9d-ac44-d65a64a61b1f</guid><pubDate>Thu, 27 Sep 2018 20:04:00 +0000</pubDate><dc:creator>Michele Beltrame</dc:creator></item><item><title>My recommended crates for computer graphics</title><link>https://jonathansteyfkens.com/rust/graphics/compute/2018/09/15/my-recommended-cg-crates.html</link><description><![CDATA[It’s been a while since my last post! Lately I’ve been quite demotivated to actually produce something worth while for doing a writeup about. Instead I offer you some thoughts on my recent findings using rust and some crates I found particularly useful for computer graphics.]]></description><guid isPermaLink="false">3cd66c51-9cd4-4548-9a94-214d3f241ae2</guid><pubDate>Sat, 15 Sep 2018 22:15:00 +0000</pubDate><dc:creator>Jonathan Steyfkens</dc:creator></item><item><title>My RustConf 2018 Closing Keynote</title><link>https://kyren.github.io/2018/09/14/rustconf-talk.html</link><description><![CDATA[I said in my talk that I would post a potentially more interesting long-form version of the talk that includes things that I couldn’t fit into the 30-ish minute time slot. What I’ve included below is my original long-form version of this talk, but my original intention was not to post this as-is. Originally I wanted to clean this up a bit more and make this into something that wasn’t so much a giant wall of text, but after I started doing this I realized that I was just rewriting it entirely, and at that rate I would never get around to releasing it, which I promised I would do in a timely manner.]]></description><guid isPermaLink="false">68ff6ef3-ead4-43c9-8813-f355d9f3710c</guid><pubDate>Fri, 14 Sep 2018 00:00:00 +0000</pubDate><dc:creator>Catherine West</dc:creator></item><item><title>RPCS3 and Dolphin emulators on macOS using gfx-portability</title><link>https://gfx-rs.github.io/2018/09/03/rpcs3-dolphin.html</link><description><![CDATA[After improving functionality and performance of gfx-portability’s Metal backend through benchmarking Dota2, and verifying certain functionality through the Vulkan Conformance Test Suite (CTS), we decided to expand our testing to other projects. We quickly found two projects which matched our criteria: RPCS3 and Dolphin.]]></description><guid isPermaLink="false">6c60dc7f-81f5-4718-9bfa-4c68e7a7d1ab</guid><pubDate>Mon,  3 Sep 2018 00:00:00 +0000</pubDate><dc:creator>gfx-rs</dc:creator></item><item><title>Programmatically generated artwork</title><link>https://isaacg1.github.io/posts/programmatically-generated-artwork/</link><description><![CDATA[I have made four rust programs for programmatically generating artwork in different styles. Here is a sample in each style, along with an explanation of the algorithms.]]></description><guid isPermaLink="false">1b68ce01-24d8-45a9-88df-be24c465141b</guid><pubDate>Sun, 26 Aug 2018 02:29:13 -0400</pubDate><dc:creator>Isaac Grosof</dc:creator></item><item><title>Gfx-hal Tutorial part 1: Resizing windows</title><link>https://falseidolfactory.com/2018/08/23/gfx-hal-part-1-resizing-windows.html</link><description><![CDATA[This tutorial builds on the code we wrote in the previous part. You can find the new code here with comments explaining everything that’s changed, and run it to see what the end result will look like. Last time we got a single triangle rendering on screen. This time we’re going to look at what we need to do to allow window resizing to work properly.]]></description><guid isPermaLink="false">72c8ca7f-1f7e-47f5-aebc-f06e63a1b367</guid><pubDate>Thu, 23 Aug 2018 00:00:00 +0000</pubDate><dc:creator>Mistodon</dc:creator></item><item><title>Journey into rust #2: Compute Shaders</title><link>https://jonathansteyfkens.com/rust/opengl/graphics/compute/shader/2018/08/19/compute-shaders.html</link><description><![CDATA[I realized after my first post of this series that it’s not just a journey into rust but also OpenGL. I’ve used other Graphics API’s before but never actually got my hands dirty into OpenGL. Someone on the rust user forums (they are awesome, go check it out!) suggested using compute shaders instead. At the time I had never used compute shaders for a project so I decided to take some time to refactor the program to use a compute shader. This post is a follow up on that remark and will explore the possibilities of using a rust together with OpenGL to run compute shaders.]]></description><guid isPermaLink="false">5e9a2cd7-e018-41d6-bfeb-a0face2c3f0e</guid><pubDate>Sun, 19 Aug 2018 20:30:00 +0000</pubDate><dc:creator>Jonathan Steyfkens</dc:creator></item><item><title>rusty_gl: A simple wrapper over rs-gl to make code safer</title><link>https://www.reddit.com/r/rust/comments/982kqg/rusty_gl_a_simple_wrapper_over_rsgl_to_make_code/</link><description><![CDATA[I enjoy using OpenGL a lot, but when I switched from C++ to Rust I found it to be less fun to use. This is because the OpenGL (from gl-rs) code never really fit alongside the rest of my Rust code, due to unsafe blocks, PascalCase function names, hacky conversions to c_void pointers etc. So, to make my life easier in the future when using OpenGL in Rust, I made this crate.]]></description><guid isPermaLink="false">0d9f9b5e-33e1-492a-976e-fcbf0826cbab</guid><pubDate>Sat, 18 Aug 2018 00:10:17 +1000</pubDate><dc:creator>Hopson97</dc:creator></item><item><title>Gfx-hal Tutorial part 0: Drawing a triangle</title><link>https://falseidolfactory.com/2018/08/16/gfx-hal-part-0-drawing-a-triangle.html</link><description><![CDATA[Eight part series on using gfx-hal for low level graphics programming.]]></description><guid isPermaLink="false">5eb3a4b0-7653-43b1-9958-a8b96bc32338</guid><pubDate>Thu, 16 Aug 2018 00:00:00 +0000</pubDate><dc:creator>Mistodon</dc:creator></item><item><title>UniverCity released into early access</title><link>https://thinkof.name/2018/08/14/early-access-release.html</link><description><![CDATA[UniverCity is a university management game being programmed in the Rust programming language. As stated above, the game is in early access and is not complete. There will be changes and additions down the line and finishing it may take some time. You may wish to wait until its further along before buying it.]]></description><guid isPermaLink="false">2e354a2e-10fe-410c-adbf-7b739def3ab6</guid><pubDate>Tue, 14 Aug 2018 10:00:00 +0000</pubDate><dc:creator>Thinkofname</dc:creator></item><item><title>GSoC 2018 - D3D11 backend for gfx-rs</title><link>https://gfx-rs.github.io/2018/08/14/gsoc.html</link><description><![CDATA[For this years GSoC I (@fkaa) worked on implementing the DirectX 11 backend for gfx, a graphics API which translates to Vulkan, DirectX 12 and Metal.]]></description><guid isPermaLink="false">c1519934-b4d6-49ed-bc58-1450331afa63</guid><pubDate>Tue, 14 Aug 2018 00:00:00 +0000</pubDate><dc:creator>Felix Kaaman</dc:creator></item><item><title>Ludum Dare 42 Postmortem</title><link>https://wiki.alopex.li/LD42Postmortem</link><description><![CDATA[One of my favorite game jams is Ludum Dare: It’s just you, a theme, and 48 hours to make a game. Pure and challenging, and I’ve participated in several of them from time to time with a variety of tools. Usually my go-to is Unity3D, though arguably my best game was in Python+Pygame. This time though, for Ludum Dare 42 on August 2018, I finally had both the energy and ability to write my game in Rust, using ggez. So I decided to write about it!]]></description><guid isPermaLink="false">8914a4f4-eff5-4563-a82f-0c55d013ef7f</guid><pubDate>Mon, 13 Aug 2018 14:53:05 +0000</pubDate><dc:creator>Simon Heath</dc:creator></item><item><title>Ray Tracing: WebAssembly vs JavaScript</title><link>http://matt-harrison.com/raytracing-webassembly-vs-javascript/</link><description><![CDATA[For the past few months I've been toying about with WebAssembly. The examples I've built using WebAssembly were very simple and could easily have been written in JavaScript with perfectly adequate performance. This got me thinking it's about time I make something to really shows where WebAssembly shines. This led me down the path of thinking about very compute-demanding applications. An obvious example is 3d graphics rendering. Even a small scene like the ones I've been creating involve computing millions of vector dot product calculations per second. This kind of CPU-intensive application seemed right up the street of WebAssembly.]]></description><guid isPermaLink="false">3bdf428b-c38a-4964-a8f2-a4e0106bd5d1</guid><pubDate>Sun, 12 Aug 2018 14:09:42 +0000</pubDate><dc:creator>Matt Harrison</dc:creator></item><item><title>Portability benchmark of Dota2 on MacOS</title><link>https://gfx-rs.github.io/2018/08/10/dota2-macos-performance.html</link><description><![CDATA[gfx-rs is a Rust project aiming to make graphics programming more accessible and portable, focusing on exposing a universal Vulkan-like API. It’s a single Rust API with multiple backends that implement it: Direct3D 12/11, Metal, Vulkan, and even OpenGL. We are also building a Vulkan Portability implementation based on it, which allows non-Rust applications using Vulkan to run everywhere. This post is focused on the Metal backend only.]]></description><guid isPermaLink="false">526c879c-7409-4234-a92c-e04b21f37d0d</guid><pubDate>Fri, 10 Aug 2018 00:00:00 +0000</pubDate><dc:creator>gfx-rs</dc:creator></item><item><title>The State of GPGPU in Rust</title><link>https://bheisler.github.io/post/state-of-gpgpu-in-rust/</link><description><![CDATA[At work a few months ago, we started experimenting with GPU-acceleration. My boss asked if I was interested. I didn’t know anything about programming GPUs, so of course I said “Heck yes, I’m interested!“. I needed to learn about GPUs in a hurry, and that led to my GPU Path Tracer series. That was a lot of fun, but it showed me that CUDA support in Rust is pretty poor.]]></description><guid isPermaLink="false">704eb876-5cac-4636-8817-4946659876e1</guid><pubDate>Wed,  8 Aug 2018 20:00:00 -0600</pubDate><dc:creator>Brook Heisler</dc:creator></item><item><title>Journey into rust #1: Conway’s Game</title><link>https://jonathansteyfkens.com/rust/opengl/graphics/2018/08/07/rust-conway-game-of-life.html</link><description><![CDATA[The language rust has been popping up on my twitter feed and my personal life more and more. It’s been promoted and presented as the ultra safe language, so naturally I decided to check it out. The upcoming series of posts “Journey into rust” will describe and document my experiences using rust, hopefully explaining certain concepts that rust does differently. This will all be written from a C++ programmers standpoint that was thought writing Object Oriented code. I encourage you the reader to think critically and correct where necessary.

On to the actual first post! After reading “the Rust Programming Language” I wanted to get my hands dirty and actually write some code. I like graphical applications and using low level graphics API’s so I decided to implement a cellular automation in rust. But just implementing cellular automation isn’t very exciting, is it? What if we could do this on the GPU…And off I went on my journey to create Conway’s game of life in rust.]]></description><guid isPermaLink="false">b7c9c3df-7ecd-41f3-8c89-5c1d35298b7b</guid><pubDate>Tue,  7 Aug 2018 22:30:01 +0000</pubDate><dc:creator>Jonathan Steyfkens</dc:creator></item><item><title>Amethyst 0.8 has been released!</title><link>https://www.amethyst.rs/blog/release-0-8/</link><description><![CDATA[With a brand new tutorial and a ton of new features, including prefabs, controller support, MP3 audio, localisation and an even better ergonomics!]]></description><guid isPermaLink="false">b5717efe-ad7b-4b02-8554-aba801aff909</guid><pubDate>Sun,  5 Aug 2018 00:00:00 +0000</pubDate><dc:creator>Moxinilian (Théo Degioanni)</dc:creator></item><item><title>Empty Rust File to Game in Nine Days</title><link>https://blog.shivoa.net/2018/07/empty-rust-file-to-game-in-nine-days.html</link><description><![CDATA[A Vulkan game from scratch in nine days. Using minimal libraries and pure Rust.]]></description><guid isPermaLink="false">acd4faef-4a0e-411b-9995-1a3554598c04</guid><pubDate>Sat, 28 Jul 2018 22:26:00 +0100</pubDate><dc:creator>Shivoa Birch</dc:creator></item><item><title>nphysics: 2D and 3D real-time physics engine</title><link>http://nphysics.org/</link><description><![CDATA[I’m excited to announce the brand new website/user-guide for the nphysics2d and nphysics3d crates: pure-rust 2D and 3D real-time physics engines with rigid bodies and joints! Online wasm-based demos are also provided (see for example the Multibody joints 34 demo).]]></description><guid isPermaLink="false">a3f0bd42-0a42-4156-9fd6-74aebe5f0465</guid><pubDate>Sun, 29 Jul 2018 03:46:07 +1000</pubDate><dc:creator>Sébastien Crozet</dc:creator></item><item><title>Rust and OpenGL from scratch, a blog post series about building an OpenGL renderer with Rust</title><link>https://www.reddit.com/r/rust/comments/92abkg/rust_and_opengl_from_scratch_a_blog_post_series/</link><description><![CDATA[I titled this post “from scratch”, because I am going to assume little knowledge of Rust and basic knowledge of 3D graphics and OpenGL.

Therefore, this tutorial may teach you basic Rust and how to get Rust working with OpenGL, however for in-depth OpenGL learning you will need another tutorial or book.

“From Scratch” also means that we will try to build abstractions ourselves, so that we get better knowledge of Rust. In addition to that, we will able to follow existing OpenGL tutorials, because we will know exactly what OpenGL functions we are calling.]]></description><guid isPermaLink="false">1220a3b8-605c-4d1d-8c38-163bd5a8f02e</guid><pubDate>Fri, 27 Jul 2018 17:01:38 +1000</pubDate><dc:creator>Nerijus Arlauskas</dc:creator></item><item><title>Writing a GPU-Accelerated Path Tracer in Rust - Part 3</title><link>https://bheisler.github.io/post/writing-gpu-accelerated-path-tracer-part-3/</link><description><![CDATA[Hello! Welcome to my third and final post on my GPU-accelerated Path Tracer in Rust. In the last post, we implemented all of the logic necessary to build a true path tracer. Problem is, even on the GPU it’s terrifically slow. This post is (mostly) about fixing that.

But first, we need to fix a bug or two, because I goofed. *sad trombone*

Step -1: Fixing Bugs /u/anderslanglands on Reddit pointed out that, since I’m using Cosine-weighted Importance Sampling, I need to do some extra math to avoid biasing the results.]]></description><guid isPermaLink="false">0b53c7ea-570b-4595-b8eb-2f62d8e9cb96</guid><pubDate>Thu, 19 Jul 2018 18:30:00 -0600</pubDate><dc:creator>Brook Heisler</dc:creator></item><item><title>Encrusted: An interpreter for Infocom-era interactive fiction games like Zork</title><link>https://sterlingdemille.com/encrusted/</link><description><![CDATA[A modern z-machine for the classics. Encrusted is an interpreter for Infocom-era interactive fiction games like Zork. Run the web interface here ↑, or get it for your terminal.]]></description><guid isPermaLink="false">dd4398c4-2ad7-4f13-a900-2d78fa78bd0c</guid><pubDate>Thu, 19 Jul 2018 04:41:01 +0000</pubDate><dc:creator>Sterling DeMille</dc:creator></item><item><title>Let&apos;s code with the Roguelike tutorial - Part 7 - Enhancing the UI</title><link>https://www.yosenspace.com/posts/lets-code-roguelike-tutorial-part7-enhancing-ui.html</link><description><![CDATA[Up to now, all the rendering code has been in the game loop in the main function. The rendering code is simple and straightforward, so, while it should have been extracted into its own function, there wasn't a pressing need to do so. Now that I'm going to enhance the UI, the rendering needs to be extracted.]]></description><guid isPermaLink="false">92d89e3b-be0d-4f75-b335-79e26b2373e5</guid><pubDate>Wed, 18 Jul 2018 08:50:00 +0000</pubDate><dc:creator>Yosen</dc:creator></item></channel></rss>