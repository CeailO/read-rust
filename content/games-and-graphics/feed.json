{
  "version": "https://jsonfeed.org/version/1",
  "title": "Read Rust - Games and Graphics",
  "home_page_url": "https://readrust.net/",
  "feed_url": "https://readrust.net/games-and-graphics/feed.json",
  "description": "Games and Graphics posts on Read Rust",
  "author": {
    "name": "Wesley Moore",
    "url": "http://www.wezm.net/"
  },
  "items": [
    {
      "id": "9a9651de-466e-411e-9449-c1d6878ffba0",
      "title": "Game Dev From Zero - Part 1: Hello",
      "content_text": "With this article, I want to introduce you to game development. I want to give you a little tour of where to start, how to explore possibilities and revive my journey a little bit at the same time. I will try to construct different games from the ground up while writing this article, so you can experience game-dev live.",
      "url": "https://hashnode.com/post/game-dev-from-zero-part-1-hello-rust-lang-cjn3brwto001jv7s2e533bdfc",
      "date_published": "2018-10-11T00:00:00+00:00",
      "author": {
        "name": "Marco Alka",
        "url": "https://hashnode.com/"
      },
      "tags": [
        "Games and Graphics"
      ]
    },
    {
      "id": "1ac9419e-3a15-4c2e-961d-20160f9ef6e9",
      "title": "Gfx-hal Tutorial part 2: Vertex buffers",
      "content_text": "For the last two parts of this tutorial, all we’ve had to look at on-screen is a single blueish triangle. In this part, we want to display a more complex shape, with more variation in color. To do this, we’ll have to stop hard-coding our triangle mesh in the vertex shader. (And start hard-coding it in the source code!)",
      "url": "https://falseidolfactory.com/2018/10/09/gfx-hal-part-2-vertex-buffers.html",
      "date_published": "2018-10-09T00:00:00+00:00",
      "author": {
        "name": "Mistodon",
        "url": "https://falseidolfactory.com/"
      },
      "tags": [
        "Games and Graphics"
      ]
    },
    {
      "id": "7abf3b08-b87f-4bd1-a4f4-4d79f4216413",
      "title": "Amethyst is growing; news on ongoing projects",
      "content_text": "We want to share some of the progress being made on Amethyst! As we've had a lot of expansion, we've also revamped the way we manage the project and we have some very interesting new features being worked on.",
      "url": "https://www.amethyst.rs/blog/dev-news-10-2018/",
      "date_published": "2018-10-14T00:00:00+00:00",
      "author": {
        "name": "Moxinilian (Théo Degioanni)",
        "url": "https://www.amethyst.rs/blog"
      },
      "tags": [
        "Games and Graphics"
      ]
    },
    {
      "id": "3d3a61ed-ff74-4407-b508-0c7405b8c653",
      "title": "Following up on the 2d graphics in Rust discussion",
      "content_text": "Ralph Levien recently published A crate I want: 2d graphics on his blog, which started some interesting discussions on reddit. At the same time there is a nascent discussion on the draw2d repository (which doesn't have any code at this point) about a potential 2d graphics crate.",
      "url": "https://nical.github.io/posts/rust-2d-graphics-01.html",
      "date_published": "2018-10-14T00:00:00+02:00",
      "author": {
        "name": "Nical",
        "url": "https://nical.github.io/index.html"
      },
      "tags": [
        "Games and Graphics"
      ]
    },
    {
      "id": "63fef91b-3a2c-4b05-9fad-bc5a80bd1733",
      "title": "A crate I want: 2d graphics",
      "content_text": "The Rust ecosystem has lot of excellent crates, and many more new ones being published. I believe one is missing, though, and I’d really like to see it happen: a cross-platform abstraction for 2D graphics. In this post I will set out what I want.",
      "url": "https://raphlinus.github.io/rust/graphics/2018/10/11/2d-graphics.html",
      "date_published": "2018-10-11T22:44:03+00:00",
      "author": {
        "name": "Raph Levien",
        "url": "https://raphlinus.github.io/"
      },
      "tags": [
        "Games and Graphics"
      ]
    },
    {
      "id": "4a3da20e-11fb-4868-9aa1-593f62439bd9",
      "title": "GLSL quasiquoting in Rust!",
      "content_text": "glsl-quasiquote-0.1 was released today! The crate provides you with two macros: glsl! and glsl_str!. Both are procedural macros that requires a nightly compiler and the proc_macro_non_items feature. They will both output a TranslationUnit, that represents a whole shader AST.",
      "url": "https://phaazon.net/blog/glsl-quasiquoting",
      "date_published": "2018-10-05T19:00:00+00:00",
      "author": {
        "name": "Dimitri Sabadie",
        "url": "http://phaazon.net/"
      },
      "tags": [
        "Games and Graphics"
      ]
    },
    {
      "id": "ec683955-b4c5-426c-858d-f180fde10abb",
      "title": "Rust RPG: Introductory Tutorial of Rust, Unit Testing, and Continuous Integration with a Roguelike",
      "content_text": "We’re going to walk through a Rust application that I’ve built, which is essentially a basic Roguelike in most regards.",
      "url": "https://medium.com/@cameron.manavian/rust-rpg-introductory-tutorial-of-rust-unit-testing-and-continuous-integration-with-a-roguelike-b7b86e90855c",
      "date_published": "2018-09-28T13:46:04.544+00:00",
      "author": {
        "name": "Cameron Manavian",
        "url": "https://medium.com/@cameron.manavian"
      },
      "tags": [
        "Games and Graphics"
      ]
    },
    {
      "id": "22538446-2c14-4b71-bd82-46c2db0371a1",
      "title": "The Undergarden, a text adventure in Rust: 2 - Objects",
      "content_text": "In this second blog post I’m showing how I implemented objects - things the player can interact with - for a text adventure written in Rust. As usual, the full code is available on GitHub.",
      "url": "https://www.cattlegrid.info/the-undergarden-text-adventure-rust-2-objects",
      "date_published": "2018-10-04T04:51:00+00:00",
      "author": {
        "name": "Michele Beltrame",
        "url": "https://www.cattlegrid.info/"
      },
      "tags": [
        "Games and Graphics"
      ]
    },
    {
      "id": "abd3f1ce-8faf-4c92-a8d3-20c34e41af97",
      "title": "Porting My CUDA Path Tracer to ptx-builder/linker",
      "content_text": "A bunch of stuff has happened since I published my post on The State of GPGPU in Rust. Most importantly, Denys Zariaiev (@denzp) released his work on a custom linker for Rust CUDA kernels, and a build.rs helper crate to make it easier to use.\nThese two crates eliminate many of the problems I referred to in my previous post. The linker solves most of the “invalid PTX file” problems, while the ptx-builder crate does all of the magic that Accel was doing behind the scenes.",
      "url": "https://bheisler.github.io/post/ptx-builder-and-linker/",
      "date_published": "2018-10-01T19:00:00-06:00",
      "author": {
        "name": "Brook Heisler",
        "url": "https://bheisler.github.io/"
      },
      "tags": [
        "Games and Graphics"
      ]
    },
    {
      "id": "c0b70c5d-190f-4c9d-ac44-d65a64a61b1f",
      "title": "The Undergarden, a text adventure in Rust: 1 - Sections",
      "content_text": "I’m attempting to write a (very simple, at least initally) text adventure in Rust, so I’m going to share progress on my blog starting today. This first post is about the sections, that to day is the rooms of a house for example.",
      "url": "https://www.cattlegrid.info/the-undergarden-text-adventure-rust-1-sections",
      "date_published": "2018-09-27T20:04:00+00:00",
      "author": {
        "name": "Michele Beltrame",
        "url": "https://www.cattlegrid.info/"
      },
      "tags": [
        "Games and Graphics"
      ]
    },
    {
      "id": "3cd66c51-9cd4-4548-9a94-214d3f241ae2",
      "title": "My recommended crates for computer graphics",
      "content_text": "It’s been a while since my last post! Lately I’ve been quite demotivated to actually produce something worth while for doing a writeup about. Instead I offer you some thoughts on my recent findings using rust and some crates I found particularly useful for computer graphics.",
      "url": "https://jonathansteyfkens.com/rust/graphics/compute/2018/09/15/my-recommended-cg-crates.html",
      "date_published": "2018-09-15T22:15:00+00:00",
      "author": {
        "name": "Jonathan Steyfkens",
        "url": "https://jonathansteyfkens.com/"
      },
      "tags": [
        "Games and Graphics"
      ]
    },
    {
      "id": "68ff6ef3-ead4-43c9-8813-f355d9f3710c",
      "title": "My RustConf 2018 Closing Keynote",
      "content_text": "I said in my talk that I would post a potentially more interesting long-form version of the talk that includes things that I couldn’t fit into the 30-ish minute time slot. What I’ve included below is my original long-form version of this talk, but my original intention was not to post this as-is. Originally I wanted to clean this up a bit more and make this into something that wasn’t so much a giant wall of text, but after I started doing this I realized that I was just rewriting it entirely, and at that rate I would never get around to releasing it, which I promised I would do in a timely manner.",
      "url": "https://kyren.github.io/2018/09/14/rustconf-talk.html",
      "date_published": "2018-09-14T00:00:00+00:00",
      "author": {
        "name": "Catherine West",
        "url": "https://kyren.github.io/"
      },
      "tags": [
        "Games and Graphics"
      ]
    },
    {
      "id": "6c60dc7f-81f5-4718-9bfa-4c68e7a7d1ab",
      "title": "RPCS3 and Dolphin emulators on macOS using gfx-portability",
      "content_text": "After improving functionality and performance of gfx-portability’s Metal backend through benchmarking Dota2, and verifying certain functionality through the Vulkan Conformance Test Suite (CTS), we decided to expand our testing to other projects. We quickly found two projects which matched our criteria: RPCS3 and Dolphin.",
      "url": "https://gfx-rs.github.io/2018/09/03/rpcs3-dolphin.html",
      "date_published": "2018-09-03T00:00:00+00:00",
      "author": {
        "name": "gfx-rs",
        "url": "https://gfx-rs.github.io/"
      },
      "tags": [
        "Games and Graphics"
      ]
    },
    {
      "id": "1b68ce01-24d8-45a9-88df-be24c465141b",
      "title": "Programmatically generated artwork",
      "content_text": "I have made four rust programs for programmatically generating artwork in different styles. Here is a sample in each style, along with an explanation of the algorithms.",
      "url": "https://isaacg1.github.io/posts/programmatically-generated-artwork/",
      "date_published": "2018-08-26T02:29:13-04:00",
      "author": {
        "name": "Isaac Grosof",
        "url": "https://isaacg1.github.io/"
      },
      "tags": [
        "Games and Graphics"
      ]
    },
    {
      "id": "72c8ca7f-1f7e-47f5-aebc-f06e63a1b367",
      "title": "Gfx-hal Tutorial part 1: Resizing windows",
      "content_text": "This tutorial builds on the code we wrote in the previous part. You can find the new code here with comments explaining everything that’s changed, and run it to see what the end result will look like. Last time we got a single triangle rendering on screen. This time we’re going to look at what we need to do to allow window resizing to work properly.",
      "url": "https://falseidolfactory.com/2018/08/23/gfx-hal-part-1-resizing-windows.html",
      "date_published": "2018-08-23T00:00:00+00:00",
      "author": {
        "name": "Mistodon",
        "url": "https://falseidolfactory.com/"
      },
      "tags": [
        "Games and Graphics"
      ]
    },
    {
      "id": "5e9a2cd7-e018-41d6-bfeb-a0face2c3f0e",
      "title": "Journey into rust #2: Compute Shaders",
      "content_text": "I realized after my first post of this series that it’s not just a journey into rust but also OpenGL. I’ve used other Graphics API’s before but never actually got my hands dirty into OpenGL. Someone on the rust user forums (they are awesome, go check it out!) suggested using compute shaders instead. At the time I had never used compute shaders for a project so I decided to take some time to refactor the program to use a compute shader. This post is a follow up on that remark and will explore the possibilities of using a rust together with OpenGL to run compute shaders.",
      "url": "https://jonathansteyfkens.com/rust/opengl/graphics/compute/shader/2018/08/19/compute-shaders.html",
      "date_published": "2018-08-19T20:30:00+00:00",
      "author": {
        "name": "Jonathan Steyfkens",
        "url": "https://jonathansteyfkens.com/"
      },
      "tags": [
        "Games and Graphics"
      ]
    },
    {
      "id": "8914a4f4-eff5-4563-a82f-0c55d013ef7f",
      "title": "Ludum Dare 42 Postmortem",
      "content_text": "One of my favorite game jams is Ludum Dare: It’s just you, a theme, and 48 hours to make a game. Pure and challenging, and I’ve participated in several of them from time to time with a variety of tools. Usually my go-to is Unity3D, though arguably my best game was in Python+Pygame. This time though, for Ludum Dare 42 on August 2018, I finally had both the energy and ability to write my game in Rust, using ggez. So I decided to write about it!",
      "url": "https://wiki.alopex.li/LD42Postmortem",
      "date_published": "2018-08-13T14:53:05+00:00",
      "author": {
        "name": "Simon Heath",
        "url": "http://patreon.com/icefox"
      },
      "tags": [
        "Games and Graphics"
      ]
    },
    {
      "id": "5eb3a4b0-7653-43b1-9958-a8b96bc32338",
      "title": "Gfx-hal Tutorial part 0: Drawing a triangle",
      "content_text": "Eight part series on using gfx-hal for low level graphics programming.",
      "url": "https://falseidolfactory.com/2018/08/16/gfx-hal-part-0-drawing-a-triangle.html",
      "date_published": "2018-08-16T00:00:00+00:00",
      "author": {
        "name": "Mistodon",
        "url": "https://falseidolfactory.com/"
      },
      "tags": [
        "Games and Graphics"
      ]
    },
    {
      "id": "acd4faef-4a0e-411b-9995-1a3554598c04",
      "title": "Empty Rust File to Game in Nine Days",
      "content_text": "A Vulkan game from scratch in nine days. Using minimal libraries and pure Rust.",
      "url": "https://blog.shivoa.net/2018/07/empty-rust-file-to-game-in-nine-days.html",
      "date_published": "2018-07-28T22:26:00+01:00",
      "author": {
        "name": "Shivoa Birch",
        "url": "https://plus.google.com/104688779548004579468"
      },
      "tags": [
        "Games and Graphics"
      ]
    },
    {
      "id": "0d9f9b5e-33e1-492a-976e-fcbf0826cbab",
      "title": "rusty_gl: A simple wrapper over rs-gl to make code safer",
      "content_text": "I enjoy using OpenGL a lot, but when I switched from C++ to Rust I found it to be less fun to use. This is because the OpenGL (from gl-rs) code never really fit alongside the rest of my Rust code, due to unsafe blocks, PascalCase function names, hacky conversions to c_void pointers etc. So, to make my life easier in the future when using OpenGL in Rust, I made this crate.",
      "url": "https://www.reddit.com/r/rust/comments/982kqg/rusty_gl_a_simple_wrapper_over_rsgl_to_make_code/",
      "date_published": "2018-08-18T00:10:17+10:00",
      "author": {
        "name": "Hopson97",
        "url": "https://www.reddit.com/user/Hopson97/"
      },
      "tags": [
        "Games and Graphics"
      ]
    },
    {
      "id": "2e354a2e-10fe-410c-adbf-7b739def3ab6",
      "title": "UniverCity released into early access",
      "content_text": "UniverCity is a university management game being programmed in the Rust programming language. As stated above, the game is in early access and is not complete. There will be changes and additions down the line and finishing it may take some time. You may wish to wait until its further along before buying it.",
      "url": "https://thinkof.name/2018/08/14/early-access-release.html",
      "date_published": "2018-08-14T10:00:00+00:00",
      "author": {
        "name": "Thinkofname",
        "url": "https://thinkof.name/"
      },
      "tags": [
        "Games and Graphics"
      ]
    },
    {
      "id": "c1519934-b4d6-49ed-bc58-1450331afa63",
      "title": "GSoC 2018 - D3D11 backend for gfx-rs",
      "content_text": "For this years GSoC I (@fkaa) worked on implementing the DirectX 11 backend for gfx, a graphics API which translates to Vulkan, DirectX 12 and Metal.",
      "url": "https://gfx-rs.github.io/2018/08/14/gsoc.html",
      "date_published": "2018-08-14T00:00:00+00:00",
      "author": {
        "name": "Felix Kaaman",
        "url": "https://github.com/fkaa"
      },
      "tags": [
        "Games and Graphics"
      ]
    },
    {
      "id": "3bdf428b-c38a-4964-a8f2-a4e0106bd5d1",
      "title": "Ray Tracing: WebAssembly vs JavaScript",
      "content_text": "For the past few months I've been toying about with WebAssembly. The examples I've built using WebAssembly were very simple and could easily have been written in JavaScript with perfectly adequate performance. This got me thinking it's about time I make something to really shows where WebAssembly shines. This led me down the path of thinking about very compute-demanding applications. An obvious example is 3d graphics rendering. Even a small scene like the ones I've been creating involve computing millions of vector dot product calculations per second. This kind of CPU-intensive application seemed right up the street of WebAssembly.",
      "url": "http://matt-harrison.com/raytracing-webassembly-vs-javascript/",
      "date_published": "2018-08-12T14:09:42+00:00",
      "author": {
        "name": "Matt Harrison",
        "url": "http://matt-harrison.com/"
      },
      "tags": [
        "Web and Network Services",
        "Games and Graphics"
      ]
    },
    {
      "id": "704eb876-5cac-4636-8817-4946659876e1",
      "title": "The State of GPGPU in Rust",
      "content_text": "At work a few months ago, we started experimenting with GPU-acceleration. My boss asked if I was interested. I didn’t know anything about programming GPUs, so of course I said “Heck yes, I’m interested!“. I needed to learn about GPUs in a hurry, and that led to my GPU Path Tracer series. That was a lot of fun, but it showed me that CUDA support in Rust is pretty poor.",
      "url": "https://bheisler.github.io/post/state-of-gpgpu-in-rust/",
      "date_published": "2018-08-08T20:00:00-06:00",
      "author": {
        "name": "Brook Heisler",
        "url": "https://bheisler.github.io/"
      },
      "tags": [
        "Games and Graphics"
      ]
    },
    {
      "id": "526c879c-7409-4234-a92c-e04b21f37d0d",
      "title": "Portability benchmark of Dota2 on MacOS",
      "content_text": "gfx-rs is a Rust project aiming to make graphics programming more accessible and portable, focusing on exposing a universal Vulkan-like API. It’s a single Rust API with multiple backends that implement it: Direct3D 12/11, Metal, Vulkan, and even OpenGL. We are also building a Vulkan Portability implementation based on it, which allows non-Rust applications using Vulkan to run everywhere. This post is focused on the Metal backend only.",
      "url": "https://gfx-rs.github.io/2018/08/10/dota2-macos-performance.html",
      "date_published": "2018-08-10T00:00:00+00:00",
      "author": {
        "name": "gfx-rs",
        "url": "https://gfx-rs.github.io/"
      },
      "tags": [
        "Games and Graphics"
      ]
    },
    {
      "id": "dd4398c4-2ad7-4f13-a900-2d78fa78bd0c",
      "title": "Encrusted: An interpreter for Infocom-era interactive fiction games like Zork",
      "content_text": "A modern z-machine for the classics. Encrusted is an interpreter for Infocom-era interactive fiction games like Zork. Run the web interface here ↑, or get it for your terminal.",
      "url": "https://sterlingdemille.com/encrusted/",
      "date_published": "2018-07-19T04:41:01+00:00",
      "author": {
        "name": "Sterling DeMille",
        "url": "https://sterlingdemille.com/"
      },
      "tags": [
        "Games and Graphics"
      ]
    },
    {
      "id": "b7c9c3df-7ecd-41f3-8c89-5c1d35298b7b",
      "title": "Journey into rust #1: Conway’s Game",
      "content_text": "The language rust has been popping up on my twitter feed and my personal life more and more. It’s been promoted and presented as the ultra safe language, so naturally I decided to check it out. The upcoming series of posts “Journey into rust” will describe and document my experiences using rust, hopefully explaining certain concepts that rust does differently. This will all be written from a C++ programmers standpoint that was thought writing Object Oriented code. I encourage you the reader to think critically and correct where necessary.\n\nOn to the actual first post! After reading “the Rust Programming Language” I wanted to get my hands dirty and actually write some code. I like graphical applications and using low level graphics API’s so I decided to implement a cellular automation in rust. But just implementing cellular automation isn’t very exciting, is it? What if we could do this on the GPU…And off I went on my journey to create Conway’s game of life in rust.",
      "url": "https://jonathansteyfkens.com/rust/opengl/graphics/2018/08/07/rust-conway-game-of-life.html",
      "date_published": "2018-08-07T22:30:01+00:00",
      "author": {
        "name": "Jonathan Steyfkens",
        "url": "https://jonathansteyfkens.com/"
      },
      "tags": [
        "Games and Graphics",
        "Getting Started"
      ]
    },
    {
      "id": "a3f0bd42-0a42-4156-9fd6-74aebe5f0465",
      "title": "nphysics: 2D and 3D real-time physics engine",
      "content_text": "I’m excited to announce the brand new website/user-guide for the nphysics2d and nphysics3d crates: pure-rust 2D and 3D real-time physics engines with rigid bodies and joints! Online wasm-based demos are also provided (see for example the Multibody joints 34 demo).",
      "url": "http://nphysics.org/",
      "date_published": "2018-07-29T03:46:07+10:00",
      "author": {
        "name": "Sébastien Crozet",
        "url": "http://nphysics.org/"
      },
      "tags": [
        "Games and Graphics",
        "Crates"
      ]
    },
    {
      "id": "b5717efe-ad7b-4b02-8554-aba801aff909",
      "title": "Amethyst 0.8 has been released!",
      "content_text": "With a brand new tutorial and a ton of new features, including prefabs, controller support, MP3 audio, localisation and an even better ergonomics!",
      "url": "https://www.amethyst.rs/blog/release-0-8/",
      "date_published": "2018-08-05T00:00:00+00:00",
      "author": {
        "name": "Moxinilian (Théo Degioanni)",
        "url": "https://www.amethyst.rs/blog"
      },
      "tags": [
        "Games and Graphics",
        "Crates"
      ]
    },
    {
      "id": "92d89e3b-be0d-4f75-b335-79e26b2373e5",
      "title": "Let's code with the Roguelike tutorial - Part 7 - Enhancing the UI",
      "content_text": "Up to now, all the rendering code has been in the game loop in the main function. The rendering code is simple and straightforward, so, while it should have been extracted into its own function, there wasn't a pressing need to do so. Now that I'm going to enhance the UI, the rendering needs to be extracted.",
      "url": "https://www.yosenspace.com/posts/lets-code-roguelike-tutorial-part7-enhancing-ui.html",
      "date_published": "2018-07-18T08:50:00+00:00",
      "author": {
        "name": "Yosen",
        "url": "https://www.yosenspace.com/index.html"
      },
      "tags": [
        "Games and Graphics"
      ]
    },
    {
      "id": "6744150e-efec-40e9-a978-ed41e314d64a",
      "title": "Let's code with the Roguelike tutorial - Part 6 - Combat engine",
      "content_text": " I now have a map, and a bunch of monsters on the map, able to attack and be attacked by the player. To provide for different kinds of monsters, I needed to add stats like combat strength and HP.",
      "url": "https://www.yosenspace.com/posts/lets-code-roguelike-tutorial-part6-combat-engine.html",
      "date_published": "2018-07-18T07:28:00+00:00",
      "author": {
        "name": "Yosen",
        "url": "https://www.yosenspace.com/index.html"
      },
      "tags": [
        "Games and Graphics"
      ]
    },
    {
      "id": "1220a3b8-605c-4d1d-8c38-163bd5a8f02e",
      "title": "Rust and OpenGL from scratch, a blog post series about building an OpenGL renderer with Rust",
      "content_text": "I titled this post “from scratch”, because I am going to assume little knowledge of Rust and basic knowledge of 3D graphics and OpenGL.\n\nTherefore, this tutorial may teach you basic Rust and how to get Rust working with OpenGL, however for in-depth OpenGL learning you will need another tutorial or book.\n\n“From Scratch” also means that we will try to build abstractions ourselves, so that we get better knowledge of Rust. In addition to that, we will able to follow existing OpenGL tutorials, because we will know exactly what OpenGL functions we are calling.",
      "url": "https://www.reddit.com/r/rust/comments/92abkg/rust_and_opengl_from_scratch_a_blog_post_series/",
      "date_published": "2018-07-27T17:01:38+10:00",
      "author": {
        "name": "Nerijus Arlauskas",
        "url": "http://nercury.github.io/"
      },
      "tags": [
        "Games and Graphics"
      ]
    },
    {
      "id": "51e59a36-6a0e-4599-b52f-5874cc1e9ec5",
      "title": "Procedural level generation with Rust",
      "content_text": "Procedural generation is a technique which allows content to be created programmatically, rather than everything in a game being specifically placed by a designer. Procedural generation doesn't mean completely randomised, rather randomised elements are used as long as they make sense.\n\nThis tutorial will show how to create a tilemap-based level with rooms connected by straight corridors, using Rust. We'll also cover how to use seeds to reproduce specific layouts and serialise the output into JSON. The rooms will be placed at random within the level, and corridors are drawn horizontally and vertically to connect the centres of the rooms.",
      "url": "https://www.jamestease.co.uk/blether/procedural-level-generation-rust",
      "date_published": "2018-07-04T00:00:00+00:00",
      "author": {
        "name": "James Tease",
        "url": "https://www.jamestease.co.uk/"
      },
      "tags": [
        "Games and Graphics"
      ]
    },
    {
      "id": "9ba882d4-cadd-4708-906b-2ec25fe72941",
      "title": "Let's code with the Roguelike tutorial - Part 5 - Setting up enemies",
      "content_text": "I now have the game up to the point where the player has a random dungeon to explore. It's time to make it more interesting by adding some threats - namely, some monsters.",
      "url": "https://www.yosenspace.com/posts/lets-code-roguelike-tutorial-part5-setting-up-enemies.html",
      "date_published": "2018-07-11T04:57:00+00:00",
      "author": {
        "name": "Yosen",
        "url": "https://www.yosenspace.com/index.html"
      },
      "tags": [
        "Games and Graphics"
      ]
    },
    {
      "id": "1e1fcc0e-6af2-4223-8689-4cab5a34222f",
      "title": "Let's code with the Roguelike tutorial - Part 4 - Field of view and exploration",
      "content_text": "In the current implementation, the player can see the entire layout of the dungeon from the beginning. The next step is to change the game to start off with the dungeon hidden, so the player will actually have some rooms to explore.",
      "url": "https://www.yosenspace.com/posts/lets-code-roguelike-tutorial-part4-field-view-exploration.html",
      "date_published": "2018-07-11T04:57:00+00:00",
      "author": {
        "name": "Yosen",
        "url": "https://www.yosenspace.com/index.html"
      },
      "tags": [
        "Games and Graphics"
      ]
    },
    {
      "id": "35ed06d7-694b-4d04-ade3-5a8816619b78",
      "title": "Let's code with the Roguelike tutorial - Part 3 - Making a dungeon",
      "content_text": "It's time to start making some rooms and connecting them together. These will require making modifications to the map, so I guess it's time to finally refactor the map code into its own legitimate class.",
      "url": "https://www.yosenspace.com/posts/lets-code-roguelike-tutorial-part3-making-dungeon.html",
      "date_published": "2018-07-04T09:42:00+00:00",
      "author": {
        "name": "Yosen",
        "url": "https://www.yosenspace.com/index.html"
      },
      "tags": [
        "Games and Graphics"
      ]
    },
    {
      "id": "a65d9a08-fc44-4976-b2ad-82b934b7961f",
      "title": "Flocking in Rust with Piston",
      "content_text": "Wikipedia states that flocking is a behavior exhibited when a group of birds, called a flock, are foraging or in flight. Flocking simulation are basically softwares which simulate this flocking behavior of birds. The original algorithm is developed by Craig Reynolds in 1986.",
      "url": "https://blog.shine.rocks/posts/flocking-in-rust-with-piston/",
      "date_published": "2018-07-15T00:00:00+00:00",
      "author": {
        "name": "Htet Aung Shine",
        "url": "https://blog.shine.rocks/"
      },
      "tags": [
        "Games and Graphics"
      ]
    },
    {
      "id": "5579acfe-3441-4097-9476-863e348858f5",
      "title": "The Cheddar shading language",
      "content_text": "Cheddar is a GLSL superset language. What it means is that most of the GLSL constructs and syntax you’re used to is valid in Cheddar – not all of it; most of it. Cheddar adds a set of features that I think are lacking to GLSL. Among them: Some non-valid GLSL constructions made valid in Cheddar to ease the writing of certain shader stages; A more functional approach to programming shaders on the GPU; Structures, types and GLSL-specific constructs sharing; Imports and modules with live reloading and transitive dependencies.",
      "url": "https://phaazon.net/blog/cheddar-0.1",
      "date_published": "2018-07-09T01:00:00+00:00",
      "author": {
        "name": "Dimitri Sabadie",
        "url": "http://phaazon.net/"
      },
      "tags": [
        "Games and Graphics"
      ]
    },
    {
      "id": "0b53c7ea-570b-4595-b8eb-2f62d8e9cb96",
      "title": "Writing a GPU-Accelerated Path Tracer in Rust - Part 3",
      "content_text": "Hello! Welcome to my third and final post on my GPU-accelerated Path Tracer in Rust. In the last post, we implemented all of the logic necessary to build a true path tracer. Problem is, even on the GPU it’s terrifically slow. This post is (mostly) about fixing that.\n\nBut first, we need to fix a bug or two, because I goofed. *sad trombone*\n\nStep -1: Fixing Bugs /u/anderslanglands on Reddit pointed out that, since I’m using Cosine-weighted Importance Sampling, I need to do some extra math to avoid biasing the results.",
      "url": "https://bheisler.github.io/post/writing-gpu-accelerated-path-tracer-part-3/",
      "date_published": "2018-07-19T18:30:00-06:00",
      "author": {
        "name": "Brook Heisler",
        "url": "https://bheisler.github.io/"
      },
      "tags": [
        "Games and Graphics"
      ]
    },
    {
      "id": "289bc607-7039-4931-838e-0451ee67e488",
      "title": "Writing a GPU-Accelerated Path Tracer in Rust - Part 2",
      "content_text": "Hello, and welcome to part two of my series on writing a GPU-accelerated path tracer in Rust. I’d meant to have this post up sooner, but nothing ruins my productivity quite like Games Done Quick. I’m back now, though, so it’s time to turn the GPU ray-tracer from the last post into a real path tracer.\n\nTracing Paths As mentioned last time, Path Tracing is an extension to Ray Tracing which attempts to simulate global illumination.",
      "url": "https://bheisler.github.io/post/writing-gpu-accelerated-path-tracer-part-2/",
      "date_published": "2018-07-12T19:00:00-06:00",
      "author": {
        "name": "Brook Heisler",
        "url": "https://bheisler.github.io/"
      },
      "tags": [
        "Games and Graphics"
      ]
    },
    {
      "id": "306a1044-e3e5-4a20-b4df-6577fa6eadf5",
      "title": "Tiny Planets",
      "content_text": "In the past few years, I've heard a lot about Rust. As someone that hacks on computer graphics and low-level infrastructure libraries, it seems relevant to my interests. I decided to make a small demo – of a procedural planet generator – and see how it went.",
      "url": "http://www.mattkeeter.com/projects/planets/",
      "date_published": "2018-07-05T02:45:00+00:00",
      "author": {
        "name": "Matt Keeter",
        "url": "http://www.mattkeeter.com/"
      },
      "tags": [
        "Games and Graphics"
      ]
    },
    {
      "id": "5489d43b-5cbb-4f2b-964e-1aacba277cd6",
      "title": "Let's code with the Roguelike tutorial - Part 2 - Entities and the map",
      "content_text": "As I mentioned in the last post, until I got a better handle on the off screen console code, I temporarily made all the Rust bindings call out to the default root console. Now that there's a bit of discussion on how the off screen consoles work, it's time to refactor the code to enable their use. ",
      "url": "https://www.yosenspace.com/posts/lets-code-roguelike-tutorial-part2-entities-map.html",
      "date_published": "2018-07-04T07:53:00+00:00",
      "author": {
        "name": "Yosen",
        "url": "https://www.yosenspace.com/index.html"
      },
      "tags": [
        "Games and Graphics"
      ]
    },
    {
      "id": "3b8f7264-75f2-4483-bb45-16770a899291",
      "title": "Scripting Language Cleanup",
      "content_text": "When we built the original Monsters and Sprites demo, we only had 9 days to get it working before the Playcrafting expo we had signed up for, so we had to cut a lot of corners. Since then I’ve been doing bug fixes and working on a lot of miscellaneous engine/language features that I either couldn’t get done in time for the demo, or didn’t realize were important until I started building it. We’ve made a few game updates since then (we now have sound!), but this post is specifically going to explore some language updates I’ve made.",
      "url": "https://www.anthropicstudios.com/2018/06/30/language-cleanup/",
      "date_published": "2018-06-30T00:00:00+00:00",
      "author": {
        "name": "Mason Remaley",
        "url": "https://www.anthropicstudios.com/"
      },
      "tags": [
        "Games and Graphics"
      ]
    },
    {
      "id": "13dc5703-c3a5-4c10-b3a5-aa53c382c940",
      "title": "NES Emulator, Part 2: I sort of know what I’m doing",
      "content_text": "In my first post about my journey to the center of the NES, I was at the point where I was still working on the CPU; implementing new addressing modes and instructions as I made my way through the nestest ROM. Well, I finally finished the CPU, including a handful of the illegal opcodes. The last of the illegal opcodes just need some placeholders, because, as I understand it, very few games use them.",
      "url": "https://medium.com/@ltriant/nes-emulator-part-2-i-sort-of-know-what-im-doing-f64d5e61caed",
      "date_published": "2018-06-29T02:24:51.394+00:00",
      "author": {
        "name": "Luke Triantafyllidis",
        "url": "https://medium.com/@ltriant"
      },
      "tags": [
        "Games and Graphics"
      ]
    },
    {
      "id": "645c96b0-5f66-4c4d-a8ee-d145298bc63d",
      "title": "Project Ice Puzzle",
      "content_text": "This game was coded in Rust and is playable in web browsers by means of WebAssembly, WebGL and Howler.js. The software I developed is partly open source in the form of Gate, which is the Rust library that powers this game and can power other similar games. Special thanks to the tools I used to create assets: Gimp, FL Studio and BFXR.",
      "url": "http://www.matthewmichelotti.com/games/project_ice_puzzle/",
      "date_published": "2018-06-25T00:00:00+00:00",
      "author": {
        "name": "Matthew Michelotti",
        "url": "http://www.matthewmichelotti.com/"
      },
      "tags": [
        "Web and Network Services",
        "Games and Graphics"
      ]
    },
    {
      "id": "495d9d83-2572-43cb-8f9d-c5c404ab83fe",
      "title": "Optimising path tracing: the last 10%",
      "content_text": "In my last post on optimising my Rust path tracer with SIMD I had got withing 10% of my performance target, that is Aras’s C++ SSE4.1 path tracer. From profiling I had determined that the main differences were MSVC using SSE versions of sinf and cosf and differences between Rayon and enkiTS thread pools. The first thing I tried was implement an SSE2 version of sin_cos based off of Julien Pommier’s code that I found via a bit of googling. This was enough to get my SSE4.1 implementation to match the performance of Aras’s SSE4.1 code. I had a slight advantage in that I just call sin_cos as a single function versus separate sin and cos functions, but meh, I’m calling my performance target reached.\n\nThe other part of this post is about Rust’s runtime and compile time CPU feature detection and some wrong turns I took along the way.",
      "url": "https://bitshifter.github.io/blog/2018/06/20/the-last-10-percent/",
      "date_published": "2018-06-20T00:00:00+00:00",
      "author": {
        "name": "bitshifter",
        "url": "https://bitshifter.github.io/"
      },
      "tags": [
        "Performance",
        "Games and Graphics"
      ]
    },
    {
      "id": "edd88db5-3f05-4171-9159-de17a3a4db8a",
      "title": "Let's Talk About Vector Graphics (In Rust)",
      "content_text": "I gave a talk about lyon at RustFest Paris. This post is the introduction of the talk, wherein I introduce vector graphics and try to get the audience somewhat excited about it. Things will get technical in the follow-up posts.",
      "url": "https://nical.github.io/posts/rustfest-paris-01.html",
      "date_published": "2018-06-18T00:00:00+02:00",
      "author": {
        "name": "Nical",
        "url": "https://nical.github.io/index.html"
      },
      "tags": [
        "Crates",
        "Games and Graphics"
      ]
    },
    {
      "id": "e62fbda5-e357-4870-a483-9dcf833b31ad",
      "title": "Running Rust on the GPU with Accel",
      "content_text": "For the past month or so, I’ve been working on a follow-up to my series on Writing a Raytracer in Rust. This time around, I’ll be talking about writing a GPU-accelerated Path Tracer. As always, I’m writing it in Rust - including the GPU kernel code. Compiling Rust for GPUs at this point is difficult and error-prone, so I thought it would be good to start with some documentation on that aspect of the problem before diving into path tracing.",
      "url": "https://bheisler.github.io/post/rust-on-the-gpu-with-accel/",
      "date_published": "2018-06-14T19:00:00-06:00",
      "author": {
        "name": "Brook Heisler",
        "url": "https://bheisler.github.io/"
      },
      "tags": [
        "Games and Graphics"
      ]
    },
    {
      "id": "9f6686d4-a03b-4420-82b0-e2c66b8b5e11",
      "title": "Gfx, windows, and resizing",
      "content_text": "These early posts will mostly be me trying to work out how to use gfx-rs. I was previously using glium which is fantastic, but is sadly no longer being developed. So my choices are: Learn Vulkan, Use raw OpenGL bindings, Use gfx.\n\nI opted to use the current released version (v0.17.1) but it’s currently undergoing a significant rearchitecture so I may move to that whenever it releases.",
      "url": "https://falseidolfactory.com/2018/05/28/gfx-windows-and-resizing.html",
      "date_published": "2018-05-28T00:00:00+01:00",
      "author": {
        "name": "Mistodon",
        "url": "https://falseidolfactory.com/"
      },
      "tags": [
        "Games and Graphics"
      ]
    },
    {
      "id": "b7e3c6ef-7be3-4f63-b8ad-04affb29716c",
      "title": "Ray Tracing in a Weekend in Rust",
      "content_text": "I was inspired to work through Peter Shirley’s Ray Tracing in a Weekend mini book (for brevity RTIAW) but I wanted to write it in Rust instead of the C++ that’s used in the book. I found out about the book via @aras_p’s blog series about a toy path tracer he’s been building.",
      "url": "https://bitshifter.github.io/blog/2018/04/29/rust-ray-tracer-in-one-weekend/",
      "date_published": "2018-04-29T00:00:00+00:00",
      "author": {
        "name": "bitshifter",
        "url": "https://bitshifter.github.io/"
      },
      "tags": [
        "Games and Graphics"
      ]
    },
    {
      "id": "49014ace-e742-49f8-887a-8fa7d1b627cc",
      "title": "Rust Case Study: Chucklefish Taps Rust to Bring Safe Concurrency to Video Games [pdf]",
      "content_text": "Chucklefish, an independent game studio based in London, publishes hit video games like Stardew Valley and Starbound. Now, the company is developing its next game, code-named Witchbrook, using the Rust programming language instead of C++. Why the switch? Two main reasons: to get better performance on multiprocessor hardware and to have fewer crashes during game play.",
      "url": "https://www.rust-lang.org/pdfs/Rust-Chucklefish-Whitepaper.pdf",
      "date_published": "2018-04-23T17:38:56+00:00",
      "author": {
        "name": "The Rust Project Developers",
        "url": "https://www.rust-lang.org/en-US/whitepapers.html"
      },
      "tags": [
        "Language",
        "Games and Graphics"
      ]
    },
    {
      "id": "d65aaebc-e17b-421b-86e8-1cc9c63a0408",
      "title": "Writing An NES Emulator with Rust and WebAssembly",
      "content_text": "I wrote the NES emulator with Rust and WebAssembly to learn Rust. It’s not perfect and have some audio bugs, but it’s good enough to play Super Mario bros.",
      "url": "https://medium.com/@bokuweb17/writing-an-nes-emulator-with-rust-and-webassembly-d64de101c49d",
      "date_published": "2018-04-11T14:30:56.719+00:00",
      "author": {
        "name": "bokuweb",
        "url": "https://medium.com/@bokuweb17"
      },
      "tags": [
        "Games and Graphics",
        "Web and Network Services"
      ]
    },
    {
      "id": "cacf27d3-9206-414d-b28f-8745eec00a4a",
      "title": "Taking the long road (Part 2): Rust bindings for a vector similarity search library",
      "content_text": "This is part 2 of a story on taking the long road towards Rust bindings to Faiss. You may wish to read part 1 first for a motivation section and a deeper understanding of how I built a plain C API on top of the C++ library.",
      "url": "https://medium.com/@e_net4/taking-the-load-road-part-2-rust-bindings-for-a-vector-similarity-search-library-914fbc1ec5ed",
      "date_published": "2018-04-12T20:11:12.081+00:00",
      "author": {
        "name": "Eduardo Pinho",
        "url": "https://medium.com/@e_net4"
      },
      "tags": [
        "Games and Graphics"
      ]
    },
    {
      "id": "7b281b2d-246c-4fec-bdf5-6eb92fbb8a34",
      "title": "The State of Game Development in Rust",
      "content_text": "Game Development is one of the fields in which Rust can gain a lot of traction. Let’s look at the current ecosystem and let’s see what the community has to offer.",
      "url": "http://www.davideaversa.it/2018/02/state-game-development-rust/",
      "date_published": "2018-02-26T17:37:27+00:00",
      "author": {
        "name": "Davide Aversa",
        "url": "http://www.davideaversa.it/"
      },
      "tags": [
        "Games and Graphics"
      ]
    },
    {
      "id": "e5d47646-8715-43d3-a39b-23115255a1fe",
      "title": "Taking the long road (Part 1): bindings for a vector similarity search library",
      "content_text": "Perhaps you have once wondered how search engines such as Google and TinEye enable their users to search for images which are similar to one that you provide, or how they can identify a building from nothing but a picture. Content-based image retrieval (CBIR) is the backbone concept, and provides exciting new ways to search for useful information. While the concept is no longer novel, the requirements imposed on systems for CBIR are ever increasing due to the increasingly larger amounts of data and demand for higher quality of retrieval.",
      "url": "https://medium.com/@e_net4/taking-the-long-road-part-1-97e6e41f6b05",
      "date_published": "2018-03-31T15:45:00.113+00:00",
      "author": {
        "name": "Eduardo Pinho",
        "url": "https://medium.com/@e_net4"
      },
      "tags": [
        "Games and Graphics"
      ]
    },
    {
      "id": "fe337d8c-3b02-4742-bfd0-59ac89d4234f",
      "title": "A geometric Rust adventure",
      "content_text": "The short version is: I have some shapes. I want to find their intersection.\n\nReally, I want more than that: I want to drop them all on a canvas, intersect everything with everything, and pluck out all the resulting polygons. The input is a set of cookie cutters, and I want to press them all down on the same sheet of dough and figure out what all the resulting contiguous pieces are. And I want to know which cookie cutter(s) each piece came from.\n\nBut intersection is a good start.",
      "url": "https://eev.ee/blog/2018/03/30/a-geometric-rust-adventure/",
      "date_published": "2018-03-30T17:17:00-07:00",
      "author": {
        "name": "Eevee",
        "url": "https://eev.ee/blog/"
      },
      "tags": [
        "Games and Graphics"
      ]
    },
    {
      "id": "85524257-1035-4e25-b20b-57737d314b55",
      "title": "Roguelike Tutorial in Rust + tcod",
      "content_text": "Hello! This tutorial will show you how to write a roguelike in the Rust programming language and the libtcod library.",
      "url": "https://tomassedovic.github.io/roguelike-tutorial/",
      "date_published": "2018-03-13T18:54:54+02:00",
      "author": {
        "name": "Tomas Sedovic",
        "url": "https://tomassedovic.github.io/roguelike-tutorial/"
      },
      "tags": [
        "Games and Graphics"
      ]
    },
    {
      "id": "ae89c8c8-fd8f-4432-9b21-1a2651142869",
      "title": "UniverCity - February Change log",
      "content_text": "UniverCity is a university management game being programmed in the Rust programming language. This month was spent mostly on the business side of things, including going through the steam partner process.",
      "url": "https://thinkof.name/2018/02/28/february-change-log.html",
      "date_published": "2018-02-28T00:00:00+00:00",
      "author": {
        "name": "Matthew Collins",
        "url": "https://thinkof.name/"
      },
      "tags": [
        "Games and Graphics"
      ]
    },
    {
      "id": "86b2dfcd-a01d-47e1-acb8-2ddbca20db62",
      "title": "Gameland intro, reimplemented in Rust for WebAssembly",
      "content_text": "My nice brother Johannes Ridderstedt sent me some old files a few weeks ago (in late 2017), stuff that he had preserved from an age-old computer of ours. One of these was the file named gameland.zip (not published yet, but I might put it up here some day.) I managed to get this running, and liked what I saw (you'll find the YouTube link to it further down on this page.) Around this time I was reading a bit about WebAssembly which I think will redefine and help reshape the web as we see it today. I was also looking at the Hello, Rust web page, and the \"FizzleFade effect using a Feistel network\" page in particular.",
      "url": "http://perlun.eu.org/en/programming/gameland/",
      "date_published": "2018-02-13T07:44:00+11:00",
      "author": {
        "name": "Per Lundberg",
        "url": "http://perlun.eu.org/en/"
      },
      "tags": [
        "Games and Graphics",
        "Web and Network Services"
      ]
    },
    {
      "id": "b8e85b25-1d33-4b69-a3ba-b2cbac2bf62e",
      "title": "RLSL (Rust -> SPIR-V compiler) Progress report",
      "content_text": "This is a follow up post. RLSL is a Rust to SPIR-V compiler. SPIR-V is the shading language for Vulkan, similar to other shading languages like GLSL, HLSL but more low level. OpenGL, DX9/11/12, Vulkan, Metal are all graphic APIs that are able to use the GPU to draw pixels on the screen. Those APIs have certain stages that can be controlled by the developer by using the correct shading language.",
      "url": "https://maikklein.github.io/rlsl-progress-report/",
      "date_published": "2018-02-09T00:00:00+00:00",
      "author": {
        "name": "Maik Klein",
        "url": "https://maikklein.github.io/"
      },
      "tags": [
        "Games and Graphics"
      ]
    },
    {
      "id": "c73d7d0b-4f7a-4448-acee-d98dbb499461",
      "title": "Adventures in Rust: A Basic 2D Game",
      "content_text": "In an effort to do more fun side projects, I’ve been learning Rust, a wonderful systems programming language developed by the Mozilla Foundation. It’s been a while since I’ve touched a compiled language as my day-to-day often deals with Python and Javascript variants. I was inspired after seeing a lot of interesting articles about Rust usage and decided to dive into learning Rust by creating a very basic 2D game, inspired by the classic Defender arcade game.",
      "url": "https://a5huynh.github.io/2018/02/02/adventures-in-rust.html",
      "date_published": "2018-02-02T00:00:00+00:00",
      "author": {
        "name": "Andrew Huynh",
        "url": "https://a5huynh.github.io/"
      },
      "tags": [
        "Games and Graphics"
      ]
    },
    {
      "id": "b8c9dfda-526c-453c-a93b-5c96a207643e",
      "title": "Hairy Stuff",
      "content_text": "Last month I was working on a lot of new test scenes for my Rust implementation of the PBRT renderer. But a big chunk of my time went into implementing the curve shape needed for the geometry of hair, and a material, which implements a hair scattering model.",
      "url": "https://www.janwalter.org/jekyll/rendering/pbrt/2018/02/01/hairy-stuff.html",
      "date_published": "2018-02-01T13:30:00+01:00",
      "author": {
        "name": "Jan Walter",
        "url": "https://www.janwalter.org/"
      },
      "tags": [
        "Games and Graphics"
      ]
    },
    {
      "id": "0cced83f-3736-4917-87a0-408fb4d9f6bb",
      "title": "Introduction to lyon: 2D vector graphics rendering on the GPU in Rust",
      "content_text": "Lyon is a side-project that I have been working on for quite a while. The goal is to play with rendering 2D vector graphics on the GPU, and it's been a lot of fun so far. I haven't talked a lot about it online (except for a couple of reddit threads a year or two ago) so I figured it would be a good topic to get this blog started.",
      "url": "https://nical.github.io/posts/lyon-intro.html",
      "date_published": "2018-01-22T00:00:00+01:00",
      "author": {
        "name": "Nical",
        "url": "https://nical.github.io/index.html"
      },
      "tags": [
        "Games and Graphics"
      ]
    }
  ]
}